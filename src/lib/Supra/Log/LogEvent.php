<?php

namespace Supra\Log;

use DateTime;
use DateTimeZone;

/**
 * Supra log event object
 */
class LogEvent
{
	/*
	 * Log level constants
	 */
	const DEBUG = 'DEBUG';
	const INFO = 'INFO';
	const WARN = 'WARN';
	const ERROR = 'ERROR';
	const FATAL = 'FATAL';
	
	/**
	 * Log level priorities
	 * @var array
	 */
	public static $levels = array(
		self::DEBUG	=> 10,
		self::INFO	=> 20,
		self::WARN	=> 30,
		self::ERROR	=> 40,
		self::FATAL	=> 50,
	);
	
	/**
	 * Default system timezone is set in the bootstrap
	 * @var string
	 */
	private static $defaultTimezone;
	
	/**
	 * Log data
	 * @var mixed
	 */
	public $data;
	
	/**
	 * Timestamp
	 * @var int
	 */
	public $timestamp;
	
	/**
	 * Microtime in miliseconds
	 * @var int
	 */
	public $microtime;
	
	/**
	 * Log level
	 * @var string
	 */
	public $level;
	
	/**
	 * File name
	 * @var string
	 */
	public $file;
	
	/**
	 * Code line
	 * @var int
	 */
	public $line;
	
	/**
	 * Logger name
	 * @var string
	 */
	public $logger;
	
	/**
	 * Log subject, generated from the log data
	 * @var string
	 */
	protected $subject;
	
	/**
	 * Message generated by log formatter
	 * @var string
	 */
	protected $message;
	
	/**
	 * Log level priority
	 * @var int
	 */
	protected $levelPriority;
	
	/**
	 * Other event parameters
	 * @var array
	 */
	protected $params;
	
	/**
	 * Log event constructor
	 * @param array $data
	 * @param string $level
	 * @param string $file
	 * @param int $line
	 * @param string $logger
	 * @param array $params
	 */
	public function __construct($data, $level, $file, $line, $logger, array $params = array())
	{
		$this->data = $data;
		$this->level = $level;
		$this->file = (string) $file;
		$this->line = (int) $line;
		$this->timestamp = time();
		$this->microtime = (string) microtime(true);
		$this->logger = $logger;
		$this->params = (array) $params;
	}
	
	/**
	 * Sets default timezone used for date output to the log
	 * @param string $timezone
	 */
	public static function setDefaultTimezone($timezone)
	{
		self::$defaultTimezone = new DateTimeZone($timezone);
	}
	
	/**
	 * Get formatted timestamp in the set timezone
	 * @param string $format
	 * @param int $time
	 * @return string
	 */
	public static function getDateInDefaultTimezone($format, $time = null)
	{
		$dateTime = new DateTime();
		$dateTime->setTimeZone(self::$defaultTimezone);

		if ( ! is_null($time)) {
			$dateTime->setTimestamp($time);
		}

		$timeString = $dateTime->format($format);

		return $timeString;
	}
	
	/**
	 * Get log event parameter array or array value
	 * @param string $name
	 * @return mixed
	 */
	public function getParams($name = null)
	{
		if (is_null($name)) {
			return $this->params;
		} elseif (array_key_exists($name, $this->params)) {
			return $this->params[$name];
		} else {
			return null;
		}
	}
	
	/**
	 * Log message function
	 * @return string
	 */
	public function getSubject()
	{
		if (is_null($this->subject)) {
			$this->subject = '';
			$this->data = (array) $this->data;
			foreach ($this->data as &$item) {
				$this->subject .= self::formatObject($item);
			}
			unset($this->data);
		}
		
		return $this->subject;
	}
	
	/**
	 * Override the subject
	 * @param string $subject
	 */
	public function setSubject($subject)
	{
		// Not interested in the data anymore
		unset($this->data);
		$this->subject = $subject;
	}
	
	/**
	 * @return string
	 */
	public function getMessage()
	{
		return $this->message;
	}

	/**
	 * Set by the log formatter
	 * @param string $message
	 */
	public function setMessage($message)
	{
		$this->message = $message;
	}
	
	/**
	 * @param type $format 
	 */
	public function formatTimestamp($format)
	{
		$formattedTime = self::getDateInDefaultTimezone($format, $this->timestamp);
		
		return $formattedTime;
	}
		
	/**
	 * Log level priority
	 * @return int
	 */
	public function getLevelPriority()
	{
		if (is_null($this->levelPriority)) {
			if (isset(self::$levels[$this->level])) {
				$this->levelPriority = self::$levels[$this->level];
			} else {
				throw Exception\LogicException::badLogLevel($this->level);
			}
		}
		return $this->levelPriority;
	}
	
	/**
	 * Format object for readable representation
	 */
	private static function formatObject(&$obj)
	{
		// Special case for exceptions
		if ($obj instanceof \Exception) {
			return $obj->__toString();
		}
		
		if (is_object($obj) || is_array($obj)){
			return print_r($obj, true);
		}
		
		return (string) $obj;
	}
	
	/**
	 * Object cast to array
	 * @return array
	 */
	public function toArray()
	{
		return array(
			'timestamp' => $this->timestamp,
			'microtime' => $this->microtime,
			'subject' => $this->getSubject(),
			'level' => $this->level,
			'levelPriority' => $this->getLevelPriority(),
			'file' => $this->file,
			'line' => $this->line,
			'logger' => $this->logger,
			'thread' => getmypid(),
		) + $this->params;
	}
	
	/**
	 * Get file/line/class/method information from the backtrace using the set offset
	 * @param int $offset
	 * @return array
	 */
	public static function getBacktraceInfo($offset)
	{
		$params = array();
		$offset++;

		if (function_exists('debug_backtrace')) {
			
			$backtrace = debug_backtrace(false);
			
			/*
			 * full backtrace class::method call summary
			$backtraceSummary = array();
			foreach ($backtrace as $k => $v) {
				$v = $v + array(
					'class' => 'main',
					'function' => 'main',
					'args' => array(),
				);
				if ($k > $offset + 1) {
					foreach ($v['args'] as &$arg) {
						if (is_object($arg)) {
							$arg = get_class($arg);
						}
						if (is_array($arg)) {
							foreach ($arg as &$_arg) {
								if (is_object($_arg)) {
									$_arg = get_class($_arg);
								}
								if (is_array($_arg)) {
									$_arg = 'Array[' . count($_arg) . ']';
								}
							}
							$arg = 'ARRAY[' . implode(',', $arg) . ']';
						}
					}
					$backtraceSummary[] = $v['class'] . '::' . $v['function'] . '(' . implode(', ', $v['args']) . ')';
				}
			}
			$backtraceSummary = implode("\n", $backtraceSummary);
			*/

			// there are situations when no file/line is set for the backtrace item, we're using next in such case
			while (isset($backtrace[$offset]) && !isset($backtrace[$offset]['file'])) {
				$offset++;
			}

			// fetch the class::method information which called the log
			if (isset($backtrace[$offset + 1])) {
				$raiseContainer = $backtrace[$offset + 1];
			} else {
				$raiseContainer = array();
			}
			$raiseContainer = $raiseContainer + array(
				'class' => 'main',
				'function' => null,
				'type' => null
			);

			// fetch the file/line where the log raise was called
			if (isset($backtrace[$offset])) {
				$backtrace = $backtrace[$offset];
			} else {
				$backtrace = array();
			}
			$backtrace = $backtrace + array(
				'file' => null,
				'line' => 0,
			);

			$params['file'] = $backtrace['file'];
			$params['line'] = $backtrace['line'];

			$params['class'] = $raiseContainer['class'];
			$params['method'] = $raiseContainer['function'];
			$params['type'] = $raiseContainer['type'];
			//$params['backtrace'] = $backtraceSummary;

		} else {
			$params = array(
				'line' => 0,
				'file' => '',
				'class' => null,
				'method' => null,
				'type' => null,
				//'backtrace' => null,
			);
		}

		return $params;
	}
}