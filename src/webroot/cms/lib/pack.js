
/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
if(typeof YUI!="undefined"){YUI._YUI=YUI;}var YUI=function(){var c=0,f=this,b=arguments,a=b.length,e=function(h,g){return(h&&h.hasOwnProperty&&(h instanceof g));},d=(typeof YUI_config!=="undefined")&&YUI_config;if(!(e(f,YUI))){f=new YUI();}else{f._init();if(YUI.GlobalConfig){f.applyConfig(YUI.GlobalConfig);}if(d){f.applyConfig(d);}if(!a){f._setup();}}if(a){for(;c<a;c++){f.applyConfig(b[c]);}f._setup();}f.instanceOf=e;return f;};(function(){var q,b,r="3.5.0",i=".",o="http://yui.yahooapis.com/",u="yui3-js-enabled",d="yui3-css-stamp",m=function(){},h=Array.prototype.slice,s={"io.xdrReady":1,"io.xdrResponse":1,"SWF.eventHandler":1},g=(typeof window!="undefined"),f=(g)?window:null,w=(g)?f.document:null,e=w&&w.documentElement,a=e&&e.className,c={},j=new Date().getTime(),n=function(A,z,y,x){if(A&&A.addEventListener){A.addEventListener(z,y,x);}else{if(A&&A.attachEvent){A.attachEvent("on"+z,y);}}},v=function(B,A,z,x){if(B&&B.removeEventListener){try{B.removeEventListener(A,z,x);}catch(y){}}else{if(B&&B.detachEvent){B.detachEvent("on"+A,z);}}},t=function(){YUI.Env.windowLoaded=true;YUI.Env.DOMReady=true;if(g){v(window,"load",t);}},k=function(z,y){var x=z.Env._loader;if(x){x.ignoreRegistered=false;x.onEnd=null;x.data=null;x.required=[];x.loadType=null;}else{x=new z.Loader(z.config);z.Env._loader=x;}YUI.Env.core=z.Array.dedupe([].concat(YUI.Env.core,["loader-base","loader-rollup","loader-yui3"]));return x;},p=function(z,y){for(var x in y){if(y.hasOwnProperty(x)){z[x]=y[x];}}},l={success:true};if(e&&a.indexOf(u)==-1){if(a){a+=" ";}a+=u;e.className=a;}if(r.indexOf("@")>-1){r="3.3.0";}q={applyConfig:function(E){E=E||m;var z,C,B=this.config,D=B.modules,y=B.groups,A=B.aliases,x=this.Env._loader;for(C in E){if(E.hasOwnProperty(C)){z=E[C];if(D&&C=="modules"){p(D,z);}else{if(A&&C=="aliases"){p(A,z);}else{if(y&&C=="groups"){p(y,z);}else{if(C=="win"){B[C]=(z&&z.contentWindow)||z;B.doc=B[C]?B[C].document:null;}else{if(C=="_yuid"){}else{B[C]=z;}}}}}}}if(x){x._config(E);}},_config:function(x){this.applyConfig(x);},_init:function(){var A,z,B=this,x=YUI.Env,y=B.Env,C;B.version=r;if(!y){B.Env={core:["get","features","intl-base","yui-log","yui-later","loader-base","loader-rollup","loader-yui3"],mods:{},versions:{},base:o,cdn:o+r+"/build/",_idx:0,_used:{},_attached:{},_missed:[],_yidx:0,_uidx:0,_guidp:"y",_loaded:{},_BASE_RE:/(?:\?(?:[^&]*&)*([^&]*))?\b(simpleyui|yui(?:-\w+)?)\/\2(?:-(min|debug))?\.js/,parseBasePath:function(H,F){var D=H.match(F),G,E;if(D){G=RegExp.leftContext||H.slice(0,H.indexOf(D[0]));E=D[3];if(D[1]){G+="?"+D[1];}G={filter:E,path:G};}return G;},getBase:x&&x.getBase||function(H){var F=(w&&w.getElementsByTagName("script"))||[],I=y.cdn,E,G,D,J;for(G=0,D=F.length;G<D;++G){J=F[G].src;if(J){E=B.Env.parseBasePath(J,H);if(E){A=E.filter;I=E.path;break;}}}return I;}};y=B.Env;y._loaded[r]={};if(x&&B!==YUI){y._yidx=++x._yidx;y._guidp=("yui_"+r+"_"+y._yidx+"_"+j).replace(/\./g,"_");}else{if(YUI._YUI){x=YUI._YUI.Env;y._yidx+=x._yidx;y._uidx+=x._uidx;for(C in x){if(!(C in y)){y[C]=x[C];}}delete YUI._YUI;}}B.id=B.stamp(B);c[B.id]=B;}B.constructor=YUI;B.config=B.config||{bootstrap:true,cacheUse:true,debug:true,doc:w,fetchCSS:true,throwFail:true,useBrowserConsole:true,useNativeES5:true,win:f};if(w&&!w.getElementById(d)){z=w.createElement("div");z.innerHTML='<div id="'+d+'" style="position: absolute !important; visibility: hidden !important"></div>';YUI.Env.cssStampEl=z.firstChild;e.insertBefore(YUI.Env.cssStampEl,e.firstChild);}B.config.lang=B.config.lang||"en-US";B.config.base=YUI.config.base||B.Env.getBase(B.Env._BASE_RE);if(!A||(!("mindebug").indexOf(A))){A="min";}A=(A)?"-"+A:A;B.config.loaderPath=YUI.config.loaderPath||"loader/loader"+A+".js";},_setup:function(C){var y,B=this,x=[],A=YUI.Env.mods,z=B.config.core||[].concat(YUI.Env.core);for(y=0;y<z.length;y++){if(A[z[y]]){x.push(z[y]);}}B._attach(["yui-base"]);B._attach(x);if(B.Loader){k(B);}},applyTo:function(D,C,z){if(!(C in s)){this.log(C+": applyTo not allowed","warn","yui");return null;}var y=c[D],B,x,A;if(y){B=C.split(".");x=y;for(A=0;A<B.length;A=A+1){x=x[B[A]];if(!x){this.log("applyTo not found: "+C,"warn","yui");}}return x&&x.apply(y,z);}return null;},add:function(y,D,C,x){x=x||{};var B=YUI.Env,E={name:y,fn:D,version:C,details:x},F,A,z=B.versions;B.mods[y]=E;z[C]=z[C]||{};z[C][y]=E;for(A in c){if(c.hasOwnProperty(A)){F=c[A].Env._loader;if(F){if(!F.moduleInfo[y]||F.moduleInfo[y].temp){F.addModule(x,y);}}}}return this;},_attach:function(C,N){var G,O,M,J,x,E,z,A=YUI.Env.mods,H=YUI.Env.aliases,y=this,F,B=y.Env._loader,D=y.Env._attached,I=C.length,B,L=[];for(G=0;G<I;G++){O=C[G];M=A[O];L.push(O);if(B&&B.conditions[O]){y.Object.each(B.conditions[O],function(Q){var P=Q&&((Q.ua&&y.UA[Q.ua])||(Q.test&&Q.test(y)));if(P){L.push(Q.name);}});}}C=L;I=C.length;for(G=0;G<I;G++){if(!D[C[G]]){O=C[G];M=A[O];if(H&&H[O]){y._attach(H[O]);continue;}if(!M){if(B&&B.moduleInfo[O]){M=B.moduleInfo[O];N=true;}if(!N&&O){if((O.indexOf("skin-")===-1)&&(O.indexOf("css")===-1)){y.Env._missed.push(O);y.Env._missed=y.Array.dedupe(y.Env._missed);y.message("NOT loaded: "+O,"warn","yui");}}}else{D[O]=true;for(F=0;F<y.Env._missed.length;F++){if(y.Env._missed[F]===O){y.message("Found: "+O+" (was reported as missing earlier)","warn","yui");y.Env._missed.splice(F,1);}}J=M.details;x=J.requires;E=J.use;z=J.after;if(x){for(F=0;F<x.length;F++){if(!D[x[F]]){if(!y._attach(x)){return false;}break;}}}if(z){for(F=0;F<z.length;F++){if(!D[z[F]]){if(!y._attach(z,true)){return false;}break;}}}if(M.fn){try{M.fn(y,O);}catch(K){y.error("Attach error: "+O,K,O);return false;}}if(E){for(F=0;F<E.length;F++){if(!D[E[F]]){if(!y._attach(E)){return false;}break;}}}}}}return true;},use:function(){var A=h.call(arguments,0),E=A[A.length-1],D=this,C=0,y=[],z,x=D.Env,B=true;if(D.Lang.isFunction(E)){A.pop();}else{E=null;}if(D.Lang.isArray(A[0])){A=A[0];}if(D.config.cacheUse){while((z=A[C++])){if(!x._attached[z]){B=false;break;}}if(B){if(A.length){}D._notify(E,l,A);return D;}}if(D._loading){D._useQueue=D._useQueue||new D.Queue();
D._useQueue.add([A,E]);}else{D._use(A,function(G,F){G._notify(E,F,A);});}return D;},_notify:function(A,x,y){if(!x.success&&this.config.loadErrorFn){this.config.loadErrorFn.call(this,this,A,x,y);}else{if(A){try{A(this,x);}catch(z){this.error("use callback error",z,y);}}}},_use:function(z,B){if(!this.Array){this._attach(["yui-base"]);}var O,G,P,L,y=this,Q=YUI.Env,A=Q.mods,x=y.Env,D=x._used,N=Q.aliases,K=Q._loaderQueue,T=z[0],F=y.Array,R=y.config,E=R.bootstrap,M=[],I=[],S=true,C=R.fetchCSS,J=function(X,W){var V=0,U=[];if(!X.length){return;}if(N){for(V=0;V<X.length;V++){if(N[X[V]]){U=[].concat(U,N[X[V]]);}else{U.push(X[V]);}}X=U;}F.each(X,function(aa){if(!W){I.push(aa);}if(D[aa]){return;}var Y=A[aa],ab,Z;if(Y){D[aa]=true;ab=Y.details.requires;Z=Y.details.use;}else{if(!Q._loaded[r][aa]){M.push(aa);}else{D[aa]=true;}}if(ab&&ab.length){J(ab);}if(Z&&Z.length){J(Z,1);}});},H=function(Y){var W=Y||{success:true,msg:"not dynamic"},V,U,X=true,Z=W.data;y._loading=false;if(Z){U=M;M=[];I=[];J(Z);V=M.length;if(V){if(M.sort().join()==U.sort().join()){V=false;}}}if(V&&Z){y._loading=true;y._use(M,function(){if(y._attach(Z)){y._notify(B,W,Z);}});}else{if(Z){X=y._attach(Z);}if(X){y._notify(B,W,z);}}if(y._useQueue&&y._useQueue.size()&&!y._loading){y._use.apply(y,y._useQueue.next());}};if(T==="*"){S=y._attach(y.Object.keys(A));if(S){H();}return y;}if(A["loader"]&&!y.Loader){y._attach(["loader"]);}if(E&&y.Loader&&z.length){G=k(y);G.require(z);G.ignoreRegistered=true;G._boot=true;G.calculate(null,(C)?null:"js");z=G.sorted;G._boot=false;}J(z);O=M.length;if(O){M=y.Object.keys(F.hash(M));O=M.length;}if(E&&O&&y.Loader){y._loading=true;G=k(y);G.onEnd=H;G.context=y;G.data=z;G.ignoreRegistered=false;G.require(z);G.insert(null,(C)?null:"js");}else{if(E&&O&&y.Get&&!x.bootstrapped){y._loading=true;P=function(){y._loading=false;K.running=false;x.bootstrapped=true;Q._bootstrapping=false;if(y._attach(["loader"])){y._use(z,B);}};if(Q._bootstrapping){K.add(P);}else{Q._bootstrapping=true;y.Get.script(R.base+R.loaderPath,{onEnd:P});}}else{S=y._attach(z);if(S){H();}}}return y;},namespace:function(){var y=arguments,C,A=0,z,B,x;for(;A<y.length;A++){C=this;x=y[A];if(x.indexOf(i)>-1){B=x.split(i);for(z=(B[0]=="YAHOO")?1:0;z<B.length;z++){C[B[z]]=C[B[z]]||{};C=C[B[z]];}}else{C[x]=C[x]||{};C=C[x];}}return C;},log:m,message:m,dump:function(x){return""+x;},error:function(B,y,A){var z=this,x;if(z.config.errorFn){x=z.config.errorFn.apply(z,arguments);}if(z.config.throwFail&&!x){throw (y||new Error(B));}else{z.message(B,"error",""+A);}return z;},guid:function(x){var y=this.Env._guidp+"_"+(++this.Env._uidx);return(x)?(x+y):y;},stamp:function(z,A){var x;if(!z){return z;}if(z.uniqueID&&z.nodeType&&z.nodeType!==9){x=z.uniqueID;}else{x=(typeof z==="string")?z:z._yuid;}if(!x){x=this.guid();if(!A){try{z._yuid=x;}catch(y){x=null;}}}return x;},destroy:function(){var x=this;if(x.Event){x.Event._unload();}delete c[x.id];delete x.Env;delete x.config;}};YUI.prototype=q;for(b in q){if(q.hasOwnProperty(b)){YUI[b]=q[b];}}YUI.applyConfig=function(x){if(!x){return;}if(YUI.GlobalConfig){this.prototype.applyConfig.call(this,YUI.GlobalConfig);}this.prototype.applyConfig.call(this,x);YUI.GlobalConfig=this.config;};YUI._init();if(g){n(window,"load",t);}else{t();}YUI.Env.add=n;YUI.Env.remove=v;if(typeof exports=="object"){exports.YUI=YUI;}}());YUI.add("yui-base",function(b){var i=b.Lang||(b.Lang={}),n=String.prototype,k=Object.prototype.toString,a={"undefined":"undefined","number":"number","boolean":"boolean","string":"string","[object Function]":"function","[object RegExp]":"regexp","[object Array]":"array","[object Date]":"date","[object Error]":"error"},c=/\{\s*([^|}]+?)\s*(?:\|([^}]*))?\s*\}/g,r=/^\s+|\s+$/g,e=/\{\s*\[(?:native code|function)\]\s*\}/i;i._isNative=function(v){return !!(b.config.useNativeES5&&v&&e.test(v));};i.isArray=i._isNative(Array.isArray)?Array.isArray:function(v){return i.type(v)==="array";};i.isBoolean=function(v){return typeof v==="boolean";};i.isDate=function(v){return i.type(v)==="date"&&v.toString()!=="Invalid Date"&&!isNaN(v);};i.isFunction=function(v){return i.type(v)==="function";};i.isNull=function(v){return v===null;};i.isNumber=function(v){return typeof v==="number"&&isFinite(v);};i.isObject=function(x,w){var v=typeof x;return(x&&(v==="object"||(!w&&(v==="function"||i.isFunction(x)))))||false;};i.isString=function(v){return typeof v==="string";};i.isUndefined=function(v){return typeof v==="undefined";};i.isValue=function(w){var v=i.type(w);switch(v){case"number":return isFinite(w);case"null":case"undefined":return false;default:return !!v;}};i.now=Date.now||function(){return new Date().getTime();};i.sub=function(v,w){return v.replace?v.replace(c,function(x,y){return i.isUndefined(w[y])?x:w[y];}):v;};i.trim=n.trim?function(v){return v&&v.trim?v.trim():v;}:function(v){try{return v.replace(r,"");}catch(w){return v;}};i.trimLeft=n.trimLeft?function(v){return v.trimLeft();}:function(v){return v.replace(/^\s+/,"");};i.trimRight=n.trimRight?function(v){return v.trimRight();}:function(v){return v.replace(/\s+$/,"");};i.type=function(v){return a[typeof v]||a[k.call(v)]||(v?"object":"null");};var f=b.Lang,q=Array.prototype,o=Object.prototype.hasOwnProperty;function j(x,A,z){var w,v;A||(A=0);if(z||j.test(x)){try{return q.slice.call(x,A);}catch(y){v=[];for(w=x.length;A<w;++A){v.push(x[A]);}return v;}}return[x];}b.Array=j;j.dedupe=function(A){var z={},x=[],w,y,v;for(w=0,v=A.length;w<v;++w){y=A[w];if(!o.call(z,y)){z[y]=1;x.push(y);}}return x;};j.each=j.forEach=f._isNative(q.forEach)?function(x,v,w){q.forEach.call(x||[],v,w||b);return b;}:function(z,x,y){for(var w=0,v=(z&&z.length)||0;w<v;++w){if(w in z){x.call(y||b,z[w],w,z);}}return b;};j.hash=function(y,w){var z={},A=(w&&w.length)||0,x,v;for(x=0,v=y.length;x<v;++x){if(x in y){z[y[x]]=A>x&&x in w?w[x]:true;}}return z;};j.indexOf=f._isNative(q.indexOf)?function(x,v,w){return q.indexOf.call(x,v,w);}:function(y,w,x){var v=y.length;x=+x||0;x=(x>0||-1)*Math.floor(Math.abs(x));if(x<0){x+=v;if(x<0){x=0;
}}for(;x<v;++x){if(x in y&&y[x]===w){return x;}}return -1;};j.numericSort=function(w,v){return w-v;};j.some=f._isNative(q.some)?function(x,v,w){return q.some.call(x,v,w);}:function(z,x,y){for(var w=0,v=z.length;w<v;++w){if(w in z&&x.call(y,z[w],w,z)){return true;}}return false;};j.test=function(x){var v=0;if(f.isArray(x)){v=1;}else{if(f.isObject(x)){try{if("length" in x&&!x.tagName&&!x.alert&&!x.apply){v=2;}}catch(w){}}}return v;};function t(){this._init();this.add.apply(this,arguments);}t.prototype={_init:function(){this._q=[];},next:function(){return this._q.shift();},last:function(){return this._q.pop();},add:function(){this._q.push.apply(this._q,arguments);return this;},size:function(){return this._q.length;}};b.Queue=t;YUI.Env._loaderQueue=YUI.Env._loaderQueue||new t();var m="__",o=Object.prototype.hasOwnProperty,l=b.Lang.isObject;b.cached=function(x,v,w){v||(v={});return function(y){var z=arguments.length>1?Array.prototype.join.call(arguments,m):String(y);if(!(z in v)||(w&&v[z]==w)){v[z]=x.apply(x,arguments);}return v[z];};};b.getLocation=function(){var v=b.config.win;return v&&v.location;};b.merge=function(){var x=arguments,y=0,w=x.length,v={};for(;y<w;++y){b.mix(v,x[y],true);}return v;};b.mix=function(v,w,C,x,z,D){var A,G,F,y,H,B,E;if(!v||!w){return v||b;}if(z){if(z===2){b.mix(v.prototype,w.prototype,C,x,0,D);}F=z===1||z===3?w.prototype:w;E=z===1||z===4?v.prototype:v;if(!F||!E){return v;}}else{F=w;E=v;}A=C&&!D;if(x){for(y=0,B=x.length;y<B;++y){H=x[y];if(!o.call(F,H)){continue;}G=A?false:H in E;if(D&&G&&l(E[H],true)&&l(F[H],true)){b.mix(E[H],F[H],C,null,0,D);}else{if(C||!G){E[H]=F[H];}}}}else{for(H in F){if(!o.call(F,H)){continue;}G=A?false:H in E;if(D&&G&&l(E[H],true)&&l(F[H],true)){b.mix(E[H],F[H],C,null,0,D);}else{if(C||!G){E[H]=F[H];}}}if(b.Object._hasEnumBug){b.mix(E,F,C,b.Object._forceEnum,z,D);}}return v;};var f=b.Lang,o=Object.prototype.hasOwnProperty,u,g=b.Object=f._isNative(Object.create)?function(v){return Object.create(v);}:(function(){function v(){}return function(w){v.prototype=w;return new v();};}()),d=g._forceEnum=["hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toString","toLocaleString","valueOf"],s=g._hasEnumBug=!{valueOf:0}.propertyIsEnumerable("valueOf"),p=g._hasProtoEnumBug=(function(){}).propertyIsEnumerable("prototype"),h=g.owns=function(w,v){return !!w&&o.call(w,v);};g.hasKey=h;g.keys=f._isNative(Object.keys)?Object.keys:function(z){if(!f.isObject(z)){throw new TypeError("Object.keys called on a non-object");}var y=[],x,w,v;if(p&&typeof z==="function"){for(w in z){if(h(z,w)&&w!=="prototype"){y.push(w);}}}else{for(w in z){if(h(z,w)){y.push(w);}}}if(s){for(x=0,v=d.length;x<v;++x){w=d[x];if(h(z,w)){y.push(w);}}}return y;};g.values=function(z){var y=g.keys(z),x=0,v=y.length,w=[];for(;x<v;++x){w.push(z[y[x]]);}return w;};g.size=function(w){try{return g.keys(w).length;}catch(v){return 0;}};g.hasValue=function(w,v){return b.Array.indexOf(g.values(w),v)>-1;};g.each=function(y,w,z,x){var v;for(v in y){if(x||h(y,v)){w.call(z||b,y[v],v,y);}}return b;};g.some=function(y,w,z,x){var v;for(v in y){if(x||h(y,v)){if(w.call(z||b,y[v],v,y)){return true;}}}return false;};g.getValue=function(z,y){if(!f.isObject(z)){return u;}var w,x=b.Array(y),v=x.length;for(w=0;z!==u&&w<v;w++){z=z[x[w]];}return z;};g.setValue=function(B,z,A){var v,y=b.Array(z),x=y.length-1,w=B;if(x>=0){for(v=0;w!==u&&v<x;v++){w=w[y[v]];}if(w!==u){w[y[v]]=A;}else{return u;}}return B;};g.isEmpty=function(v){return !g.keys(Object(v)).length;};YUI.Env.parseUA=function(B){var A=function(E){var F=0;return parseFloat(E.replace(/\./g,function(){return(F++==1)?"":".";}));},D=b.config.win,v=D&&D.navigator,y={ie:0,opera:0,gecko:0,webkit:0,safari:0,chrome:0,mobile:null,air:0,ipad:0,iphone:0,ipod:0,ios:null,android:0,silk:0,accel:false,webos:0,caja:v&&v.cajaVersion,secure:false,os:null,nodejs:0},w=B||v&&v.userAgent,C=D&&D.location,x=C&&C.href,z;y.userAgent=w;y.secure=x&&(x.toLowerCase().indexOf("https")===0);if(w){if((/windows|win32/i).test(w)){y.os="windows";}else{if((/macintosh|mac_powerpc/i).test(w)){y.os="macintosh";}else{if((/android/i).test(w)){y.os="android";}else{if((/symbos/i).test(w)){y.os="symbos";}else{if((/linux/i).test(w)){y.os="linux";}else{if((/rhino/i).test(w)){y.os="rhino";}}}}}}if((/KHTML/).test(w)){y.webkit=1;}if((/IEMobile|XBLWP7/).test(w)){y.mobile="windows";}if((/Fennec/).test(w)){y.mobile="gecko";}z=w.match(/AppleWebKit\/([^\s]*)/);if(z&&z[1]){y.webkit=A(z[1]);y.safari=y.webkit;if(/ Mobile\//.test(w)||(/iPad|iPod|iPhone/).test(w)){y.mobile="Apple";z=w.match(/OS ([^\s]*)/);if(z&&z[1]){z=A(z[1].replace("_","."));}y.ios=z;y.os="ios";y.ipad=y.ipod=y.iphone=0;z=w.match(/iPad|iPod|iPhone/);if(z&&z[0]){y[z[0].toLowerCase()]=y.ios;}}else{z=w.match(/NokiaN[^\/]*|webOS\/\d\.\d/);if(z){y.mobile=z[0];}if(/webOS/.test(w)){y.mobile="WebOS";z=w.match(/webOS\/([^\s]*);/);if(z&&z[1]){y.webos=A(z[1]);}}if(/ Android/.test(w)){if(/Mobile/.test(w)){y.mobile="Android";}z=w.match(/Android ([^\s]*);/);if(z&&z[1]){y.android=A(z[1]);}}if(/Silk/.test(w)){z=w.match(/Silk\/([^\s]*)\)/);if(z&&z[1]){y.silk=A(z[1]);}if(!y.android){y.android=2.34;y.os="Android";}if(/Accelerated=true/.test(w)){y.accel=true;}}}z=w.match(/(Chrome|CrMo)\/([^\s]*)/);if(z&&z[1]&&z[2]){y.chrome=A(z[2]);y.safari=0;if(z[1]==="CrMo"){y.mobile="chrome";}}else{z=w.match(/AdobeAIR\/([^\s]*)/);if(z){y.air=z[0];}}}if(!y.webkit){if(/Opera/.test(w)){z=w.match(/Opera[\s\/]([^\s]*)/);if(z&&z[1]){y.opera=A(z[1]);}z=w.match(/Version\/([^\s]*)/);if(z&&z[1]){y.opera=A(z[1]);}if(/Opera Mobi/.test(w)){y.mobile="opera";z=w.replace("Opera Mobi","").match(/Opera ([^\s]*)/);if(z&&z[1]){y.opera=A(z[1]);}}z=w.match(/Opera Mini[^;]*/);if(z){y.mobile=z[0];}}else{z=w.match(/MSIE\s([^;]*)/);if(z&&z[1]){y.ie=A(z[1]);}else{z=w.match(/Gecko\/([^\s]*)/);if(z){y.gecko=1;z=w.match(/rv:([^\s\)]*)/);if(z&&z[1]){y.gecko=A(z[1]);}}}}}}if(!B){if(typeof process=="object"){if(process.versions&&process.versions.node){y.os=process.platform;y.nodejs=process.versions.node;}}YUI.Env.UA=y;}return y;
};b.UA=YUI.Env.UA||YUI.Env.parseUA();YUI.Env.aliases={"anim":["anim-base","anim-color","anim-curve","anim-easing","anim-node-plugin","anim-scroll","anim-xy"],"app":["app-base","app-transitions","model","model-list","router","view"],"attribute":["attribute-base","attribute-complex"],"autocomplete":["autocomplete-base","autocomplete-sources","autocomplete-list","autocomplete-plugin"],"base":["base-base","base-pluginhost","base-build"],"cache":["cache-base","cache-offline","cache-plugin"],"collection":["array-extras","arraylist","arraylist-add","arraylist-filter","array-invoke"],"controller":["router"],"dataschema":["dataschema-base","dataschema-json","dataschema-xml","dataschema-array","dataschema-text"],"datasource":["datasource-local","datasource-io","datasource-get","datasource-function","datasource-cache","datasource-jsonschema","datasource-xmlschema","datasource-arrayschema","datasource-textschema","datasource-polling"],"datatable":["datatable-core","datatable-head","datatable-body","datatable-base","datatable-column-widths","datatable-message","datatable-mutable","datatable-sort","datatable-datasource"],"datatable-deprecated":["datatable-base-deprecated","datatable-datasource-deprecated","datatable-sort-deprecated","datatable-scroll-deprecated"],"datatype":["datatype-number","datatype-date","datatype-xml"],"datatype-date":["datatype-date-parse","datatype-date-format"],"datatype-number":["datatype-number-parse","datatype-number-format"],"datatype-xml":["datatype-xml-parse","datatype-xml-format"],"dd":["dd-ddm-base","dd-ddm","dd-ddm-drop","dd-drag","dd-proxy","dd-constrain","dd-drop","dd-scroll","dd-delegate"],"dom":["dom-base","dom-screen","dom-style","selector-native","selector"],"editor":["frame","editor-selection","exec-command","editor-base","editor-para","editor-br","editor-bidi","editor-tab","createlink-base"],"event":["event-base","event-delegate","event-synthetic","event-mousewheel","event-mouseenter","event-key","event-focus","event-resize","event-hover","event-outside","event-touch","event-move","event-flick","event-valuechange"],"event-custom":["event-custom-base","event-custom-complex"],"event-gestures":["event-flick","event-move"],"handlebars":["handlebars-compiler"],"highlight":["highlight-base","highlight-accentfold"],"history":["history-base","history-hash","history-hash-ie","history-html5"],"io":["io-base","io-xdr","io-form","io-upload-iframe","io-queue"],"json":["json-parse","json-stringify"],"loader":["loader-base","loader-rollup","loader-yui3"],"node":["node-base","node-event-delegate","node-pluginhost","node-screen","node-style"],"pluginhost":["pluginhost-base","pluginhost-config"],"querystring":["querystring-parse","querystring-stringify"],"recordset":["recordset-base","recordset-sort","recordset-filter","recordset-indexer"],"resize":["resize-base","resize-proxy","resize-constrain"],"slider":["slider-base","slider-value-range","clickable-rail","range-slider"],"text":["text-accentfold","text-wordbreak"],"widget":["widget-base","widget-htmlparser","widget-skin","widget-uievents"]};},"3.5.0");YUI.add("get",function(d){var c=d.Lang,b,e,a;d.Get=e={cssOptions:{attributes:{rel:"stylesheet"},doc:d.config.linkDoc||d.config.doc,pollInterval:50},jsOptions:{autopurge:true,doc:d.config.scriptDoc||d.config.doc},options:{attributes:{charset:"utf-8"},purgethreshold:20},REGEX_CSS:/\.css(?:[?;].*)?$/i,REGEX_JS:/\.js(?:[?;].*)?$/i,_insertCache:{},_pending:null,_purgeNodes:[],_queue:[],abort:function(k){var g,l,h,f,j;if(!k.abort){l=k;j=this._pending;k=null;if(j&&j.transaction.id===l){k=j.transaction;this._pending=null;}else{for(g=0,f=this._queue.length;g<f;++g){h=this._queue[g].transaction;if(h.id===l){k=h;this._queue.splice(g,1);break;}}}}k&&k.abort();},css:function(g,f,h){return this._load("css",g,f,h);},js:function(g,f,h){return this._load("js",g,f,h);},load:function(g,f,h){return this._load(null,g,f,h);},_autoPurge:function(f){if(f&&this._purgeNodes.length>=f){this._purge(this._purgeNodes);}},_getEnv:function(){var g=d.config.doc,f=d.UA;return(this._env={async:g&&g.createElement("script").async===true,cssFail:f.gecko>=9||f.webkit>=535.24,cssLoad:((!f.gecko&&!f.webkit)||f.gecko>=9||f.webkit>=535.24)&&!(f.chrome&&f.chrome<=18),preservesScriptOrder:!!(f.gecko||f.opera)});},_getTransaction:function(l,h){var m=[],j,f,k,g;if(!c.isArray(l)){l=[l];}h=d.merge(this.options,h);h.attributes=d.merge(this.options.attributes,h.attributes);for(j=0,f=l.length;j<f;++j){g=l[j];k={attributes:{}};if(typeof g==="string"){k.url=g;}else{if(g.url){d.mix(k,g,false,null,0,true);g=g.url;}else{continue;}}d.mix(k,h,false,null,0,true);if(!k.type){if(this.REGEX_CSS.test(g)){k.type="css";}else{if(!this.REGEX_JS.test(g)){}k.type="js";}}d.mix(k,k.type==="js"?this.jsOptions:this.cssOptions,false,null,0,true);k.attributes.id||(k.attributes.id=d.guid());if(k.win){k.doc=k.win.document;}else{k.win=k.doc.defaultView||k.doc.parentWindow;}if(k.charset){k.attributes.charset=k.charset;}m.push(k);}return new a(m,h);},_load:function(g,h,f,j){var i;if(typeof f==="function"){j=f;f={};}f||(f={});f.type=g;if(!this._env){this._getEnv();}i=this._getTransaction(h,f);this._queue.push({callback:j,transaction:i});this._next();return i;},_next:function(){var f;if(this._pending){return;}f=this._queue.shift();if(f){this._pending=f;f.transaction.execute(function(){f.callback&&f.callback.apply(this,arguments);e._pending=null;e._next();});}},_purge:function(f){var h=this._purgeNodes,j=f!==h,g,i;while(i=f.pop()){if(!i._yuiget_finished){continue;}i.parentNode&&i.parentNode.removeChild(i);if(j){g=d.Array.indexOf(h,i);if(g>-1){h.splice(g,1);}}}}};e.script=e.js;e.Transaction=a=function(h,g){var f=this;f.id=a._lastId+=1;f.data=g.data;f.errors=[];f.nodes=[];f.options=g;f.requests=h;f._callbacks=[];f._queue=[];f._waiting=0;f.tId=f.id;f.win=g.win||d.config.win;};a._lastId=0;a.prototype={_state:"new",abort:function(f){this._pending=null;this._pendingCSS=null;this._pollTimer=clearTimeout(this._pollTimer);this._queue=[];this._waiting=0;this.errors.push({error:f||"Aborted"});
this._finish();},execute:function(n){var h=this,m=h.requests,l=h._state,j,g,f,k;if(l==="done"){n&&n(h.errors.length?h.errors:null,h);return;}else{n&&h._callbacks.push(n);if(l==="executing"){return;}}h._state="executing";h._queue=f=[];if(h.options.timeout){h._timeout=setTimeout(function(){h.abort("Timeout");},h.options.timeout);}for(j=0,g=m.length;j<g;++j){k=h.requests[j];if(k.async||k.type==="css"){h._insert(k);}else{f.push(k);}}h._next();},purge:function(){e._purge(this.nodes);},_createNode:function(h,g,j){var i=j.createElement(h),f,k;if(!b){k=j.createElement("div");k.setAttribute("class","a");b=k.className==="a"?{}:{"for":"htmlFor","class":"className"};}for(f in g){if(g.hasOwnProperty(f)){i.setAttribute(b[f]||f,g[f]);}}return i;},_finish:function(){var l=this.errors.length?this.errors:null,g=this.options,k=g.context||this,j,h,f;if(this._state==="done"){return;}this._state="done";for(h=0,f=this._callbacks.length;h<f;++h){this._callbacks[h].call(k,l,this);}j=this._getEventData();if(l){if(g.onTimeout&&l[l.length-1].error==="Timeout"){g.onTimeout.call(k,j);}if(g.onFailure){g.onFailure.call(k,j);}}else{if(g.onSuccess){g.onSuccess.call(k,j);}}if(g.onEnd){g.onEnd.call(k,j);}},_getEventData:function(f){if(f){return d.merge(this,{abort:this.abort,purge:this.purge,request:f,url:f.url,win:f.win});}else{return this;}},_getInsertBefore:function(j){var k=j.doc,h=j.insertBefore,g,i,f;if(h){return typeof h==="string"?k.getElementById(h):h;}g=e._insertCache;f=d.stamp(k);if((h=g[f])){return h;}if((h=k.getElementsByTagName("base")[0])){return(g[f]=h);}h=k.head||k.getElementsByTagName("head")[0];if(h){h.appendChild(k.createTextNode(""));return(g[f]=h.lastChild);}return(g[f]=k.getElementsByTagName("script")[0]);},_insert:function(o){var l=e._env,m=this._getInsertBefore(o),i=o.type==="js",h=o.node,p=this,g=d.UA,f,j;if(!h){if(i){j="script";}else{if(!l.cssLoad&&g.gecko){j="style";}else{j="link";}}h=o.node=this._createNode(j,o.attributes,o.doc);}function k(){p._progress("Failed to load "+o.url,o);}function n(){if(f){clearTimeout(f);}p._progress(null,o);}if(i){h.setAttribute("src",o.url);if(o.async){h.async=true;}else{if(l.async){h.async=false;}if(!l.preservesScriptOrder){this._pending=o;}}}else{if(!l.cssLoad&&g.gecko){h.innerHTML=(o.attributes.charset?'@charset "'+o.attributes.charset+'";':"")+'@import "'+o.url+'";';}else{h.setAttribute("href",o.url);}}if(i&&g.ie&&g.ie<9){h.onreadystatechange=function(){if(/loaded|complete/.test(h.readyState)){h.onreadystatechange=null;n();}};}else{if(!i&&!l.cssLoad){this._poll(o);}else{h.onerror=k;h.onload=n;if(!l.cssFail&&!i){f=setTimeout(k,o.timeout||3000);}}}this._waiting+=1;this.nodes.push(h);m.parentNode.insertBefore(h,m);},_next:function(){if(this._pending){return;}if(this._queue.length){this._insert(this._queue.shift());}else{if(!this._waiting){this._finish();}}},_poll:function(n){var q=this,r=q._pendingCSS,l=d.UA.webkit,h,f,g,p,o,k;if(n){r||(r=q._pendingCSS=[]);r.push(n);if(q._pollTimer){return;}}q._pollTimer=null;for(h=0;h<r.length;++h){o=r[h];if(l){k=o.doc.styleSheets;g=k.length;p=o.node.href;while(--g>=0){if(k[g].href===p){r.splice(h,1);h-=1;q._progress(null,o);break;}}}else{try{f=!!o.node.sheet.cssRules;r.splice(h,1);h-=1;q._progress(null,o);}catch(m){}}}if(r.length){q._pollTimer=setTimeout(function(){q._poll.call(q);},q.options.pollInterval);}},_progress:function(h,g){var f=this.options;if(h){g.error=h;this.errors.push({error:h,request:g});}g.node._yuiget_finished=g.finished=true;if(f.onProgress){f.onProgress.call(f.context||this,this._getEventData(g));}if(g.autopurge){e._autoPurge(this.options.purgethreshold);e._purgeNodes.push(g.node);}if(this._pending===g){this._pending=null;}this._waiting-=1;this._next();}};},"3.5.0",{requires:["yui-base"]});YUI.add("features",function(b){var c={};b.mix(b.namespace("Features"),{tests:c,add:function(d,e,f){c[d]=c[d]||{};c[d][e]=f;},all:function(e,f){var g=c[e],d=[];if(g){b.Object.each(g,function(i,h){d.push(h+":"+(b.Features.test(e,h,f)?1:0));});}return(d.length)?d.join(";"):"";},test:function(e,g,f){f=f||[];var d,i,k,j=c[e],h=j&&j[g];if(!h){}else{d=h.result;if(b.Lang.isUndefined(d)){i=h.ua;if(i){d=(b.UA[i]);}k=h.test;if(k&&((!i)||d)){d=k.apply(b,f);}h.result=d;}}return d;}});var a=b.Features.add;a("load","0",{"name":"io-nodejs","trigger":"io-base","ua":"nodejs"});a("load","1",{"name":"graphics-canvas-default","test":function(h){var f=h.config.doc,g=h.config.defaultGraphicEngine&&h.config.defaultGraphicEngine=="canvas",e=f&&f.createElement("canvas"),d=(f&&f.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return(!d||g)&&(e&&e.getContext&&e.getContext("2d"));},"trigger":"graphics"});a("load","2",{"name":"autocomplete-list-keys","test":function(d){return !(d.UA.ios||d.UA.android);},"trigger":"autocomplete-list"});a("load","3",{"name":"graphics-svg","test":function(h){var g=h.config.doc,f=!h.config.defaultGraphicEngine||h.config.defaultGraphicEngine!="canvas",e=g&&g.createElement("canvas"),d=(g&&g.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return d&&(f||!e);},"trigger":"graphics"});a("load","4",{"name":"editor-para-ie","trigger":"editor-para","ua":"ie","when":"instead"});a("load","5",{"name":"graphics-vml-default","test":function(f){var e=f.config.doc,d=e&&e.createElement("canvas");return(e&&!e.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")&&(!d||!d.getContext||!d.getContext("2d")));},"trigger":"graphics"});a("load","6",{"name":"graphics-svg-default","test":function(h){var g=h.config.doc,f=!h.config.defaultGraphicEngine||h.config.defaultGraphicEngine!="canvas",e=g&&g.createElement("canvas"),d=(g&&g.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return d&&(f||!e);},"trigger":"graphics"});a("load","7",{"name":"history-hash-ie","test":function(e){var d=e.config.doc&&e.config.doc.documentMode;return e.UA.ie&&(!("onhashchange" in e.config.win)||!d||d<8);},"trigger":"history-hash"});
a("load","8",{"name":"transition-timer","test":function(g){var f=g.config.doc,e=(f)?f.documentElement:null,d=true;if(e&&e.style){d=!("MozTransition" in e.style||"WebkitTransition" in e.style);}return d;},"trigger":"transition"});a("load","9",{"name":"dom-style-ie","test":function(j){var h=j.Features.test,i=j.Features.add,f=j.config.win,g=j.config.doc,d="documentElement",e=false;i("style","computedStyle",{test:function(){return f&&"getComputedStyle" in f;}});i("style","opacity",{test:function(){return g&&"opacity" in g[d].style;}});e=(!h("style","opacity")&&!h("style","computedStyle"));return e;},"trigger":"dom-style"});a("load","10",{"name":"selector-css2","test":function(f){var e=f.config.doc,d=e&&!("querySelectorAll" in e);return d;},"trigger":"selector"});a("load","11",{"name":"widget-base-ie","trigger":"widget-base","ua":"ie"});a("load","12",{"name":"event-base-ie","test":function(e){var d=e.config.doc&&e.config.doc.implementation;return(d&&(!d.hasFeature("Events","2.0")));},"trigger":"node-base"});a("load","13",{"name":"dd-gestures","test":function(d){return((d.config.win&&("ontouchstart" in d.config.win))&&!(d.UA.chrome&&d.UA.chrome<6));},"trigger":"dd-drag"});a("load","14",{"name":"scrollview-base-ie","trigger":"scrollview-base","ua":"ie"});a("load","15",{"name":"app-transitions-native","test":function(f){var e=f.config.doc,d=e?e.documentElement:null;if(d&&d.style){return("MozTransition" in d.style||"WebkitTransition" in d.style);}return false;},"trigger":"app-transitions"});a("load","16",{"name":"graphics-canvas","test":function(h){var f=h.config.doc,g=h.config.defaultGraphicEngine&&h.config.defaultGraphicEngine=="canvas",e=f&&f.createElement("canvas"),d=(f&&f.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return(!d||g)&&(e&&e.getContext&&e.getContext("2d"));},"trigger":"graphics"});a("load","17",{"name":"graphics-vml","test":function(f){var e=f.config.doc,d=e&&e.createElement("canvas");return(e&&!e.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")&&(!d||!d.getContext||!d.getContext("2d")));},"trigger":"graphics"});},"3.5.0",{requires:["yui-base"]});YUI.add("intl-base",function(b){var a=/[, ]/;b.mix(b.namespace("Intl"),{lookupBestLang:function(g,h){var f,j,c,e;function d(l){var k;for(k=0;k<h.length;k+=1){if(l.toLowerCase()===h[k].toLowerCase()){return h[k];}}}if(b.Lang.isString(g)){g=g.split(a);}for(f=0;f<g.length;f+=1){j=g[f];if(!j||j==="*"){continue;}while(j.length>0){c=d(j);if(c){return c;}else{e=j.lastIndexOf("-");if(e>=0){j=j.substring(0,e);if(e>=2&&j.charAt(e-2)==="-"){j=j.substring(0,e-2);}}else{break;}}}}return"";}});},"3.5.0",{requires:["yui-base"]});YUI.add("yui-log",function(d){var c=d,e="yui:log",a="undefined",b={debug:1,info:1,warn:1,error:1};c.log=function(j,s,g,q){var l,p,n,k,o,i=c,r=i.config,h=(i.fire)?i:YUI.Env.globalEvents;if(r.debug){if(g){p=r.logExclude;n=r.logInclude;if(n&&!(g in n)){l=1;}else{if(n&&(g in n)){l=!n[g];}else{if(p&&(g in p)){l=p[g];}}}}if(!l){if(r.useBrowserConsole){k=(g)?g+": "+j:j;if(i.Lang.isFunction(r.logFn)){r.logFn.call(i,j,s,g);}else{if(typeof console!=a&&console.log){o=(s&&console[s]&&(s in b))?s:"log";console[o](k);}else{if(typeof opera!=a){opera.postError(k);}}}}if(h&&!q){if(h==i&&(!h.getEvent(e))){h.publish(e,{broadcast:2});}h.fire(e,{msg:j,cat:s,src:g});}}}return i;};c.message=function(){return c.log.apply(c,arguments);};},"3.5.0",{requires:["yui-base"]});YUI.add("yui-later",function(b){var a=[];b.later=function(j,f,k,g,h){j=j||0;g=(!b.Lang.isUndefined(g))?b.Array(g):a;f=f||b.config.win||b;var i=false,c=(f&&b.Lang.isString(k))?f[k]:k,d=function(){if(!i){if(!c.apply){c(g[0],g[1],g[2],g[3]);}else{c.apply(f,g||a);}}},e=(h)?setInterval(d,j):setTimeout(d,j);return{id:e,interval:h,cancel:function(){i=true;if(this.interval){clearInterval(e);}else{clearTimeout(e);}}};};b.Lang.later=b.later;},"3.5.0",{requires:["yui-base"]});YUI.add("loader-base",function(d){if(!YUI.Env[d.version]){(function(){var I=d.version,E="/build/",F=I+E,D=d.Env.base,A="gallery-2012.04.10-14-57",C="2in3",B="4",z="2.9.0",G=D+"combo?",H={version:I,root:F,base:d.Env.base,comboBase:G,skin:{defaultSkin:"sam",base:"assets/skins/",path:"skin.css",after:["cssreset","cssfonts","cssgrids","cssbase","cssreset-context","cssfonts-context"]},groups:{},patterns:{}},y=H.groups,x=function(K,O,L){var J=C+"."+(K||B)+"/"+(O||z)+E,M=(L&&L.base)?L.base:D,N=(L&&L.comboBase)?L.comboBase:G;y.yui2.base=M+J;y.yui2.root=J;y.yui2.comboBase=N;},w=function(J,L){var K=(J||A)+E,M=(L&&L.base)?L.base:D,N=(L&&L.comboBase)?L.comboBase:G;y.gallery.base=M+K;y.gallery.root=K;y.gallery.comboBase=N;};y[I]={};y.gallery={ext:false,combine:true,comboBase:G,update:w,patterns:{"gallery-":{},"lang/gallery-":{},"gallerycss-":{type:"css"}}};y.yui2={combine:true,ext:false,comboBase:G,update:x,patterns:{"yui2-":{configFn:function(J){if(/-skin|reset|fonts|grids|base/.test(J.name)){J.type="css";J.path=J.path.replace(/\.js/,".css");J.path=J.path.replace(/\/yui2-skin/,"/assets/skins/sam/yui2-skin");}}}}};w();x();YUI.Env[I]=H;}());}var f={},c=[],m=1024,a=YUI.Env,p=a._loaded,q="css",k="js",v="intl",s=d.version,u="",e=d.Object,r=e.each,j=d.Array,h=a._loaderQueue,t=a[s],b="skin-",i=d.Lang,n=a.mods,l,o,g=function(x,y,z,w){var A=x+"/"+y;if(!w){A+="-min";}A+="."+(z||q);return A;};d.Env.meta=t;d.Loader=function(A){var z=t.modules,x=this;A=A||{};l=t.md5;x.context=d;x.base=d.Env.meta.base+d.Env.meta.root;x.comboBase=d.Env.meta.comboBase;x.combine=A.base&&(A.base.indexOf(x.comboBase.substr(0,20))>-1);x.comboSep="&";x.maxURLLength=m;x.root=d.Env.meta.root;x.timeout=0;x.forceMap={};x.allowRollup=false;x.filters={};x.required={};x.patterns={};x.moduleInfo={};x.groups=d.merge(d.Env.meta.groups);x.skin=d.merge(d.Env.meta.skin);x.conditions={};x.config=A;x._internal=true;o=a._renderedMods;if(o){r(o,function y(C,B){x.moduleInfo[B]=d.merge(C);});o=a._conditions;r(o,function w(C,B){x.conditions[B]=d.merge(C);});}else{r(z,x.addModule,x);}x.loaded=p[s];x._inspectPage();
x._internal=false;x._config(A);x.forceMap=(x.force)?d.Array.hash(x.force):{};x.testresults=null;if(d.config.tests){x.testresults=d.config.tests;}x.sorted=[];x.dirty=true;x.inserted={};x.skipped={};x.tested={};};d.Loader.prototype={REGEX_CSS:/\.css(?:[?;].*)?$/i,FILTER_DEFS:{RAW:{"searchExp":"-min\\.js","replaceStr":".js"},DEBUG:{"searchExp":"-min\\.js","replaceStr":"-debug.js"}},_inspectPage:function(){r(this.moduleInfo,function(x,w){if(x.type&&x.type===q){if(this.isCSSLoaded(x.name)){this.loaded[w]=true;}}},this);r(n,function(y,x){if(y.details){var w=this.moduleInfo[x],A=y.details.requires,z=w&&w.requires;if(w){if(!w._inspected&&A&&z.length!=A.length){delete w.expanded;}}else{w=this.addModule(y.details,x);}w._inspected=true;}},this);},_requires:function(C,B){var y,A,D,E,w=this.moduleInfo,x=w[C],z=w[B];if(!x||!z){return false;}A=x.expanded_map;D=x.after_map;if(D&&(B in D)){return true;}D=z.after_map;if(D&&(C in D)){return false;}E=w[B]&&w[B].supersedes;if(E){for(y=0;y<E.length;y++){if(this._requires(C,E[y])){return true;}}}E=w[C]&&w[C].supersedes;if(E){for(y=0;y<E.length;y++){if(this._requires(B,E[y])){return false;}}}if(A&&(B in A)){return true;}if(x.ext&&x.type==q&&!z.ext&&z.type==q){return true;}return false;},_config:function(C){var y,x,B,z,A,D,w=this;if(C){for(y in C){if(C.hasOwnProperty(y)){B=C[y];if(y=="require"){w.require(B);}else{if(y=="skin"){if(typeof B==="string"){w.skin.defaultSkin=C.skin;B={defaultSkin:B};}d.mix(w.skin,B,true);}else{if(y=="groups"){for(x in B){if(B.hasOwnProperty(x)){D=x;A=B[x];w.addGroup(A,D);if(A.aliases){r(A.aliases,w.addAlias,w);}}}}else{if(y=="modules"){r(B,w.addModule,w);}else{if(y==="aliases"){r(B,w.addAlias,w);}else{if(y=="gallery"){this.groups.gallery.update(B,C);}else{if(y=="yui2"||y=="2in3"){this.groups.yui2.update(C["2in3"],C.yui2,C);}else{w[y]=B;}}}}}}}}}}z=w.filter;if(i.isString(z)){z=z.toUpperCase();w.filterName=z;w.filter=w.FILTER_DEFS[z];if(z=="DEBUG"){w.require("yui-log","dump");}}if(w.lang){}},formatSkin:function(y,w){var x=b+y;if(w){x=x+"-"+w;}return x;},_addSkin:function(F,D,E){var C,B,x,w,A=this.moduleInfo,y=this.skin,z=A[D]&&A[D].ext;if(D){x=this.formatSkin(F,D);if(!A[x]){C=A[D];B=C.pkg||D;w={name:x,group:C.group,type:"css",after:y.after,path:(E||B)+"/"+y.base+F+"/"+D+".css",ext:z};if(C.base){w.base=C.base;}if(C.configFn){w.configFn=C.configFn;}this.addModule(w,x);}}return x;},addAlias:function(w,x){YUI.Env.aliases[x]=w;this.addModule({name:x,use:w});},addGroup:function(z,x){var y=z.modules,w=this;x=x||z.name;z.name=x;w.groups[x]=z;if(z.patterns){r(z.patterns,function(B,A){B.group=x;w.patterns[A]=B;});}if(y){r(y,function(B,A){if(typeof B==="string"){B={name:A,fullpath:B};}B.group=x;w.addModule(B,A);},w);}},addModule:function(N,U){U=U||N.name;if(typeof N==="string"){N={name:U,fullpath:N};}if(this.moduleInfo[U]&&this.moduleInfo[U].temp){N=d.merge(this.moduleInfo[U],N);}N.name=U;if(!N||!N.name){return null;}if(!N.type){N.type=k;var L=N.path||N.fullpath;if(L&&this.REGEX_CSS.test(L)){N.type=q;}}if(!N.path&&!N.fullpath){N.path=g(U,U,N.type);}N.supersedes=N.supersedes||N.use;N.ext=("ext" in N)?N.ext:(this._internal)?false:true;var R=N.submodules,Q,O,H,w,I,y,M,x,P,J,F,C,A,z,T,S,G,B,D,E=this.conditions,K;this.moduleInfo[U]=N;N.requires=N.requires||[];if(N.skinnable){B=this._addSkin(this.skin.defaultSkin,U);N.requires.unshift(B);}N.requires=this.filterRequires(N.requires)||[];if(!N.langPack&&N.lang){J=j(N.lang);for(P=0;P<J.length;P++){T=J[P];F=this.getLangPackName(T,U);y=this.moduleInfo[F];if(!y){y=this._addLangPack(T,N,F);}}}if(R){w=N.supersedes||[];O=0;for(Q in R){if(R.hasOwnProperty(Q)){I=R[Q];I.path=I.path||g(U,Q,N.type);I.pkg=U;I.group=N.group;if(I.supersedes){w=w.concat(I.supersedes);}y=this.addModule(I,Q);w.push(Q);if(y.skinnable){N.skinnable=true;G=this.skin.overrides;if(G&&G[Q]){for(P=0;P<G[Q].length;P++){B=this._addSkin(G[Q][P],Q,U);w.push(B);}}B=this._addSkin(this.skin.defaultSkin,Q,U);w.push(B);}if(I.lang&&I.lang.length){J=j(I.lang);for(P=0;P<J.length;P++){T=J[P];F=this.getLangPackName(T,U);C=this.getLangPackName(T,Q);y=this.moduleInfo[F];if(!y){y=this._addLangPack(T,N,F);}A=A||j.hash(y.supersedes);if(!(C in A)){y.supersedes.push(C);}N.lang=N.lang||[];z=z||j.hash(N.lang);if(!(T in z)){N.lang.push(T);}F=this.getLangPackName(u,U);C=this.getLangPackName(u,Q);y=this.moduleInfo[F];if(!y){y=this._addLangPack(T,N,F);}if(!(C in A)){y.supersedes.push(C);}}}O++;}}N.supersedes=j.dedupe(w);if(this.allowRollup){N.rollup=(O<4)?O:Math.min(O-1,4);}}M=N.plugins;if(M){for(Q in M){if(M.hasOwnProperty(Q)){x=M[Q];x.pkg=U;x.path=x.path||g(U,Q,N.type);x.requires=x.requires||[];x.group=N.group;this.addModule(x,Q);if(N.skinnable){this._addSkin(this.skin.defaultSkin,Q,U);}}}}if(N.condition){H=N.condition.trigger;if(YUI.Env.aliases[H]){H=YUI.Env.aliases[H];}if(!d.Lang.isArray(H)){H=[H];}for(Q=0;Q<H.length;Q++){K=H[Q];D=N.condition.when;E[K]=E[K]||{};E[K][U]=N.condition;if(D&&D!="after"){if(D=="instead"){N.supersedes=N.supersedes||[];N.supersedes.push(K);}else{}}else{N.after=N.after||[];N.after.push(K);}}}if(N.supersedes){N.supersedes=this.filterRequires(N.supersedes);}if(N.after){N.after=this.filterRequires(N.after);N.after_map=j.hash(N.after);}if(N.configFn){S=N.configFn(N);if(S===false){delete this.moduleInfo[U];delete a._renderedMods[U];N=null;}}if(N){if(!a._renderedMods){a._renderedMods={};}a._renderedMods[U]=d.merge(N);a._conditions=E;}return N;},require:function(x){var w=(typeof x==="string")?j(arguments):x;this.dirty=true;this.required=d.merge(this.required,j.hash(this.filterRequires(w)));this._explodeRollups();},_explodeRollups:function(){var x=this,w,y=x.required;if(!x.allowRollup){r(y,function(z,A){w=x.getModule(A);if(w&&w.use){j.each(w.use,function(B){w=x.getModule(B);if(w&&w.use){j.each(w.use,function(C){y[C]=true;});}else{y[B]=true;}});}});x.required=y;}},filterRequires:function(z){if(z){if(!d.Lang.isArray(z)){z=[z];}z=d.Array(z);var B=[],y,x,A,w;for(y=0;y<z.length;y++){x=this.getModule(z[y]);if(x&&x.use){for(A=0;A<x.use.length;A++){w=this.getModule(x.use[A]);
if(w&&w.use){B=d.Array.dedupe([].concat(B,this.filterRequires(w.use)));}else{B.push(x.use[A]);}}}else{B.push(z[y]);}}z=B;}return z;},getRequires:function(R){if(!R){return c;}if(R._parsed){return R.expanded||c;}var L,H,K,D,C,T,A=this.testresults,U=R.name,B,S=n[U]&&n[U].details,N,I,w,E,O,F,z,P,Q,y,G=R.lang||R.intl,M=this.moduleInfo,J=d.Features&&d.Features.tests.load,x;if(R.temp&&S){O=R;R=this.addModule(S,U);R.group=O.group;R.pkg=O.pkg;delete R.expanded;}if(R.expanded&&(!this.lang||R.langCache===this.lang)){return R.expanded;}N=[];x={};E=this.filterRequires(R.requires);if(R.lang){N.unshift("intl");E.unshift("intl");G=true;}F=this.filterRequires(R.optional);R._parsed=true;R.langCache=this.lang;for(L=0;L<E.length;L++){if(!x[E[L]]){N.push(E[L]);x[E[L]]=true;H=this.getModule(E[L]);if(H){D=this.getRequires(H);G=G||(H.expanded_map&&(v in H.expanded_map));for(K=0;K<D.length;K++){N.push(D[K]);}}}}E=this.filterRequires(R.supersedes);if(E){for(L=0;L<E.length;L++){if(!x[E[L]]){if(R.submodules){N.push(E[L]);}x[E[L]]=true;H=this.getModule(E[L]);if(H){D=this.getRequires(H);G=G||(H.expanded_map&&(v in H.expanded_map));for(K=0;K<D.length;K++){N.push(D[K]);}}}}}if(F&&this.loadOptional){for(L=0;L<F.length;L++){if(!x[F[L]]){N.push(F[L]);x[F[L]]=true;H=M[F[L]];if(H){D=this.getRequires(H);G=G||(H.expanded_map&&(v in H.expanded_map));for(K=0;K<D.length;K++){N.push(D[K]);}}}}}B=this.conditions[U];if(B){R._parsed=false;if(A&&J){r(A,function(V,X){var W=J[X].name;if(!x[W]&&J[X].trigger==U){if(V&&J[X]){x[W]=true;N.push(W);}}});}else{r(B,function(X,W){if(!x[W]){var V=X&&((!X.ua&&!X.test)||(X.ua&&d.UA[X.ua])||(X.test&&X.test(d,E)));if(V){x[W]=true;N.push(W);H=this.getModule(W);if(H){D=this.getRequires(H);for(K=0;K<D.length;K++){N.push(D[K]);}}}}},this);}}if(R.skinnable){P=this.skin.overrides;r(YUI.Env.aliases,function(V,W){if(d.Array.indexOf(V,U)>-1){Q=W;}});if(P&&(P[U]||(Q&&P[Q]))){y=U;if(P[Q]){y=Q;}for(L=0;L<P[y].length;L++){z=this._addSkin(P[y][L],U);if(!this.isCSSLoaded(z,this._boot)){N.push(z);}}}else{z=this._addSkin(this.skin.defaultSkin,U);if(!this.isCSSLoaded(z,this._boot)){N.push(z);}}}R._parsed=false;if(G){if(R.lang&&!R.langPack&&d.Intl){T=d.Intl.lookupBestLang(this.lang||u,R.lang);C=this.getLangPackName(T,U);if(C){N.unshift(C);}}N.unshift(v);}R.expanded_map=j.hash(N);R.expanded=e.keys(R.expanded_map);return R.expanded;},isCSSLoaded:function(x,A){if(!x||!YUI.Env.cssStampEl||(!A&&this.ignoreRegistered)){return false;}var z=YUI.Env.cssStampEl,w=false,y=z.currentStyle;z.className=x;if(!y){y=d.config.doc.defaultView.getComputedStyle(z,null);}if(y&&y["display"]==="none"){w=true;}z.className="";return w;},getProvides:function(x){var w=this.getModule(x),z,y;if(!w){return f;}if(w&&!w.provides){z={};y=w.supersedes;if(y){j.each(y,function(A){d.mix(z,this.getProvides(A));},this);}z[x]=true;w.provides=z;}return w.provides;},calculate:function(x,w){if(x||w||this.dirty){if(x){this._config(x);}if(!this._init){this._setup();}this._explode();if(this.allowRollup){this._rollup();}else{this._explodeRollups();}this._reduce();this._sort();}},_addLangPack:function(C,w,B){var z=w.name,x,y,A=this.moduleInfo[B];if(!A){x=g((w.pkg||z),B,k,true);y={path:x,intl:true,langPack:true,ext:w.ext,group:w.group,supersedes:[]};if(w.configFn){y.configFn=w.configFn;}this.addModule(y,B);if(C){d.Env.lang=d.Env.lang||{};d.Env.lang[C]=d.Env.lang[C]||{};d.Env.lang[C][z]=true;}}return this.moduleInfo[B];},_setup:function(){var C=this.moduleInfo,z,A,y,w,x,B;for(z in C){if(C.hasOwnProperty(z)){w=C[z];if(w){w.requires=j.dedupe(w.requires);if(w.lang&&w.lang.length){B=this.getLangPackName(u,z);this._addLangPack(null,w,B);}}}}x={};if(!this.ignoreRegistered){d.mix(x,a.mods);}if(this.ignore){d.mix(x,j.hash(this.ignore));}for(y in x){if(x.hasOwnProperty(y)){d.mix(x,this.getProvides(y));}}if(this.force){for(A=0;A<this.force.length;A++){if(this.force[A] in x){delete x[this.force[A]];}}}d.mix(this.loaded,x);this._init=true;},getLangPackName:function(x,w){return("lang/"+w+((x)?"_"+x:""));},_explode:function(){var A=this.required,w,z,x={},y=this;y.dirty=false;y._explodeRollups();A=y.required;r(A,function(B,C){if(!x[C]){x[C]=true;w=y.getModule(C);if(w){var D=w.expound;if(D){A[D]=y.getModule(D);z=y.getRequires(A[D]);d.mix(A,j.hash(z));}z=y.getRequires(w);d.mix(A,j.hash(z));}}});},getModule:function(B){if(!B){return null;}var A,z,x,w=this.moduleInfo[B],y=this.patterns;if(!w){for(x in y){if(y.hasOwnProperty(x)){A=y[x];if(!A.test){A.test=function(D,C){return(D.indexOf(C)>-1);};}if(A.test(B,x)){z=A;break;}}}if(z){if(A.action){A.action.call(this,B,x);}else{w=this.addModule(d.merge(z),B);w.temp=true;}}}return w;},_rollup:function(){},_reduce:function(B){B=B||this.required;var y,x,A,w,z=this.loadType,C=this.ignore?j.hash(this.ignore):false;for(y in B){if(B.hasOwnProperty(y)){w=this.getModule(y);if(((this.loaded[y]||n[y])&&!this.forceMap[y]&&!this.ignoreRegistered)||(z&&w&&w.type!=z)){delete B[y];}if(C&&C[y]){delete B[y];}A=w&&w.supersedes;if(A){for(x=0;x<A.length;x++){if(A[x] in B){delete B[A[x]];}}}}}return B;},_finish:function(y,x){h.running=false;var w=this.onEnd;if(w){w.call(this.context,{msg:y,data:this.data,success:x});}this._continue();},_onSuccess:function(){var y=this,x=d.merge(y.skipped),A,w=[],z=y.requireRegistration,C,B;r(x,function(D){delete y.inserted[D];});y.skipped={};r(y.inserted,function(E,D){var F=y.getModule(D);if(F&&z&&F.type==k&&!(D in YUI.Env.mods)){w.push(D);}else{d.mix(y.loaded,y.getProvides(D));}});A=y.onSuccess;B=(w.length)?"notregistered":"success";C=!(w.length);if(A){A.call(y.context,{msg:B,data:y.data,success:C,failed:w,skipped:x});}y._finish(B,C);},_onProgress:function(x){var w=this;if(w.onProgress){w.onProgress.call(w.context,{name:x.url,data:x.data});}},_onFailure:function(A){var y=this.onFailure,z=[],x=0,w=A.errors.length;for(x;x<w;x++){z.push(A.errors[x].error);}z=z.join(",");if(y){y.call(this.context,{msg:z,data:this.data,success:false});}this._finish(z,false);},_onTimeout:function(){var w=this.onTimeout;if(w){w.call(this.context,{msg:"timeout",data:this.data,success:false});
}},_sort:function(){var F=e.keys(this.required),B={},w=0,y,E,D,A,z,C,x;for(;;){y=F.length;C=false;for(A=w;A<y;A++){E=F[A];for(z=A+1;z<y;z++){x=E+F[z];if(!B[x]&&this._requires(E,F[z])){D=F.splice(z,1);F.splice(A,0,D[0]);B[x]=true;C=true;break;}}if(C){break;}else{w++;}}if(!C){break;}}this.sorted=F;},_insert:function(w,z,D,y){if(w){this._config(w);}if(!y){this.calculate(z);}var A=this.resolve(),E=this,C=0,B=0;if(D){A[((D===k)?q:k)]=[];}if(A.js.length){C++;}if(A.css.length){C++;}var x=function(J){B++;var F={},H=0,G="",I;if(J&&J.errors){for(H=0;H<J.errors.length;H++){if(J.errors[H].request){G=J.errors[H].request.url;}else{G=J.errors[H];}F[G]=G;}}if(J&&J.data&&J.data.length&&(J.type==="success")){for(H=0;H<J.data.length;H++){E.inserted[J.data[H].name]=true;}}if(B===C){E._loading=null;if(J&&J.fn){I=J.fn;delete J.fn;I.call(E,J);}}};this._loading=true;if(!A.js.length&&!A.css.length){B=-1;x({fn:E._onSuccess});return;}if(A.css.length){d.Get.css(A.css,{data:A.cssMods,attributes:E.cssAttributes,insertBefore:E.insertBefore,charset:E.charset,timeout:E.timeout,context:E,onProgress:function(F){E._onProgress.call(E,F);},onTimeout:function(F){E._onTimeout.call(E,F);},onSuccess:function(F){F.type="success";F.fn=E._onSuccess;x.call(E,F);},onFailure:function(F){F.type="failure";F.fn=E._onFailure;x.call(E,F);}});}if(A.js.length){d.Get.js(A.js,{data:A.jsMods,insertBefore:E.insertBefore,attributes:E.jsAttributes,charset:E.charset,timeout:E.timeout,autopurge:false,context:E,async:true,onProgress:function(F){E._onProgress.call(E,F);},onTimeout:function(F){E._onTimeout.call(E,F);},onSuccess:function(F){F.type="success";F.fn=E._onSuccess;x.call(E,F);},onFailure:function(F){F.type="failure";F.fn=E._onFailure;x.call(E,F);}});}},_continue:function(){if(!(h.running)&&h.size()>0){h.running=true;h.next()();}},insert:function(z,x,y){var w=this,A=d.merge(this);delete A.require;delete A.dirty;h.add(function(){w._insert(A,z,x,y);});this._continue();},loadNext:function(w){return;},_filter:function(y,x,B){var A=this.filter,w=x&&(x in this.filters),z=w&&this.filters[x],C=B||(this.moduleInfo[x]?this.moduleInfo[x].group:null);if(C&&this.groups[C]&&this.groups[C].filter){z=this.groups[C].filter;w=true;}if(y){if(w){A=(i.isString(z))?this.FILTER_DEFS[z.toUpperCase()]||null:z;}if(A){y=y.replace(new RegExp(A.searchExp,"g"),A.replaceStr);}}return y;},_url:function(y,w,x){return this._filter((x||this.base||"")+y,w);},resolve:function(x,O){var X,W,U,E,J,G,T,I,N,V,y,H,R,D,aa,F,Y,M=[],K,Q,A={},P=this,w,z,Z=[],B=(P.ignoreRegistered)?{}:P.inserted,S={js:[],jsMods:[],css:[],cssMods:[]},C=P.loadType||"js";if(x){P.calculate();}O=O||P.sorted;var L=function(ab){if(ab){I=(ab.group&&P.groups[ab.group])||f;if(I.async===false){ab.async=I.async;}E=(ab.fullpath)?P._filter(ab.fullpath,O[W]):P._url(ab.path,O[W],I.base||ab.base);if(ab.attributes||ab.async===false){E={url:E,async:ab.async};if(ab.attributes){E.attributes=ab.attributes;}}S[ab.type].push(E);S[ab.type+"Mods"].push(ab);}else{}};X=O.length;aa=P.comboBase;E=aa;R={};for(W=0;W<X;W++){H=aa;U=P.getModule(O[W]);N=U&&U.group;I=P.groups[N];if(N&&I){if(!I.combine||U.fullpath){L(U);continue;}U.combine=true;if(I.comboBase){H=I.comboBase;}if("root" in I&&i.isValue(I.root)){U.root=I.root;}U.comboSep=I.comboSep||P.comboSep;U.maxURLLength=I.maxURLLength||P.maxURLLength;}else{if(!P.combine){L(U);continue;}}R[H]=R[H]||[];R[H].push(U);}for(V in R){if(R.hasOwnProperty(V)){A[V]=A[V]||{js:[],jsMods:[],css:[],cssMods:[]};E=V;D=R[V];X=D.length;if(X){for(W=0;W<X;W++){if(B[D[W]]){continue;}U=D[W];if(U&&(U.combine||!U.ext)){A[V].comboSep=U.comboSep;A[V].group=U.group;A[V].maxURLLength=U.maxURLLength;y=((i.isValue(U.root))?U.root:P.root)+(U.path||U.fullpath);y=P._filter(y,U.name);A[V][U.type].push(y);A[V][U.type+"Mods"].push(U);}else{if(D[W]){L(D[W]);}}}}}}for(V in A){F=V;w=A[F].comboSep||P.comboSep;z=A[F].maxURLLength||P.maxURLLength;for(C in A[F]){if(C===k||C===q){Y=A[F][C];D=A[F][C+"Mods"];X=Y.length;K=F+Y.join(w);Q=K.length;if(z<=F.length){z=m;}if(X){if(Q>z){M=[];for(O=0;O<X;O++){M.push(Y[O]);K=F+M.join(w);if(K.length>z){U=M.pop();K=F+M.join(w);S[C].push(P._filter(K,null,A[F].group));M=[];if(U){M.push(U);}}}if(M.length){K=F+M.join(w);S[C].push(P._filter(K,null,A[F].group));}}else{S[C].push(P._filter(K,null,A[F].group));}}S[C+"Mods"]=S[C+"Mods"].concat(D);}}}A=null;return S;},load:function(w){if(!w){return;}var x=this,y=x.resolve(true);x.data=y;x.onEnd=function(){w.apply(x.context||x,arguments);};x.insert();}};},"3.5.0",{requires:["get","features"]});YUI.add("loader-rollup",function(a){a.Loader.prototype._rollup=function(){var k,h,g,o,b=this.required,e,f=this.moduleInfo,d,l,n;if(this.dirty||!this.rollups){this.rollups={};for(k in f){if(f.hasOwnProperty(k)){g=this.getModule(k);if(g&&g.rollup){this.rollups[k]=g;}}}}for(;;){d=false;for(k in this.rollups){if(this.rollups.hasOwnProperty(k)){if(!b[k]&&((!this.loaded[k])||this.forceMap[k])){g=this.getModule(k);o=g.supersedes||[];e=false;if(!g.rollup){continue;}l=0;for(h=0;h<o.length;h++){n=f[o[h]];if(this.loaded[o[h]]&&!this.forceMap[o[h]]){e=false;break;}else{if(b[o[h]]&&g.type==n.type){l++;e=(l>=g.rollup);if(e){break;}}}}if(e){b[k]=true;d=true;this.getRequires(g);}}}}if(!d){break;}}};},"3.5.0",{requires:["loader-base"]});YUI.add("loader-yui3",function(a){YUI.Env[a.version].modules=YUI.Env[a.version].modules||{"align-plugin":{"requires":["node-screen","node-pluginhost"]},"anim":{"use":["anim-base","anim-color","anim-curve","anim-easing","anim-node-plugin","anim-scroll","anim-xy"]},"anim-base":{"requires":["base-base","node-style"]},"anim-color":{"requires":["anim-base"]},"anim-curve":{"requires":["anim-xy"]},"anim-easing":{"requires":["anim-base"]},"anim-node-plugin":{"requires":["node-pluginhost","anim-base"]},"anim-scroll":{"requires":["anim-base"]},"anim-shape-transform":{"requires":["anim-base","anim-easing","matrix"]},"anim-xy":{"requires":["anim-base","node-screen"]},"app":{"use":["app-base","app-transitions","model","model-list","router","view"]},"app-base":{"requires":["classnamemanager","pjax-base","router","view"]},"app-transitions":{"requires":["app-base"]},"app-transitions-css":{"type":"css"},"app-transitions-native":{"condition":{"name":"app-transitions-native","test":function(d){var c=d.config.doc,b=c?c.documentElement:null;
if(b&&b.style){return("MozTransition" in b.style||"WebkitTransition" in b.style);}return false;},"trigger":"app-transitions"},"requires":["app-transitions","app-transitions-css","parallel","transition"]},"array-extras":{"requires":["yui-base"]},"array-invoke":{"requires":["yui-base"]},"arraylist":{"requires":["yui-base"]},"arraylist-add":{"requires":["arraylist"]},"arraylist-filter":{"requires":["arraylist"]},"arraysort":{"requires":["yui-base"]},"async-queue":{"requires":["event-custom"]},"attribute":{"use":["attribute-base","attribute-complex"]},"attribute-base":{"requires":["attribute-core","attribute-events","attribute-extras"]},"attribute-complex":{"requires":["attribute-base"]},"attribute-core":{"requires":["yui-base"]},"attribute-events":{"requires":["event-custom"]},"attribute-extras":{"requires":["yui-base"]},"autocomplete":{"use":["autocomplete-base","autocomplete-sources","autocomplete-list","autocomplete-plugin"]},"autocomplete-base":{"optional":["autocomplete-sources"],"requires":["array-extras","base-build","escape","event-valuechange","node-base"]},"autocomplete-filters":{"requires":["array-extras","text-wordbreak"]},"autocomplete-filters-accentfold":{"requires":["array-extras","text-accentfold","text-wordbreak"]},"autocomplete-highlighters":{"requires":["array-extras","highlight-base"]},"autocomplete-highlighters-accentfold":{"requires":["array-extras","highlight-accentfold"]},"autocomplete-list":{"after":["autocomplete-sources"],"lang":["en"],"requires":["autocomplete-base","event-resize","node-screen","selector-css3","shim-plugin","widget","widget-position","widget-position-align"],"skinnable":true},"autocomplete-list-keys":{"condition":{"name":"autocomplete-list-keys","test":function(b){return !(b.UA.ios||b.UA.android);},"trigger":"autocomplete-list"},"requires":["autocomplete-list","base-build"]},"autocomplete-plugin":{"requires":["autocomplete-list","node-pluginhost"]},"autocomplete-sources":{"optional":["io-base","json-parse","jsonp","yql"],"requires":["autocomplete-base"]},"base":{"use":["base-base","base-pluginhost","base-build"]},"base-base":{"after":["attribute-complex"],"requires":["base-core","attribute-base"]},"base-build":{"requires":["base-base"]},"base-core":{"requires":["attribute-core"]},"base-pluginhost":{"requires":["base-base","pluginhost"]},"button":{"requires":["button-core","cssbutton","widget"]},"button-core":{"requires":["attribute-core","classnamemanager","node-base"]},"button-group":{"requires":["button-plugin","cssbutton","widget"]},"button-plugin":{"requires":["button-core","cssbutton","node-pluginhost"]},"cache":{"use":["cache-base","cache-offline","cache-plugin"]},"cache-base":{"requires":["base"]},"cache-offline":{"requires":["cache-base","json"]},"cache-plugin":{"requires":["plugin","cache-base"]},"calendar":{"lang":["de","en","fr","ja","nb-NO","pt-BR","ru","zh-HANT-TW"],"requires":["calendar-base","calendarnavigator"],"skinnable":true},"calendar-base":{"lang":["de","en","fr","ja","nb-NO","pt-BR","ru","zh-HANT-TW"],"requires":["widget","substitute","datatype-date","datatype-date-math","cssgrids"],"skinnable":true},"calendarnavigator":{"requires":["plugin","classnamemanager","datatype-date","node","substitute"],"skinnable":true},"charts":{"requires":["charts-base"]},"charts-base":{"requires":["dom","datatype-number","datatype-date","event-custom","event-mouseenter","event-touch","widget","widget-position","widget-stack","graphics"]},"charts-legend":{"requires":["charts-base"]},"classnamemanager":{"requires":["yui-base"]},"clickable-rail":{"requires":["slider-base"]},"collection":{"use":["array-extras","arraylist","arraylist-add","arraylist-filter","array-invoke"]},"console":{"lang":["en","es","ja"],"requires":["yui-log","widget","substitute"],"skinnable":true},"console-filters":{"requires":["plugin","console"],"skinnable":true},"controller":{"use":["router"]},"cookie":{"requires":["yui-base"]},"createlink-base":{"requires":["editor-base"]},"cssbase":{"after":["cssreset","cssfonts","cssgrids","cssreset-context","cssfonts-context","cssgrids-context"],"type":"css"},"cssbase-context":{"after":["cssreset","cssfonts","cssgrids","cssreset-context","cssfonts-context","cssgrids-context"],"type":"css"},"cssbutton":{"type":"css"},"cssfonts":{"type":"css"},"cssfonts-context":{"type":"css"},"cssgrids":{"optional":["cssreset","cssfonts"],"type":"css"},"cssgrids-base":{"optional":["cssreset","cssfonts"],"type":"css"},"cssgrids-units":{"optional":["cssreset","cssfonts"],"requires":["cssgrids-base"],"type":"css"},"cssreset":{"type":"css"},"cssreset-context":{"type":"css"},"dataschema":{"use":["dataschema-base","dataschema-json","dataschema-xml","dataschema-array","dataschema-text"]},"dataschema-array":{"requires":["dataschema-base"]},"dataschema-base":{"requires":["base"]},"dataschema-json":{"requires":["dataschema-base","json"]},"dataschema-text":{"requires":["dataschema-base"]},"dataschema-xml":{"requires":["dataschema-base"]},"datasource":{"use":["datasource-local","datasource-io","datasource-get","datasource-function","datasource-cache","datasource-jsonschema","datasource-xmlschema","datasource-arrayschema","datasource-textschema","datasource-polling"]},"datasource-arrayschema":{"requires":["datasource-local","plugin","dataschema-array"]},"datasource-cache":{"requires":["datasource-local","plugin","cache-base"]},"datasource-function":{"requires":["datasource-local"]},"datasource-get":{"requires":["datasource-local","get"]},"datasource-io":{"requires":["datasource-local","io-base"]},"datasource-jsonschema":{"requires":["datasource-local","plugin","dataschema-json"]},"datasource-local":{"requires":["base"]},"datasource-polling":{"requires":["datasource-local"]},"datasource-textschema":{"requires":["datasource-local","plugin","dataschema-text"]},"datasource-xmlschema":{"requires":["datasource-local","plugin","dataschema-xml"]},"datatable":{"use":["datatable-core","datatable-head","datatable-body","datatable-base","datatable-column-widths","datatable-message","datatable-mutable","datatable-sort","datatable-datasource"]},"datatable-base":{"requires":["datatable-core","datatable-head","datatable-body","base-build","widget"],"skinnable":true},"datatable-base-deprecated":{"requires":["recordset-base","widget","substitute","event-mouseenter"],"skinnable":true},"datatable-body":{"requires":["datatable-core","view","classnamemanager"]},"datatable-column-widths":{"requires":["datatable-base"]},"datatable-core":{"requires":["escape","model-list","node-event-delegate"]},"datatable-datasource":{"requires":["datatable-base","plugin","datasource-local"]},"datatable-datasource-deprecated":{"requires":["datatable-base-deprecated","plugin","datasource-local"]},"datatable-deprecated":{"use":["datatable-base-deprecated","datatable-datasource-deprecated","datatable-sort-deprecated","datatable-scroll-deprecated"]},"datatable-head":{"requires":["datatable-core","view","classnamemanager"]},"datatable-message":{"lang":["en"],"requires":["datatable-base"],"skinnable":true},"datatable-mutable":{"requires":["datatable-base"]},"datatable-scroll":{"requires":["datatable-base","datatable-column-widths","dom-screen"],"skinnable":true},"datatable-scroll-deprecated":{"requires":["datatable-base-deprecated","plugin"]},"datatable-sort":{"lang":["en"],"requires":["datatable-base"],"skinnable":true},"datatable-sort-deprecated":{"lang":["en"],"requires":["datatable-base-deprecated","plugin","recordset-sort"]},"datatype":{"use":["datatype-number","datatype-date","datatype-xml"]},"datatype-date":{"supersedes":["datatype-date-format"],"use":["datatype-date-parse","datatype-date-format"]},"datatype-date-format":{"lang":["ar","ar-JO","ca","ca-ES","da","da-DK","de","de-AT","de-DE","el","el-GR","en","en-AU","en-CA","en-GB","en-IE","en-IN","en-JO","en-MY","en-NZ","en-PH","en-SG","en-US","es","es-AR","es-BO","es-CL","es-CO","es-EC","es-ES","es-MX","es-PE","es-PY","es-US","es-UY","es-VE","fi","fi-FI","fr","fr-BE","fr-CA","fr-FR","hi","hi-IN","id","id-ID","it","it-IT","ja","ja-JP","ko","ko-KR","ms","ms-MY","nb","nb-NO","nl","nl-BE","nl-NL","pl","pl-PL","pt","pt-BR","ro","ro-RO","ru","ru-RU","sv","sv-SE","th","th-TH","tr","tr-TR","vi","vi-VN","zh-Hans","zh-Hans-CN","zh-Hant","zh-Hant-HK","zh-Hant-TW"]},"datatype-date-math":{"requires":["yui-base"]},"datatype-date-parse":{},"datatype-number":{"use":["datatype-number-parse","datatype-number-format"]},"datatype-number-format":{},"datatype-number-parse":{},"datatype-xml":{"use":["datatype-xml-parse","datatype-xml-format"]},"datatype-xml-format":{},"datatype-xml-parse":{},"dd":{"use":["dd-ddm-base","dd-ddm","dd-ddm-drop","dd-drag","dd-proxy","dd-constrain","dd-drop","dd-scroll","dd-delegate"]},"dd-constrain":{"requires":["dd-drag"]},"dd-ddm":{"requires":["dd-ddm-base","event-resize"]},"dd-ddm-base":{"requires":["node","base","yui-throttle","classnamemanager"]},"dd-ddm-drop":{"requires":["dd-ddm"]},"dd-delegate":{"requires":["dd-drag","dd-drop-plugin","event-mouseenter"]},"dd-drag":{"requires":["dd-ddm-base"]},"dd-drop":{"requires":["dd-drag","dd-ddm-drop"]},"dd-drop-plugin":{"requires":["dd-drop"]},"dd-gestures":{"condition":{"name":"dd-gestures","test":function(b){return((b.config.win&&("ontouchstart" in b.config.win))&&!(b.UA.chrome&&b.UA.chrome<6));
},"trigger":"dd-drag"},"requires":["dd-drag","event-synthetic","event-gestures"]},"dd-plugin":{"optional":["dd-constrain","dd-proxy"],"requires":["dd-drag"]},"dd-proxy":{"requires":["dd-drag"]},"dd-scroll":{"requires":["dd-drag"]},"dial":{"lang":["en","es"],"requires":["widget","dd-drag","substitute","event-mouseenter","event-move","event-key","transition","intl"],"skinnable":true},"dom":{"use":["dom-base","dom-screen","dom-style","selector-native","selector"]},"dom-base":{"requires":["dom-core"]},"dom-core":{"requires":["oop","features"]},"dom-deprecated":{"requires":["dom-base"]},"dom-screen":{"requires":["dom-base","dom-style"]},"dom-style":{"requires":["dom-base"]},"dom-style-ie":{"condition":{"name":"dom-style-ie","test":function(h){var f=h.Features.test,g=h.Features.add,d=h.config.win,e=h.config.doc,b="documentElement",c=false;g("style","computedStyle",{test:function(){return d&&"getComputedStyle" in d;}});g("style","opacity",{test:function(){return e&&"opacity" in e[b].style;}});c=(!f("style","opacity")&&!f("style","computedStyle"));return c;},"trigger":"dom-style"},"requires":["dom-style"]},"dump":{"requires":["yui-base"]},"editor":{"use":["frame","editor-selection","exec-command","editor-base","editor-para","editor-br","editor-bidi","editor-tab","createlink-base"]},"editor-base":{"requires":["base","frame","node","exec-command","editor-selection"]},"editor-bidi":{"requires":["editor-base"]},"editor-br":{"requires":["editor-base"]},"editor-lists":{"requires":["editor-base"]},"editor-para":{"requires":["editor-para-base"]},"editor-para-base":{"requires":["editor-base"]},"editor-para-ie":{"condition":{"name":"editor-para-ie","trigger":"editor-para","ua":"ie","when":"instead"},"requires":["editor-para-base"]},"editor-selection":{"requires":["node"]},"editor-tab":{"requires":["editor-base"]},"escape":{"requires":["yui-base"]},"event":{"after":["node-base"],"use":["event-base","event-delegate","event-synthetic","event-mousewheel","event-mouseenter","event-key","event-focus","event-resize","event-hover","event-outside","event-touch","event-move","event-flick","event-valuechange"]},"event-base":{"after":["node-base"],"requires":["event-custom-base"]},"event-base-ie":{"after":["event-base"],"condition":{"name":"event-base-ie","test":function(c){var b=c.config.doc&&c.config.doc.implementation;return(b&&(!b.hasFeature("Events","2.0")));},"trigger":"node-base"},"requires":["node-base"]},"event-contextmenu":{"requires":["event-synthetic","dom-screen"]},"event-custom":{"use":["event-custom-base","event-custom-complex"]},"event-custom-base":{"requires":["oop"]},"event-custom-complex":{"requires":["event-custom-base"]},"event-delegate":{"requires":["node-base"]},"event-flick":{"requires":["node-base","event-touch","event-synthetic"]},"event-focus":{"requires":["event-synthetic"]},"event-gestures":{"use":["event-flick","event-move"]},"event-hover":{"requires":["event-mouseenter"]},"event-key":{"requires":["event-synthetic"]},"event-mouseenter":{"requires":["event-synthetic"]},"event-mousewheel":{"requires":["node-base"]},"event-move":{"requires":["node-base","event-touch","event-synthetic"]},"event-outside":{"requires":["event-synthetic"]},"event-resize":{"requires":["node-base","event-synthetic"]},"event-simulate":{"requires":["event-base"]},"event-synthetic":{"requires":["node-base","event-custom-complex"]},"event-touch":{"requires":["node-base"]},"event-valuechange":{"requires":["event-focus","event-synthetic"]},"exec-command":{"requires":["frame"]},"features":{"requires":["yui-base"]},"file":{"requires":["file-flash","file-html5"]},"file-flash":{"requires":["base"]},"file-html5":{"requires":["base"]},"frame":{"requires":["base","node","selector-css3","substitute","yui-throttle"]},"get":{"requires":["yui-base"]},"graphics":{"requires":["node","event-custom","pluginhost","matrix"]},"graphics-canvas":{"condition":{"name":"graphics-canvas","test":function(f){var d=f.config.doc,e=f.config.defaultGraphicEngine&&f.config.defaultGraphicEngine=="canvas",c=d&&d.createElement("canvas"),b=(d&&d.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return(!b||e)&&(c&&c.getContext&&c.getContext("2d"));},"trigger":"graphics"},"requires":["graphics"]},"graphics-canvas-default":{"condition":{"name":"graphics-canvas-default","test":function(f){var d=f.config.doc,e=f.config.defaultGraphicEngine&&f.config.defaultGraphicEngine=="canvas",c=d&&d.createElement("canvas"),b=(d&&d.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return(!b||e)&&(c&&c.getContext&&c.getContext("2d"));},"trigger":"graphics"}},"graphics-svg":{"condition":{"name":"graphics-svg","test":function(f){var e=f.config.doc,d=!f.config.defaultGraphicEngine||f.config.defaultGraphicEngine!="canvas",c=e&&e.createElement("canvas"),b=(e&&e.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return b&&(d||!c);},"trigger":"graphics"},"requires":["graphics"]},"graphics-svg-default":{"condition":{"name":"graphics-svg-default","test":function(f){var e=f.config.doc,d=!f.config.defaultGraphicEngine||f.config.defaultGraphicEngine!="canvas",c=e&&e.createElement("canvas"),b=(e&&e.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return b&&(d||!c);},"trigger":"graphics"}},"graphics-vml":{"condition":{"name":"graphics-vml","test":function(d){var c=d.config.doc,b=c&&c.createElement("canvas");return(c&&!c.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")&&(!b||!b.getContext||!b.getContext("2d")));},"trigger":"graphics"},"requires":["graphics"]},"graphics-vml-default":{"condition":{"name":"graphics-vml-default","test":function(d){var c=d.config.doc,b=c&&c.createElement("canvas");return(c&&!c.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")&&(!b||!b.getContext||!b.getContext("2d")));},"trigger":"graphics"}},"handlebars":{"use":["handlebars-compiler"]},"handlebars-base":{"requires":["escape"]},"handlebars-compiler":{"requires":["handlebars-base"]},"highlight":{"use":["highlight-base","highlight-accentfold"]},"highlight-accentfold":{"requires":["highlight-base","text-accentfold"]},"highlight-base":{"requires":["array-extras","classnamemanager","escape","text-wordbreak"]},"history":{"use":["history-base","history-hash","history-hash-ie","history-html5"]},"history-base":{"requires":["event-custom-complex"]},"history-hash":{"after":["history-html5"],"requires":["event-synthetic","history-base","yui-later"]},"history-hash-ie":{"condition":{"name":"history-hash-ie","test":function(c){var b=c.config.doc&&c.config.doc.documentMode;
return c.UA.ie&&(!("onhashchange" in c.config.win)||!b||b<8);},"trigger":"history-hash"},"requires":["history-hash","node-base"]},"history-html5":{"optional":["json"],"requires":["event-base","history-base","node-base"]},"imageloader":{"requires":["base-base","node-style","node-screen"]},"intl":{"requires":["intl-base","event-custom"]},"intl-base":{"requires":["yui-base"]},"io":{"use":["io-base","io-xdr","io-form","io-upload-iframe","io-queue"]},"io-base":{"requires":["event-custom-base","querystring-stringify-simple"]},"io-form":{"requires":["io-base","node-base"]},"io-nodejs":{"condition":{"name":"io-nodejs","trigger":"io-base","ua":"nodejs"},"requires":["io-base"]},"io-queue":{"requires":["io-base","queue-promote"]},"io-upload-iframe":{"requires":["io-base","node-base"]},"io-xdr":{"requires":["io-base","datatype-xml-parse"]},"json":{"use":["json-parse","json-stringify"]},"json-parse":{"requires":["yui-base"]},"json-stringify":{"requires":["yui-base"]},"jsonp":{"requires":["get","oop"]},"jsonp-url":{"requires":["jsonp"]},"loader":{"use":["loader-base","loader-rollup","loader-yui3"]},"loader-base":{"requires":["get","features"]},"loader-rollup":{"requires":["loader-base"]},"loader-yui3":{"requires":["loader-base"]},"matrix":{"requires":["yui-base"]},"model":{"requires":["base-build","escape","json-parse"]},"model-list":{"requires":["array-extras","array-invoke","arraylist","base-build","escape","json-parse","model"]},"node":{"use":["node-base","node-event-delegate","node-pluginhost","node-screen","node-style"]},"node-base":{"requires":["event-base","node-core","dom-base"]},"node-core":{"requires":["dom-core","selector"]},"node-deprecated":{"requires":["node-base"]},"node-event-delegate":{"requires":["node-base","event-delegate"]},"node-event-html5":{"requires":["node-base"]},"node-event-simulate":{"requires":["node-base","event-simulate"]},"node-flick":{"requires":["classnamemanager","transition","event-flick","plugin"],"skinnable":true},"node-focusmanager":{"requires":["attribute","node","plugin","node-event-simulate","event-key","event-focus"]},"node-load":{"requires":["node-base","io-base"]},"node-menunav":{"requires":["node","classnamemanager","plugin","node-focusmanager"],"skinnable":true},"node-pluginhost":{"requires":["node-base","pluginhost"]},"node-screen":{"requires":["dom-screen","node-base"]},"node-style":{"requires":["dom-style","node-base"]},"oop":{"requires":["yui-base"]},"overlay":{"requires":["widget","widget-stdmod","widget-position","widget-position-align","widget-stack","widget-position-constrain"],"skinnable":true},"panel":{"requires":["widget","widget-autohide","widget-buttons","widget-modality","widget-position","widget-position-align","widget-position-constrain","widget-stack","widget-stdmod"],"skinnable":true},"parallel":{"requires":["yui-base"]},"pjax":{"requires":["pjax-base","io-base"]},"pjax-base":{"requires":["classnamemanager","node-event-delegate","router"]},"pjax-plugin":{"requires":["node-pluginhost","pjax","plugin"]},"plugin":{"requires":["base-base"]},"pluginhost":{"use":["pluginhost-base","pluginhost-config"]},"pluginhost-base":{"requires":["yui-base"]},"pluginhost-config":{"requires":["pluginhost-base"]},"profiler":{"requires":["yui-base"]},"querystring":{"use":["querystring-parse","querystring-stringify"]},"querystring-parse":{"requires":["yui-base","array-extras"]},"querystring-parse-simple":{"requires":["yui-base"]},"querystring-stringify":{"requires":["yui-base"]},"querystring-stringify-simple":{"requires":["yui-base"]},"queue-promote":{"requires":["yui-base"]},"range-slider":{"requires":["slider-base","slider-value-range","clickable-rail"]},"recordset":{"use":["recordset-base","recordset-sort","recordset-filter","recordset-indexer"]},"recordset-base":{"requires":["base","arraylist"]},"recordset-filter":{"requires":["recordset-base","array-extras","plugin"]},"recordset-indexer":{"requires":["recordset-base","plugin"]},"recordset-sort":{"requires":["arraysort","recordset-base","plugin"]},"resize":{"use":["resize-base","resize-proxy","resize-constrain"]},"resize-base":{"requires":["base","widget","substitute","event","oop","dd-drag","dd-delegate","dd-drop"],"skinnable":true},"resize-constrain":{"requires":["plugin","resize-base"]},"resize-plugin":{"optional":["resize-constrain"],"requires":["resize-base","plugin"]},"resize-proxy":{"requires":["plugin","resize-base"]},"rls":{"requires":["get","features"]},"router":{"optional":["querystring-parse"],"requires":["array-extras","base-build","history"]},"scrollview":{"requires":["scrollview-base","scrollview-scrollbars"]},"scrollview-base":{"requires":["widget","event-gestures","event-mousewheel","transition"],"skinnable":true},"scrollview-base-ie":{"condition":{"name":"scrollview-base-ie","trigger":"scrollview-base","ua":"ie"},"requires":["scrollview-base"]},"scrollview-list":{"requires":["plugin","classnamemanager"],"skinnable":true},"scrollview-paginator":{"requires":["plugin"]},"scrollview-scrollbars":{"requires":["classnamemanager","transition","plugin"],"skinnable":true},"selector":{"requires":["selector-native"]},"selector-css2":{"condition":{"name":"selector-css2","test":function(d){var c=d.config.doc,b=c&&!("querySelectorAll" in c);return b;},"trigger":"selector"},"requires":["selector-native"]},"selector-css3":{"requires":["selector-native","selector-css2"]},"selector-native":{"requires":["dom-base"]},"shim-plugin":{"requires":["node-style","node-pluginhost"]},"slider":{"use":["slider-base","slider-value-range","clickable-rail","range-slider"]},"slider-base":{"requires":["widget","dd-constrain","substitute","event-key"],"skinnable":true},"slider-value-range":{"requires":["slider-base"]},"sortable":{"requires":["dd-delegate","dd-drop-plugin","dd-proxy"]},"sortable-scroll":{"requires":["dd-scroll","sortable"]},"stylesheet":{"requires":["yui-base"]},"substitute":{"optional":["dump"],"requires":["yui-base"]},"swf":{"requires":["event-custom","node","swfdetect","escape"]},"swfdetect":{"requires":["yui-base"]},"tabview":{"requires":["widget","widget-parent","widget-child","tabview-base","node-pluginhost","node-focusmanager"],"skinnable":true},"tabview-base":{"requires":["node-event-delegate","classnamemanager","skin-sam-tabview"]},"tabview-plugin":{"requires":["tabview-base"]},"test":{"requires":["event-simulate","event-custom","substitute","json-stringify"],"skinnable":true},"test-console":{"requires":["console-filters","test"],"skinnable":true},"text":{"use":["text-accentfold","text-wordbreak"]},"text-accentfold":{"requires":["array-extras","text-data-accentfold"]},"text-data-accentfold":{"requires":["yui-base"]},"text-data-wordbreak":{"requires":["yui-base"]},"text-wordbreak":{"requires":["array-extras","text-data-wordbreak"]},"transition":{"requires":["node-style"]},"transition-timer":{"condition":{"name":"transition-timer","test":function(e){var d=e.config.doc,c=(d)?d.documentElement:null,b=true;
if(c&&c.style){b=!("MozTransition" in c.style||"WebkitTransition" in c.style);}return b;},"trigger":"transition"},"requires":["transition"]},"uploader":{"requires":["uploader-html5","uploader-flash"]},"uploader-deprecated":{"requires":["event-custom","node","base","swf"]},"uploader-flash":{"requires":["swf","widget","substitute","base","cssbutton","node","event-custom","file-flash","uploader-queue"]},"uploader-html5":{"requires":["widget","node-event-simulate","substitute","file-html5","uploader-queue"]},"uploader-queue":{"requires":["base"]},"view":{"requires":["base-build","node-event-delegate"]},"view-node-map":{"requires":["view"]},"widget":{"use":["widget-base","widget-htmlparser","widget-skin","widget-uievents"]},"widget-anim":{"requires":["anim-base","plugin","widget"]},"widget-autohide":{"requires":["base-build","event-key","event-outside","widget"]},"widget-base":{"requires":["attribute","base-base","base-pluginhost","classnamemanager","event-focus","node-base","node-style"],"skinnable":true},"widget-base-ie":{"condition":{"name":"widget-base-ie","trigger":"widget-base","ua":"ie"},"requires":["widget-base"]},"widget-buttons":{"requires":["button-plugin","cssbutton","widget-stdmod"]},"widget-child":{"requires":["base-build","widget"]},"widget-htmlparser":{"requires":["widget-base"]},"widget-locale":{"requires":["widget-base"]},"widget-modality":{"requires":["base-build","event-outside","widget"],"skinnable":true},"widget-parent":{"requires":["arraylist","base-build","widget"]},"widget-position":{"requires":["base-build","node-screen","widget"]},"widget-position-align":{"requires":["widget-position"]},"widget-position-constrain":{"requires":["widget-position"]},"widget-skin":{"requires":["widget-base"]},"widget-stack":{"requires":["base-build","widget"],"skinnable":true},"widget-stdmod":{"requires":["base-build","widget"]},"widget-uievents":{"requires":["node-event-delegate","widget-base"]},"yql":{"requires":["jsonp","jsonp-url"]},"yui":{},"yui-base":{},"yui-later":{"requires":["yui-base"]},"yui-log":{"requires":["yui-base"]},"yui-rls":{},"yui-throttle":{"requires":["yui-base"]}};YUI.Env[a.version].md5="f5a3bc9bda2441a3b15fb52c567fc1f7";},"3.5.0",{requires:["loader-base"]});YUI.add("yui",function(a){},"3.5.0",{use:["yui-base","get","features","intl-base","yui-log","yui-later","loader-base","loader-rollup","loader-yui3"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("loader-base",function(d){if(!YUI.Env[d.version]){(function(){var I=d.version,E="/build/",F=I+E,D=d.Env.base,A="gallery-2012.04.10-14-57",C="2in3",B="4",z="2.9.0",G=D+"combo?",H={version:I,root:F,base:d.Env.base,comboBase:G,skin:{defaultSkin:"sam",base:"assets/skins/",path:"skin.css",after:["cssreset","cssfonts","cssgrids","cssbase","cssreset-context","cssfonts-context"]},groups:{},patterns:{}},y=H.groups,x=function(K,O,L){var J=C+"."+(K||B)+"/"+(O||z)+E,M=(L&&L.base)?L.base:D,N=(L&&L.comboBase)?L.comboBase:G;y.yui2.base=M+J;y.yui2.root=J;y.yui2.comboBase=N;},w=function(J,L){var K=(J||A)+E,M=(L&&L.base)?L.base:D,N=(L&&L.comboBase)?L.comboBase:G;y.gallery.base=M+K;y.gallery.root=K;y.gallery.comboBase=N;};y[I]={};y.gallery={ext:false,combine:true,comboBase:G,update:w,patterns:{"gallery-":{},"lang/gallery-":{},"gallerycss-":{type:"css"}}};y.yui2={combine:true,ext:false,comboBase:G,update:x,patterns:{"yui2-":{configFn:function(J){if(/-skin|reset|fonts|grids|base/.test(J.name)){J.type="css";J.path=J.path.replace(/\.js/,".css");J.path=J.path.replace(/\/yui2-skin/,"/assets/skins/sam/yui2-skin");}}}}};w();x();YUI.Env[I]=H;}());}var f={},c=[],m=1024,a=YUI.Env,p=a._loaded,q="css",k="js",v="intl",s=d.version,u="",e=d.Object,r=e.each,j=d.Array,h=a._loaderQueue,t=a[s],b="skin-",i=d.Lang,n=a.mods,l,o,g=function(x,y,z,w){var A=x+"/"+y;if(!w){A+="-min";}A+="."+(z||q);return A;};d.Env.meta=t;d.Loader=function(A){var z=t.modules,x=this;A=A||{};l=t.md5;x.context=d;x.base=d.Env.meta.base+d.Env.meta.root;x.comboBase=d.Env.meta.comboBase;x.combine=A.base&&(A.base.indexOf(x.comboBase.substr(0,20))>-1);x.comboSep="&";x.maxURLLength=m;x.root=d.Env.meta.root;x.timeout=0;x.forceMap={};x.allowRollup=false;x.filters={};x.required={};x.patterns={};x.moduleInfo={};x.groups=d.merge(d.Env.meta.groups);x.skin=d.merge(d.Env.meta.skin);x.conditions={};x.config=A;x._internal=true;o=a._renderedMods;if(o){r(o,function y(C,B){x.moduleInfo[B]=d.merge(C);});o=a._conditions;r(o,function w(C,B){x.conditions[B]=d.merge(C);});}else{r(z,x.addModule,x);}x.loaded=p[s];x._inspectPage();x._internal=false;x._config(A);x.forceMap=(x.force)?d.Array.hash(x.force):{};x.testresults=null;if(d.config.tests){x.testresults=d.config.tests;}x.sorted=[];x.dirty=true;x.inserted={};x.skipped={};x.tested={};};d.Loader.prototype={REGEX_CSS:/\.css(?:[?;].*)?$/i,FILTER_DEFS:{RAW:{"searchExp":"-min\\.js","replaceStr":".js"},DEBUG:{"searchExp":"-min\\.js","replaceStr":"-debug.js"}},_inspectPage:function(){r(this.moduleInfo,function(x,w){if(x.type&&x.type===q){if(this.isCSSLoaded(x.name)){this.loaded[w]=true;}}},this);r(n,function(y,x){if(y.details){var w=this.moduleInfo[x],A=y.details.requires,z=w&&w.requires;if(w){if(!w._inspected&&A&&z.length!=A.length){delete w.expanded;}}else{w=this.addModule(y.details,x);}w._inspected=true;}},this);},_requires:function(C,B){var y,A,D,E,w=this.moduleInfo,x=w[C],z=w[B];if(!x||!z){return false;}A=x.expanded_map;D=x.after_map;if(D&&(B in D)){return true;}D=z.after_map;if(D&&(C in D)){return false;}E=w[B]&&w[B].supersedes;if(E){for(y=0;y<E.length;y++){if(this._requires(C,E[y])){return true;}}}E=w[C]&&w[C].supersedes;if(E){for(y=0;y<E.length;y++){if(this._requires(B,E[y])){return false;}}}if(A&&(B in A)){return true;}if(x.ext&&x.type==q&&!z.ext&&z.type==q){return true;}return false;},_config:function(C){var y,x,B,z,A,D,w=this;if(C){for(y in C){if(C.hasOwnProperty(y)){B=C[y];if(y=="require"){w.require(B);}else{if(y=="skin"){if(typeof B==="string"){w.skin.defaultSkin=C.skin;B={defaultSkin:B};}d.mix(w.skin,B,true);}else{if(y=="groups"){for(x in B){if(B.hasOwnProperty(x)){D=x;A=B[x];w.addGroup(A,D);if(A.aliases){r(A.aliases,w.addAlias,w);}}}}else{if(y=="modules"){r(B,w.addModule,w);}else{if(y==="aliases"){r(B,w.addAlias,w);}else{if(y=="gallery"){this.groups.gallery.update(B,C);}else{if(y=="yui2"||y=="2in3"){this.groups.yui2.update(C["2in3"],C.yui2,C);}else{w[y]=B;}}}}}}}}}}z=w.filter;if(i.isString(z)){z=z.toUpperCase();w.filterName=z;w.filter=w.FILTER_DEFS[z];if(z=="DEBUG"){w.require("yui-log","dump");}}if(w.lang){}},formatSkin:function(y,w){var x=b+y;if(w){x=x+"-"+w;}return x;},_addSkin:function(F,D,E){var C,B,x,w,A=this.moduleInfo,y=this.skin,z=A[D]&&A[D].ext;if(D){x=this.formatSkin(F,D);if(!A[x]){C=A[D];B=C.pkg||D;w={name:x,group:C.group,type:"css",after:y.after,path:(E||B)+"/"+y.base+F+"/"+D+".css",ext:z};if(C.base){w.base=C.base;}if(C.configFn){w.configFn=C.configFn;}this.addModule(w,x);}}return x;},addAlias:function(w,x){YUI.Env.aliases[x]=w;this.addModule({name:x,use:w});},addGroup:function(z,x){var y=z.modules,w=this;x=x||z.name;z.name=x;w.groups[x]=z;if(z.patterns){r(z.patterns,function(B,A){B.group=x;w.patterns[A]=B;});}if(y){r(y,function(B,A){if(typeof B==="string"){B={name:A,fullpath:B};}B.group=x;w.addModule(B,A);},w);}},addModule:function(N,U){U=U||N.name;if(typeof N==="string"){N={name:U,fullpath:N};}if(this.moduleInfo[U]&&this.moduleInfo[U].temp){N=d.merge(this.moduleInfo[U],N);}N.name=U;if(!N||!N.name){return null;}if(!N.type){N.type=k;var L=N.path||N.fullpath;if(L&&this.REGEX_CSS.test(L)){N.type=q;}}if(!N.path&&!N.fullpath){N.path=g(U,U,N.type);}N.supersedes=N.supersedes||N.use;N.ext=("ext" in N)?N.ext:(this._internal)?false:true;var R=N.submodules,Q,O,H,w,I,y,M,x,P,J,F,C,A,z,T,S,G,B,D,E=this.conditions,K;this.moduleInfo[U]=N;N.requires=N.requires||[];if(N.skinnable){B=this._addSkin(this.skin.defaultSkin,U);N.requires.unshift(B);}N.requires=this.filterRequires(N.requires)||[];if(!N.langPack&&N.lang){J=j(N.lang);for(P=0;P<J.length;P++){T=J[P];F=this.getLangPackName(T,U);y=this.moduleInfo[F];if(!y){y=this._addLangPack(T,N,F);}}}if(R){w=N.supersedes||[];O=0;for(Q in R){if(R.hasOwnProperty(Q)){I=R[Q];I.path=I.path||g(U,Q,N.type);I.pkg=U;I.group=N.group;if(I.supersedes){w=w.concat(I.supersedes);}y=this.addModule(I,Q);w.push(Q);if(y.skinnable){N.skinnable=true;G=this.skin.overrides;if(G&&G[Q]){for(P=0;P<G[Q].length;P++){B=this._addSkin(G[Q][P],Q,U);w.push(B);}}B=this._addSkin(this.skin.defaultSkin,Q,U);w.push(B);
}if(I.lang&&I.lang.length){J=j(I.lang);for(P=0;P<J.length;P++){T=J[P];F=this.getLangPackName(T,U);C=this.getLangPackName(T,Q);y=this.moduleInfo[F];if(!y){y=this._addLangPack(T,N,F);}A=A||j.hash(y.supersedes);if(!(C in A)){y.supersedes.push(C);}N.lang=N.lang||[];z=z||j.hash(N.lang);if(!(T in z)){N.lang.push(T);}F=this.getLangPackName(u,U);C=this.getLangPackName(u,Q);y=this.moduleInfo[F];if(!y){y=this._addLangPack(T,N,F);}if(!(C in A)){y.supersedes.push(C);}}}O++;}}N.supersedes=j.dedupe(w);if(this.allowRollup){N.rollup=(O<4)?O:Math.min(O-1,4);}}M=N.plugins;if(M){for(Q in M){if(M.hasOwnProperty(Q)){x=M[Q];x.pkg=U;x.path=x.path||g(U,Q,N.type);x.requires=x.requires||[];x.group=N.group;this.addModule(x,Q);if(N.skinnable){this._addSkin(this.skin.defaultSkin,Q,U);}}}}if(N.condition){H=N.condition.trigger;if(YUI.Env.aliases[H]){H=YUI.Env.aliases[H];}if(!d.Lang.isArray(H)){H=[H];}for(Q=0;Q<H.length;Q++){K=H[Q];D=N.condition.when;E[K]=E[K]||{};E[K][U]=N.condition;if(D&&D!="after"){if(D=="instead"){N.supersedes=N.supersedes||[];N.supersedes.push(K);}else{}}else{N.after=N.after||[];N.after.push(K);}}}if(N.supersedes){N.supersedes=this.filterRequires(N.supersedes);}if(N.after){N.after=this.filterRequires(N.after);N.after_map=j.hash(N.after);}if(N.configFn){S=N.configFn(N);if(S===false){delete this.moduleInfo[U];delete a._renderedMods[U];N=null;}}if(N){if(!a._renderedMods){a._renderedMods={};}a._renderedMods[U]=d.merge(N);a._conditions=E;}return N;},require:function(x){var w=(typeof x==="string")?j(arguments):x;this.dirty=true;this.required=d.merge(this.required,j.hash(this.filterRequires(w)));this._explodeRollups();},_explodeRollups:function(){var x=this,w,y=x.required;if(!x.allowRollup){r(y,function(z,A){w=x.getModule(A);if(w&&w.use){j.each(w.use,function(B){w=x.getModule(B);if(w&&w.use){j.each(w.use,function(C){y[C]=true;});}else{y[B]=true;}});}});x.required=y;}},filterRequires:function(z){if(z){if(!d.Lang.isArray(z)){z=[z];}z=d.Array(z);var B=[],y,x,A,w;for(y=0;y<z.length;y++){x=this.getModule(z[y]);if(x&&x.use){for(A=0;A<x.use.length;A++){w=this.getModule(x.use[A]);if(w&&w.use){B=d.Array.dedupe([].concat(B,this.filterRequires(w.use)));}else{B.push(x.use[A]);}}}else{B.push(z[y]);}}z=B;}return z;},getRequires:function(R){if(!R){return c;}if(R._parsed){return R.expanded||c;}var L,H,K,D,C,T,A=this.testresults,U=R.name,B,S=n[U]&&n[U].details,N,I,w,E,O,F,z,P,Q,y,G=R.lang||R.intl,M=this.moduleInfo,J=d.Features&&d.Features.tests.load,x;if(R.temp&&S){O=R;R=this.addModule(S,U);R.group=O.group;R.pkg=O.pkg;delete R.expanded;}if(R.expanded&&(!this.lang||R.langCache===this.lang)){return R.expanded;}N=[];x={};E=this.filterRequires(R.requires);if(R.lang){N.unshift("intl");E.unshift("intl");G=true;}F=this.filterRequires(R.optional);R._parsed=true;R.langCache=this.lang;for(L=0;L<E.length;L++){if(!x[E[L]]){N.push(E[L]);x[E[L]]=true;H=this.getModule(E[L]);if(H){D=this.getRequires(H);G=G||(H.expanded_map&&(v in H.expanded_map));for(K=0;K<D.length;K++){N.push(D[K]);}}}}E=this.filterRequires(R.supersedes);if(E){for(L=0;L<E.length;L++){if(!x[E[L]]){if(R.submodules){N.push(E[L]);}x[E[L]]=true;H=this.getModule(E[L]);if(H){D=this.getRequires(H);G=G||(H.expanded_map&&(v in H.expanded_map));for(K=0;K<D.length;K++){N.push(D[K]);}}}}}if(F&&this.loadOptional){for(L=0;L<F.length;L++){if(!x[F[L]]){N.push(F[L]);x[F[L]]=true;H=M[F[L]];if(H){D=this.getRequires(H);G=G||(H.expanded_map&&(v in H.expanded_map));for(K=0;K<D.length;K++){N.push(D[K]);}}}}}B=this.conditions[U];if(B){R._parsed=false;if(A&&J){r(A,function(V,X){var W=J[X].name;if(!x[W]&&J[X].trigger==U){if(V&&J[X]){x[W]=true;N.push(W);}}});}else{r(B,function(X,W){if(!x[W]){var V=X&&((!X.ua&&!X.test)||(X.ua&&d.UA[X.ua])||(X.test&&X.test(d,E)));if(V){x[W]=true;N.push(W);H=this.getModule(W);if(H){D=this.getRequires(H);for(K=0;K<D.length;K++){N.push(D[K]);}}}}},this);}}if(R.skinnable){P=this.skin.overrides;r(YUI.Env.aliases,function(V,W){if(d.Array.indexOf(V,U)>-1){Q=W;}});if(P&&(P[U]||(Q&&P[Q]))){y=U;if(P[Q]){y=Q;}for(L=0;L<P[y].length;L++){z=this._addSkin(P[y][L],U);if(!this.isCSSLoaded(z,this._boot)){N.push(z);}}}else{z=this._addSkin(this.skin.defaultSkin,U);if(!this.isCSSLoaded(z,this._boot)){N.push(z);}}}R._parsed=false;if(G){if(R.lang&&!R.langPack&&d.Intl){T=d.Intl.lookupBestLang(this.lang||u,R.lang);C=this.getLangPackName(T,U);if(C){N.unshift(C);}}N.unshift(v);}R.expanded_map=j.hash(N);R.expanded=e.keys(R.expanded_map);return R.expanded;},isCSSLoaded:function(x,A){if(!x||!YUI.Env.cssStampEl||(!A&&this.ignoreRegistered)){return false;}var z=YUI.Env.cssStampEl,w=false,y=z.currentStyle;z.className=x;if(!y){y=d.config.doc.defaultView.getComputedStyle(z,null);}if(y&&y["display"]==="none"){w=true;}z.className="";return w;},getProvides:function(x){var w=this.getModule(x),z,y;if(!w){return f;}if(w&&!w.provides){z={};y=w.supersedes;if(y){j.each(y,function(A){d.mix(z,this.getProvides(A));},this);}z[x]=true;w.provides=z;}return w.provides;},calculate:function(x,w){if(x||w||this.dirty){if(x){this._config(x);}if(!this._init){this._setup();}this._explode();if(this.allowRollup){this._rollup();}else{this._explodeRollups();}this._reduce();this._sort();}},_addLangPack:function(C,w,B){var z=w.name,x,y,A=this.moduleInfo[B];if(!A){x=g((w.pkg||z),B,k,true);y={path:x,intl:true,langPack:true,ext:w.ext,group:w.group,supersedes:[]};if(w.configFn){y.configFn=w.configFn;}this.addModule(y,B);if(C){d.Env.lang=d.Env.lang||{};d.Env.lang[C]=d.Env.lang[C]||{};d.Env.lang[C][z]=true;}}return this.moduleInfo[B];},_setup:function(){var C=this.moduleInfo,z,A,y,w,x,B;for(z in C){if(C.hasOwnProperty(z)){w=C[z];if(w){w.requires=j.dedupe(w.requires);if(w.lang&&w.lang.length){B=this.getLangPackName(u,z);this._addLangPack(null,w,B);}}}}x={};if(!this.ignoreRegistered){d.mix(x,a.mods);}if(this.ignore){d.mix(x,j.hash(this.ignore));}for(y in x){if(x.hasOwnProperty(y)){d.mix(x,this.getProvides(y));}}if(this.force){for(A=0;A<this.force.length;A++){if(this.force[A] in x){delete x[this.force[A]];}}}d.mix(this.loaded,x);this._init=true;
},getLangPackName:function(x,w){return("lang/"+w+((x)?"_"+x:""));},_explode:function(){var A=this.required,w,z,x={},y=this;y.dirty=false;y._explodeRollups();A=y.required;r(A,function(B,C){if(!x[C]){x[C]=true;w=y.getModule(C);if(w){var D=w.expound;if(D){A[D]=y.getModule(D);z=y.getRequires(A[D]);d.mix(A,j.hash(z));}z=y.getRequires(w);d.mix(A,j.hash(z));}}});},getModule:function(B){if(!B){return null;}var A,z,x,w=this.moduleInfo[B],y=this.patterns;if(!w){for(x in y){if(y.hasOwnProperty(x)){A=y[x];if(!A.test){A.test=function(D,C){return(D.indexOf(C)>-1);};}if(A.test(B,x)){z=A;break;}}}if(z){if(A.action){A.action.call(this,B,x);}else{w=this.addModule(d.merge(z),B);w.temp=true;}}}return w;},_rollup:function(){},_reduce:function(B){B=B||this.required;var y,x,A,w,z=this.loadType,C=this.ignore?j.hash(this.ignore):false;for(y in B){if(B.hasOwnProperty(y)){w=this.getModule(y);if(((this.loaded[y]||n[y])&&!this.forceMap[y]&&!this.ignoreRegistered)||(z&&w&&w.type!=z)){delete B[y];}if(C&&C[y]){delete B[y];}A=w&&w.supersedes;if(A){for(x=0;x<A.length;x++){if(A[x] in B){delete B[A[x]];}}}}}return B;},_finish:function(y,x){h.running=false;var w=this.onEnd;if(w){w.call(this.context,{msg:y,data:this.data,success:x});}this._continue();},_onSuccess:function(){var y=this,x=d.merge(y.skipped),A,w=[],z=y.requireRegistration,C,B;r(x,function(D){delete y.inserted[D];});y.skipped={};r(y.inserted,function(E,D){var F=y.getModule(D);if(F&&z&&F.type==k&&!(D in YUI.Env.mods)){w.push(D);}else{d.mix(y.loaded,y.getProvides(D));}});A=y.onSuccess;B=(w.length)?"notregistered":"success";C=!(w.length);if(A){A.call(y.context,{msg:B,data:y.data,success:C,failed:w,skipped:x});}y._finish(B,C);},_onProgress:function(x){var w=this;if(w.onProgress){w.onProgress.call(w.context,{name:x.url,data:x.data});}},_onFailure:function(A){var y=this.onFailure,z=[],x=0,w=A.errors.length;for(x;x<w;x++){z.push(A.errors[x].error);}z=z.join(",");if(y){y.call(this.context,{msg:z,data:this.data,success:false});}this._finish(z,false);},_onTimeout:function(){var w=this.onTimeout;if(w){w.call(this.context,{msg:"timeout",data:this.data,success:false});}},_sort:function(){var F=e.keys(this.required),B={},w=0,y,E,D,A,z,C,x;for(;;){y=F.length;C=false;for(A=w;A<y;A++){E=F[A];for(z=A+1;z<y;z++){x=E+F[z];if(!B[x]&&this._requires(E,F[z])){D=F.splice(z,1);F.splice(A,0,D[0]);B[x]=true;C=true;break;}}if(C){break;}else{w++;}}if(!C){break;}}this.sorted=F;},_insert:function(w,z,D,y){if(w){this._config(w);}if(!y){this.calculate(z);}var A=this.resolve(),E=this,C=0,B=0;if(D){A[((D===k)?q:k)]=[];}if(A.js.length){C++;}if(A.css.length){C++;}var x=function(J){B++;var F={},H=0,G="",I;if(J&&J.errors){for(H=0;H<J.errors.length;H++){if(J.errors[H].request){G=J.errors[H].request.url;}else{G=J.errors[H];}F[G]=G;}}if(J&&J.data&&J.data.length&&(J.type==="success")){for(H=0;H<J.data.length;H++){E.inserted[J.data[H].name]=true;}}if(B===C){E._loading=null;if(J&&J.fn){I=J.fn;delete J.fn;I.call(E,J);}}};this._loading=true;if(!A.js.length&&!A.css.length){B=-1;x({fn:E._onSuccess});return;}if(A.css.length){d.Get.css(A.css,{data:A.cssMods,attributes:E.cssAttributes,insertBefore:E.insertBefore,charset:E.charset,timeout:E.timeout,context:E,onProgress:function(F){E._onProgress.call(E,F);},onTimeout:function(F){E._onTimeout.call(E,F);},onSuccess:function(F){F.type="success";F.fn=E._onSuccess;x.call(E,F);},onFailure:function(F){F.type="failure";F.fn=E._onFailure;x.call(E,F);}});}if(A.js.length){d.Get.js(A.js,{data:A.jsMods,insertBefore:E.insertBefore,attributes:E.jsAttributes,charset:E.charset,timeout:E.timeout,autopurge:false,context:E,async:true,onProgress:function(F){E._onProgress.call(E,F);},onTimeout:function(F){E._onTimeout.call(E,F);},onSuccess:function(F){F.type="success";F.fn=E._onSuccess;x.call(E,F);},onFailure:function(F){F.type="failure";F.fn=E._onFailure;x.call(E,F);}});}},_continue:function(){if(!(h.running)&&h.size()>0){h.running=true;h.next()();}},insert:function(z,x,y){var w=this,A=d.merge(this);delete A.require;delete A.dirty;h.add(function(){w._insert(A,z,x,y);});this._continue();},loadNext:function(w){return;},_filter:function(y,x,B){var A=this.filter,w=x&&(x in this.filters),z=w&&this.filters[x],C=B||(this.moduleInfo[x]?this.moduleInfo[x].group:null);if(C&&this.groups[C]&&this.groups[C].filter){z=this.groups[C].filter;w=true;}if(y){if(w){A=(i.isString(z))?this.FILTER_DEFS[z.toUpperCase()]||null:z;}if(A){y=y.replace(new RegExp(A.searchExp,"g"),A.replaceStr);}}return y;},_url:function(y,w,x){return this._filter((x||this.base||"")+y,w);},resolve:function(x,O){var X,W,U,E,J,G,T,I,N,V,y,H,R,D,aa,F,Y,M=[],K,Q,A={},P=this,w,z,Z=[],B=(P.ignoreRegistered)?{}:P.inserted,S={js:[],jsMods:[],css:[],cssMods:[]},C=P.loadType||"js";if(x){P.calculate();}O=O||P.sorted;var L=function(ab){if(ab){I=(ab.group&&P.groups[ab.group])||f;if(I.async===false){ab.async=I.async;}E=(ab.fullpath)?P._filter(ab.fullpath,O[W]):P._url(ab.path,O[W],I.base||ab.base);if(ab.attributes||ab.async===false){E={url:E,async:ab.async};if(ab.attributes){E.attributes=ab.attributes;}}S[ab.type].push(E);S[ab.type+"Mods"].push(ab);}else{}};X=O.length;aa=P.comboBase;E=aa;R={};for(W=0;W<X;W++){H=aa;U=P.getModule(O[W]);N=U&&U.group;I=P.groups[N];if(N&&I){if(!I.combine||U.fullpath){L(U);continue;}U.combine=true;if(I.comboBase){H=I.comboBase;}if("root" in I&&i.isValue(I.root)){U.root=I.root;}U.comboSep=I.comboSep||P.comboSep;U.maxURLLength=I.maxURLLength||P.maxURLLength;}else{if(!P.combine){L(U);continue;}}R[H]=R[H]||[];R[H].push(U);}for(V in R){if(R.hasOwnProperty(V)){A[V]=A[V]||{js:[],jsMods:[],css:[],cssMods:[]};E=V;D=R[V];X=D.length;if(X){for(W=0;W<X;W++){if(B[D[W]]){continue;}U=D[W];if(U&&(U.combine||!U.ext)){A[V].comboSep=U.comboSep;A[V].group=U.group;A[V].maxURLLength=U.maxURLLength;y=((i.isValue(U.root))?U.root:P.root)+(U.path||U.fullpath);y=P._filter(y,U.name);A[V][U.type].push(y);A[V][U.type+"Mods"].push(U);}else{if(D[W]){L(D[W]);}}}}}}for(V in A){F=V;w=A[F].comboSep||P.comboSep;z=A[F].maxURLLength||P.maxURLLength;for(C in A[F]){if(C===k||C===q){Y=A[F][C];
D=A[F][C+"Mods"];X=Y.length;K=F+Y.join(w);Q=K.length;if(z<=F.length){z=m;}if(X){if(Q>z){M=[];for(O=0;O<X;O++){M.push(Y[O]);K=F+M.join(w);if(K.length>z){U=M.pop();K=F+M.join(w);S[C].push(P._filter(K,null,A[F].group));M=[];if(U){M.push(U);}}}if(M.length){K=F+M.join(w);S[C].push(P._filter(K,null,A[F].group));}}else{S[C].push(P._filter(K,null,A[F].group));}}S[C+"Mods"]=S[C+"Mods"].concat(D);}}}A=null;return S;},load:function(w){if(!w){return;}var x=this,y=x.resolve(true);x.data=y;x.onEnd=function(){w.apply(x.context||x,arguments);};x.insert();}};},"3.5.0",{requires:["get","features"]});YUI.add("loader-rollup",function(a){a.Loader.prototype._rollup=function(){var k,h,g,o,b=this.required,e,f=this.moduleInfo,d,l,n;if(this.dirty||!this.rollups){this.rollups={};for(k in f){if(f.hasOwnProperty(k)){g=this.getModule(k);if(g&&g.rollup){this.rollups[k]=g;}}}}for(;;){d=false;for(k in this.rollups){if(this.rollups.hasOwnProperty(k)){if(!b[k]&&((!this.loaded[k])||this.forceMap[k])){g=this.getModule(k);o=g.supersedes||[];e=false;if(!g.rollup){continue;}l=0;for(h=0;h<o.length;h++){n=f[o[h]];if(this.loaded[o[h]]&&!this.forceMap[o[h]]){e=false;break;}else{if(b[o[h]]&&g.type==n.type){l++;e=(l>=g.rollup);if(e){break;}}}}if(e){b[k]=true;d=true;this.getRequires(g);}}}}if(!d){break;}}};},"3.5.0",{requires:["loader-base"]});YUI.add("loader-yui3",function(a){YUI.Env[a.version].modules=YUI.Env[a.version].modules||{"align-plugin":{"requires":["node-screen","node-pluginhost"]},"anim":{"use":["anim-base","anim-color","anim-curve","anim-easing","anim-node-plugin","anim-scroll","anim-xy"]},"anim-base":{"requires":["base-base","node-style"]},"anim-color":{"requires":["anim-base"]},"anim-curve":{"requires":["anim-xy"]},"anim-easing":{"requires":["anim-base"]},"anim-node-plugin":{"requires":["node-pluginhost","anim-base"]},"anim-scroll":{"requires":["anim-base"]},"anim-shape-transform":{"requires":["anim-base","anim-easing","matrix"]},"anim-xy":{"requires":["anim-base","node-screen"]},"app":{"use":["app-base","app-transitions","model","model-list","router","view"]},"app-base":{"requires":["classnamemanager","pjax-base","router","view"]},"app-transitions":{"requires":["app-base"]},"app-transitions-css":{"type":"css"},"app-transitions-native":{"condition":{"name":"app-transitions-native","test":function(d){var c=d.config.doc,b=c?c.documentElement:null;if(b&&b.style){return("MozTransition" in b.style||"WebkitTransition" in b.style);}return false;},"trigger":"app-transitions"},"requires":["app-transitions","app-transitions-css","parallel","transition"]},"array-extras":{"requires":["yui-base"]},"array-invoke":{"requires":["yui-base"]},"arraylist":{"requires":["yui-base"]},"arraylist-add":{"requires":["arraylist"]},"arraylist-filter":{"requires":["arraylist"]},"arraysort":{"requires":["yui-base"]},"async-queue":{"requires":["event-custom"]},"attribute":{"use":["attribute-base","attribute-complex"]},"attribute-base":{"requires":["attribute-core","attribute-events","attribute-extras"]},"attribute-complex":{"requires":["attribute-base"]},"attribute-core":{"requires":["yui-base"]},"attribute-events":{"requires":["event-custom"]},"attribute-extras":{"requires":["yui-base"]},"autocomplete":{"use":["autocomplete-base","autocomplete-sources","autocomplete-list","autocomplete-plugin"]},"autocomplete-base":{"optional":["autocomplete-sources"],"requires":["array-extras","base-build","escape","event-valuechange","node-base"]},"autocomplete-filters":{"requires":["array-extras","text-wordbreak"]},"autocomplete-filters-accentfold":{"requires":["array-extras","text-accentfold","text-wordbreak"]},"autocomplete-highlighters":{"requires":["array-extras","highlight-base"]},"autocomplete-highlighters-accentfold":{"requires":["array-extras","highlight-accentfold"]},"autocomplete-list":{"after":["autocomplete-sources"],"lang":["en"],"requires":["autocomplete-base","event-resize","node-screen","selector-css3","shim-plugin","widget","widget-position","widget-position-align"],"skinnable":true},"autocomplete-list-keys":{"condition":{"name":"autocomplete-list-keys","test":function(b){return !(b.UA.ios||b.UA.android);},"trigger":"autocomplete-list"},"requires":["autocomplete-list","base-build"]},"autocomplete-plugin":{"requires":["autocomplete-list","node-pluginhost"]},"autocomplete-sources":{"optional":["io-base","json-parse","jsonp","yql"],"requires":["autocomplete-base"]},"base":{"use":["base-base","base-pluginhost","base-build"]},"base-base":{"after":["attribute-complex"],"requires":["base-core","attribute-base"]},"base-build":{"requires":["base-base"]},"base-core":{"requires":["attribute-core"]},"base-pluginhost":{"requires":["base-base","pluginhost"]},"button":{"requires":["button-core","cssbutton","widget"]},"button-core":{"requires":["attribute-core","classnamemanager","node-base"]},"button-group":{"requires":["button-plugin","cssbutton","widget"]},"button-plugin":{"requires":["button-core","cssbutton","node-pluginhost"]},"cache":{"use":["cache-base","cache-offline","cache-plugin"]},"cache-base":{"requires":["base"]},"cache-offline":{"requires":["cache-base","json"]},"cache-plugin":{"requires":["plugin","cache-base"]},"calendar":{"lang":["de","en","fr","ja","nb-NO","pt-BR","ru","zh-HANT-TW"],"requires":["calendar-base","calendarnavigator"],"skinnable":true},"calendar-base":{"lang":["de","en","fr","ja","nb-NO","pt-BR","ru","zh-HANT-TW"],"requires":["widget","substitute","datatype-date","datatype-date-math","cssgrids"],"skinnable":true},"calendarnavigator":{"requires":["plugin","classnamemanager","datatype-date","node","substitute"],"skinnable":true},"charts":{"requires":["charts-base"]},"charts-base":{"requires":["dom","datatype-number","datatype-date","event-custom","event-mouseenter","event-touch","widget","widget-position","widget-stack","graphics"]},"charts-legend":{"requires":["charts-base"]},"classnamemanager":{"requires":["yui-base"]},"clickable-rail":{"requires":["slider-base"]},"collection":{"use":["array-extras","arraylist","arraylist-add","arraylist-filter","array-invoke"]},"console":{"lang":["en","es","ja"],"requires":["yui-log","widget","substitute"],"skinnable":true},"console-filters":{"requires":["plugin","console"],"skinnable":true},"controller":{"use":["router"]},"cookie":{"requires":["yui-base"]},"createlink-base":{"requires":["editor-base"]},"cssbase":{"after":["cssreset","cssfonts","cssgrids","cssreset-context","cssfonts-context","cssgrids-context"],"type":"css"},"cssbase-context":{"after":["cssreset","cssfonts","cssgrids","cssreset-context","cssfonts-context","cssgrids-context"],"type":"css"},"cssbutton":{"type":"css"},"cssfonts":{"type":"css"},"cssfonts-context":{"type":"css"},"cssgrids":{"optional":["cssreset","cssfonts"],"type":"css"},"cssgrids-base":{"optional":["cssreset","cssfonts"],"type":"css"},"cssgrids-units":{"optional":["cssreset","cssfonts"],"requires":["cssgrids-base"],"type":"css"},"cssreset":{"type":"css"},"cssreset-context":{"type":"css"},"dataschema":{"use":["dataschema-base","dataschema-json","dataschema-xml","dataschema-array","dataschema-text"]},"dataschema-array":{"requires":["dataschema-base"]},"dataschema-base":{"requires":["base"]},"dataschema-json":{"requires":["dataschema-base","json"]},"dataschema-text":{"requires":["dataschema-base"]},"dataschema-xml":{"requires":["dataschema-base"]},"datasource":{"use":["datasource-local","datasource-io","datasource-get","datasource-function","datasource-cache","datasource-jsonschema","datasource-xmlschema","datasource-arrayschema","datasource-textschema","datasource-polling"]},"datasource-arrayschema":{"requires":["datasource-local","plugin","dataschema-array"]},"datasource-cache":{"requires":["datasource-local","plugin","cache-base"]},"datasource-function":{"requires":["datasource-local"]},"datasource-get":{"requires":["datasource-local","get"]},"datasource-io":{"requires":["datasource-local","io-base"]},"datasource-jsonschema":{"requires":["datasource-local","plugin","dataschema-json"]},"datasource-local":{"requires":["base"]},"datasource-polling":{"requires":["datasource-local"]},"datasource-textschema":{"requires":["datasource-local","plugin","dataschema-text"]},"datasource-xmlschema":{"requires":["datasource-local","plugin","dataschema-xml"]},"datatable":{"use":["datatable-core","datatable-head","datatable-body","datatable-base","datatable-column-widths","datatable-message","datatable-mutable","datatable-sort","datatable-datasource"]},"datatable-base":{"requires":["datatable-core","datatable-head","datatable-body","base-build","widget"],"skinnable":true},"datatable-base-deprecated":{"requires":["recordset-base","widget","substitute","event-mouseenter"],"skinnable":true},"datatable-body":{"requires":["datatable-core","view","classnamemanager"]},"datatable-column-widths":{"requires":["datatable-base"]},"datatable-core":{"requires":["escape","model-list","node-event-delegate"]},"datatable-datasource":{"requires":["datatable-base","plugin","datasource-local"]},"datatable-datasource-deprecated":{"requires":["datatable-base-deprecated","plugin","datasource-local"]},"datatable-deprecated":{"use":["datatable-base-deprecated","datatable-datasource-deprecated","datatable-sort-deprecated","datatable-scroll-deprecated"]},"datatable-head":{"requires":["datatable-core","view","classnamemanager"]},"datatable-message":{"lang":["en"],"requires":["datatable-base"],"skinnable":true},"datatable-mutable":{"requires":["datatable-base"]},"datatable-scroll":{"requires":["datatable-base","datatable-column-widths","dom-screen"],"skinnable":true},"datatable-scroll-deprecated":{"requires":["datatable-base-deprecated","plugin"]},"datatable-sort":{"lang":["en"],"requires":["datatable-base"],"skinnable":true},"datatable-sort-deprecated":{"lang":["en"],"requires":["datatable-base-deprecated","plugin","recordset-sort"]},"datatype":{"use":["datatype-number","datatype-date","datatype-xml"]},"datatype-date":{"supersedes":["datatype-date-format"],"use":["datatype-date-parse","datatype-date-format"]},"datatype-date-format":{"lang":["ar","ar-JO","ca","ca-ES","da","da-DK","de","de-AT","de-DE","el","el-GR","en","en-AU","en-CA","en-GB","en-IE","en-IN","en-JO","en-MY","en-NZ","en-PH","en-SG","en-US","es","es-AR","es-BO","es-CL","es-CO","es-EC","es-ES","es-MX","es-PE","es-PY","es-US","es-UY","es-VE","fi","fi-FI","fr","fr-BE","fr-CA","fr-FR","hi","hi-IN","id","id-ID","it","it-IT","ja","ja-JP","ko","ko-KR","ms","ms-MY","nb","nb-NO","nl","nl-BE","nl-NL","pl","pl-PL","pt","pt-BR","ro","ro-RO","ru","ru-RU","sv","sv-SE","th","th-TH","tr","tr-TR","vi","vi-VN","zh-Hans","zh-Hans-CN","zh-Hant","zh-Hant-HK","zh-Hant-TW"]},"datatype-date-math":{"requires":["yui-base"]},"datatype-date-parse":{},"datatype-number":{"use":["datatype-number-parse","datatype-number-format"]},"datatype-number-format":{},"datatype-number-parse":{},"datatype-xml":{"use":["datatype-xml-parse","datatype-xml-format"]},"datatype-xml-format":{},"datatype-xml-parse":{},"dd":{"use":["dd-ddm-base","dd-ddm","dd-ddm-drop","dd-drag","dd-proxy","dd-constrain","dd-drop","dd-scroll","dd-delegate"]},"dd-constrain":{"requires":["dd-drag"]},"dd-ddm":{"requires":["dd-ddm-base","event-resize"]},"dd-ddm-base":{"requires":["node","base","yui-throttle","classnamemanager"]},"dd-ddm-drop":{"requires":["dd-ddm"]},"dd-delegate":{"requires":["dd-drag","dd-drop-plugin","event-mouseenter"]},"dd-drag":{"requires":["dd-ddm-base"]},"dd-drop":{"requires":["dd-drag","dd-ddm-drop"]},"dd-drop-plugin":{"requires":["dd-drop"]},"dd-gestures":{"condition":{"name":"dd-gestures","test":function(b){return((b.config.win&&("ontouchstart" in b.config.win))&&!(b.UA.chrome&&b.UA.chrome<6));
},"trigger":"dd-drag"},"requires":["dd-drag","event-synthetic","event-gestures"]},"dd-plugin":{"optional":["dd-constrain","dd-proxy"],"requires":["dd-drag"]},"dd-proxy":{"requires":["dd-drag"]},"dd-scroll":{"requires":["dd-drag"]},"dial":{"lang":["en","es"],"requires":["widget","dd-drag","substitute","event-mouseenter","event-move","event-key","transition","intl"],"skinnable":true},"dom":{"use":["dom-base","dom-screen","dom-style","selector-native","selector"]},"dom-base":{"requires":["dom-core"]},"dom-core":{"requires":["oop","features"]},"dom-deprecated":{"requires":["dom-base"]},"dom-screen":{"requires":["dom-base","dom-style"]},"dom-style":{"requires":["dom-base"]},"dom-style-ie":{"condition":{"name":"dom-style-ie","test":function(h){var f=h.Features.test,g=h.Features.add,d=h.config.win,e=h.config.doc,b="documentElement",c=false;g("style","computedStyle",{test:function(){return d&&"getComputedStyle" in d;}});g("style","opacity",{test:function(){return e&&"opacity" in e[b].style;}});c=(!f("style","opacity")&&!f("style","computedStyle"));return c;},"trigger":"dom-style"},"requires":["dom-style"]},"dump":{"requires":["yui-base"]},"editor":{"use":["frame","editor-selection","exec-command","editor-base","editor-para","editor-br","editor-bidi","editor-tab","createlink-base"]},"editor-base":{"requires":["base","frame","node","exec-command","editor-selection"]},"editor-bidi":{"requires":["editor-base"]},"editor-br":{"requires":["editor-base"]},"editor-lists":{"requires":["editor-base"]},"editor-para":{"requires":["editor-para-base"]},"editor-para-base":{"requires":["editor-base"]},"editor-para-ie":{"condition":{"name":"editor-para-ie","trigger":"editor-para","ua":"ie","when":"instead"},"requires":["editor-para-base"]},"editor-selection":{"requires":["node"]},"editor-tab":{"requires":["editor-base"]},"escape":{"requires":["yui-base"]},"event":{"after":["node-base"],"use":["event-base","event-delegate","event-synthetic","event-mousewheel","event-mouseenter","event-key","event-focus","event-resize","event-hover","event-outside","event-touch","event-move","event-flick","event-valuechange"]},"event-base":{"after":["node-base"],"requires":["event-custom-base"]},"event-base-ie":{"after":["event-base"],"condition":{"name":"event-base-ie","test":function(c){var b=c.config.doc&&c.config.doc.implementation;return(b&&(!b.hasFeature("Events","2.0")));},"trigger":"node-base"},"requires":["node-base"]},"event-contextmenu":{"requires":["event-synthetic","dom-screen"]},"event-custom":{"use":["event-custom-base","event-custom-complex"]},"event-custom-base":{"requires":["oop"]},"event-custom-complex":{"requires":["event-custom-base"]},"event-delegate":{"requires":["node-base"]},"event-flick":{"requires":["node-base","event-touch","event-synthetic"]},"event-focus":{"requires":["event-synthetic"]},"event-gestures":{"use":["event-flick","event-move"]},"event-hover":{"requires":["event-mouseenter"]},"event-key":{"requires":["event-synthetic"]},"event-mouseenter":{"requires":["event-synthetic"]},"event-mousewheel":{"requires":["node-base"]},"event-move":{"requires":["node-base","event-touch","event-synthetic"]},"event-outside":{"requires":["event-synthetic"]},"event-resize":{"requires":["node-base","event-synthetic"]},"event-simulate":{"requires":["event-base"]},"event-synthetic":{"requires":["node-base","event-custom-complex"]},"event-touch":{"requires":["node-base"]},"event-valuechange":{"requires":["event-focus","event-synthetic"]},"exec-command":{"requires":["frame"]},"features":{"requires":["yui-base"]},"file":{"requires":["file-flash","file-html5"]},"file-flash":{"requires":["base"]},"file-html5":{"requires":["base"]},"frame":{"requires":["base","node","selector-css3","substitute","yui-throttle"]},"get":{"requires":["yui-base"]},"graphics":{"requires":["node","event-custom","pluginhost","matrix"]},"graphics-canvas":{"condition":{"name":"graphics-canvas","test":function(f){var d=f.config.doc,e=f.config.defaultGraphicEngine&&f.config.defaultGraphicEngine=="canvas",c=d&&d.createElement("canvas"),b=(d&&d.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return(!b||e)&&(c&&c.getContext&&c.getContext("2d"));},"trigger":"graphics"},"requires":["graphics"]},"graphics-canvas-default":{"condition":{"name":"graphics-canvas-default","test":function(f){var d=f.config.doc,e=f.config.defaultGraphicEngine&&f.config.defaultGraphicEngine=="canvas",c=d&&d.createElement("canvas"),b=(d&&d.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return(!b||e)&&(c&&c.getContext&&c.getContext("2d"));},"trigger":"graphics"}},"graphics-svg":{"condition":{"name":"graphics-svg","test":function(f){var e=f.config.doc,d=!f.config.defaultGraphicEngine||f.config.defaultGraphicEngine!="canvas",c=e&&e.createElement("canvas"),b=(e&&e.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return b&&(d||!c);},"trigger":"graphics"},"requires":["graphics"]},"graphics-svg-default":{"condition":{"name":"graphics-svg-default","test":function(f){var e=f.config.doc,d=!f.config.defaultGraphicEngine||f.config.defaultGraphicEngine!="canvas",c=e&&e.createElement("canvas"),b=(e&&e.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1"));return b&&(d||!c);},"trigger":"graphics"}},"graphics-vml":{"condition":{"name":"graphics-vml","test":function(d){var c=d.config.doc,b=c&&c.createElement("canvas");return(c&&!c.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")&&(!b||!b.getContext||!b.getContext("2d")));},"trigger":"graphics"},"requires":["graphics"]},"graphics-vml-default":{"condition":{"name":"graphics-vml-default","test":function(d){var c=d.config.doc,b=c&&c.createElement("canvas");return(c&&!c.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")&&(!b||!b.getContext||!b.getContext("2d")));},"trigger":"graphics"}},"handlebars":{"use":["handlebars-compiler"]},"handlebars-base":{"requires":["escape"]},"handlebars-compiler":{"requires":["handlebars-base"]},"highlight":{"use":["highlight-base","highlight-accentfold"]},"highlight-accentfold":{"requires":["highlight-base","text-accentfold"]},"highlight-base":{"requires":["array-extras","classnamemanager","escape","text-wordbreak"]},"history":{"use":["history-base","history-hash","history-hash-ie","history-html5"]},"history-base":{"requires":["event-custom-complex"]},"history-hash":{"after":["history-html5"],"requires":["event-synthetic","history-base","yui-later"]},"history-hash-ie":{"condition":{"name":"history-hash-ie","test":function(c){var b=c.config.doc&&c.config.doc.documentMode;
return c.UA.ie&&(!("onhashchange" in c.config.win)||!b||b<8);},"trigger":"history-hash"},"requires":["history-hash","node-base"]},"history-html5":{"optional":["json"],"requires":["event-base","history-base","node-base"]},"imageloader":{"requires":["base-base","node-style","node-screen"]},"intl":{"requires":["intl-base","event-custom"]},"intl-base":{"requires":["yui-base"]},"io":{"use":["io-base","io-xdr","io-form","io-upload-iframe","io-queue"]},"io-base":{"requires":["event-custom-base","querystring-stringify-simple"]},"io-form":{"requires":["io-base","node-base"]},"io-nodejs":{"condition":{"name":"io-nodejs","trigger":"io-base","ua":"nodejs"},"requires":["io-base"]},"io-queue":{"requires":["io-base","queue-promote"]},"io-upload-iframe":{"requires":["io-base","node-base"]},"io-xdr":{"requires":["io-base","datatype-xml-parse"]},"json":{"use":["json-parse","json-stringify"]},"json-parse":{"requires":["yui-base"]},"json-stringify":{"requires":["yui-base"]},"jsonp":{"requires":["get","oop"]},"jsonp-url":{"requires":["jsonp"]},"loader":{"use":["loader-base","loader-rollup","loader-yui3"]},"loader-base":{"requires":["get","features"]},"loader-rollup":{"requires":["loader-base"]},"loader-yui3":{"requires":["loader-base"]},"matrix":{"requires":["yui-base"]},"model":{"requires":["base-build","escape","json-parse"]},"model-list":{"requires":["array-extras","array-invoke","arraylist","base-build","escape","json-parse","model"]},"node":{"use":["node-base","node-event-delegate","node-pluginhost","node-screen","node-style"]},"node-base":{"requires":["event-base","node-core","dom-base"]},"node-core":{"requires":["dom-core","selector"]},"node-deprecated":{"requires":["node-base"]},"node-event-delegate":{"requires":["node-base","event-delegate"]},"node-event-html5":{"requires":["node-base"]},"node-event-simulate":{"requires":["node-base","event-simulate"]},"node-flick":{"requires":["classnamemanager","transition","event-flick","plugin"],"skinnable":true},"node-focusmanager":{"requires":["attribute","node","plugin","node-event-simulate","event-key","event-focus"]},"node-load":{"requires":["node-base","io-base"]},"node-menunav":{"requires":["node","classnamemanager","plugin","node-focusmanager"],"skinnable":true},"node-pluginhost":{"requires":["node-base","pluginhost"]},"node-screen":{"requires":["dom-screen","node-base"]},"node-style":{"requires":["dom-style","node-base"]},"oop":{"requires":["yui-base"]},"overlay":{"requires":["widget","widget-stdmod","widget-position","widget-position-align","widget-stack","widget-position-constrain"],"skinnable":true},"panel":{"requires":["widget","widget-autohide","widget-buttons","widget-modality","widget-position","widget-position-align","widget-position-constrain","widget-stack","widget-stdmod"],"skinnable":true},"parallel":{"requires":["yui-base"]},"pjax":{"requires":["pjax-base","io-base"]},"pjax-base":{"requires":["classnamemanager","node-event-delegate","router"]},"pjax-plugin":{"requires":["node-pluginhost","pjax","plugin"]},"plugin":{"requires":["base-base"]},"pluginhost":{"use":["pluginhost-base","pluginhost-config"]},"pluginhost-base":{"requires":["yui-base"]},"pluginhost-config":{"requires":["pluginhost-base"]},"profiler":{"requires":["yui-base"]},"querystring":{"use":["querystring-parse","querystring-stringify"]},"querystring-parse":{"requires":["yui-base","array-extras"]},"querystring-parse-simple":{"requires":["yui-base"]},"querystring-stringify":{"requires":["yui-base"]},"querystring-stringify-simple":{"requires":["yui-base"]},"queue-promote":{"requires":["yui-base"]},"range-slider":{"requires":["slider-base","slider-value-range","clickable-rail"]},"recordset":{"use":["recordset-base","recordset-sort","recordset-filter","recordset-indexer"]},"recordset-base":{"requires":["base","arraylist"]},"recordset-filter":{"requires":["recordset-base","array-extras","plugin"]},"recordset-indexer":{"requires":["recordset-base","plugin"]},"recordset-sort":{"requires":["arraysort","recordset-base","plugin"]},"resize":{"use":["resize-base","resize-proxy","resize-constrain"]},"resize-base":{"requires":["base","widget","substitute","event","oop","dd-drag","dd-delegate","dd-drop"],"skinnable":true},"resize-constrain":{"requires":["plugin","resize-base"]},"resize-plugin":{"optional":["resize-constrain"],"requires":["resize-base","plugin"]},"resize-proxy":{"requires":["plugin","resize-base"]},"rls":{"requires":["get","features"]},"router":{"optional":["querystring-parse"],"requires":["array-extras","base-build","history"]},"scrollview":{"requires":["scrollview-base","scrollview-scrollbars"]},"scrollview-base":{"requires":["widget","event-gestures","event-mousewheel","transition"],"skinnable":true},"scrollview-base-ie":{"condition":{"name":"scrollview-base-ie","trigger":"scrollview-base","ua":"ie"},"requires":["scrollview-base"]},"scrollview-list":{"requires":["plugin","classnamemanager"],"skinnable":true},"scrollview-paginator":{"requires":["plugin"]},"scrollview-scrollbars":{"requires":["classnamemanager","transition","plugin"],"skinnable":true},"selector":{"requires":["selector-native"]},"selector-css2":{"condition":{"name":"selector-css2","test":function(d){var c=d.config.doc,b=c&&!("querySelectorAll" in c);return b;},"trigger":"selector"},"requires":["selector-native"]},"selector-css3":{"requires":["selector-native","selector-css2"]},"selector-native":{"requires":["dom-base"]},"shim-plugin":{"requires":["node-style","node-pluginhost"]},"slider":{"use":["slider-base","slider-value-range","clickable-rail","range-slider"]},"slider-base":{"requires":["widget","dd-constrain","substitute","event-key"],"skinnable":true},"slider-value-range":{"requires":["slider-base"]},"sortable":{"requires":["dd-delegate","dd-drop-plugin","dd-proxy"]},"sortable-scroll":{"requires":["dd-scroll","sortable"]},"stylesheet":{"requires":["yui-base"]},"substitute":{"optional":["dump"],"requires":["yui-base"]},"swf":{"requires":["event-custom","node","swfdetect","escape"]},"swfdetect":{"requires":["yui-base"]},"tabview":{"requires":["widget","widget-parent","widget-child","tabview-base","node-pluginhost","node-focusmanager"],"skinnable":true},"tabview-base":{"requires":["node-event-delegate","classnamemanager","skin-sam-tabview"]},"tabview-plugin":{"requires":["tabview-base"]},"test":{"requires":["event-simulate","event-custom","substitute","json-stringify"],"skinnable":true},"test-console":{"requires":["console-filters","test"],"skinnable":true},"text":{"use":["text-accentfold","text-wordbreak"]},"text-accentfold":{"requires":["array-extras","text-data-accentfold"]},"text-data-accentfold":{"requires":["yui-base"]},"text-data-wordbreak":{"requires":["yui-base"]},"text-wordbreak":{"requires":["array-extras","text-data-wordbreak"]},"transition":{"requires":["node-style"]},"transition-timer":{"condition":{"name":"transition-timer","test":function(e){var d=e.config.doc,c=(d)?d.documentElement:null,b=true;
if(c&&c.style){b=!("MozTransition" in c.style||"WebkitTransition" in c.style);}return b;},"trigger":"transition"},"requires":["transition"]},"uploader":{"requires":["uploader-html5","uploader-flash"]},"uploader-deprecated":{"requires":["event-custom","node","base","swf"]},"uploader-flash":{"requires":["swf","widget","substitute","base","cssbutton","node","event-custom","file-flash","uploader-queue"]},"uploader-html5":{"requires":["widget","node-event-simulate","substitute","file-html5","uploader-queue"]},"uploader-queue":{"requires":["base"]},"view":{"requires":["base-build","node-event-delegate"]},"view-node-map":{"requires":["view"]},"widget":{"use":["widget-base","widget-htmlparser","widget-skin","widget-uievents"]},"widget-anim":{"requires":["anim-base","plugin","widget"]},"widget-autohide":{"requires":["base-build","event-key","event-outside","widget"]},"widget-base":{"requires":["attribute","base-base","base-pluginhost","classnamemanager","event-focus","node-base","node-style"],"skinnable":true},"widget-base-ie":{"condition":{"name":"widget-base-ie","trigger":"widget-base","ua":"ie"},"requires":["widget-base"]},"widget-buttons":{"requires":["button-plugin","cssbutton","widget-stdmod"]},"widget-child":{"requires":["base-build","widget"]},"widget-htmlparser":{"requires":["widget-base"]},"widget-locale":{"requires":["widget-base"]},"widget-modality":{"requires":["base-build","event-outside","widget"],"skinnable":true},"widget-parent":{"requires":["arraylist","base-build","widget"]},"widget-position":{"requires":["base-build","node-screen","widget"]},"widget-position-align":{"requires":["widget-position"]},"widget-position-constrain":{"requires":["widget-position"]},"widget-skin":{"requires":["widget-base"]},"widget-stack":{"requires":["base-build","widget"],"skinnable":true},"widget-stdmod":{"requires":["base-build","widget"]},"widget-uievents":{"requires":["node-event-delegate","widget-base"]},"yql":{"requires":["jsonp","jsonp-url"]},"yui":{},"yui-base":{},"yui-later":{"requires":["yui-base"]},"yui-log":{"requires":["yui-base"]},"yui-rls":{},"yui-throttle":{"requires":["yui-base"]}};YUI.Env[a.version].md5="f5a3bc9bda2441a3b15fb52c567fc1f7";},"3.5.0",{requires:["loader-base"]});YUI.add("loader",function(a){},"3.5.0",{use:["loader-base","loader-rollup","loader-yui3"]});//Invoke strict mode
"use strict";

if (typeof Supra === "undefined") {	
(function (window) {
	/*
	 * Invoke strict mode because using combo may be
	 * loaded with script which doesn't have strict mode
	 */
	"use strict";
	
	/**
	 * Create YUI instance for internal use
	 */
	var Y = YUI();
	
	/**
	 * Global Supra namespace
	 * 
	 * Shorthand of YUI(Supra.YUI_BASE).use(...)
	 * Only required argument is "ready callback function"
	 * 
	 * @param {Object} base Optional. Extend base with this argument
	 * @param {String} require Optional. Module which will be loaded before calling ready function
	 * @param {Function} fn Required. Ready callback function
	 */
	var Supra = window.Supra = function () {
		var base = null,
			args = [].concat(Supra.useModules),
			cache_errors = Supra.data.catchNativeErrors,
			type = null;
		
		for(var i=0, ii=arguments.length; i<ii; i++) {
			type = Y.Lang.type(arguments[i]);
			
			if (type == 'function') {	// Callback function
				
				// catch errors in callback function
				var fn = arguments[i];
				
				if (cache_errors) {
					args.push(function () {
						try {
							fn.apply(this, arguments);
						} catch (e) {
							Y.log(e, 'error');
						}
					});	
				} else {
					args.push(fn);
				}
			
			} else if (type == 'string') {				// Module
				
				// add module to the arguments  
				args.push(arguments[i]);
				
			} else if (type == 'array') { 		// List of modules
			
				args = args.concat(arguments[i]);
			
			} else if (type == 'object') { 		// Base parameters
				
				// additional parameters for base
				base = arguments[i];
				Supra.yui_base_set = false;
				
				if ('modules' in base) {
					base = {'groups': {'supra': base}};
				}
			}
		}
		
		if (!Supra.yui_base_set) {
			base = (base ? Y.mix(base, Supra.YUI_BASE, false, null, 0, true) : Supra.YUI_BASE);
			Supra.yui_base_set = true;
		}
		
		//Re-use same YUI instance
		if (base) {
			//If additional base properties are set, apply them
			Y.applyConfig(base);
		}
		
		Y.use.apply(Y,args);
	};
	
	/* Make YUI instance accessible from Supra namespace, single instance for App */
	Supra.Y = Y;
	
	/**
	 * Configuration for YUI
	 */
	
	/* Increase URL max length */
	Y.Env._loader.maxURLLength = 2000;
	
	/* YUI() base configuration */
	Supra.YUI_BASE = {
		//YUI file combo
		combine:	true,
		root: "Y$",
		base: "Y$",
		realBase: "/cms/lib/yui." + Y.version + "/build/",
	    comboBase:	"/cms/lib/supra/combo/combo.php?",
	    filter:		{
				        //Remove supra. from module paths
				        'searchExp': "(supra|website)\\.([^/]*?)(-min)?(\\.js|\\.css)?",
				        'replaceStr': "$2$4"
			        },
		
		//Default skin
		skin: {
			defaultSkin: "supra"
		},
		
		//Add groups to enable automatic loading of Supra modules
		//Additional groups can be added using Supra.setModuleGroupPath
		groups: {
			supra: {
				//Supra modules
				combine: true,
				root: "S$",
				base: "S$",
				realBase: "/cms/lib/supra/build/",
				//Use YUI file combo
				comboBase: "/cms/lib/supra/combo/combo.php?",
				modules: {}	//@see modules.js
			},
			website: {
				//Website specific modules
				combine: true,
				root: "/cms/",
				base: "/cms/",
				//Use YUI file combo
				comboBase: "/cms/lib/supra/combo/combo.php?",
				filter: "raw",
				modules: {}
			}
		}
	};
	
	//YUI() base configuration has been applied
	Supra.yui_base_set = false;
	
	/**
	 * Mix objects or arrays together
	 * HTMLNode 	
	 * 
	 * @param {Object} dest Destination object
	 * @param {Object} src Source object
	 * @param {Boolean} deep If true, object children which are object will be mixed together
	 * @return Mixed object
	 * @type {Object}
	 */
	Supra.mix = function() {
		var options = null,
			key = null,
			src = null,
			copy = null,
			copyIsArray = null,
			target = arguments[0] || {},
			length = arguments.length,
			deep = false;
		
		//Last argument for deep mixing
		if ( typeof arguments[arguments.length - 1] === 'boolean' ) {
			deep = arguments[arguments.length - 1];
			length--;
		}
		
		if (!Y.Lang.isObject(target)) {
			//If not an object and not a function reset to object
			target = {};
		}
		
		for (var i=1; i<length; i++) {
			
			if ((options = arguments[i]) != null && options !== target) {
				// Extend the base object
				for (key in options) {
					src = target[key];
					copy = options[key];
	
					//Prevent loop
					if (target === copy) {
						continue;
					}
	
					//Recurse only if object or array, nodes are recursed
					if (deep && copy && (Y.Lang.isPlainObject(copy) || (copyIsArray = Y.Lang.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							src = src && Y.Lang.isArray(src) ? src : [];
						} else {
							src = src && Y.Lang.isPlainObject(src) ? src : {};
						}
						
						target[key] = Supra.mix( src, copy, deep );
	
					} else if (copy !== undefined) {
						target[key] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	/**
	 * Retrieves the sub value at the provided path, from the value object provided.
	 * 
	 * @param {Object} obj The object from which to extract the property value.
	 * @param {Object} path A path array, specifying the object traversal path from which to obtain the sub value.
	 * @returns {Object} The value stored in the path, undefined if not found, undefined if the source is not an object. Returns the source object if an empty path is provided.
	 */
	Supra.getObjectValue = function (obj, path) {
		if (!path || !path.length) {
			return obj;
		}
		if(!obj || !Y.Lang.isObject(obj)) {
			return undefined;
		}
		
		var i = 0,
			path = Y.Array(path),
			size = path.length;
		
		for (; obj !== undefined && i < size; i++) {
			obj = obj ? obj[path[i]] : undefined;
		}
		
		return obj;
	};
	
})(window);
}
(function () {
	
	var Y = Supra.Y;
	
	/**
	 * Data storage
	 */
	Supra.data = {
		
		//Date format
		'dateFormat': '%d.%m.%Y',
		
		//First day of the week: 1 - Monday, 0 - Sunday
		'dateFirstWeekDay': 1,
		
		//Time format
		'timeFormat': '%H:%M:%S',
		'timeFormatShort': '%H:%M',
		
		//Locale (LANGUAGE_CONTEXT)
		'locale': '',

		'contexts': [],
		
		//Catch JS errors
		'catchNativeErrors': false,
		
		//Session check by periodically pinging server
		'sessionCheckPings': false,
		
		
		/**
		 * Set data
		 */
		set: function (key ,value) {
			var group = null;
			if (value && Y.Lang.isObject(value)) {
				if (key in Supra.YUI_BASE.groups.supra.modules) group = Supra.YUI_BASE.groups.supra.modules;
				else if (key in Supra.YUI_BASE.groups.website.modules) group = Supra.YUI_BASE.groups.website.modules;
				
				if (group) {
					var mod = Supra.YUI_BASE.groups.supra.modules[key], found = false;
					if (value.requires) {
						for(var i=0,ii=value.requires.length; i<ii; i++) {
							if (Y.Array.indexOf(mod.requires, value.requires[i]) == -1) {
								mod.requires.push(value.requires[i]);
							}
						}
					}
				}
			}
			
			if (value === undefined && Y.Lang.isObject(key)) {
				Supra.mix(Supra.data, key, true); 
			} else {
				var fn = '_' + key + 'Change',
					prevVal = Supra.data[key];
				
				Supra.data[key] = value;
				
				if (fn in Supra.data) {
					Supra.data[fn](value, prevVal);
				}
			}
		},
		
		/**
		 * Returns data
		 * 
		 * @param {String} key
		 * @param {Object} default_value
		 * @return Data item
		 * @type {Object}
		 */
		get: function (keys, default_value) {
			var keys = Y.Lang.isArray(keys) ? keys : [keys],
				ret = Supra.data;
			
			for(var i=0,ii=keys.length; i<ii; i++) {
				if (typeof ret == 'object' && keys[i] in ret) {
					ret = ret[keys[i]];
				} else {
					// Look for getter if there is no such key
					if (keys.length == 1 && typeof keys[0] === 'string') {
						var fn = '_' + keys[0] + 'Getter';
						if (this[fn] && typeof this[fn] === 'function') return this[fn]();
					}
					return default_value;
				}
			}
			
			return ret;
		},

		/**
		 * Get locale data by ID
		 *
		 * @param {String} key
		 * @return locale data object
		 * @type {Object}
		 */
		getLocale: function (localeId) {
			var contexts = Supra.data.get('contexts'),
				context;
			
			for(var i=0,ii=contexts.length; i<ii; i++) {
				context = contexts[i];
				for(var k=0,kk=context.languages.length; k<kk; k++) {
					if (context.languages[k].id == localeId) {
						return context.languages[k];
					}
				}
			}
		},
		
		/**
		 * Mix together
		 * 
		 * @param {Object} target
		 * @param {Object} source
		 */
		mix: function (target, source) {
			Supra.data.set(target, Supra.Y.mix(source, Supra.data.get(target, {}), false, null, 0, 2));
		},
		
		/**
		 * Add function which will handle property change
		 * 
		 * @param {String} property Property name
		 * @param {Function} handler Handler function
		 */
		registerHandler: function (property, handler) {
			if (Y.Lang.isFunction(handler)) {
				this['_' + property + 'Change'] = handler;
			}
		},
		
		
		
		/**
		 * When date format changes update YUI configuration
		 */
		_dateFormatChange: function (newVal, prevVal) {
			if (newVal !== prevVal) {
				Supra.Y.config.dateFormat = newVal;
				Supra.Y.Global.fire('dataFormatChange', {'newVal': newVal, 'prevVal': prevVal});
			}
		},
		
		/**
		 * On locale change fire event
		 */
		_localeChange: function (newVal, prevVal) {
			if (newVal !== prevVal) {
				Supra.Y.Global.fire('localeChange', {'newVal': newVal, 'prevVal': prevVal});
			}
		},
		
		/**
		 * On sessionCheckPings change start/stop timer
		 */
		_sessionCheckPingsChange: function (newVal, prevVal) {
			if (newVal !== prevVal) {
				if (newVal) {
					Supra.session.ping();
				} else {
					Supra.session.cancelPing();
				}
			}
		},
		
		/**
		 * Returns true if language features are enabled, otherwise false
		 * 
		 * @returns {Boolean} True if enabled, otherwise false
		 */
		_languageFeaturesEnabledGetter: (function () {
			var supported = null;
			
			function checkSupport () {
				// Only in portal language features may not be visible to user
				// if (!Supra.data.get(["site", "portal"])) return false;
				
				var contexts = Supra.data.get('contexts') || [],
					count = 0;
			
				for(var i=0,ii=contexts.length; i<ii; i++) count += contexts[i].languages.length;
				
				// There is only one language and this is portal site, don't show any language related features
				if (count <= 1) return false;
				
				// More than one language, show features
				return true;
			}
			
			return function () {
				if (supported === null) {
					supported = checkSupport();
				}
				return supported;
			}
		})()
	};
	
	//Update YUI configuration on load
	Supra.Y.config.dateFormat = Supra.data.dateFormat;
	
})();(function () {
	
	var Y = Supra.Y;
	
	/**
	 * Add module to module definition list
	 * 
	 * @param {String} id Module id
	 * @param {Object} definition Module definition
	 */
	Supra.addModule = function (id, definition) {
		if (Y.Lang.isString(id) && Y.Lang.isObject(definition)) {
			var groupId = id.match(/^[a-z0-9\_\-]+/);
			if (!groupId || !Supra.YUI_BASE.groups[groupId]) {
				groupId = 'supra';
			}
			Supra.YUI_BASE.groups[groupId].modules[id] = definition;
			
			//Reset configuration state
			Supra.yui_base_set = false;
		}
	};
	
	/**
	 * Add list of modules to the definitions list
	 * 
	 * @param {Object} definitions Module definitions
	 */
	Supra.addModules = function (definitions) {
		if (Y.Lang.isObject(definitions)) {
			for (var key in definitions) {
				
				Supra.addModule(key, definitions[key]);
				
			}
		}
	};
	
	/**
	 * Set path to modules with group prefix
	 * 
	 * @param {String} group Module group
	 * @param {String} path Path to modules
	 */
	Supra.setModuleGroupPath = function (group, path) {
		var config = Supra.YUI_BASE.groups[group];
		
		//Set default configuration
		if (!config) {
			config = Supra.YUI_BASE.groups[group] = {
				//Website specific modules
				combine: true,
				root: "/cms/",
				base: "/cms/",
				//Use YUI file combo
				comboBase: "/cms/lib/supra/combo/combo.php?",
				filter: "raw",
				modules: {}
			};
		}
		
		//Add trailing slash
		path = path.replace(/\/$/, '') + '/';
		config.root = path;
		config.base = path;
		
		//Reset configuration state
		Supra.yui_base_set = false;
	};
	
	/**
	 * Returns path to modules with group prefix
	 * 
	 * @param {String} group Module group
	 * @returns {String} Path to modules
	 */
	Supra.getModuleGroupPath = function (group) {
		var config = Supra.YUI_BASE.groups[group];
		if (config) {
			return config.root;
		} else {
			return null;
		}
	};
	
	/**
	 * Add module to automatically included module list
	 * 
	 * @param {String} module Name of the module, which will be automatically loaded
	 */
	Supra.autoLoadModule = function (module) {
		Supra.useModules.push(module);
	};
	
	
})();




/**
 * List of modules, which are added to use() automatically when using Supra()
 * @type {Array}
 */
Supra.useModules = [
	'base',
	'node', 'node-focusmanager',
	'widget', 'widget-child',
	'event',
	'querystring',
	'escape',
	'cookie',
	'transition',
	'router',
	
	'supra.timer',
	'supra.dd-ddm',
	'supra.event',
	'supra.deferred',
	'supra.intl',
	'supra.lang',
	'substitute',
	'supra.datatype-date-reformat',	// + supra.datatype-date-parse
	'supra.base',					// + base, node
	'supra.panel',					// + supra.button, widget, overlay
	'supra.permission',
	'supra.io',						// + io, json, jsonp
	'supra.io-session',
	'supra.io-css',
	'supra.dom',
	'supra.template',
	'supra.input',
	'supra.manager',
	
	'supra.header',
	'supra.plugin-layout',
	'supra.languagebar'
];


/**
 * Supra module definitions
 * @type {Object}
 */
Supra.YUI_BASE.groups.supra.modules = {
	/**
	 * Supra.Debug module
	 */
	'supra.debug': {
		path: 'debug/debug.js'
	},
	
	/**
	 * Y.Base extension
	 */
	'supra.base': {
		path: 'base/base.js'
	},
	
	/**
	 * Timer functions
	 */
	'supra.timer': {
		path: 'timer/timer.js'
	},
	
	/**
	 * Supra.Intl
	 */
	'supra.intl': {
		path: 'intl/intl.js',
		requires: ['intl', 'supra.io']
	},
	
	/**
	 * Y.Lang extension
	 */
	'supra.lang': {
		path: 'lang/lang.js'
	},
	
	/**
	 * Supra.Lipsum
	 */
	'supra.lipsum': {
		path: 'lipsum/lipsum.js'
	},
	
	/**
	 * Y.DOM extension
	 */
	'supra.dom': {
		path: 'dom/dom.js'
	},
	
	'supra.io': {
		path: 'io/io.js',
		requires: ['io', 'json', 'jsonp', 'jsonp-url']
	},
	'supra.io-session': {
		path: 'io/session.js',
		requires: [
			'io'
		]
	},
	'supra.io-css': {
		path: 'io/css.js',
		requires: [
			'io'
		]
	},
	'supra.io-upload': {
		path: 'io/upload.js',
		requires: [
			'supra.io-upload-legacy'
		]
	},
	'supra.io-upload-legacy': {
		path: 'io/upload-legacy.js',
		requires: [
			'base',
			'json'
		]
	},
	
	/**
	 * File upload helper
	 */
	'supra.uploader': {
		path: 'uploader/uploader.js',
		requires: [
			'supra.io-upload'
		]
	},
	
	/**
	 * Y.DD.DDM extension to allow shims for multiple documents
	 */
	'supra.dd-ddm': {
		path: 'dd-ddm/dd-ddm.js',
		requires: [
			'dd-ddm'
		]
	},
	
	/**
	 * Event 'exist' plugin
	 */
	'supra.event': {
		path: 'event/event.js'
	},
	
	/**
	 * Deferred object
	 */
	'supra.deferred': {
		path: 'event/deferred.js'
	},
	
	/**
	 * Layout plugin
	 */
	'supra.plugin-layout': {
		path: 'layout/layout.js',
		requires: ['widget', 'plugin']
	},
	
	/**
	 * Button widget
	 */
	'supra.button': {
		path: 'button/button.js',
		requires: ['node-focusmanager', 'widget', 'widget-child'],
		skinnable: true
	},
	
	'supra.button-plugin-input': {
		path: 'button/plugin-input.js',
		requires: ['plugin', 'supra.button']
	},
	
	/**
	 * Button widget
	 */
	'supra.button-group': {
		path: 'button-group/button-group.js',
		requires: ['widget', 'widget-child']
	},
	
	/**
	 * Media Library widget
	 */
	'supra.medialibrary': {
		path: 'medialibrary/medialibrary.js',
		requires: [
			'supra.medialibrary-list'
		],
		skinnable: true
	},
	
	'supra.medialibrary-data-object': {
		path: 'medialibrary/dataobject.js',
		requires: [
			'attribute',
			'array-extras'
		]
	},
	
	'supra.medialibrary-list': {
		path: 'medialibrary/medialist.js',
		requires: [
			'widget',
			'supra.slideshow',
			'supra.medialibrary-data-object'
		]
	},
	
	'supra.medialibrary-list-extended': {
		path: 'medialibrary/medialist-extended.js',
		requires: [
			'supra.input',
			'supra.medialibrary',
			'supra.slideshow-multiview',
			'supra.medialibrary-list-edit',
			'supra.medialibrary-image-editor',
			'supra.medialibrary-list-folder-dd'
		]
	},
	
	'supra.medialibrary-list-dd': {
		path: 'medialibrary/medialist-dd.js',
		requires: [
			'plugin',
			'supra.medialibrary'
		]
	},
	
	'supra.medialibrary-list-folder-dd': {
		path: 'medialibrary/medialist-extended-dd.js',
		requires: [
			'plugin',
			'dd',
			'supra.medialibrary'
		]
	},
	
	'supra.medialibrary-list-edit': {
		path: 'medialibrary/medialist-edit.js',
		requires: [
			'plugin'
		]
	},
	
	'supra.medialibrary-upload': {
		path: 'medialibrary/upload.js',
		requires: [
			'supra.io-upload',
			'plugin'
		]
	},
	
	'supra.medialibrary-image-editor': {
		path: 'medialibrary-image-editor/medialibrary-image-editor.js',
		requires: [
			'plugin',
			'transition'
		],
		skinnable: true
	},
	
	/**
	 * Editor widget
	 */
	'supra.htmleditor': {
		path: 'htmleditor/htmleditor.js',
		requires: [
			'supra.htmleditor-base',
			'supra.htmleditor-parser',
			'supra.htmleditor-selection',
			'supra.htmleditor-dom',
			'supra.htmleditor-traverse',
			'supra.htmleditor-editable',
			'supra.htmleditor-commands',
			'supra.htmleditor-plugins',
			'supra.htmleditor-data',
			'supra.htmleditor-toolbar',
			
			'supra.htmleditor-plugin-image',
			'supra.htmleditor-plugin-icon',
			'supra.htmleditor-plugin-gallery',
			'supra.htmleditor-plugin-link',
			'supra.htmleditor-plugin-video',
			'supra.htmleditor-plugin-table',
			'supra.htmleditor-plugin-itemlist',
			'supra.htmleditor-plugin-table-mobile',
			'supra.htmleditor-plugin-fullscreen',
			'supra.htmleditor-plugin-formats',
			'supra.htmleditor-plugin-lists',
			'supra.htmleditor-plugin-textstyle',
			'supra.htmleditor-plugin-shortcuts',
			'supra.htmleditor-plugin-styles',
			'supra.htmleditor-plugin-paste',
			'supra.htmleditor-plugin-paragraph',
			'supra.htmleditor-plugin-paragraph-string',
			'supra.htmleditor-plugin-paragraph-text',
			'supra.htmleditor-plugin-source',
			'supra.htmleditor-plugin-fonts',
			'supra.htmleditor-plugin-align',
			'supra.htmleditor-plugin-insert',
			'supra.htmleditor-plugin-maxlength'
		],
		skinnable: true
	},
		'supra.htmleditor-base': {
			path: 'htmleditor/htmleditor-base.js',
			requires: ['supra.iframe-stylesheet-parser']
		},
		'supra.htmleditor-parser': {
			path: 'htmleditor/htmleditor-parser.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-selection': {
			path: 'htmleditor/htmleditor-selection.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-dom': {
			path: 'htmleditor/htmleditor-dom.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-traverse': {
			path: 'htmleditor/htmleditor-traverse.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-editable': {
			path: 'htmleditor/htmleditor-editable.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-commands': {
			path: 'htmleditor/htmleditor-commands.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugins': {
			path: 'htmleditor/htmleditor-plugins.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-data': {
			path: 'htmleditor/htmleditor-data.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-toolbar': {
			path: 'htmleditor/toolbar.js',
			requires: ['supra.panel', 'supra.button']
		},
		
		/* Plugins */
		'supra.htmleditor-plugin-link': {
			path: 'htmleditor/plugins/plugin-link.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-video': {
			path: 'htmleditor/plugins/plugin-video',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-gallery': {
			path: 'htmleditor/plugins/plugin-gallery.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-insert': {
			path: 'htmleditor/plugins/plugin-insert.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-image': {
			path: 'htmleditor/plugins/plugin-image.js',
			requires: ['supra.htmleditor-base', 'supra.imageresizer', 'supra.manager']
		},
		'supra.htmleditor-plugin-icon': {
			path: 'htmleditor/plugins/plugin-icon.js',
			requires: ['supra.htmleditor-base', 'supra.imageresizer', 'supra.manager']
		},
		'supra.htmleditor-plugin-table': {
			path: 'htmleditor/plugins/plugin-table.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-table-mobile': {
			path: 'htmleditor/plugins/plugin-table-mobile.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-itemlist': {
			path: 'htmleditor/plugins/plugin-itemlist.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-fullscreen': {
			path: 'htmleditor/plugins/plugin-fullscreen.js',
			requires: ['supra.manager', 'supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-textstyle': {
			path: 'htmleditor/plugins/plugin-textstyle.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-shortcuts': {
			path: 'htmleditor/plugins/plugin-shortcuts.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-formats': {
			path: 'htmleditor/plugins/plugin-formats.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-lists': {
			path: 'htmleditor/plugins/plugin-lists.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-styles': {
			path: 'htmleditor/plugins/plugin-styles.js',
			requires: ['supra.htmleditor-base', 'supra.template']
		},
		'supra.htmleditor-plugin-paste': {
			path: 'htmleditor/plugins/plugin-paste.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-paragraph': {
			path: 'htmleditor/plugins/plugin-paragraph.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-paragraph-string': {
			path: 'htmleditor/plugins/plugin-paragraph-string.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-paragraph-text': {
			path: 'htmleditor/plugins/plugin-paragraph-text.js',
			requires: ['supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-source': {
			path: 'htmleditor/plugins/plugin-source.js',
			requires: ['supra.manager', 'supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-fonts': {
			path: 'htmleditor/plugins/plugin-fonts.js',
			requires: ['supra.manager', 'supra.htmleditor-base', 'supra.input-fonts', 'supra.google-fonts']
		},
		'supra.htmleditor-plugin-align': {
			path: 'htmleditor/plugins/plugin-align.js',
			requires: ['supra.manager', 'supra.htmleditor-base']
		},
		'supra.htmleditor-plugin-maxlength': {
			path: 'htmleditor/plugins/plugin-maxlength.js',
			requires: ['supra.htmleditor-base']
		},
	
	/**
	 * Iframe + stylesheet parser
	 */
	'supra.iframe-stylesheet-parser': {
		path: 'iframe/stylesheet-parser.js',
		requires: ['base']
	},
	'supra.iframe': {
		path: 'iframe/iframe.js',
		requires: ['widget', 'supra.iframe-stylesheet-parser', 'supra.google-fonts'],
		skinnable: true
	},
	
	/**
	 * Google fonts
	 */
	'supra.google-fonts': {
		path: 'google-fonts/google-fonts.js',
		requires: ['base']
	},
	
	/**
	 * Image resize 
	 */
	'supra.imageresizer': {
		path: 'imageresizer/imageresizer.js',
		requires: ['supra.panel', 'supra.slider', 'dd-plugin', 'supra.datatype-image', 'supra.datatype-icon'],
		skinnable: true
	},
	
	/**
	 * Header widget
	 */
	'supra.header': {
		path: 'header/header.js',
		requires: ['supra.header.appdock'],
		skinnable: true
	},
	'supra.header.appdock': {
		path: 'header/appdock.js',
		requires: ['supra.tooltip']
	},
	
	/**
	 * DataGrid
	 */
	'supra.datagrid': {
		path: 'datagrid/datagrid.js',
		requires: ['widget', 'datasource', 'dataschema', 'datatype', 'querystring', 'supra.datagrid-row', 'supra.scrollable'],
		skinnable: true
	},
	'supra.datagrid-loader': {
		path: 'datagrid/datagrid-loader.js',
		requires: ['plugin', 'supra.datagrid']
	},
	'supra.datagrid-sortable': {
		path: 'datagrid/datagrid-sortable.js',
		requires: ['plugin', 'supra.datagrid']
	},
	'supra.datagrid-draggable': {
		path: 'datagrid/datagrid-draggable.js',
		requires: ['plugin', 'dd-delegate', 'dd-drag', 'dd-proxy', 'dd-drop', 'supra.datagrid']
	},
	'supra.datagrid-row': {
		path: 'datagrid/datagrid-row.js',
		requires: ['widget']
	},
	'supra.datagrid-new-item': {
		path: 'datagrid-new-item/datagrid-new-item.js',
		requires: ['widget', 'dd-drag'],
		skinnable: true
	},
	
	/**
	 * List
	 */
	'supra.list': {
		path: 'list/list.js',
		requires: [
			'supra.list-new-item'
		],
		skinnable: true
	},
	'supra.list-new-item': {
		path: 'list/new-item.js',
		requires: ['widget', 'dd-drag']
	},
	
	/**
	 * Panel
	 */
	'supra.panel': {
		path: 'panel/panel.js',
		requires: ['overlay', 'supra.button'],
		skinnable: true
	},
	'supra.tooltip': {
		path: 'panel/tooltip.js',
		requires: ['supra.panel']
	},
	
	/**
	 * Slider widget
	 */
	'supra.slider': {
		path: 'slider/slider.js',
		requires: ['slider'],
		skinnable: true
	},
	
	/**
	 * Slideshow widget
	 */
	'supra.slideshow': {
		path: 'slideshow/slideshow.js',
		requires: ['widget', 'anim', 'supra.slideshow-input-button', 'supra.scrollable'],
		skinnable: true
	},
	'supra.slideshow-multiview': {
		path: 'slideshow/slideshow-multiview.js',
		requires: ['supra.slideshow']
	},
	'supra.slideshow-input-button': {
		path: 'slideshow/slideshow-input-button.js',
		requires: ['supra.input-proto']
	},
	
	/**
	 * Scrollable widget
	 */
	'supra.scrollable': {
		path: 'scrollable/scrollable.js',
		requires: ['widget', 'anim'],
		skinnable: true
	},
	
	/**
	 * Footer
	 */
	'supra.footer': {
		path: 'footer/footer.js',
		skinnable: true
	},
	
	/**
	 * Tree widget
	 */
	'supra.tree': {
		path: 'tree/tree.js',
		requires: ['supra.tree-node', 'supra.tree-plugin-expand-history', 'widget', 'widget-parent'],
		skinnable: true
	},
	'supra.tree-draggable': {
		path: 'tree/tree-draggable.js',
		requires: ['supra.tree', 'supra.tree-node-draggable']
	},
	'supra.tree-node': {
		path: 'tree/tree-node.js',
		requires: ['widget', 'widget-child']
	},
	'supra.tree-node-draggable': {
		path: 'tree/tree-node-draggable.js',
		requires: ['dd', 'supra.tree-node']
	},
	'supra.tree-plugin-expand-history': {
		path: 'tree/plugin-expand-history.js',
		requires: ['plugin', 'cookie', 'supra.tree']
	},
	
	/**
	 * Input widgets
	 */
	'supra.input-proto': {
		path: 'input/proto.js',
		requires: ['widget', 'supra.lipsum']
	},
	'supra.input-hidden': {
		path: 'input/hidden.js',
		requires: ['supra.input-proto']
	},
	'supra.input-string': {
		path: 'input/string.js',
		requires: ['supra.input-proto']
	},
	'supra.input-text': {
		path: 'input/text.js',
		requires: ['supra.input-string']
	},
	'supra.input-number': {
		path: 'input/number.js',
		requires: ['supra.input-string']
	},
	'supra.input-path': {
		path: 'input/path.js',
		requires: ['supra.input-string']
	},
	'supra.input-checkbox': {
		path: 'input/checkbox.js',
		requires: ['supra.input-proto', 'anim']
	},
	'supra.input-file-upload': {
		path: 'input/fileupload.js',
		requires: ['supra.input-proto', 'supra.uploader', 'supra.tooltip']
	},
	'supra.input-select': {
		path: 'input/select.js',
		requires: ['supra.input-string', 'anim', 'supra.scrollable']
	},
	'supra.input-select-list': {
		path: 'input/select-list.js',
		requires: ['supra.input-proto', 'supra.button']
	},
	'supra.input-select-visual': {
		path: 'input/select-visual.js',
		requires: ['supra.input-select-list']
	},
	'supra.input-slider': {
		path: 'input/slider.js',
		requires: ['supra.input-proto', 'supra.slider']
	},
	'supra.input-link': {
		path: 'input/link.js',
		requires: ['supra.input-proto']
	},
	'supra.input-image': {
		path: 'input/image.js',
		requires: ['supra.input-proto']
	},
	'supra.input-file': {
		path: 'input/file.js',
		requires: ['supra.input-proto']
	},
	'supra.input-map': {
		path: 'input/map.js',
		requires: ['supra.input-proto']
	},
	'supra.input-map-inline': {
		path: 'input/map-inline.js',
		requires: ['supra.input-proto']
	},
	'supra.input-color': {
		path: 'input/color.js',
		requires: ['supra.input-proto', 'dd', 'supra.datatype-color']
	},
	'supra.input-fonts': {
		path: 'input/fonts.js',
		requires: ['supra.input-select-visual']
	},
	'supra.input-date': {
		path: 'input/date.js',
		requires: ['supra.input-proto', 'supra.calendar']
	},
	'supra.input-block-background': {
		path: 'input/block-background.js',
		requires: ['supra.input-proto', 'supra.datatype-image']
	},
	'supra.input-image-inline': {
		path: 'input/image-inline.js',
		requires: ['supra.input-block-background']
	},
	'supra.input-icon-inline': {
		path: 'input/icon-inline.js',
		requires: ['supra.input-proto']
	},
	'supra.input-video': {
		path: 'input/video.js',
		requires: ['supra.input-hidden']
	},
	'supra.input-keywords': {
		path: 'input/keywords.js',
		requires: ['supra.input-proto', 'supra.io']
	},
	'supra.input-set': {
		path: 'input/set.js',
		requires: ['supra.input-hidden']
	},
	'supra.input-group': {
		path: 'input/group.js',
		requires: ['supra.input-hidden']
	},
	'supra.input-media-inline': {
		path: 'input/media-inline.js',
		requires: ['supra.input-proto', 'supra.uploader', 'supra.datatype-image']
	},
	
	'supra.input-string-clear': {
		path: 'input/string.js',
		requires: ['supra.input-string', 'plugin']
	},
	
	'supra.form': {
		path: 'input/form.js',
		requires: [
			'querystring',
			'widget',
			'supra.input-proto',
			'supra.input-hidden',
			'supra.input-string',
			'supra.input-text',
			'supra.input-html',
			'supra.input-number',
			'supra.input-path',
			'supra.input-checkbox',
			'supra.input-file-upload',
			'supra.input-select',
			'supra.input-select-list',
			'supra.input-select-visual',
			'supra.input-slider',
			'supra.input-link',
			'supra.input-image',
			'supra.input-file',
			'supra.input-map',
			'supra.input-map-inline',
			'supra.input-color',
			'supra.input-date',
			'supra.input-block-background',
			'supra.input-image-inline',
			'supra.input-icon-inline',
			'supra.input-inline-html',
			'supra.input-inline-string',
			'supra.input-inline-text',
			'supra.input-video',
			'supra.input-keywords',
			'supra.input-set',
			'supra.input-group',
			'supra.input-media-inline',
			
			'supra.button-plugin-input',
			'supra.input-string-clear'
		]
	},
	'supra.input': {
		path: 'input/input.js',
		requires: ['supra.form'],
		skinnable: true
	},
	
	//HTML editor
	'supra.input-html': {
		path: 'input/html.js',
		requires: ['supra.input-proto', 'supra.htmleditor']
	},
	
	//In-line HTML editor
	'supra.input-inline-html': {
		path: 'input/html-inline.js',
		requires: ['supra.input-proto']
	},
	
	//In-line string editor
	'supra.input-inline-string': {
		path: 'input/string-inline.js',
		requires: ['supra.input-inline-html']
	},
	
	//In-line text editor
	'supra.input-inline-text': {
		path: 'input/text-inline.js',
		requires: ['supra.input-inline-string']
	},
	
	/**
	 * Calendar widget
	 */
	'supra.datatype-date-parse': {
		path: 'datatype/datatype-date-parse.js',
		requires: ['datatype-date']
	},
	
	'supra.datatype-date-reformat': {
		path: 'datatype/datatype-date-reformat.js',
		requires: ['supra.datatype-date-parse']
	},
	
	'supra.calendar': {
		path: 'calendar/calendar.js',
		requires: ['widget', 'anim', 'datatype-date'],
		skinnable: true
	},
	
	/**
	 * Color
	 */
	'supra.datatype-color': {
		path: 'datatype/datatype-color.js'
	},
	
	/**
	 * Image
	 */
	'supra.datatype-image': {
		path: 'datatype/datatype-image.js'
	},
	
	/**
	 * Icon
	 */
	'supra.datatype-icon': {
		path: 'datatype/datatype-icon.js'
	},
	
	/**
	 * Tabs
	 */
	'supra.tabs': {
		path: 'tabs/tabs.js',
		requires: ['widget'],
		skinnable: true
	},
	
	/**
	 * Language bar
	 */
	'supra.languagebar': {
		path: 'languagebar/languagebar.js',
		requires: ['supra.tooltip'],
		skinnable: true
	},
	
	/**
	 * Permission
	 */
	'supra.permission': {
		path: 'permission/permission.js'
	},
	
	/**
	 * Template
	 */
	'supra.template': {
		path: 'template/template.js',
		requires: [
			'supra.template-compiler'
		]
	},
	'supra.template-compiler': {
		path: 'template/template-compiler.js'
	},
	
	/**
	 * Help
	 */
	'supra.help': {
		path: 'help/help.js',
		skinnable: true,
		requires: [
			'supra.help-tip'
		]
	},
	
	'supra.help-tip': {
		path: 'help/tip.js',
		requires: [
			'widget'
		]
	},
	
	/**
	 * Manager
	 */
	'supra.manager': {
		path: 'manager/manager.js',
		requires: [
			'supra.permission',
			'supra.manager-base',
			'supra.manager-loader',
			'supra.manager-loader-actions',
			'supra.manager-action',
			'supra.manager-action-base',
			'supra.manager-action-plugin-manager',
			'supra.manager-action-plugin-base',
			'supra.manager-action-plugin-panel',
			'supra.manager-action-plugin-form',
			'supra.manager-action-plugin-footer',
			'supra.manager-action-plugin-container',
			'supra.manager-action-plugin-maincontent',
			'supra.manager-action-plugin-layout-sidebar'
		]
	},
	'supra.manager-base': {
		path: 'manager/base.js'
	},
	'supra.manager-loader': {
		path: 'manager/loader.js',
		requires: ['supra.manager-base']
	},
	'supra.manager-loader-actions': {
		path: 'manager/loader-common-actions.js',
		requires: ['supra.manager-loader']
	},
	'supra.manager-action': {
		path: 'manager/action.js',
		requires: ['supra.manager-base']
	},
	'supra.manager-action-base': {
		path: 'manager/action/base.js',
		requires: ['supra.manager-action']
	},
	'supra.manager-action-plugin-manager': {
		path: 'manager/action/plugin-manager.js',
		requires: ['supra.manager-base']
	},
	'supra.manager-action-plugin-base': {
		path: 'manager/action/plugin-base.js',
		requires: ['supra.manager-base']
	},
	'supra.manager-action-plugin-panel': {
		path: 'manager/action/plugin-panel.js',
		requires: ['supra.manager-action-plugin-base', 'supra.panel']
	},
	'supra.manager-action-plugin-form': {
		path: 'manager/action/plugin-form.js',
		requires: ['supra.manager-action-plugin-base', 'supra.input']
	},
	'supra.manager-action-plugin-footer': {
		path: 'manager/action/plugin-footer.js',
		requires: ['supra.manager-action-plugin-base', 'supra.footer']
	},
	'supra.manager-action-plugin-container': {
		path: 'manager/action/plugin-container.js',
		requires: ['supra.manager-action-plugin-base']
	},
	'supra.manager-action-plugin-maincontent': {
		path: 'manager/action/plugin-maincontent.js',
		requires: ['supra.manager-action-plugin-base']
	},
	'supra.manager-action-plugin-layout-sidebar': {
		path: 'manager/action/plugin-layout-sidebar.js',
		requires: ['supra.manager-action-plugin-base', 'supra.input', 'supra.scrollable']
	}
	
};YUI.add('supra.timer', function(Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Throttle function call
	 * If delay argument is true, then instead of calling function every 'ms'
	 * milliseconds it's called once if in last 'ms' function wasn't called 
	 * 
	 * @param {Function} fn
	 * @param {Number} ms
	 * @param {Object} context
	 * @param {Boolean} delay I
	 * @private
	 */
	Supra.throttle = function (fn, ms, context, delay) {
		var ms = ms || 50;
		var last_time = 0;
		var timeout = null;
		var args = [];
		
		if (ms === -1) {
			return (function() {
				fn.apply(context, arguments);
			});
		}
		
		function call () {
			fn.apply(context || window, args);
			last_time = +new Date();
			clearTimeout(timeout);
			timeout = null;
		}
		
		return function () {
			//Save arguments
			args = [].slice.call(arguments, 0);
			
			if (delay) {
				if (timeout) clearTimeout(timeout);
				timeout = setTimeout(call, ms);
			} else {
				if ((+new Date()) - last_time > ms) {
					call();
				} else if (!timeout) {
					timeout = setTimeout(call, ms);
				}
			}
		};
	};
	
	/**
	 * Immediatelly call a callback on next cycle
	 * Similar to Y.later, but executes callback as soon as possible, but still is async
	 * 
	 * @param {Object} context Optional, callback execution context
	 * @param {Function} callback Callback function
	 */
	Supra.immediate = (function () {
		var callbacks = [],
			channel = null,
			transmit = null,
			receive =  null,
			attach = null;
		
		receive = function () {
			var c  = callbacks,
				i  = 0,
				ii = c.length;
			
			for (; i<ii; i++) {
				callbacks[i]();
			}
			
			callbacks = [];
		};
		
		if (window.setImmediate) {
			// No browser support for now
			transmit = function () {
				window.setImmediate(receive);
			};
		} else if (window.msSetImmediate) {
			// IE10+
			transmit = function () {
				window.msSetImmediate(receive);
			};
		} else if (window.postMessage) {
			// FF, Chrome, Safari, Opera, IE8+
			window.addEventListener('message', function (event) {
				if (event.source === window && event.data.indexOf('supra.immediate') === 0) {
					receive();
				}
			}, false);
			
			transmit = function () {
				postMessage('supra.immediate', '*');
			};
		} else if (window.MessageChannel) {
			// 
			channel = new MessageChannel();
			channel.port1.onmessage = function (event) {
				if (event.data == 'supra.immediate') {
					receive();
				}
			};
			
			transmit = function () {
				channel.port2.postMessage('supra.immediate');
			};
		} else {
			transmit = function () {
				setTimeout(receive, 0);
			};
		}
		
		attach = function (context, callback) {
			if (Y.Lang.isFunction(context)) {
				callback = context;
			} else {
				callback = Y.bind(callback, context);
			}
			
			callbacks.push(callback);
			transmit();
		};
		
		return attach;
	})();
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version);/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("attribute-core",function(c){c.State=function(){this.data={};};c.State.prototype={add:function(v,w,y){var x=this.data;x[v]=x[v]||{};x[v][w]=y;},addAll:function(v,x){var w;for(w in x){if(x.hasOwnProperty(w)){this.add(v,w,x[w]);}}},remove:function(v,w){var x=this.data;if(x[v]){delete x[v][w];}},removeAll:function(v,x){var w=this.data;if(!x){if(w[v]){delete w[v];}}else{c.each(x,function(z,y){if(c.Lang.isString(y)){this.remove(v,y);}else{this.remove(v,z);}},this);}},get:function(v,w){var x=this.data;return(x[v])?x[v][w]:undefined;},getAll:function(w,v){var y=this.data,x;if(!v){c.each(y[w],function(A,z){x=x||{};x[z]=A;});}else{x=y[w];}return x;}};var i=c.Object,d=c.Lang,q=".",k="getter",j="setter",l="readOnly",r="writeOnce",p="initOnly",u="validator",f="value",m="valueFn",o="lazyAdd",t="added",h="_bypassProxy",b="initializing",g="initValue",a="lazy",n="isLazyAdd",e;function s(w,v,x){this._initAttrHost(w,v,x);}s.INVALID_VALUE={};e=s.INVALID_VALUE;s._ATTR_CFG=[j,k,u,f,m,r,l,o,h];s.prototype={_initAttrHost:function(w,v,x){this._state=new c.State();this._initAttrs(w,v,x);},addAttr:function(w,v,y){var z=this,B=z._state,A,x;v=v||{};y=(o in v)?v[o]:y;if(y&&!z.attrAdded(w)){B.addAll(w,{lazy:v,added:true});}else{if(!z.attrAdded(w)||B.get(w,n)){x=(f in v);if(x){A=v.value;delete v.value;}v.added=true;v.initializing=true;B.addAll(w,v);if(x){z.set(w,A);}B.remove(w,b);}}return z;},attrAdded:function(v){return !!this._state.get(v,t);},get:function(v){return this._getAttr(v);},_isLazyAttr:function(v){return this._state.get(v,a);},_addLazyAttr:function(x,v){var y=this._state,w=y.get(x,a);y.add(x,n,true);y.remove(x,a);this.addAttr(x,w);},set:function(v,w){return this._setAttr(v,w);},_set:function(v,w){return this._setAttr(v,w,null,true);},_setAttr:function(x,A,v,y){var E=true,w=this._state,B=this._stateProxy,H,D,G,I,z,C,F;if(x.indexOf(q)!==-1){G=x;I=x.split(q);x=I.shift();}if(this._isLazyAttr(x)){this._addLazyAttr(x);}H=w.getAll(x,true)||{};D=(!(f in H));if(B&&x in B&&!H._bypassProxy){D=false;}C=H.writeOnce;F=H.initializing;if(!D&&!y){if(C){E=false;}if(H.readOnly){E=false;}}if(!F&&!y&&C===p){E=false;}if(E){if(!D){z=this.get(x);}if(I){A=i.setValue(c.clone(z),I,A);if(A===undefined){E=false;}}if(E){if(!this._fireAttrChange||F){this._setAttrVal(x,G,z,A);}else{this._fireAttrChange(x,G,z,A,v);}}}return this;},_getAttr:function(x){var y=this,C=x,z=y._state,A,v,B,w;if(x.indexOf(q)!==-1){A=x.split(q);x=A.shift();}if(y._tCfgs&&y._tCfgs[x]){w={};w[x]=y._tCfgs[x];delete y._tCfgs[x];y._addAttrs(w,y._tVals);}if(y._isLazyAttr(x)){y._addLazyAttr(x);}B=y._getStateVal(x);v=z.get(x,k);if(v&&!v.call){v=this[v];}B=(v)?v.call(y,B,C):B;B=(A)?i.getValue(B,A):B;return B;},_getStateVal:function(v){var w=this._stateProxy;return w&&(v in w)&&!this._state.get(v,h)?w[v]:this._state.get(v,f);},_setStateVal:function(v,x){var w=this._stateProxy;if(w&&(v in w)&&!this._state.get(v,h)){w[v]=x;}else{this._state.add(v,f,x);}},_setAttrVal:function(H,G,C,A){var I=this,D=true,F=this._state.getAll(H,true)||{},y=F.validator,B=F.setter,E=F.initializing,x=this._getStateVal(H),w=G||H,z,v;if(y){if(!y.call){y=this[y];}if(y){v=y.call(I,A,w);if(!v&&E){A=F.defaultValue;v=true;}}}if(!y||v){if(B){if(!B.call){B=this[B];}if(B){z=B.call(I,A,w);if(z===e){D=false;}else{if(z!==undefined){A=z;}}}}if(D){if(!G&&(A===x)&&!d.isObject(A)){D=false;}else{if(!(g in F)){F.initValue=A;}I._setStateVal(H,A);}}}else{D=false;}return D;},setAttrs:function(v){return this._setAttrs(v);},_setAttrs:function(w){for(var v in w){if(w.hasOwnProperty(v)){this.set(v,w[v]);}}return this;},getAttrs:function(v){return this._getAttrs(v);},_getAttrs:function(y){var A=this,C={},z,w,v,B,x=(y===true);y=(y&&!x)?y:i.keys(A._state.data);for(z=0,w=y.length;z<w;z++){v=y[z];B=A.get(v);if(!x||A._getStateVal(v)!=A._state.get(v,g)){C[v]=A.get(v);}}return C;},addAttrs:function(v,w,x){var y=this;if(v){y._tCfgs=v;y._tVals=y._normAttrVals(w);y._addAttrs(v,y._tVals,x);y._tCfgs=y._tVals=null;}return y;},_addAttrs:function(w,x,y){var A=this,v,z,B;for(v in w){if(w.hasOwnProperty(v)){z=w[v];z.defaultValue=z.value;B=A._getAttrInitVal(v,z,A._tVals);if(B!==undefined){z.value=B;}if(A._tCfgs[v]){delete A._tCfgs[v];}A.addAttr(v,z,y);}}},_protectAttrs:function(w){if(w){w=c.merge(w);for(var v in w){if(w.hasOwnProperty(v)){w[v]=c.merge(w[v]);}}}return w;},_normAttrVals:function(v){return(v)?c.merge(v):null;},_getAttrInitVal:function(v,w,y){var z,x;if(!w.readOnly&&y&&y.hasOwnProperty(v)){z=y[v];}else{z=w.value;x=w.valueFn;if(x){if(!x.call){x=this[x];}if(x){z=x.call(this,v);}}}return z;},_initAttrs:function(w,v,z){w=w||this.constructor.ATTRS;var y=c.Base,x=c.BaseCore,A=(y&&c.instanceOf(this,y)),B=(!A&&x&&c.instanceOf(this,x));if(w&&!A&&!B){this.addAttrs(this._protectAttrs(w),v,z);}}};c.AttributeCore=s;},"3.5.0");/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("base-core",function(a){var e=a.Object,i=a.Lang,h=".",l="initialized",d="destroyed",c="initializer",b=Object.prototype.constructor,j="deep",m="shallow",k="destructor",g=a.AttributeCore,f=function(t,q,o){var u;for(u in q){if(o[u]){t[u]=q[u];}}return t;};function n(o){if(!this._BaseInvoked){this._BaseInvoked=true;this._initBase(o);}}n._ATTR_CFG=g._ATTR_CFG.concat("cloneDefaultValue");n._ATTR_CFG_HASH=a.Array.hash(n._ATTR_CFG);n._NON_ATTRS_CFG=["plugins"];n.NAME="baseCore";n.ATTRS={initialized:{readOnly:true,value:false},destroyed:{readOnly:true,value:false}};n.prototype={_initBase:function(o){a.stamp(this);this._initAttribute(o);var p=a.Plugin&&a.Plugin.Host;if(this._initPlugins&&p){p.call(this);}if(this._lazyAddAttrs!==false){this._lazyAddAttrs=true;}this.name=this.constructor.NAME;this.init.apply(this,arguments);},_initAttribute:function(){g.apply(this);},init:function(o){this._baseInit(o);return this;},_baseInit:function(o){this._initHierarchy(o);if(this._initPlugins){this._initPlugins(o);}this._set(l,true);},destroy:function(){this._baseDestroy();return this;},_baseDestroy:function(){if(this._destroyPlugins){this._destroyPlugins();}this._destroyHierarchy();this._set(d,true);},_getClasses:function(){if(!this._classes){this._initHierarchyData();}return this._classes;},_getAttrCfgs:function(){if(!this._attrs){this._initHierarchyData();}return this._attrs;},_filterAttrCfgs:function(s,p){var q=null,o,r=s.ATTRS;if(r){for(o in r){if(p[o]){q=q||{};q[o]=p[o];p[o]=null;}}}return q;},_filterAdHocAttrs:function(r,p){var q,s=this._nonAttrs,o;if(p){q={};for(o in p){if(!r[o]&&!s[o]&&p.hasOwnProperty(o)){q[o]={value:p[o]};}}}return q;},_initHierarchyData:function(){var u=this.constructor,r,o,s,t=(this._allowAdHocAttrs)?{}:null,q=[],p=[];while(u){q[q.length]=u;if(u.ATTRS){p[p.length]=u.ATTRS;}if(this._allowAdHocAttrs){s=u._NON_ATTRS_CFG;if(s){for(r=0,o=s.length;r<o;r++){t[s[r]]=true;}}}u=u.superclass?u.superclass.constructor:null;}this._classes=q;this._nonAttrs=t;this._attrs=this._aggregateAttrs(p);},_attrCfgHash:function(){return n._ATTR_CFG_HASH;},_aggregateAttrs:function(v){var r,w,q,o,x,p,u,t=this._attrCfgHash(),s={};if(v){for(p=v.length-1;p>=0;--p){w=v[p];for(r in w){if(w.hasOwnProperty(r)){q=f({},w[r],t);o=q.value;u=q.cloneDefaultValue;if(o){if((u===undefined&&(b===o.constructor||i.isArray(o)))||u===j||u===true){q.value=a.clone(o);}else{if(u===m){q.value=a.merge(o);}}}x=null;if(r.indexOf(h)!==-1){x=r.split(h);r=x.shift();}if(x&&s[r]&&s[r].value){e.setValue(s[r].value,x,o);}else{if(!x){if(!s[r]){s[r]=q;}else{f(s[r],q,t);}}}}}}}return s;},_initHierarchy:function(u){var q=this._lazyAddAttrs,v,x,z,s,p,y,t,r=this._getClasses(),o=this._getAttrCfgs(),w=r.length-1;for(z=w;z>=0;z--){v=r[z];x=v.prototype;t=v._yuibuild&&v._yuibuild.exts;if(t){for(s=0,p=t.length;s<p;s++){t[s].apply(this,arguments);}}this.addAttrs(this._filterAttrCfgs(v,o),u,q);if(this._allowAdHocAttrs&&z===w){this.addAttrs(this._filterAdHocAttrs(o,u),u,q);}if(x.hasOwnProperty(c)){x.initializer.apply(this,arguments);}if(t){for(s=0;s<p;s++){y=t[s].prototype;if(y.hasOwnProperty(c)){y.initializer.apply(this,arguments);}}}}},_destroyHierarchy:function(){var s,t,w,u,q,o,r,v,p=this._getClasses();for(w=0,u=p.length;w<u;w++){s=p[w];t=s.prototype;r=s._yuibuild&&s._yuibuild.exts;if(r){for(q=0,o=r.length;q<o;q++){v=r[q].prototype;if(v.hasOwnProperty(k)){v.destructor.apply(this,arguments);}}}if(t.hasOwnProperty(k)){t.destructor.apply(this,arguments);}}},toString:function(){return this.name+"["+a.stamp(this,true)+"]";}};a.mix(n,g,false,null,1);n.prototype.constructor=n;a.BaseCore=n;},"3.5.0",{requires:["attribute-core"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("oop",function(h){var d=h.Lang,c=h.Array,b=Object.prototype,a="_~yuim~_",e=b.hasOwnProperty,g=b.toString;function f(l,k,m,i,j){if(l&&l[j]&&l!==h){return l[j].call(l,k,m);}else{switch(c.test(l)){case 1:return c[j](l,k,m);case 2:return c[j](h.Array(l,0,true),k,m);default:return h.Object[j](l,k,m,i);}}}h.augment=function(i,k,r,o,s){var n=i.prototype,m=n&&k,q=k.prototype,v=n||i,j,u,p,l,t;s=s?h.Array(s):[];if(m){u={};p={};l={};j=function(x,w){if(r||!(w in n)){if(g.call(x)==="[object Function]"){l[w]=x;u[w]=p[w]=function(){return t(this,x,arguments);};}else{u[w]=x;}}};t=function(w,y,z){for(var x in l){if(e.call(l,x)&&w[x]===p[x]){w[x]=l[x];}}k.apply(w,s);return y.apply(w,z);};if(o){h.Array.each(o,function(w){if(w in q){j(q[w],w);}});}else{h.Object.each(q,j,null,true);}}h.mix(v,u||q,r,o);if(!m){k.apply(v,s);}return i;};h.aggregate=function(k,j,i,l){return h.mix(k,j,i,l,0,true);};h.extend=function(l,k,i,n){if(!k||!l){h.error("extend failed, verify dependencies");}var m=k.prototype,j=h.Object(m);l.prototype=j;j.constructor=l;l.superclass=m;if(k!=Object&&m.constructor==b.constructor){m.constructor=k;}if(i){h.mix(j,i,true);}if(n){h.mix(l,n,true);}return l;};h.each=function(k,j,l,i){return f(k,j,l,i,"each");};h.some=function(k,j,l,i){return f(k,j,l,i,"some");};h.clone=function(l,m,r,s,k,q){if(!d.isObject(l)){return l;}if(h.instanceOf(l,YUI)){return l;}var n,j=q||{},i,p=h.each;switch(d.type(l)){case"date":return new Date(l);case"regexp":return l;case"function":return l;case"array":n=[];break;default:if(l[a]){return j[l[a]];}i=h.guid();n=(m)?{}:h.Object(l);l[a]=i;j[i]=l;}if(!l.addEventListener&&!l.attachEvent){p(l,function(t,o){if((o||o===0)&&(!r||(r.call(s||this,t,o,this,l)!==false))){if(o!==a){if(o=="prototype"){}else{this[o]=h.clone(t,m,r,s,k||l,j);}}}},n);}if(!q){h.Object.each(j,function(t,o){if(t[a]){try{delete t[a];}catch(u){t[a]=null;}}},this);j=null;}return n;};h.bind=function(i,k){var j=arguments.length>2?h.Array(arguments,2,true):null;return function(){var m=d.isString(i)?k[i]:i,l=(j)?j.concat(h.Array(arguments,0,true)):arguments;return m.apply(k||m,l);};};h.rbind=function(i,k){var j=arguments.length>2?h.Array(arguments,2,true):null;return function(){var m=d.isString(i)?k[i]:i,l=(j)?h.Array(arguments,0,true).concat(j):arguments;return m.apply(k||m,l);};};},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-custom-base",function(b){b.Env.evt={handles:{},plugins:{}};var g=0,i=1,p={objs:{},before:function(s,u,v,w){var t=s,r;if(w){r=[s,w].concat(b.Array(arguments,4,true));t=b.rbind.apply(b,r);}return this._inject(g,t,u,v);},after:function(s,u,v,w){var t=s,r;if(w){r=[s,w].concat(b.Array(arguments,4,true));t=b.rbind.apply(b,r);}return this._inject(i,t,u,v);},_inject:function(r,t,u,w){var x=b.stamp(u),v,s;if(!this.objs[x]){this.objs[x]={};}v=this.objs[x];if(!v[w]){v[w]=new b.Do.Method(u,w);u[w]=function(){return v[w].exec.apply(v[w],arguments);};}s=x+b.stamp(t)+w;v[w].register(s,t,r);return new b.EventHandle(v[w],s);},detach:function(r){if(r.detach){r.detach();}},_unload:function(s,r){}};b.Do=p;p.Method=function(r,s){this.obj=r;this.methodName=s;this.method=r[s];this.before={};this.after={};};p.Method.prototype.register=function(s,t,r){if(r){this.after[s]=t;}else{this.before[s]=t;}};p.Method.prototype._delete=function(r){delete this.before[r];delete this.after[r];};p.Method.prototype.exec=function(){var t=b.Array(arguments,0,true),u,s,x,v=this.before,r=this.after,w=false;for(u in v){if(v.hasOwnProperty(u)){s=v[u].apply(this.obj,t);if(s){switch(s.constructor){case p.Halt:return s.retVal;case p.AlterArgs:t=s.newArgs;break;case p.Prevent:w=true;break;default:}}}}if(!w){s=this.method.apply(this.obj,t);}p.originalRetVal=s;p.currentRetVal=s;for(u in r){if(r.hasOwnProperty(u)){x=r[u].apply(this.obj,t);if(x&&x.constructor==p.Halt){return x.retVal;}else{if(x&&x.constructor==p.AlterReturn){s=x.newRetVal;p.currentRetVal=s;}}}}return s;};p.AlterArgs=function(s,r){this.msg=s;this.newArgs=r;};p.AlterReturn=function(s,r){this.msg=s;this.newRetVal=r;};p.Halt=function(s,r){this.msg=s;this.retVal=r;};p.Prevent=function(r){this.msg=r;};p.Error=p.Halt;var m="after",q=["broadcast","monitored","bubbles","context","contextFn","currentTarget","defaultFn","defaultTargetOnly","details","emitFacade","fireOnce","async","host","preventable","preventedFn","queuable","silent","stoppedFn","target","type"],n=9,a="yui:log";b.CustomEvent=function(r,s){s=s||{};this.id=b.stamp(this);this.type=r;this.context=b;this.logSystem=(r==a);this.silent=this.logSystem;this.subscribers={};this.afters={};this.preventable=true;this.bubbles=true;this.signature=n;this.subCount=0;this.afterCount=0;this.applyConfig(s,true);};b.CustomEvent.prototype={constructor:b.CustomEvent,hasSubs:function(r){var v=this.subCount,t=this.afterCount,u=this.sibling;if(u){v+=u.subCount;t+=u.afterCount;}if(r){return(r=="after")?t:v;}return(v+t);},monitor:function(t){this.monitored=true;var s=this.id+"|"+this.type+"_"+t,r=b.Array(arguments,0,true);r[0]=s;return this.host.on.apply(this.host,r);},getSubs:function(){var u=b.merge(this.subscribers),r=b.merge(this.afters),t=this.sibling;if(t){b.mix(u,t.subscribers);b.mix(r,t.afters);}return[u,r];},applyConfig:function(s,r){if(s){b.mix(this,s,r,q);}},_on:function(w,u,t,r){if(!w){this.log("Invalid callback for CE: "+this.type);}var v=new b.Subscriber(w,u,t,r);if(this.fireOnce&&this.fired){if(this.async){setTimeout(b.bind(this._notify,this,v,this.firedWith),0);}else{this._notify(v,this.firedWith);}}if(r==m){this.afters[v.id]=v;this.afterCount++;}else{this.subscribers[v.id]=v;this.subCount++;}return new b.EventHandle(this,v);},subscribe:function(t,s){var r=(arguments.length>2)?b.Array(arguments,2,true):null;return this._on(t,s,r,true);},on:function(t,s){var r=(arguments.length>2)?b.Array(arguments,2,true):null;if(this.host){this.host._monitor("attach",this.type,{args:arguments});}return this._on(t,s,r,true);},after:function(t,s){var r=(arguments.length>2)?b.Array(arguments,2,true):null;return this._on(t,s,r,m);},detach:function(w,u){if(w&&w.detach){return w.detach();}var t,v,x=0,r=b.merge(this.subscribers,this.afters);for(t in r){if(r.hasOwnProperty(t)){v=r[t];if(v&&(!w||w===v.fn)){this._delete(v);x++;}}}return x;},unsubscribe:function(){return this.detach.apply(this,arguments);},_notify:function(v,u,r){this.log(this.type+"->"+"sub: "+v.id);var t;t=v.notify(u,this);if(false===t||this.stopped>1){this.log(this.type+" cancelled by subscriber");return false;}return true;},log:function(s,r){if(!this.silent){}},fire:function(){if(this.fireOnce&&this.fired){this.log("fireOnce event: "+this.type+" already fired");return true;}else{var r=b.Array(arguments,0,true);this.fired=true;this.firedWith=r;if(this.emitFacade){return this.fireComplex(r);}else{return this.fireSimple(r);}}},fireSimple:function(r){this.stopped=0;this.prevented=0;if(this.hasSubs()){var s=this.getSubs();this._procSubs(s[0],r);this._procSubs(s[1],r);}this._broadcast(r);return this.stopped?false:true;},fireComplex:function(r){r[0]=r[0]||{};return this.fireSimple(r);},_procSubs:function(v,t,r){var w,u;for(u in v){if(v.hasOwnProperty(u)){w=v[u];if(w&&w.fn){if(false===this._notify(w,t,r)){this.stopped=2;}if(this.stopped==2){return false;}}}}return true;},_broadcast:function(s){if(!this.stopped&&this.broadcast){var r=b.Array(s);r.unshift(this.type);if(this.host!==b){b.fire.apply(b,r);}if(this.broadcast==2){b.Global.fire.apply(b.Global,r);}}},unsubscribeAll:function(){return this.detachAll.apply(this,arguments);},detachAll:function(){return this.detach();},_delete:function(r){if(r){if(this.subscribers[r.id]){delete this.subscribers[r.id];this.subCount--;}if(this.afters[r.id]){delete this.afters[r.id];this.afterCount--;}}if(this.host){this.host._monitor("detach",this.type,{ce:this,sub:r});}if(r){r.deleted=true;}}};b.Subscriber=function(t,s,r){this.fn=t;this.context=s;this.id=b.stamp(this);this.args=r;};b.Subscriber.prototype={constructor:b.Subscriber,_notify:function(v,t,u){if(this.deleted&&!this.postponed){if(this.postponed){delete this.fn;delete this.context;}else{delete this.postponed;return null;}}var r=this.args,s;switch(u.signature){case 0:s=this.fn.call(v,u.type,t,v);break;case 1:s=this.fn.call(v,t[0]||null,v);break;default:if(r||t){t=t||[];r=(r)?t.concat(r):t;s=this.fn.apply(v,r);}else{s=this.fn.call(v);}}if(this.once){u._delete(this);}return s;},notify:function(s,u){var v=this.context,r=true;
if(!v){v=(u.contextFn)?u.contextFn():u.context;}if(b.config.throwFail){r=this._notify(v,s,u);}else{try{r=this._notify(v,s,u);}catch(t){b.error(this+" failed: "+t.message,t);}}return r;},contains:function(s,r){if(r){return((this.fn==s)&&this.context==r);}else{return(this.fn==s);}}};b.EventHandle=function(r,s){this.evt=r;this.sub=s;};b.EventHandle.prototype={batch:function(r,s){r.call(s||this,this);if(b.Lang.isArray(this.evt)){b.Array.each(this.evt,function(t){t.batch.call(s||t,r);});}},detach:function(){var r=this.evt,t=0,s;if(r){if(b.Lang.isArray(r)){for(s=0;s<r.length;s++){t+=r[s].detach();}}else{r._delete(this.sub);t=1;}}return t;},monitor:function(r){return this.evt.monitor.apply(this.evt,arguments);}};var j=b.Lang,h=":",e="|",l="~AFTER~",k=b.Array,c=b.cached(function(r){return r.replace(/(.*)(:)(.*)/,"*$2$3");}),o=b.cached(function(r,s){if(!s||!j.isString(r)||r.indexOf(h)>-1){return r;}return s+h+r;}),f=b.cached(function(u,w){var s=u,v,x,r;if(!j.isString(s)){return s;}r=s.indexOf(l);if(r>-1){x=true;s=s.substr(l.length);}r=s.indexOf(e);if(r>-1){v=s.substr(0,(r));s=s.substr(r+1);if(s=="*"){s=null;}}return[v,(w)?o(s,w):s,x,s];}),d=function(r){var s=(j.isObject(r))?r:{};this._yuievt=this._yuievt||{id:b.guid(),events:{},targets:{},config:s,chain:("chain" in s)?s.chain:b.config.chain,bubbling:false,defaults:{context:s.context||this,host:this,emitFacade:s.emitFacade,fireOnce:s.fireOnce,queuable:s.queuable,monitored:s.monitored,broadcast:s.broadcast,defaultTargetOnly:s.defaultTargetOnly,bubbles:("bubbles" in s)?s.bubbles:true}};};d.prototype={constructor:d,once:function(){var r=this.on.apply(this,arguments);r.batch(function(s){if(s.sub){s.sub.once=true;}});return r;},onceAfter:function(){var r=this.after.apply(this,arguments);r.batch(function(s){if(s.sub){s.sub.once=true;}});return r;},parseType:function(r,s){return f(r,s||this._yuievt.config.prefix);},on:function(v,A,t){var D=f(v,this._yuievt.config.prefix),F,G,s,J,C,B,H,x=b.Env.evt.handles,u,r,y,I=b.Node,E,z,w;this._monitor("attach",D[1],{args:arguments,category:D[0],after:D[2]});if(j.isObject(v)){if(j.isFunction(v)){return b.Do.before.apply(b.Do,arguments);}F=A;G=t;s=k(arguments,0,true);J=[];if(j.isArray(v)){w=true;}u=v._after;delete v._after;b.each(v,function(M,L){if(j.isObject(M)){F=M.fn||((j.isFunction(M))?M:F);G=M.context||G;}var K=(u)?l:"";s[0]=K+((w)?M:L);s[1]=F;s[2]=G;J.push(this.on.apply(this,s));},this);return(this._yuievt.chain)?this:new b.EventHandle(J);}B=D[0];u=D[2];y=D[3];if(I&&b.instanceOf(this,I)&&(y in I.DOM_EVENTS)){s=k(arguments,0,true);s.splice(2,0,I.getDOMNode(this));return b.on.apply(b,s);}v=D[1];if(b.instanceOf(this,YUI)){r=b.Env.evt.plugins[v];s=k(arguments,0,true);s[0]=y;if(I){E=s[2];if(b.instanceOf(E,b.NodeList)){E=b.NodeList.getDOMNodes(E);}else{if(b.instanceOf(E,I)){E=I.getDOMNode(E);}}z=(y in I.DOM_EVENTS);if(z){s[2]=E;}}if(r){H=r.on.apply(b,s);}else{if((!v)||z){H=b.Event._attach(s);}}}if(!H){C=this._yuievt.events[v]||this.publish(v);H=C._on(A,t,(arguments.length>3)?k(arguments,3,true):null,(u)?"after":true);}if(B){x[B]=x[B]||{};x[B][v]=x[B][v]||[];x[B][v].push(H);}return(this._yuievt.chain)?this:H;},subscribe:function(){return this.on.apply(this,arguments);},detach:function(A,C,r){var G=this._yuievt.events,v,x=b.Node,E=x&&(b.instanceOf(this,x));if(!A&&(this!==b)){for(v in G){if(G.hasOwnProperty(v)){G[v].detach(C,r);}}if(E){b.Event.purgeElement(x.getDOMNode(this));}return this;}var u=f(A,this._yuievt.config.prefix),z=j.isArray(u)?u[0]:null,H=(u)?u[3]:null,w,D=b.Env.evt.handles,F,B,y,t,s=function(M,K,L){var J=M[K],N,I;if(J){for(I=J.length-1;I>=0;--I){N=J[I].evt;if(N.host===L||N.el===L){J[I].detach();}}}};if(z){B=D[z];A=u[1];F=(E)?b.Node.getDOMNode(this):this;if(B){if(A){s(B,A,F);}else{for(v in B){if(B.hasOwnProperty(v)){s(B,v,F);}}}return this;}}else{if(j.isObject(A)&&A.detach){A.detach();return this;}else{if(E&&((!H)||(H in x.DOM_EVENTS))){y=k(arguments,0,true);y[2]=x.getDOMNode(this);b.detach.apply(b,y);return this;}}}w=b.Env.evt.plugins[H];if(b.instanceOf(this,YUI)){y=k(arguments,0,true);if(w&&w.detach){w.detach.apply(b,y);return this;}else{if(!A||(!w&&x&&(A in x.DOM_EVENTS))){y[0]=A;b.Event.detach.apply(b.Event,y);return this;}}}t=G[u[1]];if(t){t.detach(C,r);}return this;},unsubscribe:function(){return this.detach.apply(this,arguments);},detachAll:function(r){return this.detach(r);},unsubscribeAll:function(){return this.detachAll.apply(this,arguments);},publish:function(t,u){var s,y,r,x,w=this._yuievt,v=w.config.prefix;if(j.isObject(t)){r={};b.each(t,function(A,z){r[z]=this.publish(z,A||u);},this);return r;}t=(v)?o(t,v):t;this._monitor("publish",t,{args:arguments});s=w.events;y=s[t];if(y){if(u){y.applyConfig(u,true);}}else{x=w.defaults;y=new b.CustomEvent(t,(u)?b.merge(x,u):x);s[t]=y;}return s[t];},_monitor:function(u,r,v){var s,t=this.getEvent(r);if((this._yuievt.config.monitored&&(!t||t.monitored))||(t&&t.monitored)){s=r+"_"+u;v.monitored=u;this.fire.call(this,s,v);}},fire:function(v){var z=j.isString(v),u=(z)?v:(v&&v.type),y,s,x=this._yuievt.config.prefix,w,r=(z)?k(arguments,1,true):arguments;u=(x)?o(u,x):u;this._monitor("fire",u,{args:r});y=this.getEvent(u,true);w=this.getSibling(u,y);if(w&&!y){y=this.publish(u);}if(!y){if(this._yuievt.hasTargets){return this.bubble({type:u},r,this);}s=true;}else{y.sibling=w;s=y.fire.apply(y,r);}return(this._yuievt.chain)?this:s;},getSibling:function(r,t){var s;if(r.indexOf(h)>-1){r=c(r);s=this.getEvent(r,true);if(s){s.applyConfig(t);s.bubbles=false;s.broadcast=0;}}return s;},getEvent:function(s,r){var u,t;if(!r){u=this._yuievt.config.prefix;s=(u)?o(s,u):s;}t=this._yuievt.events;return t[s]||null;},after:function(t,s){var r=k(arguments,0,true);switch(j.type(t)){case"function":return b.Do.after.apply(b.Do,arguments);case"array":case"object":r[0]._after=true;break;default:r[0]=l+t;}return this.on.apply(this,r);},before:function(){return this.on.apply(this,arguments);}};b.EventTarget=d;b.mix(b,d.prototype);d.call(b,{bubbles:false});YUI.Env.globalEvents=YUI.Env.globalEvents||new d();
b.Global=YUI.Env.globalEvents;},"3.5.0",{requires:["oop"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-custom-complex",function(f){var b,e,d={},a=f.CustomEvent.prototype,c=f.EventTarget.prototype;f.EventFacade=function(h,g){h=h||d;this._event=h;this.details=h.details;this.type=h.type;this._type=h.type;this.target=h.target;this.currentTarget=g;this.relatedTarget=h.relatedTarget;};f.extend(f.EventFacade,Object,{stopPropagation:function(){this._event.stopPropagation();this.stopped=1;},stopImmediatePropagation:function(){this._event.stopImmediatePropagation();this.stopped=2;},preventDefault:function(){this._event.preventDefault();this.prevented=1;},halt:function(g){this._event.halt(g);this.prevented=1;this.stopped=(g)?2:1;}});a.fireComplex=function(p){var r,l,g,n,i,o,u,j,h,t=this,s=t.host||t,m,k;if(t.stack){if(t.queuable&&t.type!=t.stack.next.type){t.log("queue "+t.type);t.stack.queue.push([t,p]);return true;}}r=t.stack||{id:t.id,next:t,silent:t.silent,stopped:0,prevented:0,bubbling:null,type:t.type,afterQueue:new f.Queue(),defaultTargetOnly:t.defaultTargetOnly,queue:[]};j=t.getSubs();t.stopped=(t.type!==r.type)?0:r.stopped;t.prevented=(t.type!==r.type)?0:r.prevented;t.target=t.target||s;u=new f.EventTarget({fireOnce:true,context:s});t.events=u;if(t.stoppedFn){u.on("stopped",t.stoppedFn);}t.currentTarget=s;t.details=p.slice();t.log("Firing "+t.type);t._facade=null;l=t._getFacade(p);if(f.Lang.isObject(p[0])){p[0]=l;}else{p.unshift(l);}if(j[0]){t._procSubs(j[0],p,l);}if(t.bubbles&&s.bubble&&!t.stopped){k=r.bubbling;r.bubbling=t.type;if(r.type!=t.type){r.stopped=0;r.prevented=0;}o=s.bubble(t,p,null,r);t.stopped=Math.max(t.stopped,r.stopped);t.prevented=Math.max(t.prevented,r.prevented);r.bubbling=k;}if(t.prevented){if(t.preventedFn){t.preventedFn.apply(s,p);}}else{if(t.defaultFn&&((!t.defaultTargetOnly&&!r.defaultTargetOnly)||s===l.target)){t.defaultFn.apply(s,p);}}t._broadcast(p);if(j[1]&&!t.prevented&&t.stopped<2){if(r.id===t.id||t.type!=s._yuievt.bubbling){t._procSubs(j[1],p,l);while((m=r.afterQueue.last())){m();}}else{h=j[1];if(r.execDefaultCnt){h=f.merge(h);f.each(h,function(q){q.postponed=true;});}r.afterQueue.add(function(){t._procSubs(h,p,l);});}}t.target=null;if(r.id===t.id){n=r.queue;while(n.length){g=n.pop();i=g[0];r.next=i;i.fire.apply(i,g[1]);}t.stack=null;}o=!(t.stopped);if(t.type!=s._yuievt.bubbling){r.stopped=0;r.prevented=0;t.stopped=0;t.prevented=0;}return o;};a._getFacade=function(){var g=this._facade,j,i,h=this.details;if(!g){g=new f.EventFacade(this,this.currentTarget);}j=h&&h[0];if(f.Lang.isObject(j,true)){i={};f.mix(i,g,true,e);f.mix(g,j,true);f.mix(g,i,true,e);g.type=j.type||g.type;}g.details=this.details;g.target=this.originalTarget||this.target;g.currentTarget=this.currentTarget;g.stopped=0;g.prevented=0;this._facade=g;return this._facade;};a.stopPropagation=function(){this.stopped=1;if(this.stack){this.stack.stopped=1;}this.events.fire("stopped",this);};a.stopImmediatePropagation=function(){this.stopped=2;if(this.stack){this.stack.stopped=2;}this.events.fire("stopped",this);};a.preventDefault=function(){if(this.preventable){this.prevented=1;if(this.stack){this.stack.prevented=1;}}};a.halt=function(g){if(g){this.stopImmediatePropagation();}else{this.stopPropagation();}this.preventDefault();};c.addTarget=function(g){this._yuievt.targets[f.stamp(g)]=g;this._yuievt.hasTargets=true;};c.getTargets=function(){return f.Object.values(this._yuievt.targets);};c.removeTarget=function(g){delete this._yuievt.targets[f.stamp(g)];};c.bubble=function(u,q,o,s){var m=this._yuievt.targets,p=true,v,r=u&&u.type,h,l,n,j,g=o||(u&&u.target)||this,k;if(!u||((!u.stopped)&&m)){for(l in m){if(m.hasOwnProperty(l)){v=m[l];h=v.getEvent(r,true);j=v.getSibling(r,h);if(j&&!h){h=v.publish(r);}k=v._yuievt.bubbling;v._yuievt.bubbling=r;if(!h){if(v._yuievt.hasTargets){v.bubble(u,q,g,s);}}else{h.sibling=j;h.target=g;h.originalTarget=g;h.currentTarget=v;n=h.broadcast;h.broadcast=false;h.emitFacade=true;h.stack=s;p=p&&h.fire.apply(h,q||u.details||[]);h.broadcast=n;h.originalTarget=null;if(h.stopped){break;}}v._yuievt.bubbling=k;}}}return p;};b=new f.EventFacade();e=f.Object.keys(b);},"3.5.0",{requires:["event-custom-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("attribute-events",function(e){var f=e.EventTarget,d="Change",a="broadcast",c="published";function b(){this._ATTR_E_FACADE={};f.call(this,{emitFacade:true});}b._ATTR_CFG=[a];b.prototype={set:function(g,i,h){return this._setAttr(g,i,h);},_set:function(g,i,h){return this._setAttr(g,i,h,true);},setAttrs:function(g,h){return this._setAttrs(g,h);},_fireAttrChange:function(o,n,k,j,g){var q=this,m=o+d,i=q._state,p,l,h;if(!i.get(o,c)){h={queuable:false,defaultTargetOnly:true,defaultFn:q._defAttrChangeFn,silent:true};l=i.get(o,a);if(l!==undefined){h.broadcast=l;}q.publish(m,h);i.add(o,c,true);}p=(g)?e.merge(g):q._ATTR_E_FACADE;p.attrName=o;p.subAttrName=n;p.prevVal=k;p.newVal=j;q.fire(m,p);},_defAttrChangeFn:function(g){if(!this._setAttrVal(g.attrName,g.subAttrName,g.prevVal,g.newVal)){g.stopImmediatePropagation();}else{g.newVal=this.get(g.attrName);}}};e.mix(b,f,false,null,1);e.AttributeEvents=b;},"3.5.0",{requires:["event-custom"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("attribute-extras",function(f){var a="broadcast",d="published",e="initValue",c={readOnly:1,writeOnce:1,getter:1,broadcast:1};function b(){}b.prototype={modifyAttr:function(h,g){var i=this,k,j;if(i.attrAdded(h)){if(i._isLazyAttr(h)){i._addLazyAttr(h);}j=i._state;for(k in g){if(c[k]&&g.hasOwnProperty(k)){j.add(h,k,g[k]);if(k===a){j.remove(h,d);}}}}},removeAttr:function(g){this._state.removeAll(g);},reset:function(g){var h=this;if(g){if(h._isLazyAttr(g)){h._addLazyAttr(g);}h.set(g,h._state.get(g,e));}else{f.each(h._state.data,function(i,j){h.reset(j);});}return h;},_getAttrCfg:function(g){var i,h=this._state;if(g){i=h.getAll(g)||{};}else{i={};f.each(h.data,function(j,k){i[k]=h.getAll(k);});}return i;}};f.AttributeExtras=b;},"3.5.0");/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("attribute-base",function(b){var a=function(){this._ATTR_E_FACADE=null;this._yuievt=null;b.AttributeCore.apply(this,arguments);b.AttributeEvents.apply(this,arguments);b.AttributeExtras.apply(this,arguments);};b.mix(a,b.AttributeCore,false,null,1);b.mix(a,b.AttributeExtras,false,null,1);b.mix(a,b.AttributeEvents,true,null,1);a.INVALID_VALUE=b.AttributeCore.INVALID_VALUE;a._ATTR_CFG=b.AttributeCore._ATTR_CFG.concat(b.AttributeEvents._ATTR_CFG);b.Attribute=a;},"3.5.0",{requires:["attribute-core","attribute-events","attribute-extras"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("attribute-complex",function(b){var a=b.Object,c=".";b.Attribute.Complex=function(){};b.Attribute.Complex.prototype={_normAttrVals:function(g){var i={},h={},j,d,f,e;if(g){for(e in g){if(g.hasOwnProperty(e)){if(e.indexOf(c)!==-1){j=e.split(c);d=j.shift();f=h[d]=h[d]||[];f[f.length]={path:j,value:g[e]};}else{i[e]=g[e];}}}return{simple:i,complex:h};}else{return null;}},_getAttrInitVal:function(m,j,p){var e=j.value,o=j.valueFn,d,f,h,g,q,n,k;if(o){if(!o.call){o=this[o];}if(o){e=o.call(this,m);}}if(!j.readOnly&&p){d=p.simple;if(d&&d.hasOwnProperty(m)){e=d[m];}f=p.complex;if(f&&f.hasOwnProperty(m)){k=f[m];for(h=0,g=k.length;h<g;++h){q=k[h].path;n=k[h].value;a.setValue(e,q,n);}}}return e;}};b.mix(b.Attribute,b.Attribute.Complex,true,null,1);b.AttributeComplex=b.Attribute.Complex;},"3.5.0",{requires:["attribute-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("base-base",function(b){var g=b.Lang,e="destroy",i="init",h="bubbleTargets",c="_bubbleTargets",j=b.BaseCore,f=b.AttributeCore,a=b.Attribute;function d(){j.apply(this,arguments);}d._ATTR_CFG=a._ATTR_CFG.concat("cloneDefaultValue");d._ATTR_CFG_HASH=b.Array.hash(d._ATTR_CFG);d._NON_ATTRS_CFG=j._NON_ATTRS_CFG.concat(["on","after","bubbleTargets"]);d.NAME="base";d.ATTRS=f.prototype._protectAttrs(j.ATTRS);d.prototype={_initBase:function(k){this._eventPrefix=this.constructor.EVENT_PREFIX||this.constructor.NAME;b.BaseCore.prototype._initBase.call(this,k);},_initAttribute:function(k){a.call(this);this._yuievt.config.prefix=this._eventPrefix;},_attrCfgHash:function(){return d._ATTR_CFG_HASH;},init:function(k){this.publish(i,{queuable:false,fireOnce:true,defaultTargetOnly:true,defaultFn:this._defInitFn});this._preInitEventCfg(k);this.fire(i,{cfg:k});return this;},_preInitEventCfg:function(m){if(m){if(m.on){this.on(m.on);}if(m.after){this.after(m.after);}}var n,k,p,o=(m&&h in m);if(o||c in this){p=o?(m&&m.bubbleTargets):this._bubbleTargets;if(g.isArray(p)){for(n=0,k=p.length;n<k;n++){this.addTarget(p[n]);}}else{if(p){this.addTarget(p);}}}},destroy:function(){this.publish(e,{queuable:false,fireOnce:true,defaultTargetOnly:true,defaultFn:this._defDestroyFn});this.fire(e);this.detachAll();return this;},_defInitFn:function(k){this._baseInit(k.cfg);},_defDestroyFn:function(k){this._baseDestroy(k.cfg);}};b.mix(d,a,false,null,1);b.mix(d,j,false,null,1);d.prototype.constructor=d;b.Base=d;},"3.5.0",{requires:["base-core","attribute-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("pluginhost-base",function(c){var a=c.Lang;function b(){this._plugins={};}b.prototype={plug:function(g,d){var e,h,f;if(a.isArray(g)){for(e=0,h=g.length;e<h;e++){this.plug(g[e]);}}else{if(g&&!a.isFunction(g)){d=g.cfg;g=g.fn;}if(g&&g.NS){f=g.NS;d=d||{};d.host=this;if(this.hasPlugin(f)){this[f].setAttrs(d);}else{this[f]=new g(d);this._plugins[f]=g;}}}return this;},unplug:function(f){var e=f,d=this._plugins;if(f){if(a.isFunction(f)){e=f.NS;if(e&&(!d[e]||d[e]!==f)){e=null;}}if(e){if(this[e]){this[e].destroy();delete this[e];}if(d[e]){delete d[e];}}}else{for(e in this._plugins){if(this._plugins.hasOwnProperty(e)){this.unplug(e);}}}return this;},hasPlugin:function(d){return(this._plugins[d]&&this[d]);},_initPlugins:function(d){this._plugins=this._plugins||{};if(this._initConfigPlugins){this._initConfigPlugins(d);}},_destroyPlugins:function(){this.unplug();}};c.namespace("Plugin").Host=b;},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("pluginhost-config",function(c){var b=c.Plugin.Host,a=c.Lang;b.prototype._initConfigPlugins=function(e){var g=(this._getClasses)?this._getClasses():[this.constructor],d=[],h={},f,j,l,m,k;for(j=g.length-1;j>=0;j--){f=g[j];m=f._UNPLUG;if(m){c.mix(h,m,true);}l=f._PLUG;if(l){c.mix(d,l,true);}}for(k in d){if(d.hasOwnProperty(k)){if(!h[k]){this.plug(d[k]);}}}if(e&&e.plugins){this.plug(e.plugins);}};b.plug=function(e,j,g){var k,h,d,f;if(e!==c.Base){e._PLUG=e._PLUG||{};if(!a.isArray(j)){if(g){j={fn:j,cfg:g};}j=[j];}for(h=0,d=j.length;h<d;h++){k=j[h];f=k.NAME||k.fn.NAME;e._PLUG[f]=k;}}};b.unplug=function(e,h){var j,g,d,f;if(e!==c.Base){e._UNPLUG=e._UNPLUG||{};if(!a.isArray(h)){h=[h];}for(g=0,d=h.length;g<d;g++){j=h[g];f=j.NAME;if(!e._PLUG[f]){e._UNPLUG[f]=j;}else{delete e._PLUG[f];}}}};},"3.5.0",{requires:["pluginhost-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("base-pluginhost",function(c){var a=c.Base,b=c.Plugin.Host;c.mix(a,b,false,null,1);a.plug=b.plug;a.unplug=b.unplug;},"3.5.0",{requires:["base-base","pluginhost"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("base-build",function(g){var c=g.Base,a=g.Lang,b="initializer",e="destructor",f,d=function(j,i,h){if(h[j]){i[j]=(i[j]||[]).concat(h[j]);}};c._build=function(h,o,t,x,w,q){var y=c._build,j=y._ctor(o,q),m=y._cfg(o,q,t),v=y._mixCust,k=j._yuibuild.dynamic,p,n,u,z,s,r;for(p=0,n=t.length;p<n;p++){u=t[p];z=u.prototype;s=z[b];r=z[e];delete z[b];delete z[e];g.mix(j,u,true,null,1);v(j,u,m);if(s){z[b]=s;}if(r){z[e]=r;}j._yuibuild.exts.push(u);}if(x){g.mix(j.prototype,x,true);}if(w){g.mix(j,y._clean(w,m),true);v(j,w,m);}j.prototype.hasImpl=y._impl;if(k){j.NAME=h;j.prototype.constructor=j;}return j;};f=c._build;g.mix(f,{_mixCust:function(h,t,p){var o,j,q,k,m,n;if(p){o=p.aggregates;j=p.custom;q=p.statics;}if(q){g.mix(h,t,true,q);}if(o){for(n=0,m=o.length;n<m;n++){k=o[n];if(!h.hasOwnProperty(k)&&t.hasOwnProperty(k)){h[k]=a.isArray(t[k])?[]:{};}g.aggregate(h,t,true,[k]);}}if(j){for(n in j){if(j.hasOwnProperty(n)){j[n](n,h,t);}}}},_tmpl:function(h){function i(){i.superclass.constructor.apply(this,arguments);}g.extend(i,h);return i;},_impl:function(n){var q=this._getClasses(),p,k,h,o,r,m;for(p=0,k=q.length;p<k;p++){h=q[p];if(h._yuibuild){o=h._yuibuild.exts;r=o.length;for(m=0;m<r;m++){if(o[m]===n){return true;}}}}return false;},_ctor:function(h,i){var k=(i&&false===i.dynamic)?false:true,l=(k)?f._tmpl(h):h,j=l._yuibuild;if(!j){j=l._yuibuild={};}j.id=j.id||null;j.exts=j.exts||[];j.dynamic=k;return l;},_cfg:function(m,q,n){var k=[],p={},v=[],h,t=(q&&q.aggregates),u=(q&&q.custom),r=(q&&q.statics),s=m,o,j;while(s&&s.prototype){h=s._buildCfg;if(h){if(h.aggregates){k=k.concat(h.aggregates);}if(h.custom){g.mix(p,h.custom,true);}if(h.statics){v=v.concat(h.statics);}}s=s.superclass?s.superclass.constructor:null;}if(n){for(o=0,j=n.length;o<j;o++){s=n[o];h=s._buildCfg;if(h){if(h.aggregates){k=k.concat(h.aggregates);}if(h.custom){g.mix(p,h.custom,true);}if(h.statics){v=v.concat(h.statics);}}}}if(t){k=k.concat(t);}if(u){g.mix(p,q.cfgBuild,true);}if(r){v=v.concat(r);}return{aggregates:k,custom:p,statics:v};},_clean:function(q,j){var p,k,h,n=g.merge(q),o=j.aggregates,m=j.custom;for(p in m){if(n.hasOwnProperty(p)){delete n[p];}}for(k=0,h=o.length;k<h;k++){p=o[k];if(n.hasOwnProperty(p)){delete n[p];}}return n;}});c.build=function(j,h,k,i){return f(j,h,k,null,null,i);};c.create=function(h,k,j,i,l){return f(h,k,j,i,l);};c.mix=function(h,i){return f(null,h,i,null,null,{dynamic:false});};c._buildCfg={custom:{ATTRS:function(m,k,i){k.ATTRS=k.ATTRS||{};if(i.ATTRS){var j=i.ATTRS,l=k.ATTRS,h;for(h in j){if(j.hasOwnProperty(h)){l[h]=l[h]||{};g.mix(l[h],j[h],true);}}}},_NON_ATTRS_CFG:d},aggregates:["_PLUG","_UNPLUG"]};},"3.5.0",{requires:["base-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dom-core",function(e){var n="nodeType",c="ownerDocument",b="documentElement",a="defaultView",g="parentWindow",j="tagName",k="parentNode",i="previousSibling",l="nextSibling",h="contains",d="compareDocumentPosition",m=[],f={byId:function(p,o){return f.allById(p,o)[0]||null;},getId:function(o){var p;if(o.id&&!o.id.tagName&&!o.id.item){p=o.id;}else{if(o.attributes&&o.attributes.id){p=o.attributes.id.value;}}return p;},setId:function(o,p){if(o.setAttribute){o.setAttribute("id",p);}else{o.id=p;}},ancestor:function(p,q,s,r){var o=null;if(s){o=(!q||q(p))?p:null;}return o||f.elementByAxis(p,k,q,null,r);},ancestors:function(q,r,t,s){var p=q,o=[];while((p=f.ancestor(p,r,t,s))){t=false;if(p){o.unshift(p);if(s&&s(p)){return o;}}}return o;},elementByAxis:function(p,s,r,q,o){while(p&&(p=p[s])){if((q||p[j])&&(!r||r(p))){return p;}if(o&&o(p)){return null;}}return null;},contains:function(p,q){var o=false;if(!q||!p||!q[n]||!p[n]){o=false;}else{if(p[h]){if(e.UA.opera||q[n]===1){o=p[h](q);}else{o=f._bruteContains(p,q);}}else{if(p[d]){if(p===q||!!(p[d](q)&16)){o=true;}}}}return o;},inDoc:function(q,r){var p=false,o;if(q&&q.nodeType){(r)||(r=q[c]);o=r[b];if(o&&o.contains&&q.tagName){p=o.contains(q);}else{p=f.contains(o,q);}}return p;},allById:function(t,o){o=o||e.config.doc;var p=[],q=[],r,s;if(o.querySelectorAll){q=o.querySelectorAll('[id="'+t+'"]');}else{if(o.all){p=o.all(t);if(p){if(p.nodeName){if(p.id===t){q.push(p);p=m;}else{p=[p];}}if(p.length){for(r=0;s=p[r++];){if(s.id===t||(s.attributes&&s.attributes.id&&s.attributes.id.value===t)){q.push(s);}}}}}else{q=[f._getDoc(o).getElementById(t)];}}return q;},isWindow:function(o){return !!(o&&o.alert&&o.document);},_removeChildNodes:function(o){while(o.firstChild){o.removeChild(o.firstChild);}},siblings:function(r,q){var o=[],p=r;while((p=p[i])){if(p[j]&&(!q||q(p))){o.unshift(p);}}p=r;while((p=p[l])){if(p[j]&&(!q||q(p))){o.push(p);}}return o;},_bruteContains:function(o,p){while(p){if(o===p){return true;}p=p.parentNode;}return false;},_getRegExp:function(p,o){o=o||"";f._regexCache=f._regexCache||{};if(!f._regexCache[p+o]){f._regexCache[p+o]=new RegExp(p,o);}return f._regexCache[p+o];},_getDoc:function(o){var p=e.config.doc;if(o){p=(o[n]===9)?o:o[c]||o.document||e.config.doc;}return p;},_getWin:function(o){var p=f._getDoc(o);return p[a]||p[g]||e.config.win;},_batch:function(o,w,u,t,s,q){w=(typeof w==="string")?f[w]:w;var x,r=0,p,v;if(w&&o){while((p=o[r++])){x=x=w.call(f,p,u,t,s,q);if(typeof x!=="undefined"){(v)||(v=[]);v.push(x);}}}return(typeof v!=="undefined")?v:o;},generateID:function(o){var p=o.id;if(!p){p=e.stamp(o);o.id=p;}return p;}};e.DOM=f;},"3.5.0",{requires:["oop","features"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dom-base",function(b){var o=b.config.doc.documentElement,g=b.DOM,m="tagName",a="ownerDocument",c="",n=b.Features.add,k=b.Features.test;b.mix(g,{getText:(o.textContent!==undefined)?function(s){var r="";if(s){r=s.textContent;}return r||"";}:function(s){var r="";if(s){r=s.innerText||s.nodeValue;}return r||"";},setText:(o.textContent!==undefined)?function(r,s){if(r){r.textContent=s;}}:function(r,s){if("innerText" in r){r.innerText=s;}else{if("nodeValue" in r){r.nodeValue=s;}}},CUSTOM_ATTRIBUTES:(!o.hasAttribute)?{"for":"htmlFor","class":"className"}:{"htmlFor":"for","className":"class"},setAttribute:function(t,r,u,s){if(t&&r&&t.setAttribute){r=g.CUSTOM_ATTRIBUTES[r]||r;t.setAttribute(r,u,s);}},getAttribute:function(u,r,t){t=(t!==undefined)?t:2;var s="";if(u&&r&&u.getAttribute){r=g.CUSTOM_ATTRIBUTES[r]||r;s=u.getAttribute(r,t);if(s===null){s="";}}return s;},VALUE_SETTERS:{},VALUE_GETTERS:{},getValue:function(t){var s="",r;if(t&&t[m]){r=g.VALUE_GETTERS[t[m].toLowerCase()];if(r){s=r(t);}else{s=t.value;}}if(s===c){s=c;}return(typeof s==="string")?s:"";},setValue:function(r,s){var t;if(r&&r[m]){t=g.VALUE_SETTERS[r[m].toLowerCase()];if(t){t(r,s);}else{r.value=s;}}},creators:{}});n("value-set","select",{test:function(){var r=b.config.doc.createElement("select");r.innerHTML="<option>1</option><option>2</option>";r.value="2";return(r.value&&r.value==="2");}});if(!k("value-set","select")){g.VALUE_SETTERS.select=function(u,v){for(var s=0,r=u.getElementsByTagName("option"),t;t=r[s++];){if(g.getValue(t)===v){t.selected=true;break;}}};}b.mix(g.VALUE_GETTERS,{button:function(r){return(r.attributes&&r.attributes.value)?r.attributes.value.value:"";}});b.mix(g.VALUE_SETTERS,{button:function(s,t){var r=s.attributes.value;if(!r){r=s[a].createAttribute("value");s.setAttributeNode(r);}r.value=t;}});b.mix(g.VALUE_GETTERS,{option:function(s){var r=s.attributes;return(r.value&&r.value.specified)?s.value:s.text;},select:function(s){var t=s.value,r=s.options;if(r&&r.length){if(s.multiple){}else{if(s.selectedIndex>-1){t=g.getValue(r[s.selectedIndex]);}}}return t;}});var h,f,q;b.mix(b.DOM,{hasClass:function(t,s){var r=b.DOM._getRegExp("(?:^|\\s+)"+s+"(?:\\s+|$)");return r.test(t.className);},addClass:function(s,r){if(!b.DOM.hasClass(s,r)){s.className=b.Lang.trim([s.className,r].join(" "));}},removeClass:function(s,r){if(r&&f(s,r)){s.className=b.Lang.trim(s.className.replace(b.DOM._getRegExp("(?:^|\\s+)"+r+"(?:\\s+|$)")," "));if(f(s,r)){q(s,r);}}},replaceClass:function(s,r,t){q(s,r);h(s,t);},toggleClass:function(s,r,t){var u=(t!==undefined)?t:!(f(s,r));if(u){h(s,r);}else{q(s,r);}}});f=b.DOM.hasClass;q=b.DOM.removeClass;h=b.DOM.addClass;var e=/<([a-z]+)/i,g=b.DOM,n=b.Features.add,k=b.Features.test,j={},i=function(t,r){var u=b.config.doc.createElement("div"),s=true;u.innerHTML=t;if(!u.firstChild||u.firstChild.tagName!==r.toUpperCase()){s=false;}return s;},p=/(?:\/(?:thead|tfoot|tbody|caption|col|colgroup)>)+\s*<tbody/,d="<table>",l="</table>";b.mix(b.DOM,{_fragClones:{},_create:function(s,t,r){r=r||"div";var u=g._fragClones[r];if(u){u=u.cloneNode(false);}else{u=g._fragClones[r]=t.createElement(r);}u.innerHTML=s;return u;},_children:function(v,r){var t=0,s=v.children,w,u,x;if(s&&s.tags){if(r){s=v.children.tags(r);}else{u=s.tags("!").length;}}if(!s||(!s.tags&&r)||u){w=s||v.childNodes;s=[];while((x=w[t++])){if(x.nodeType===1){if(!r||r===x.tagName){s.push(x);}}}}return s||[];},create:function(v,y){if(typeof v==="string"){v=b.Lang.trim(v);}y=y||b.config.doc;var u=e.exec(v),w=g._create,s=j,x=null,t,z,r;if(v!=undefined){if(u&&u[1]){t=s[u[1].toLowerCase()];if(typeof t==="function"){w=t;}else{z=t;}}r=w(v,y,z).childNodes;if(r.length===1){x=r[0].parentNode.removeChild(r[0]);}else{if(r[0]&&r[0].className==="yui3-big-dummy"){if(r.length===2){x=r[0].nextSibling;}else{r[0].parentNode.removeChild(r[0]);x=g._nl2frag(r,y);}}else{x=g._nl2frag(r,y);}}}return x;},_nl2frag:function(s,v){var t=null,u,r;if(s&&(s.push||s.item)&&s[0]){v=v||s[0].ownerDocument;t=v.createDocumentFragment();if(s.item){s=b.Array(s,0,true);}for(u=0,r=s.length;u<r;u++){t.appendChild(s[u]);}}return t;},addHTML:function(y,x,t){var r=y.parentNode,v=0,w,s=x,u;if(x!=undefined){if(x.nodeType){u=x;}else{if(typeof x=="string"||typeof x=="number"){s=u=g.create(x);}else{if(x[0]&&x[0].nodeType){u=b.config.doc.createDocumentFragment();while((w=x[v++])){u.appendChild(w);}}}}}if(t){if(u&&t.parentNode){t.parentNode.insertBefore(u,t);}else{switch(t){case"replace":while(y.firstChild){y.removeChild(y.firstChild);}if(u){y.appendChild(u);}break;case"before":if(u){r.insertBefore(u,y);}break;case"after":if(u){if(y.nextSibling){r.insertBefore(u,y.nextSibling);}else{r.appendChild(u);}}break;default:if(u){y.appendChild(u);}}}}else{if(u){y.appendChild(u);}}return s;},wrap:function(u,s){var t=(s&&s.nodeType)?s:b.DOM.create(s),r=t.getElementsByTagName("*");if(r.length){t=r[r.length-1];}if(u.parentNode){u.parentNode.replaceChild(t,u);}t.appendChild(u);},unwrap:function(u){var s=u.parentNode,t=s.lastChild,r=u,v;if(s){v=s.parentNode;if(v){u=s.firstChild;while(u!==t){r=u.nextSibling;v.insertBefore(u,s);u=r;}v.replaceChild(t,s);}else{s.removeChild(u);}}}});n("innerhtml","table",{test:function(){var r=b.config.doc.createElement("table");try{r.innerHTML="<tbody></tbody>";}catch(s){return false;}return(r.firstChild&&r.firstChild.nodeName==="TBODY");}});n("innerhtml-div","tr",{test:function(){return i("<tr></tr>","tr");}});n("innerhtml-div","script",{test:function(){return i("<script><\/script>","script");}});if(!k("innerhtml","table")){j.tbody=function(s,t){var u=g.create(d+s+l,t),r=b.DOM._children(u,"tbody")[0];if(u.children.length>1&&r&&!p.test(s)){r.parentNode.removeChild(r);}return u;};}if(!k("innerhtml-div","script")){j.script=function(r,s){var t=s.createElement("div");t.innerHTML="-"+r;t.removeChild(t.firstChild);return t;};j.link=j.style=j.script;}if(!k("innerhtml-div","tr")){b.mix(j,{option:function(r,s){return g.create('<select><option class="yui3-big-dummy" selected></option>'+r+"</select>",s);
},tr:function(r,s){return g.create("<tbody>"+r+"</tbody>",s);},td:function(r,s){return g.create("<tr>"+r+"</tr>",s);},col:function(r,s){return g.create("<colgroup>"+r+"</colgroup>",s);},tbody:"table"});b.mix(j,{legend:"fieldset",th:j.td,thead:j.tbody,tfoot:j.tbody,caption:j.tbody,colgroup:j.tbody,optgroup:j.option});}g.creators=j;b.mix(b.DOM,{setWidth:function(s,r){b.DOM._setSize(s,"width",r);},setHeight:function(s,r){b.DOM._setSize(s,"height",r);},_setSize:function(s,u,t){t=(t>0)?t:0;var r=0;s.style[u]=t+"px";r=(u==="height")?s.offsetHeight:s.offsetWidth;if(r>t){t=t-(r-t);if(t<0){t=0;}s.style[u]=t+"px";}}});},"3.5.0",{requires:["dom-core"]});YUI.add('supra.dom', function(Y) {
	//Invoke strict mode
	"use strict";
	
	//If already defined, then exit
	if (Y.DOM.removeFromDOM) return;
	
	/**
	 * Removes element from DOM to restore its position later
	 * 
	 * @param {Object} node
	 * @return Point information aboute node and its position
	 * @type {Object}
	 */
	Y.DOM.removeFromDOM = function (node) {
		var node = (node.nodeType ? new Y.Node(node) : node);
		var where = '';
		var ref = node.ancestor();
		var tmp = node.previous();
		
		if (tmp) {
			ref = tmp;
			where = 'after';
		} else {
			tmp = node.next();
			if (tmp) {
				where = 'before';
				ref = tmp;
			}
		}
		
		tmp = Y.Node.getDOMNode(node);
		tmp.parentNode.removeChild(tmp);
		
		return {
			'node': node,
			'where': where,
			'ref': ref
		}
	};
	
	Y.DOM.restoreInDOM = function (point) {
		point.ref.insert(point.node, point.where);
	};
	
	if (document.body.classList) {
		var addClass, removeClass, hasClass;
		var hasClassResults = window.hasClassResults = [];
		
		Y.DOM.hasClass = function (node, className) {
			if (node && node.classList && className && className.indexOf) {
				if (className.indexOf(' ') !== -1) {
					className = className.split(' ');
					for (var i=0, ii=className.length; i<ii; i++) {
						if (!node.classList.contains(className[i])) return false;
					}
					return true;
				} else {
					return node.classList.contains(className);
				}
			}
			return true;
		};
		Y.DOM.addClass = function (node, className) {
			if (node && node.classList && className && className.indexOf) {
				if (className.indexOf(' ') !== -1) {
					className = className.split(' ');
					for (var i=0, ii=className.length; i<ii; i++) {
						if (className[i]) node.classList.add(className[i]);
					}
				} else {
					node.classList.add(className);
				}
			}
		};
		Y.DOM.removeClass = function (node, className) {
			if (node && node.classList && className && className.indexOf) {
				if (className.indexOf(' ') !== -1) {
					className = className.split(' ');
					for (var i=0, ii=className.length; i<ii; i++) {
						if (className[i]) node.classList.remove(className[i]);
					}
				} else {
					node.classList.remove(className);
				}
			}
		};
		Y.DOM.replaceClass = function (node, oldC, newC) {
			Y.DOM.removeClass(node, oldC);
			Y.DOM.addClass(node, newC);
		};
		Y.DOM.toggleClass = function (node, className, force) {
			var add = (force !== undefined) ? force :
	                !(hasClass(node, className));
	
	        if (add) {
	            addClass(node, className);
	        } else {
	            removeClass(node, className);
	        }
		};
		
		hasClass = Y.DOM.hasClass;
		addClass = Y.DOM.addClass;
		removeClass = Y.DOM.removeClass;
	}
	
}, YUI.version ,{requires:['dom-core']});

YUI.Env.mods['dom-base'].details.requires.push('supra.dom');
/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("selector-native",function(a){(function(e){e.namespace("Selector");var c="compareDocumentPosition",d="ownerDocument";var b={_types:{esc:{token:"\uE000",re:/\\[:\[\]\(\)#\.\'\>+~"]/gi},attr:{token:"\uE001",re:/(\[[^\]]*\])/g},pseudo:{token:"\uE002",re:/(\([^\)]*\))/g}},useNative:true,_escapeId:function(f){if(f){f=f.replace(/([:\[\]\(\)#\.'<>+~"])/g,"\\$1");}return f;},_compare:("sourceIndex" in e.config.doc.documentElement)?function(i,h){var g=i.sourceIndex,f=h.sourceIndex;if(g===f){return 0;}else{if(g>f){return 1;}}return -1;}:(e.config.doc.documentElement[c]?function(g,f){if(g[c](f)&4){return -1;}else{return 1;}}:function(j,i){var h,f,g;if(j&&i){h=j[d].createRange();h.setStart(j,0);f=i[d].createRange();f.setStart(i,0);g=h.compareBoundaryPoints(1,f);}return g;}),_sort:function(f){if(f){f=e.Array(f,0,true);if(f.sort){f.sort(b._compare);}}return f;},_deDupe:function(f){var g=[],h,j;for(h=0;(j=f[h++]);){if(!j._found){g[g.length]=j;j._found=true;}}for(h=0;(j=g[h++]);){j._found=null;j.removeAttribute("_found");}return g;},query:function(g,o,p,f){o=o||e.config.doc;var l=[],h=(e.Selector.useNative&&e.config.doc.querySelector&&!f),k=[[g,o]],m,q,j,n=(h)?e.Selector._nativeQuery:e.Selector._bruteQuery;if(g&&n){if(!f&&(!h||o.tagName)){k=b._splitQueries(g,o);}for(j=0;(m=k[j++]);){q=n(m[0],m[1],p);if(!p){q=e.Array(q,0,true);}if(q){l=l.concat(q);}}if(k.length>1){l=b._sort(b._deDupe(l));}}return(p)?(l[0]||null):l;},_replaceSelector:function(f){var g=e.Selector._parse("esc",f),h,i;f=e.Selector._replace("esc",f);i=e.Selector._parse("pseudo",f);f=b._replace("pseudo",f);h=e.Selector._parse("attr",f);f=e.Selector._replace("attr",f);return{esc:g,attrs:h,pseudos:i,selector:f};},_restoreSelector:function(g){var f=g.selector;f=e.Selector._restore("attr",f,g.attrs);f=e.Selector._restore("pseudo",f,g.pseudos);f=e.Selector._restore("esc",f,g.esc);return f;},_replaceCommas:function(f){var g=e.Selector._replaceSelector(f),f=g.selector;if(f){f=f.replace(",","\uE007","g");g.selector=f;f=e.Selector._restoreSelector(g);}return f;},_splitQueries:function(h,l){if(h.indexOf(",")>-1){h=e.Selector._replaceCommas(h);}var g=h.split("\uE007"),j=[],m="",n,k,f;if(l){if(l.nodeType===1){n=e.Selector._escapeId(e.DOM.getId(l));if(!n){n=e.guid();e.DOM.setId(l,n);}m='[id="'+n+'"] ';}for(k=0,f=g.length;k<f;++k){h=m+g[k];j.push([h,l]);}}return j;},_nativeQuery:function(f,g,h){if(e.UA.webkit&&f.indexOf(":checked")>-1&&(e.Selector.pseudos&&e.Selector.pseudos.checked)){return e.Selector.query(f,g,h,true);}try{return g["querySelector"+(h?"":"All")](f);}catch(i){return e.Selector.query(f,g,h,true);}},filter:function(g,f){var h=[],j,k;if(g&&f){for(j=0;(k=g[j++]);){if(e.Selector.test(k,f)){h[h.length]=k;}}}else{}return h;},test:function(k,l,q){var o=false,g=false,h,r,u,p,t,f,n,m,s;if(k&&k.tagName){if(typeof l=="function"){o=l.call(k,k);}else{h=l.split(",");if(!q&&!e.DOM.inDoc(k)){r=k.parentNode;if(r){q=r;}else{t=k[d].createDocumentFragment();t.appendChild(k);q=t;g=true;}}q=q||k[d];f=e.Selector._escapeId(e.DOM.getId(k));if(!f){f=e.guid();e.DOM.setId(k,f);}for(n=0;(s=h[n++]);){s+='[id="'+f+'"]';p=e.Selector.query(s,q);for(m=0;u=p[m++];){if(u===k){o=true;break;}}if(o){break;}}if(g){t.removeChild(k);}}}return o;},ancestor:function(g,f,h){return e.DOM.ancestor(g,function(i){return e.Selector.test(i,f);},h);},_parse:function(g,f){return f.match(e.Selector._types[g].re);},_replace:function(g,f){var h=e.Selector._types[g];return f.replace(h.re,h.token);},_restore:function(j,g,h){if(h){var l=e.Selector._types[j].token,k,f;for(k=0,f=h.length;k<f;++k){g=g.replace(l,h[k]);}}return g;}};e.mix(e.Selector,b,true);})(a);},"3.5.0",{requires:["dom-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("selector",function(a){},"3.5.0",{requires:["selector-native"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-core",function(c){var j=".",e="nodeName",n="nodeType",b="ownerDocument",m="tagName",d="_yuid",i={},p=Array.prototype.slice,f=c.DOM,k=function(r){if(!this.getDOMNode){return new k(r);}if(typeof r=="string"){r=k._fromString(r);if(!r){return null;}}var q=(r.nodeType!==9)?r.uniqueID:r[d];if(q&&k._instances[q]&&k._instances[q]._node!==r){r[d]=null;}q=q||c.stamp(r);if(!q){q=c.guid();}this[d]=q;this._node=r;this._stateProxy=r;if(this._initPlugins){this._initPlugins();}},o=function(r){var q=null;if(r){q=(typeof r=="string")?function(s){return c.Selector.test(s,r);}:function(s){return r(c.one(s));};}return q;};k.ATTRS={};k.DOM_EVENTS={};k._fromString=function(q){if(q){if(q.indexOf("doc")===0){q=c.config.doc;}else{if(q.indexOf("win")===0){q=c.config.win;}else{q=c.Selector.query(q,null,true);}}}return q||null;};k.NAME="node";k.re_aria=/^(?:role$|aria-)/;k.SHOW_TRANSITION="fadeIn";k.HIDE_TRANSITION="fadeOut";k._instances={};k.getDOMNode=function(q){if(q){return(q.nodeType)?q:q._node||null;}return null;};k.scrubVal=function(r,q){if(r){if(typeof r=="object"||typeof r=="function"){if(n in r||f.isWindow(r)){r=c.one(r);}else{if((r.item&&!r._nodes)||(r[0]&&r[0][n])){r=c.all(r);}}}}else{if(typeof r==="undefined"){r=q;}else{if(r===null){r=null;}}}return r;};k.addMethod=function(q,s,r){if(q&&s&&typeof s=="function"){k.prototype[q]=function(){var u=p.call(arguments),v=this,t;if(u[0]&&u[0]._node){u[0]=u[0]._node;}if(u[1]&&u[1]._node){u[1]=u[1]._node;}u.unshift(v._node);t=s.apply(v,u);if(t){t=k.scrubVal(t,v);}(typeof t!="undefined")||(t=v);return t;};}else{}};k.importMethod=function(s,q,r){if(typeof q=="string"){r=r||q;k.addMethod(r,s[q],s);}else{c.Array.each(q,function(t){k.importMethod(s,t);});}};k.one=function(t){var q=null,s,r;if(t){if(typeof t=="string"){t=k._fromString(t);if(!t){return null;}}else{if(t.getDOMNode){return t;}}if(t.nodeType||c.DOM.isWindow(t)){r=(t.uniqueID&&t.nodeType!==9)?t.uniqueID:t._yuid;q=k._instances[r];s=q?q._node:null;if(!q||(s&&t!==s)){q=new k(t);if(t.nodeType!=11){k._instances[q[d]]=q;}}}}return q;};k.DEFAULT_SETTER=function(q,s){var r=this._stateProxy,t;if(q.indexOf(j)>-1){t=q;q=q.split(j);c.Object.setValue(r,q,s);}else{if(typeof r[q]!="undefined"){r[q]=s;}}return s;};k.DEFAULT_GETTER=function(q){var r=this._stateProxy,s;if(q.indexOf&&q.indexOf(j)>-1){s=c.Object.getValue(r,q.split(j));}else{if(typeof r[q]!="undefined"){s=r[q];}}return s;};c.mix(k.prototype,{DATA_PREFIX:"data-",toString:function(){var t=this[d]+": not bound to a node",s=this._node,q,u,r;if(s){q=s.attributes;u=(q&&q.id)?s.getAttribute("id"):null;r=(q&&q.className)?s.getAttribute("className"):null;t=s[e];if(u){t+="#"+u;}if(r){t+="."+r.replace(" ",".");}t+=" "+this[d];}return t;},get:function(q){var r;if(this._getAttr){r=this._getAttr(q);}else{r=this._get(q);}if(r){r=k.scrubVal(r,this);}else{if(r===null){r=null;}}return r;},_get:function(q){var r=k.ATTRS[q],s;if(r&&r.getter){s=r.getter.call(this);}else{if(k.re_aria.test(q)){s=this._node.getAttribute(q,2);}else{s=k.DEFAULT_GETTER.apply(this,arguments);}}return s;},set:function(q,s){var r=k.ATTRS[q];if(this._setAttr){this._setAttr.apply(this,arguments);}else{if(r&&r.setter){r.setter.call(this,s,q);}else{if(k.re_aria.test(q)){this._node.setAttribute(q,s);}else{k.DEFAULT_SETTER.apply(this,arguments);}}}return this;},setAttrs:function(q){if(this._setAttrs){this._setAttrs(q);}else{c.Object.each(q,function(r,s){this.set(s,r);},this);}return this;},getAttrs:function(r){var q={};if(this._getAttrs){this._getAttrs(r);}else{c.Array.each(r,function(s,t){q[s]=this.get(s);},this);}return q;},compareTo:function(q){var r=this._node;if(q&&q._node){q=q._node;}return r===q;},inDoc:function(r){var q=this._node;r=(r)?r._node||r:q[b];if(r.documentElement){return f.contains(r.documentElement,q);}},getById:function(s){var r=this._node,q=f.byId(s,r[b]);if(q&&f.contains(r,q)){q=c.one(q);}else{q=null;}return q;},ancestor:function(q,s,r){if(arguments.length===2&&(typeof s=="string"||typeof s=="function")){r=s;}return c.one(f.ancestor(this._node,o(q),s,o(r)));},ancestors:function(q,s,r){if(arguments.length===2&&(typeof s=="string"||typeof s=="function")){r=s;}return c.all(f.ancestors(this._node,o(q),s,o(r)));},previous:function(r,q){return c.one(f.elementByAxis(this._node,"previousSibling",o(r),q));},next:function(r,q){return c.one(f.elementByAxis(this._node,"nextSibling",o(r),q));},siblings:function(q){return c.all(f.siblings(this._node,o(q)));},one:function(q){return c.one(c.Selector.query(q,this._node,true));},all:function(q){var r=c.all(c.Selector.query(q,this._node));r._query=q;r._queryRoot=this._node;return r;},test:function(q){return c.Selector.test(this._node,q);},remove:function(q){var r=this._node;if(r&&r.parentNode){r.parentNode.removeChild(r);}if(q){this.destroy();}return this;},replace:function(q){var r=this._node;if(typeof q=="string"){q=k.create(q);}r.parentNode.replaceChild(k.getDOMNode(q),r);return this;},replaceChild:function(r,q){if(typeof r=="string"){r=f.create(r);}return c.one(this._node.replaceChild(k.getDOMNode(r),k.getDOMNode(q)));},destroy:function(s){var r=c.config.doc.uniqueID?"uniqueID":"_yuid",q;this.purge();if(this.unplug){this.unplug();}this.clearData();if(s){c.NodeList.each(this.all("*"),function(t){q=k._instances[t[r]];if(q){q.destroy();}});}this._node=null;this._stateProxy=null;delete k._instances[this._yuid];},invoke:function(x,r,q,w,v,u){var t=this._node,s;if(r&&r._node){r=r._node;}if(q&&q._node){q=q._node;}s=t[x](r,q,w,v,u);return k.scrubVal(s,this);},swap:c.config.doc.documentElement.swapNode?function(q){this._node.swapNode(k.getDOMNode(q));}:function(q){q=k.getDOMNode(q);var s=this._node,r=q.parentNode,t=q.nextSibling;if(t===s){r.insertBefore(s,q);}else{if(q===s.nextSibling){r.insertBefore(q,s);}else{s.parentNode.replaceChild(q,s);f.addHTML(r,s,t);}}return this;},hasMethod:function(r){var q=this._node;return !!(q&&r in q&&typeof q[r]!="unknown"&&(typeof q[r]=="function"||String(q[r]).indexOf("function")===1));},isFragment:function(){return(this.get("nodeType")===11);
},empty:function(){this.get("childNodes").remove().destroy(true);return this;},getDOMNode:function(){return this._node;}},true);c.Node=k;c.one=k.one;var a=function(q){var r=[];if(q){if(typeof q==="string"){this._query=q;q=c.Selector.query(q);}else{if(q.nodeType||f.isWindow(q)){q=[q];}else{if(q._node){q=[q._node];}else{if(q[0]&&q[0]._node){c.Array.each(q,function(s){if(s._node){r.push(s._node);}});q=r;}else{q=c.Array(q,0,true);}}}}}this._nodes=q||[];};a.NAME="NodeList";a.getDOMNodes=function(q){return(q&&q._nodes)?q._nodes:q;};a.each=function(q,t,s){var r=q._nodes;if(r&&r.length){c.Array.each(r,t,s||q);}else{}};a.addMethod=function(q,s,r){if(q&&s){a.prototype[q]=function(){var u=[],t=arguments;c.Array.each(this._nodes,function(z){var y=(z.uniqueID&&z.nodeType!==9)?"uniqueID":"_yuid",w=c.Node._instances[z[y]],x,v;if(!w){w=a._getTempNode(z);}x=r||w;v=s.apply(x,t);if(v!==undefined&&v!==w){u[u.length]=v;}});return u.length?u:this;};}else{}};a.importMethod=function(s,q,r){if(typeof q==="string"){r=r||q;a.addMethod(q,s[q]);}else{c.Array.each(q,function(t){a.importMethod(s,t);});}};a._getTempNode=function(r){var q=a._tempNode;if(!q){q=c.Node.create("<div></div>");a._tempNode=q;}q._node=r;q._stateProxy=r;return q;};c.mix(a.prototype,{_invoke:function(t,s,q){var r=(q)?[]:this;this.each(function(u){var v=u[t].apply(u,s);if(q){r.push(v);}});return r;},item:function(q){return c.one((this._nodes||[])[q]);},each:function(s,r){var q=this;c.Array.each(this._nodes,function(u,t){u=c.one(u);return s.call(r||u,u,t,q);});return q;},batch:function(r,q){var s=this;c.Array.each(this._nodes,function(v,u){var t=c.Node._instances[v[d]];if(!t){t=a._getTempNode(v);}return r.call(q||t,t,u,s);});return s;},some:function(s,r){var q=this;return c.Array.some(this._nodes,function(u,t){u=c.one(u);r=r||u;return s.call(r,u,t,q);});},toFrag:function(){return c.one(c.DOM._nl2frag(this._nodes));},indexOf:function(q){return c.Array.indexOf(this._nodes,c.Node.getDOMNode(q));},filter:function(q){return c.all(c.Selector.filter(this._nodes,q));},modulus:function(t,s){s=s||0;var q=[];a.each(this,function(u,r){if(r%t===s){q.push(u);}});return c.all(q);},odd:function(){return this.modulus(2,1);},even:function(){return this.modulus(2);},destructor:function(){},refresh:function(){var t,r=this._nodes,s=this._query,q=this._queryRoot;if(s){if(!q){if(r&&r[0]&&r[0].ownerDocument){q=r[0].ownerDocument;}}this._nodes=c.Selector.query(s,q);}return this;},size:function(){return this._nodes.length;},isEmpty:function(){return this._nodes.length<1;},toString:function(){var t="",s=this[d]+": not bound to any nodes",q=this._nodes,r;if(q&&q[0]){r=q[0];t+=r[e];if(r.id){t+="#"+r.id;}if(r.className){t+="."+r.className.replace(" ",".");}if(q.length>1){t+="...["+q.length+" items]";}}return t||s;},getDOMNodes:function(){return this._nodes;}},true);a.importMethod(c.Node.prototype,["destroy","empty","remove","set"]);a.prototype.get=function(r){var u=[],t=this._nodes,s=false,v=a._getTempNode,q,w;if(t[0]){q=c.Node._instances[t[0]._yuid]||v(t[0]);w=q._get(r);if(w&&w.nodeType){s=true;}}c.Array.each(t,function(x){q=c.Node._instances[x._yuid];if(!q){q=v(x);}w=q._get(r);if(!s){w=c.Node.scrubVal(w,q);}u.push(w);});return(s)?c.all(u):u;};c.NodeList=a;c.all=function(q){return new a(q);};c.Node.all=c.all;var l=c.NodeList,h=Array.prototype,g={"concat":1,"pop":0,"push":0,"shift":0,"slice":1,"splice":1,"unshift":0};c.Object.each(g,function(r,q){l.prototype[q]=function(){var u=[],v=0,s,t;while(typeof(s=arguments[v++])!="undefined"){u.push(s._node||s._nodes||s);}t=h[q].apply(this._nodes,u);if(r){t=c.all(t);}else{t=c.Node.scrubVal(t);}return t;};});c.Array.each(["removeChild","hasChildNodes","cloneNode","hasAttribute","scrollIntoView","getElementsByTagName","focus","blur","submit","reset","select","createCaption"],function(q){c.Node.prototype[q]=function(u,s,r){var t=this.invoke(q,u,s,r);return t;};});c.Node.prototype.removeAttribute=function(q){var r=this._node;if(r){r.removeAttribute(q);}return this;};c.Node.importMethod(c.DOM,["contains","setAttribute","getAttribute","wrap","unwrap","generateID"]);c.NodeList.importMethod(c.Node.prototype,["getAttribute","setAttribute","removeAttribute","unwrap","wrap","generateID"]);},"3.5.0",{requires:["dom-core","selector"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-base",function(e){var d=["hasClass","addClass","removeClass","replaceClass","toggleClass"];e.Node.importMethod(e.DOM,d);e.NodeList.importMethod(e.Node.prototype,d);var c=e.Node,b=e.DOM;c.create=function(f,g){if(g&&g._node){g=g._node;}return e.one(b.create(f,g));};e.mix(c.prototype,{create:c.create,insert:function(g,f){this._insert(g,f);return this;},_insert:function(i,g){var h=this._node,f=null;if(typeof g=="number"){g=this._node.childNodes[g];}else{if(g&&g._node){g=g._node;}}if(i&&typeof i!="string"){i=i._node||i._nodes||i;}f=b.addHTML(h,i,g);return f;},prepend:function(f){return this.insert(f,0);},append:function(f){return this.insert(f,null);},appendChild:function(f){return c.scrubVal(this._insert(f));},insertBefore:function(g,f){return e.Node.scrubVal(this._insert(g,f));},appendTo:function(f){e.one(f).append(this);return this;},setContent:function(f){this._insert(f,"replace");return this;},getContent:function(f){return this.get("innerHTML");}});e.Node.prototype.setHTML=e.Node.prototype.setContent;e.Node.prototype.getHTML=e.Node.prototype.getContent;e.NodeList.importMethod(e.Node.prototype,["append","insert","appendChild","insertBefore","prepend","setContent","getContent","setHTML","getHTML"]);var c=e.Node,b=e.DOM;c.ATTRS={text:{getter:function(){return b.getText(this._node);},setter:function(f){b.setText(this._node,f);return f;}},"for":{getter:function(){return b.getAttribute(this._node,"for");},setter:function(f){b.setAttribute(this._node,"for",f);return f;}},"options":{getter:function(){return this._node.getElementsByTagName("option");}},"children":{getter:function(){var j=this._node,h=j.children,k,g,f;if(!h){k=j.childNodes;h=[];for(g=0,f=k.length;g<f;++g){if(k[g].tagName){h[h.length]=k[g];}}}return e.all(h);}},value:{getter:function(){return b.getValue(this._node);},setter:function(f){b.setValue(this._node,f);return f;}}};e.Node.importMethod(e.DOM,["setAttribute","getAttribute"]);var c=e.Node;var a=e.NodeList;c.DOM_EVENTS={abort:1,beforeunload:1,blur:1,change:1,click:1,close:1,command:1,contextmenu:1,dblclick:1,DOMMouseScroll:1,drag:1,dragstart:1,dragenter:1,dragover:1,dragleave:1,dragend:1,drop:1,error:1,focus:1,key:1,keydown:1,keypress:1,keyup:1,load:1,message:1,mousedown:1,mouseenter:1,mouseleave:1,mousemove:1,mousemultiwheel:1,mouseout:1,mouseover:1,mouseup:1,mousewheel:1,orientationchange:1,reset:1,resize:1,select:1,selectstart:1,submit:1,scroll:1,textInput:1,unload:1};e.mix(c.DOM_EVENTS,e.Env.evt.plugins);e.augment(c,e.EventTarget);e.mix(c.prototype,{purge:function(g,f){e.Event.purgeElement(this._node,g,f);return this;}});e.mix(e.NodeList.prototype,{_prepEvtArgs:function(i,h,g){var f=e.Array(arguments,0,true);if(f.length<2){f[2]=this._nodes;}else{f.splice(2,0,this._nodes);}f[3]=g||this;return f;},on:function(h,g,f){return e.on.apply(e,this._prepEvtArgs.apply(this,arguments));},once:function(h,g,f){return e.once.apply(e,this._prepEvtArgs.apply(this,arguments));},after:function(h,g,f){return e.after.apply(e,this._prepEvtArgs.apply(this,arguments));},onceAfter:function(h,g,f){return e.onceAfter.apply(e,this._prepEvtArgs.apply(this,arguments));}});a.importMethod(e.Node.prototype,["detach","detachAll"]);e.mix(e.Node.ATTRS,{offsetHeight:{setter:function(f){e.DOM.setHeight(this._node,f);return f;},getter:function(){return this._node.offsetHeight;}},offsetWidth:{setter:function(f){e.DOM.setWidth(this._node,f);return f;},getter:function(){return this._node.offsetWidth;}}});e.mix(e.Node.prototype,{sizeTo:function(f,g){var i;if(arguments.length<2){i=e.one(f);f=i.get("offsetWidth");g=i.get("offsetHeight");}this.setAttrs({offsetWidth:f,offsetHeight:g});}});var c=e.Node;e.mix(c.prototype,{show:function(f){f=arguments[arguments.length-1];this.toggleView(true,f);return this;},_show:function(){this.setStyle("display","");},_isHidden:function(){return e.DOM.getStyle(this._node,"display")==="none";},toggleView:function(f,g){this._toggleView.apply(this,arguments);return this;},_toggleView:function(f,g){g=arguments[arguments.length-1];if(typeof f!="boolean"){f=(this._isHidden())?1:0;}if(f){this._show();}else{this._hide();}if(typeof g=="function"){g.call(this);}return this;},hide:function(f){f=arguments[arguments.length-1];this.toggleView(false,f);return this;},_hide:function(){this.setStyle("display","none");}});e.NodeList.importMethod(e.Node.prototype,["show","hide","toggleView"]);if(!e.config.doc.documentElement.hasAttribute){e.Node.prototype.hasAttribute=function(f){if(f==="value"){if(this.get("value")!==""){return true;}}return !!(this._node.attributes[f]&&this._node.attributes[f].specified);};}e.Node.prototype.focus=function(){try{this._node.focus();}catch(f){}return this;};e.Node.ATTRS.type={setter:function(g){if(g==="hidden"){try{this._node.type="hidden";}catch(f){this.setStyle("display","none");this._inputType="hidden";}}else{try{this._node.type=g;}catch(f){}}return g;},getter:function(){return this._inputType||this._node.type;},_bypassProxy:true};if(e.config.doc.createElement("form").elements.nodeType){e.Node.ATTRS.elements={getter:function(){return this.all("input, textarea, button, select");}};}e.mix(e.Node.prototype,{_initData:function(){if(!("_data" in this)){this._data={};}},getData:function(g){this._initData();var h=this._data,f=h;if(arguments.length){if(g in h){f=h[g];}else{f=this._getDataAttribute(g);}}else{if(typeof h=="object"&&h!==null){f={};e.Object.each(h,function(i,j){f[j]=i;});f=this._getDataAttributes(f);}}return f;},_getDataAttributes:function(k){k=k||{};var l=0,j=this._node.attributes,f=j.length,m=this.DATA_PREFIX,h=m.length,g;while(l<f){g=j[l].name;if(g.indexOf(m)===0){g=g.substr(h);if(!(g in k)){k[g]=this._getDataAttribute(g);}}l+=1;}return k;},_getDataAttribute:function(g){var g=this.DATA_PREFIX+g,h=this._node,f=h.attributes,i=f&&f[g]&&f[g].value;return i;},setData:function(f,g){this._initData();if(arguments.length>1){this._data[f]=g;}else{this._data=f;}return this;},clearData:function(f){if("_data" in this){if(typeof f!="undefined"){delete this._data[f];
}else{delete this._data;}}return this;}});e.mix(e.NodeList.prototype,{getData:function(g){var f=(arguments.length)?[g]:[];return this._invoke("getData",f,true);},setData:function(g,h){var f=(arguments.length>1)?[g,h]:[g];return this._invoke("setData",f);},clearData:function(g){var f=(arguments.length)?[g]:[];return this._invoke("clearData",[g]);}});},"3.5.0",{requires:["dom-base","node-core","event-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
(function(){var a=YUI.Env;if(!a._ready){a._ready=function(){a.DOMReady=true;a.remove(YUI.config.doc,"DOMContentLoaded",a._ready);};a.add(YUI.config.doc,"DOMContentLoaded",a._ready);}})();YUI.add("event-base",function(e){e.publish("domready",{fireOnce:true,async:true});if(YUI.Env.DOMReady){e.fire("domready");}else{e.Do.before(function(){e.fire("domready");},YUI.Env,"_ready");}var b=e.UA,d={},a={63232:38,63233:40,63234:37,63235:39,63276:33,63277:34,25:9,63272:46,63273:36,63275:35},c=function(h){if(!h){return h;}try{if(h&&3==h.nodeType){h=h.parentNode;}}catch(g){return null;}return e.one(h);},f=function(g,h,i){this._event=g;this._currentTarget=h;this._wrapper=i||d;this.init();};e.extend(f,Object,{init:function(){var i=this._event,j=this._wrapper.overrides,g=i.pageX,l=i.pageY,k,h=this._currentTarget;this.altKey=i.altKey;this.ctrlKey=i.ctrlKey;this.metaKey=i.metaKey;this.shiftKey=i.shiftKey;this.type=(j&&j.type)||i.type;this.clientX=i.clientX;this.clientY=i.clientY;this.pageX=g;this.pageY=l;k=i.keyCode||i.charCode;if(b.webkit&&(k in a)){k=a[k];}this.keyCode=k;this.charCode=k;this.which=i.which||i.charCode||k;this.button=this.which;this.target=c(i.target);this.currentTarget=c(h);this.relatedTarget=c(i.relatedTarget);if(i.type=="mousewheel"||i.type=="DOMMouseScroll"){this.wheelDelta=(i.detail)?(i.detail*-1):Math.round(i.wheelDelta/80)||((i.wheelDelta<0)?-1:1);}if(this._touch){this._touch(i,h,this._wrapper);}},stopPropagation:function(){this._event.stopPropagation();this._wrapper.stopped=1;this.stopped=1;},stopImmediatePropagation:function(){var g=this._event;if(g.stopImmediatePropagation){g.stopImmediatePropagation();}else{this.stopPropagation();}this._wrapper.stopped=2;this.stopped=2;},preventDefault:function(g){var h=this._event;h.preventDefault();h.returnValue=g||false;this._wrapper.prevented=1;this.prevented=1;},halt:function(g){if(g){this.stopImmediatePropagation();}else{this.stopPropagation();}this.preventDefault();}});f.resolve=c;e.DOM2EventFacade=f;e.DOMEventFacade=f;(function(){e.Env.evt.dom_wrappers={};e.Env.evt.dom_map={};var q=e.Env.evt,i=e.config,n=i.win,s=YUI.Env.add,l=YUI.Env.remove,p=function(){YUI.Env.windowLoaded=true;e.Event._load();l(n,"load",p);},g=function(){e.Event._unload();},j="domready",m="~yui|2|compat~",o=function(u){try{return(u&&typeof u!=="string"&&e.Lang.isNumber(u.length)&&!u.tagName&&!u.alert);}catch(t){return false;}},h=e.CustomEvent.prototype._delete,k=function(u){var t=h.apply(this,arguments);if(!this.subCount&&!this.afterCount){e.Event._clean(this);}return t;},r=function(){var v=false,w=0,u=[],x=q.dom_wrappers,t=null,y=q.dom_map;return{POLL_RETRYS:1000,POLL_INTERVAL:40,lastError:null,_interval:null,_dri:null,DOMReady:false,startInterval:function(){if(!r._interval){r._interval=setInterval(r._poll,r.POLL_INTERVAL);}},onAvailable:function(z,D,H,A,E,G){var F=e.Array(z),B,C;for(B=0;B<F.length;B=B+1){u.push({id:F[B],fn:D,obj:H,override:A,checkReady:E,compat:G});}w=this.POLL_RETRYS;setTimeout(r._poll,0);C=new e.EventHandle({_delete:function(){if(C.handle){C.handle.detach();return;}var J,I;for(J=0;J<F.length;J++){for(I=0;I<u.length;I++){if(F[J]===u[I].id){u.splice(I,1);}}}}});return C;},onContentReady:function(D,B,C,A,z){return r.onAvailable(D,B,C,A,true,z);},attach:function(C,B,A,z){return r._attach(e.Array(arguments,0,true));},_createWrapper:function(F,E,z,A,D){var C,G=e.stamp(F),B="event:"+G+E;if(false===D){B+="native";}if(z){B+="capture";}C=x[B];if(!C){C=e.publish(B,{silent:true,bubbles:false,contextFn:function(){if(A){return C.el;}else{C.nodeRef=C.nodeRef||e.one(C.el);return C.nodeRef;}}});C.overrides={};C.el=F;C.key=B;C.domkey=G;C.type=E;C.fn=function(H){C.fire(r.getEvent(H,F,(A||(false===D))));};C.capture=z;if(F==n&&E=="load"){C.fireOnce=true;t=B;}C._delete=k;x[B]=C;y[G]=y[G]||{};y[G][B]=C;s(F,E,C.fn,z);}return C;},_attach:function(F,E){var K,M,C,J,z,B=false,D,G=F[0],H=F[1],A=F[2]||n,N=E&&E.facade,L=E&&E.capture,I=E&&E.overrides;if(F[F.length-1]===m){K=true;}if(!H||!H.call){return false;}if(o(A)){M=[];e.each(A,function(P,O){F[2]=P;M.push(r._attach(F.slice(),E));});return new e.EventHandle(M);}else{if(e.Lang.isString(A)){if(K){C=e.DOM.byId(A);}else{C=e.Selector.query(A);switch(C.length){case 0:C=null;break;case 1:C=C[0];break;default:F[2]=C;return r._attach(F,E);}}if(C){A=C;}else{D=r.onAvailable(A,function(){D.handle=r._attach(F,E);},r,true,false,K);return D;}}}if(!A){return false;}if(e.Node&&e.instanceOf(A,e.Node)){A=e.Node.getDOMNode(A);}J=r._createWrapper(A,G,L,K,N);if(I){e.mix(J.overrides,I);}if(A==n&&G=="load"){if(YUI.Env.windowLoaded){B=true;}}if(K){F.pop();}z=F[3];D=J._on(H,z,(F.length>4)?F.slice(4):null);if(B){J.fire();}return D;},detach:function(G,H,B,E){var F=e.Array(arguments,0,true),J,C,I,D,z,A;if(F[F.length-1]===m){J=true;}if(G&&G.detach){return G.detach();}if(typeof B=="string"){if(J){B=e.DOM.byId(B);}else{B=e.Selector.query(B);C=B.length;if(C<1){B=null;}else{if(C==1){B=B[0];}}}}if(!B){return false;}if(B.detach){F.splice(2,1);return B.detach.apply(B,F);}else{if(o(B)){I=true;for(D=0,C=B.length;D<C;++D){F[2]=B[D];I=(e.Event.detach.apply(e.Event,F)&&I);}return I;}}if(!G||!H||!H.call){return r.purgeElement(B,false,G);}z="event:"+e.stamp(B)+G;A=x[z];if(A){return A.detach(H);}else{return false;}},getEvent:function(C,A,z){var B=C||n.event;return(z)?B:new e.DOMEventFacade(B,A,x["event:"+e.stamp(A)+C.type]);},generateId:function(z){return e.DOM.generateID(z);},_isValidCollection:o,_load:function(z){if(!v){v=true;if(e.fire){e.fire(j);}r._poll();}},_poll:function(){if(r.locked){return;}if(e.UA.ie&&!YUI.Env.DOMReady){r.startInterval();return;}r.locked=true;var A,z,E,B,D,F,C=!v;if(!C){C=(w>0);}D=[];F=function(I,J){var H,G=J.override;try{if(J.compat){if(J.override){if(G===true){H=J.obj;}else{H=G;}}else{H=I;}J.fn.call(H,J.obj);}else{H=J.obj||e.one(I);J.fn.apply(H,(e.Lang.isArray(G))?G:[]);}}catch(K){}};for(A=0,z=u.length;A<z;++A){E=u[A];if(E&&!E.checkReady){B=(E.compat)?e.DOM.byId(E.id):e.Selector.query(E.id,null,true);if(B){F(B,E);u[A]=null;}else{D.push(E);}}}for(A=0,z=u.length;
A<z;++A){E=u[A];if(E&&E.checkReady){B=(E.compat)?e.DOM.byId(E.id):e.Selector.query(E.id,null,true);if(B){if(v||(B.get&&B.get("nextSibling"))||B.nextSibling){F(B,E);u[A]=null;}}else{D.push(E);}}}w=(D.length===0)?0:w-1;if(C){r.startInterval();}else{clearInterval(r._interval);r._interval=null;}r.locked=false;return;},purgeElement:function(B,z,G){var E=(e.Lang.isString(B))?e.Selector.query(B,null,true):B,H=r.getListeners(E,G),D,F,C,A;if(z&&E){H=H||[];C=e.Selector.query("*",E);D=0;F=C.length;for(;D<F;++D){A=r.getListeners(C[D],G);if(A){H=H.concat(A);}}}if(H){for(D=0,F=H.length;D<F;++D){H[D].detachAll();}}},_clean:function(B){var A=B.key,z=B.domkey;l(B.el,B.type,B.fn,B.capture);delete x[A];delete e._yuievt.events[A];if(y[z]){delete y[z][A];if(!e.Object.size(y[z])){delete y[z];}}},getListeners:function(D,C){var E=e.stamp(D,true),z=y[E],B=[],A=(C)?"event:"+E+C:null,F=q.plugins;if(!z){return null;}if(A){if(F[C]&&F[C].eventDef){A+="_synth";}if(z[A]){B.push(z[A]);}A+="native";if(z[A]){B.push(z[A]);}}else{e.each(z,function(H,G){B.push(H);});}return(B.length)?B:null;},_unload:function(z){e.each(x,function(B,A){if(B.type=="unload"){B.fire(z);}B.detachAll();});l(n,"unload",g);},nativeAdd:s,nativeRemove:l};}();e.Event=r;if(i.injected||YUI.Env.windowLoaded){p();}else{s(n,"load",p);}if(e.UA.ie){e.on(j,r._poll);}s(n,"unload",g);r.Custom=e.CustomEvent;r.Subscriber=e.Subscriber;r.Target=e.EventTarget;r.Handle=e.EventHandle;r.Facade=e.EventFacade;r._poll();})();e.Env.evt.plugins.available={on:function(i,h,k,j){var g=arguments.length>4?e.Array(arguments,4,true):null;return e.Event.onAvailable.call(e.Event,k,h,j,g);}};e.Env.evt.plugins.contentready={on:function(i,h,k,j){var g=arguments.length>4?e.Array(arguments,4,true):null;return e.Event.onContentReady.call(e.Event,k,h,j,g);}};},"3.5.0",{requires:["event-custom-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-delegate",function(a){var c=a.Array,h=a.Lang,b=h.isString,i=h.isObject,e=h.isArray,g=a.Selector.test,d=a.Env.evt.handles;function f(u,w,l,k){var s=c(arguments,0,true),t=b(l)?l:null,r,o,j,n,v,m,q,x,p;if(i(u)){x=[];if(e(u)){for(m=0,q=u.length;m<q;++m){s[0]=u[m];x.push(a.delegate.apply(a,s));}}else{s.unshift(null);for(m in u){if(u.hasOwnProperty(m)){s[0]=m;s[1]=u[m];x.push(a.delegate.apply(a,s));}}}return new a.EventHandle(x);}r=u.split(/\|/);if(r.length>1){v=r.shift();s[0]=u=r.shift();}o=a.Node.DOM_EVENTS[u];if(i(o)&&o.delegate){p=o.delegate.apply(o,arguments);}if(!p){if(!u||!w||!l||!k){return;}j=(t)?a.Selector.query(t,null,true):l;if(!j&&b(l)){p=a.on("available",function(){a.mix(p,a.delegate.apply(a,s),true);},l);}if(!p&&j){s.splice(2,2,j);p=a.Event._attach(s,{facade:false});p.sub.filter=k;p.sub._notify=f.notifySub;}}if(p&&v){n=d[v]||(d[v]={});n=n[u]||(n[u]=[]);n.push(p);}return p;}f.notifySub=function(q,l,p){l=l.slice();if(this.args){l.push.apply(l,this.args);}var o=f._applyFilter(this.filter,l,p),n,m,j,k;if(o){o=c(o);n=l[0]=new a.DOMEventFacade(l[0],p.el,p);n.container=a.one(p.el);for(m=0,j=o.length;m<j&&!n.stopped;++m){n.currentTarget=a.one(o[m]);k=this.fn.apply(this.context||n.currentTarget,l);if(k===false){break;}}return k;}};f.compileFilter=a.cached(function(j){return function(l,k){return g(l._node,j,(k.currentTarget===k.target)?null:k.currentTarget._node);};});f._applyFilter=function(n,l,q){var p=l[0],j=q.el,o=p.target||p.srcElement,k=[],m=false;if(o.nodeType===3){o=o.parentNode;}l.unshift(o);if(b(n)){while(o){m=(o===j);if(g(o,n,(m?null:j))){k.push(o);}if(m){break;}o=o.parentNode;}}else{l[0]=a.one(o);l[1]=new a.DOMEventFacade(p,j,q);while(o){if(n.apply(l[0],l)){k.push(o);}if(o===j){break;}o=o.parentNode;l[0]=a.one(o);}l[1]=p;}if(k.length<=1){k=k[0];}l.shift();return k;};a.delegate=a.Event.delegate=f;},"3.5.0",{requires:["node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-event-delegate",function(a){a.Node.prototype.delegate=function(d){var c=a.Array(arguments,0,true),b=(a.Lang.isObject(d)&&!a.Lang.isArray(d))?1:2;c.splice(b,0,this._node);return a.delegate.apply(a,c);};},"3.5.0",{requires:["node-base","event-delegate"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-pluginhost",function(a){a.Node.plug=function(){var b=a.Array(arguments);b.unshift(a.Node);a.Plugin.Host.plug.apply(a.Base,b);return a.Node;};a.Node.unplug=function(){var b=a.Array(arguments);b.unshift(a.Node);a.Plugin.Host.unplug.apply(a.Base,b);return a.Node;};a.mix(a.Node,a.Plugin.Host,false,null,1);a.NodeList.prototype.plug=function(){var b=arguments;a.NodeList.each(this,function(c){a.Node.prototype.plug.apply(a.one(c),b);});};a.NodeList.prototype.unplug=function(){var b=arguments;a.NodeList.each(this,function(c){a.Node.prototype.unplug.apply(a.one(c),b);});};},"3.5.0",{requires:["node-base","pluginhost"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dom-style",function(a){(function(e){var p="documentElement",b="defaultView",n="ownerDocument",h="style",i="float",r="cssFloat",s="styleFloat",k="transparent",d="getComputedStyle",c="getBoundingClientRect",o=e.config.win,g=e.config.doc,t=undefined,q=e.DOM,f="transform",l=["WebkitTransform","MozTransform","OTransform"],m=/color$/i,j=/width|height|top|left|right|bottom|margin|padding/i;e.Array.each(l,function(u){if(u in g[p].style){f=u;}});e.mix(q,{DEFAULT_UNIT:"px",CUSTOM_STYLES:{},setStyle:function(x,u,y,w){w=w||x.style;var v=q.CUSTOM_STYLES;if(w){if(y===null||y===""){y="";}else{if(!isNaN(new Number(y))&&j.test(u)){y+=q.DEFAULT_UNIT;}}if(u in v){if(v[u].set){v[u].set(x,y,w);return;}else{if(typeof v[u]==="string"){u=v[u];}}}else{if(u===""){u="cssText";y="";}}w[u]=y;}},getStyle:function(x,u,w){w=w||x.style;var v=q.CUSTOM_STYLES,y="";if(w){if(u in v){if(v[u].get){return v[u].get(x,u,w);}else{if(typeof v[u]==="string"){u=v[u];}}}y=w[u];if(y===""){y=q[d](x,u);}}return y;},setStyles:function(v,w){var u=v.style;e.each(w,function(x,y){q.setStyle(v,y,x,u);},q);},getComputedStyle:function(w,u){var y="",x=w[n],v;if(w[h]&&x[b]&&x[b][d]){v=x[b][d](w,null);if(v){y=v[u];}}return y;}});if(g[p][h][r]!==t){q.CUSTOM_STYLES[i]=r;}else{if(g[p][h][s]!==t){q.CUSTOM_STYLES[i]=s;}}if(e.UA.opera){q[d]=function(w,v){var u=w[n][b],x=u[d](w,"")[v];if(m.test(v)){x=e.Color.toRGB(x);}return x;};}if(e.UA.webkit){q[d]=function(w,v){var u=w[n][b],x=u[d](w,"")[v];if(x==="rgba(0, 0, 0, 0)"){x=k;}return x;};}e.DOM._getAttrOffset=function(y,v){var A=e.DOM[d](y,v),x=y.offsetParent,u,w,z;if(A==="auto"){u=e.DOM.getStyle(y,"position");if(u==="static"||u==="relative"){A=0;}else{if(x&&x[c]){w=x[c]()[v];z=y[c]()[v];if(v==="left"||v==="top"){A=z-w;}else{A=w-y[c]()[v];}}}}return A;};e.DOM._getOffset=function(u){var w,v=null;if(u){w=q.getStyle(u,"position");v=[parseInt(q[d](u,"left"),10),parseInt(q[d](u,"top"),10)];if(isNaN(v[0])){v[0]=parseInt(q.getStyle(u,"left"),10);if(isNaN(v[0])){v[0]=(w==="relative")?0:u.offsetLeft||0;}}if(isNaN(v[1])){v[1]=parseInt(q.getStyle(u,"top"),10);if(isNaN(v[1])){v[1]=(w==="relative")?0:u.offsetTop||0;}}}return v;};q.CUSTOM_STYLES.transform={set:function(v,w,u){u[f]=w;},get:function(v,u){return q[d](v,f);}};})(a);(function(d){var b=parseInt,c=RegExp;d.Color={KEYWORDS:{black:"000",silver:"c0c0c0",gray:"808080",white:"fff",maroon:"800000",red:"f00",purple:"800080",fuchsia:"f0f",green:"008000",lime:"0f0",olive:"808000",yellow:"ff0",navy:"000080",blue:"00f",teal:"008080",aqua:"0ff"},re_RGB:/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,re_hex:/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,re_hex3:/([0-9A-F])/gi,toRGB:function(e){if(!d.Color.re_RGB.test(e)){e=d.Color.toHex(e);}if(d.Color.re_hex.exec(e)){e="rgb("+[b(c.$1,16),b(c.$2,16),b(c.$3,16)].join(", ")+")";}return e;},toHex:function(f){f=d.Color.KEYWORDS[f]||f;if(d.Color.re_RGB.exec(f)){f=[Number(c.$1).toString(16),Number(c.$2).toString(16),Number(c.$3).toString(16)];for(var e=0;e<f.length;e++){if(f[e].length<2){f[e]="0"+f[e];}}f=f.join("");}if(f.length<6){f=f.replace(d.Color.re_hex3,"$1$1");}if(f!=="transparent"&&f.indexOf("#")<0){f="#"+f;}return f.toUpperCase();}};})(a);},"3.5.0",{requires:["dom-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dom-screen",function(a){(function(f){var d="documentElement",q="compatMode",o="position",c="fixed",m="relative",g="left",h="top",i="BackCompat",p="medium",e="borderLeftWidth",b="borderTopWidth",r="getBoundingClientRect",k="getComputedStyle",l=f.DOM,n=/^t(?:able|d|h)$/i,j;if(f.UA.ie){if(f.config.doc[q]!=="BackCompat"){j=d;}else{j="body";}}f.mix(l,{winHeight:function(t){var s=l._getWinSize(t).height;return s;},winWidth:function(t){var s=l._getWinSize(t).width;return s;},docHeight:function(t){var s=l._getDocSize(t).height;return Math.max(s,l._getWinSize(t).height);},docWidth:function(t){var s=l._getDocSize(t).width;return Math.max(s,l._getWinSize(t).width);},docScrollX:function(u,v){v=v||(u)?l._getDoc(u):f.config.doc;var t=v.defaultView,s=(t)?t.pageXOffset:0;return Math.max(v[d].scrollLeft,v.body.scrollLeft,s);},docScrollY:function(u,v){v=v||(u)?l._getDoc(u):f.config.doc;var t=v.defaultView,s=(t)?t.pageYOffset:0;return Math.max(v[d].scrollTop,v.body.scrollTop,s);},getXY:function(){if(f.config.doc[d][r]){return function(v){var D=null,w,t,y,x,C,B,A,z,s,u;if(v&&v.tagName){A=v.ownerDocument;y=A[q];if(y!==i){u=A[d];}else{u=A.body;}if(u.contains){s=u.contains(v);}else{s=f.DOM.contains(u,v);}if(s){z=A.defaultView;if(z&&"pageXOffset" in z){w=z.pageXOffset;t=z.pageYOffset;}else{w=(j)?A[j].scrollLeft:l.docScrollX(v,A);t=(j)?A[j].scrollTop:l.docScrollY(v,A);}if(f.UA.ie){if(!A.documentMode||A.documentMode<8||y===i){C=u.clientLeft;B=u.clientTop;}}x=v[r]();D=[x.left,x.top];if(C||B){D[0]-=C;D[1]-=B;}if((t||w)){if(!f.UA.ios||(f.UA.ios>=4.2)){D[0]+=w;D[1]+=t;}}}else{D=l._getOffset(v);}}return D;};}else{return function(t){var w=null,v,s,y,u,x;if(t){if(l.inDoc(t)){w=[t.offsetLeft,t.offsetTop];v=t.ownerDocument;s=t;y=((f.UA.gecko||f.UA.webkit>519)?true:false);while((s=s.offsetParent)){w[0]+=s.offsetLeft;w[1]+=s.offsetTop;if(y){w=l._calcBorders(s,w);}}if(l.getStyle(t,o)!=c){s=t;while((s=s.parentNode)){u=s.scrollTop;x=s.scrollLeft;if(f.UA.gecko&&(l.getStyle(s,"overflow")!=="visible")){w=l._calcBorders(s,w);}if(u||x){w[0]-=x;w[1]-=u;}}w[0]+=l.docScrollX(t,v);w[1]+=l.docScrollY(t,v);}else{w[0]+=l.docScrollX(t,v);w[1]+=l.docScrollY(t,v);}}else{w=l._getOffset(t);}}return w;};}}(),getScrollbarWidth:f.cached(function(){var v=f.config.doc,t=v.createElement("div"),s=v.getElementsByTagName("body")[0],u=0.1;if(s){t.style.cssText="position:absolute;visibility:hidden;overflow:scroll;width:20px;";t.appendChild(v.createElement("p")).style.height="1px";s.insertBefore(t,s.firstChild);u=t.offsetWidth-t.clientWidth;s.removeChild(t);}return u;},null,0.1),getX:function(s){return l.getXY(s)[0];},getY:function(s){return l.getXY(s)[1];},setXY:function(t,w,z){var u=l.setStyle,y,x,s,v;if(t&&w){y=l.getStyle(t,o);x=l._getOffset(t);if(y=="static"){y=m;u(t,o,y);}v=l.getXY(t);if(w[0]!==null){u(t,g,w[0]-v[0]+x[0]+"px");}if(w[1]!==null){u(t,h,w[1]-v[1]+x[1]+"px");}if(!z){s=l.getXY(t);if(s[0]!==w[0]||s[1]!==w[1]){l.setXY(t,w,true);}}}else{}},setX:function(t,s){return l.setXY(t,[s,null]);},setY:function(s,t){return l.setXY(s,[null,t]);},swapXY:function(t,s){var u=l.getXY(t);l.setXY(t,l.getXY(s));l.setXY(s,u);},_calcBorders:function(v,w){var u=parseInt(l[k](v,b),10)||0,s=parseInt(l[k](v,e),10)||0;if(f.UA.gecko){if(n.test(v.tagName)){u=0;s=0;}}w[0]+=s;w[1]+=u;return w;},_getWinSize:function(v,y){y=y||(v)?l._getDoc(v):f.config.doc;var x=y.defaultView||y.parentWindow,z=y[q],u=x.innerHeight,t=x.innerWidth,s=y[d];if(z&&!f.UA.opera){if(z!="CSS1Compat"){s=y.body;}u=s.clientHeight;t=s.clientWidth;}return{height:u,width:t};},_getDocSize:function(t){var u=(t)?l._getDoc(t):f.config.doc,s=u[d];if(u[q]!="CSS1Compat"){s=u.body;}return{height:s.scrollHeight,width:s.scrollWidth};}});})(a);(function(g){var d="top",c="right",h="bottom",b="left",f=function(m,k){var o=Math.max(m[d],k[d]),p=Math.min(m[c],k[c]),i=Math.min(m[h],k[h]),j=Math.max(m[b],k[b]),n={};n[d]=o;n[c]=p;n[h]=i;n[b]=j;return n;},e=g.DOM;g.mix(e,{region:function(j){var k=e.getXY(j),i=false;if(j&&k){i=e._getRegion(k[1],k[0]+j.offsetWidth,k[1]+j.offsetHeight,k[0]);}return i;},intersect:function(k,i,m){var j=m||e.region(k),l={},p=i,o;if(p.tagName){l=e.region(p);}else{if(g.Lang.isObject(i)){l=i;}else{return false;}}o=f(l,j);return{top:o[d],right:o[c],bottom:o[h],left:o[b],area:((o[h]-o[d])*(o[c]-o[b])),yoff:((o[h]-o[d])),xoff:(o[c]-o[b]),inRegion:e.inRegion(k,i,false,m)};},inRegion:function(l,i,j,o){var m={},k=o||e.region(l),q=i,p;if(q.tagName){m=e.region(q);}else{if(g.Lang.isObject(i)){m=i;}else{return false;}}if(j){return(k[b]>=m[b]&&k[c]<=m[c]&&k[d]>=m[d]&&k[h]<=m[h]);}else{p=f(m,k);if(p[h]>=p[d]&&p[c]>=p[b]){return true;}else{return false;}}},inViewportRegion:function(j,i,k){return e.inRegion(j,e.viewportRegion(j),i,k);},_getRegion:function(k,m,i,j){var n={};n[d]=n[1]=k;n[b]=n[0]=j;n[h]=i;n[c]=m;n.width=n[c]-n[b];n.height=n[h]-n[d];return n;},viewportRegion:function(j){j=j||g.config.doc.documentElement;var i=false,l,k;if(j){l=e.docScrollX(j);k=e.docScrollY(j);i=e._getRegion(k,e.winWidth(j)+l,k+e.winHeight(j),l);}return i;}});})(a);},"3.5.0",{requires:["dom-base","dom-style"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-screen",function(a){a.each(["winWidth","winHeight","docWidth","docHeight","docScrollX","docScrollY"],function(b){a.Node.ATTRS[b]={getter:function(){var c=Array.prototype.slice.call(arguments);c.unshift(a.Node.getDOMNode(this));return a.DOM[b].apply(this,c);}};});a.Node.ATTRS.scrollLeft={getter:function(){var b=a.Node.getDOMNode(this);return("scrollLeft" in b)?b.scrollLeft:a.DOM.docScrollX(b);},setter:function(c){var b=a.Node.getDOMNode(this);if(b){if("scrollLeft" in b){b.scrollLeft=c;}else{if(b.document||b.nodeType===9){a.DOM._getWin(b).scrollTo(c,a.DOM.docScrollY(b));}}}else{}}};a.Node.ATTRS.scrollTop={getter:function(){var b=a.Node.getDOMNode(this);return("scrollTop" in b)?b.scrollTop:a.DOM.docScrollY(b);},setter:function(c){var b=a.Node.getDOMNode(this);if(b){if("scrollTop" in b){b.scrollTop=c;}else{if(b.document||b.nodeType===9){a.DOM._getWin(b).scrollTo(a.DOM.docScrollX(b),c);}}}else{}}};a.Node.importMethod(a.DOM,["getXY","setXY","getX","setX","getY","setY","swapXY"]);a.Node.ATTRS.region={getter:function(){var b=this.getDOMNode(),c;if(b&&!b.tagName){if(b.nodeType===9){b=b.documentElement;}}if(a.DOM.isWindow(b)){c=a.DOM.viewportRegion(b);}else{c=a.DOM.region(b);}return c;}};a.Node.ATTRS.viewportRegion={getter:function(){return a.DOM.viewportRegion(a.Node.getDOMNode(this));}};a.Node.importMethod(a.DOM,"inViewportRegion");a.Node.prototype.intersect=function(b,d){var c=a.Node.getDOMNode(this);if(a.instanceOf(b,a.Node)){b=a.Node.getDOMNode(b);}return a.DOM.intersect(c,b,d);};a.Node.prototype.inRegion=function(b,d,e){var c=a.Node.getDOMNode(this);if(a.instanceOf(b,a.Node)){b=a.Node.getDOMNode(b);}return a.DOM.inRegion(c,b,d,e);};},"3.5.0",{requires:["node-base","dom-screen"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-style",function(a){(function(b){b.mix(b.Node.prototype,{setStyle:function(c,d){b.DOM.setStyle(this._node,c,d);return this;},setStyles:function(c){b.DOM.setStyles(this._node,c);return this;},getStyle:function(c){return b.DOM.getStyle(this._node,c);},getComputedStyle:function(c){return b.DOM.getComputedStyle(this._node,c);}});b.NodeList.importMethod(b.Node.prototype,["getStyle","getComputedStyle","setStyle","setStyles"]);})(a);},"3.5.0",{requires:["dom-style","node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-synthetic",function(b){var j=b.Env.evt.dom_map,d=b.Array,i=b.Lang,l=i.isObject,c=i.isString,e=i.isArray,g=b.Selector.query,k=function(){};function h(n,m){this.handle=n;this.emitFacade=m;}h.prototype.fire=function(s){var t=d(arguments,0,true),q=this.handle,o=q.evt,m=q.sub,p=m.context,u=m.filter,n=s||{},r;if(this.emitFacade){if(!s||!s.preventDefault){n=o._getFacade();if(l(s)&&!s.preventDefault){b.mix(n,s,true);t[0]=n;}else{t.unshift(n);}}n.type=o.type;n.details=t.slice();if(u){n.container=o.host;}}else{if(u&&l(s)&&s.currentTarget){t.shift();}}m.context=p||n.currentTarget||o.host;r=o.fire.apply(o,t);m.context=p;return r;};function f(o,n,m){this.handles=[];this.el=o;this.key=m;this.domkey=n;}f.prototype={constructor:f,type:"_synth",fn:k,capture:false,register:function(m){m.evt.registry=this;this.handles.push(m);},unregister:function(p){var o=this.handles,n=j[this.domkey],m;for(m=o.length-1;m>=0;--m){if(o[m].sub===p){o.splice(m,1);break;}}if(!o.length){delete n[this.key];if(!b.Object.size(n)){delete j[this.domkey];}}},detachAll:function(){var n=this.handles,m=n.length;while(--m>=0){n[m].detach();}}};function a(){this._init.apply(this,arguments);}b.mix(a,{Notifier:h,SynthRegistry:f,getRegistry:function(s,r,p){var q=s._node,o=b.stamp(q),n="event:"+o+r+"_synth",m=j[o];if(p){if(!m){m=j[o]={};}if(!m[n]){m[n]=new f(q,o,n);}}return(m&&m[n])||null;},_deleteSub:function(n){if(n&&n.fn){var m=this.eventDef,o=(n.filter)?"detachDelegate":"detach";this.subscribers={};this.subCount=0;m[o](n.node,n,this.notifier,n.filter);this.registry.unregister(n);delete n.fn;delete n.node;delete n.context;}},prototype:{constructor:a,_init:function(){var m=this.publishConfig||(this.publishConfig={});this.emitFacade=("emitFacade" in m)?m.emitFacade:true;m.emitFacade=false;},processArgs:k,on:k,detach:k,delegate:k,detachDelegate:k,_on:function(s,t){var u=[],o=s.slice(),p=this.processArgs(s,t),q=s[2],m=t?"delegate":"on",n,r;n=(c(q))?g(q):d(q||b.one(b.config.win));if(!n.length&&c(q)){r=b.on("available",function(){b.mix(r,b[m].apply(b,o),true);},q);return r;}b.Array.each(n,function(w){var x=s.slice(),v;w=b.one(w);if(w){if(t){v=x.splice(3,1)[0];}x.splice(0,4,x[1],x[3]);if(!this.preventDups||!this.getSubs(w,s,null,true)){u.push(this._subscribe(w,m,x,p,v));}}},this);return(u.length===1)?u[0]:new b.EventHandle(u);},_subscribe:function(q,o,t,r,p){var v=new b.CustomEvent(this.type,this.publishConfig),s=v.on.apply(v,t),u=new h(s,this.emitFacade),n=a.getRegistry(q,this.type,true),m=s.sub;m.node=q;m.filter=p;if(r){this.applyArgExtras(r,m);}b.mix(v,{eventDef:this,notifier:u,host:q,currentTarget:q,target:q,el:q._node,_delete:a._deleteSub},true);s.notifier=u;n.register(s);this[o](q,m,u,p);return s;},applyArgExtras:function(m,n){n._extra=m;},_detach:function(o){var t=o[2],r=(c(t))?g(t):d(t),s,q,m,p,n;o.splice(2,1);for(q=0,m=r.length;q<m;++q){s=b.one(r[q]);if(s){p=this.getSubs(s,o);if(p){for(n=p.length-1;n>=0;--n){p[n].detach();}}}}},getSubs:function(o,u,n,q){var m=a.getRegistry(o,this.type),v=[],t,p,s,r;if(m){t=m.handles;if(!n){n=this.subMatch;}for(p=0,s=t.length;p<s;++p){r=t[p];if(n.call(this,r.sub,u)){if(q){return r;}else{v.push(t[p]);}}}}return v.length&&v;},subMatch:function(n,m){return !m[1]||n.fn===m[1];}}},true);b.SyntheticEvent=a;b.Event.define=function(o,n,q){var p,r,m;if(o&&o.type){p=o;q=n;}else{if(n){p=b.merge({type:o},n);}}if(p){if(q||!b.Node.DOM_EVENTS[p.type]){r=function(){a.apply(this,arguments);};b.extend(r,a,p);m=new r();o=m.type;b.Node.DOM_EVENTS[o]=b.Env.evt.plugins[o]={eventDef:m,on:function(){return m._on(d(arguments));},delegate:function(){return m._on(d(arguments),true);},detach:function(){return m._detach(d(arguments));}};}}else{if(c(o)||e(o)){b.Array.each(d(o),function(s){b.Node.DOM_EVENTS[s]=1;});}}return m;};},"3.5.0",{requires:["node-base","event-custom-complex"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-key",function(g){var e="+alt",c="+ctrl",d="+meta",b="+shift",a=g.Lang.trim,f={KEY_MAP:{enter:13,esc:27,backspace:8,tab:9,pageup:33,pagedown:34},_typeRE:/^(up|down|press):/,_keysRE:/^(?:up|down|press):|\+(alt|ctrl|meta|shift)/g,processArgs:function(m){var p=m.splice(3,1)[0],o=g.Array.hash(p.match(/\+(?:alt|ctrl|meta|shift)\b/g)||[]),j={type:this._typeRE.test(p)?RegExp.$1:null,mods:o,keys:null},n=p.replace(this._keysRE,""),k,q,h,l;if(n){n=n.split(",");j.keys={};for(l=n.length-1;l>=0;--l){k=a(n[l]);if(!k){continue;}if(+k==k){j.keys[k]=o;}else{h=k.toLowerCase();if(this.KEY_MAP[h]){j.keys[this.KEY_MAP[h]]=o;if(!j.type){j.type="down";}}else{k=k.charAt(0);q=k.toUpperCase();if(o["+shift"]){k=q;}j.keys[k.charCodeAt(0)]=(k===q)?g.merge(o,{"+shift":true}):o;}}}}if(!j.type){j.type="press";}return j;},on:function(n,k,m,j){var h=k._extra,i="key"+h.type,l=h.keys,o=(j)?"delegate":"on";k._detach=n[o](i,function(q){var p=l?l[q.which]:h.mods;if(p&&(!p[e]||(p[e]&&q.altKey))&&(!p[c]||(p[c]&&q.ctrlKey))&&(!p[d]||(p[d]&&q.metaKey))&&(!p[b]||(p[b]&&q.shiftKey))){m.fire(q);}},j);},detach:function(j,h,i){h._detach.detach();}};f.delegate=f.on;f.detachDelegate=f.detach;g.Event.define("key",f,true);},"3.5.0",{requires:["event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-focus",function(f){var d=f.Event,c=f.Lang,a=c.isString,e=f.Array.indexOf,b=c.isFunction(f.DOM.create('<p onbeforeactivate=";"/>').onbeforeactivate);function g(i,h,k){var j="_"+i+"Notifiers";f.Event.define(i,{_attach:function(m,n,l){if(f.DOM.isWindow(m)){return d._attach([i,function(o){n.fire(o);},m]);}else{return d._attach([h,this._proxy,m,this,n,l],{capture:true});}},_proxy:function(o,s,q){var p=o.target,m=o.currentTarget,r=p.getData(j),t=f.stamp(m._node),l=(b||p!==m),n;s.currentTarget=(q)?p:m;s.container=(q)?m:null;if(!r){r={};p.setData(j,r);if(l){n=d._attach([k,this._notify,p._node]).sub;n.once=true;}}else{l=true;}if(!r[t]){r[t]=[];}r[t].push(s);if(!l){this._notify(o);}},_notify:function(w,q){var C=w.currentTarget,l=C.getData(j),x=C.ancestors(),B=C.get("ownerDocument"),s=[],m=l?f.Object.keys(l).length:0,A,r,t,n,o,y,u,v,p,z;C.clearData(j);x.push(C);if(B){x.unshift(B);}x._nodes.reverse();y=m;x.some(function(H){var G=f.stamp(H),E=l[G],F,D;if(E){m--;for(F=0,D=E.length;F<D;++F){if(E[F].handle.sub.filter){s.push(E[F]);}}}return !m;});m=y;while(m&&(A=x.shift())){n=f.stamp(A);r=l[n];if(r){for(u=0,v=r.length;u<v;++u){t=r[u];p=t.handle.sub;o=true;w.currentTarget=A;if(p.filter){o=p.filter.apply(A,[A,w].concat(p.args||[]));s.splice(e(s,t),1);}if(o){w.container=t.container;z=t.fire(w);}if(z===false||w.stopped===2){break;}}delete r[n];m--;}if(w.stopped!==2){for(u=0,v=s.length;u<v;++u){t=s[u];p=t.handle.sub;if(p.filter.apply(A,[A,w].concat(p.args||[]))){w.container=t.container;w.currentTarget=A;z=t.fire(w);}if(z===false||w.stopped===2){break;}}}if(w.stopped){break;}}},on:function(n,l,m){l.handle=this._attach(n._node,m);},detach:function(m,l){l.handle.detach();},delegate:function(o,m,n,l){if(a(l)){m.filter=function(p){return f.Selector.test(p._node,l,o===p?null:o._node);};}m.handle=this._attach(o._node,n,true);},detachDelegate:function(m,l){l.handle.detach();}},true);}if(b){g("focus","beforeactivate","focusin");g("blur","beforedeactivate","focusout");}else{g("focus","focus","focus");g("blur","blur","blur");}},"3.5.0",{requires:["event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("plugin",function(b){function a(c){if(!(this.hasImpl&&this.hasImpl(b.Plugin.Base))){a.superclass.constructor.apply(this,arguments);}else{a.prototype.initializer.apply(this,arguments);}}a.ATTRS={host:{writeOnce:true}};a.NAME="plugin";a.NS="plugin";b.extend(a,b.Base,{_handles:null,initializer:function(c){this._handles=[];},destructor:function(){if(this._handles){for(var d=0,c=this._handles.length;d<c;d++){this._handles[d].detach();}}},doBefore:function(g,d,c){var e=this.get("host"),f;if(g in e){f=this.beforeHostMethod(g,d,c);}else{if(e.on){f=this.onHostEvent(g,d,c);}}return f;},doAfter:function(g,d,c){var e=this.get("host"),f;if(g in e){f=this.afterHostMethod(g,d,c);}else{if(e.after){f=this.afterHostEvent(g,d,c);}}return f;},onHostEvent:function(e,d,c){var f=this.get("host").on(e,d,c||this);this._handles.push(f);return f;},afterHostEvent:function(e,d,c){var f=this.get("host").after(e,d,c||this);this._handles.push(f);return f;},beforeHostMethod:function(f,d,c){var e=b.Do.before(d,this.get("host"),f,c||this);this._handles.push(e);return e;},afterHostMethod:function(f,d,c){var e=b.Do.after(d,this.get("host"),f,c||this);this._handles.push(e);return e;},toString:function(){return this.constructor.NAME+"["+this.constructor.NS+"]";}});b.namespace("Plugin").Base=a;},"3.5.0",{requires:["base-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-simulate",function(a){(function(){var k=a.Lang,j=a.Array,f=k.isFunction,d=k.isString,g=k.isBoolean,o=k.isObject,n=k.isNumber,m=a.config.doc,p={click:1,dblclick:1,mouseover:1,mouseout:1,mousedown:1,mouseup:1,mousemove:1,contextmenu:1},l={keydown:1,keyup:1,keypress:1},c={blur:1,change:1,focus:1,resize:1,scroll:1,select:1},e={scroll:1,resize:1,reset:1,submit:1,change:1,select:1,error:1,abort:1};a.mix(e,p);a.mix(e,l);function i(v,z,u,s,B,r,q,A,x,D,C){if(!v){a.error("simulateKeyEvent(): Invalid target.");}if(d(z)){z=z.toLowerCase();switch(z){case"textevent":z="keypress";break;case"keyup":case"keydown":case"keypress":break;default:a.error("simulateKeyEvent(): Event type '"+z+"' not supported.");}}else{a.error("simulateKeyEvent(): Event type must be a string.");}if(!g(u)){u=true;}if(!g(s)){s=true;}if(!o(B)){B=a.config.win;}if(!g(r)){r=false;}if(!g(q)){q=false;}if(!g(A)){A=false;}if(!g(x)){x=false;}if(!n(D)){D=0;}if(!n(C)){C=0;}var y=null;if(f(m.createEvent)){try{y=m.createEvent("KeyEvents");y.initKeyEvent(z,u,s,B,r,q,A,x,D,C);}catch(w){try{y=m.createEvent("Events");}catch(t){y=m.createEvent("UIEvents");}finally{y.initEvent(z,u,s);y.view=B;y.altKey=q;y.ctrlKey=r;y.shiftKey=A;y.metaKey=x;y.keyCode=D;y.charCode=C;}}v.dispatchEvent(y);}else{if(o(m.createEventObject)){y=m.createEventObject();y.bubbles=u;y.cancelable=s;y.view=B;y.ctrlKey=r;y.altKey=q;y.shiftKey=A;y.metaKey=x;y.keyCode=(C>0)?C:D;v.fireEvent("on"+z,y);}else{a.error("simulateKeyEvent(): No event simulation framework present.");}}}function b(A,F,x,u,G,z,w,v,t,r,s,q,E,C,y,B){if(!A){a.error("simulateMouseEvent(): Invalid target.");}if(d(F)){F=F.toLowerCase();if(!p[F]){a.error("simulateMouseEvent(): Event type '"+F+"' not supported.");}}else{a.error("simulateMouseEvent(): Event type must be a string.");}if(!g(x)){x=true;}if(!g(u)){u=(F!="mousemove");}if(!o(G)){G=a.config.win;}if(!n(z)){z=1;}if(!n(w)){w=0;}if(!n(v)){v=0;}if(!n(t)){t=0;}if(!n(r)){r=0;}if(!g(s)){s=false;}if(!g(q)){q=false;}if(!g(E)){E=false;}if(!g(C)){C=false;}if(!n(y)){y=0;}B=B||null;var D=null;if(f(m.createEvent)){D=m.createEvent("MouseEvents");if(D.initMouseEvent){D.initMouseEvent(F,x,u,G,z,w,v,t,r,s,q,E,C,y,B);}else{D=m.createEvent("UIEvents");D.initEvent(F,x,u);D.view=G;D.detail=z;D.screenX=w;D.screenY=v;D.clientX=t;D.clientY=r;D.ctrlKey=s;D.altKey=q;D.metaKey=C;D.shiftKey=E;D.button=y;D.relatedTarget=B;}if(B&&!D.relatedTarget){if(F=="mouseout"){D.toElement=B;}else{if(F=="mouseover"){D.fromElement=B;}}}A.dispatchEvent(D);}else{if(o(m.createEventObject)){D=m.createEventObject();D.bubbles=x;D.cancelable=u;D.view=G;D.detail=z;D.screenX=w;D.screenY=v;D.clientX=t;D.clientY=r;D.ctrlKey=s;D.altKey=q;D.metaKey=C;D.shiftKey=E;switch(y){case 0:D.button=1;break;case 1:D.button=4;break;case 2:break;default:D.button=0;}D.relatedTarget=B;A.fireEvent("on"+F,D);}else{a.error("simulateMouseEvent(): No event simulation framework present.");}}}function h(w,v,s,r,q,u){if(!w){a.error("simulateUIEvent(): Invalid target.");}if(d(v)){v=v.toLowerCase();if(!c[v]){a.error("simulateUIEvent(): Event type '"+v+"' not supported.");}}else{a.error("simulateUIEvent(): Event type must be a string.");}var t=null;if(!g(s)){s=(v in e);}if(!g(r)){r=(v=="submit");}if(!o(q)){q=a.config.win;}if(!n(u)){u=1;}if(f(m.createEvent)){t=m.createEvent("UIEvents");t.initUIEvent(v,s,r,q,u);w.dispatchEvent(t);}else{if(o(m.createEventObject)){t=m.createEventObject();t.bubbles=s;t.cancelable=r;t.view=q;t.detail=u;w.fireEvent("on"+v,t);}else{a.error("simulateUIEvent(): No event simulation framework present.");}}}a.Event.simulate=function(s,r,q){q=q||{};if(p[r]){b(s,r,q.bubbles,q.cancelable,q.view,q.detail,q.screenX,q.screenY,q.clientX,q.clientY,q.ctrlKey,q.altKey,q.shiftKey,q.metaKey,q.button,q.relatedTarget);}else{if(l[r]){i(s,r,q.bubbles,q.cancelable,q.view,q.ctrlKey,q.altKey,q.shiftKey,q.metaKey,q.keyCode,q.charCode);}else{if(c[r]){h(s,r,q.bubbles,q.cancelable,q.view,q.detail);}else{a.error("simulate(): Event '"+r+"' can't be simulated.");}}}};})();},"3.5.0",{requires:["event-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-event-simulate",function(a){a.Node.prototype.simulate=function(c,b){a.Event.simulate(a.Node.getDOMNode(this),c,b);};},"3.5.0",{requires:["node-base","event-simulate"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("node-focusmanager",function(b){var j="activeDescendant",l="id",i="disabled",n="tabIndex",e="focused",a="focusClass",q="circular",c="UI",f="key",g=j+"Change",o="host",p={37:true,38:true,39:true,40:true},m={"a":true,"button":true,"input":true,"object":true},h=b.Lang,k=b.UA,d=function(){d.superclass.constructor.apply(this,arguments);};d.ATTRS={focused:{value:false,readOnly:true},descendants:{getter:function(r){return this.get(o).all(r);}},activeDescendant:{setter:function(v){var t=h.isNumber,s=b.Attribute.INVALID_VALUE,r=this._descendantsMap,y=this._descendants,x,u,w;if(t(v)){x=v;u=x;}else{if((v instanceof b.Node)&&r){x=r[v.get(l)];if(t(x)){u=x;}else{u=s;}}else{u=s;}}if(y){w=y.item(x);if(w&&w.get("disabled")){u=s;}}return u;}},keys:{value:{next:null,previous:null}},focusClass:{},circular:{value:true}};b.extend(d,b.Plugin.Base,{_stopped:true,_descendants:null,_descendantsMap:null,_focusedNode:null,_lastNodeIndex:0,_eventHandlers:null,_initDescendants:function(){var y=this.get("descendants"),r={},w=-1,v,u=this.get(j),x,s,t=0;if(h.isUndefined(u)){u=-1;}if(y){v=y.size();for(t=0;t<v;t++){x=y.item(t);if(w===-1&&!x.get(i)){w=t;}if(u<0&&parseInt(x.getAttribute(n,2),10)===0){u=t;}if(x){x.set(n,-1);}s=x.get(l);if(!s){s=b.guid();x.set(l,s);}r[s]=t;}if(u<0){u=0;}x=y.item(u);if(!x||x.get(i)){x=y.item(w);u=w;}this._lastNodeIndex=v-1;this._descendants=y;this._descendantsMap=r;this.set(j,u);if(x){x.set(n,0);}}},_isDescendant:function(r){return(r.get(l) in this._descendantsMap);},_removeFocusClass:function(){var s=this._focusedNode,t=this.get(a),r;if(t){r=h.isString(t)?t:t.className;}if(s&&r){s.removeClass(r);}},_detachKeyHandler:function(){var s=this._prevKeyHandler,r=this._nextKeyHandler;if(s){s.detach();}if(r){r.detach();}},_preventScroll:function(r){if(p[r.keyCode]&&this._isDescendant(r.target)){r.preventDefault();}},_fireClick:function(s){var r=s.target,t=r.get("nodeName").toLowerCase();if(s.keyCode===13&&(!m[t]||(t==="a"&&!r.getAttribute("href")))){r.simulate("click");}},_attachKeyHandler:function(){this._detachKeyHandler();var u=this.get("keys.next"),s=this.get("keys.previous"),t=this.get(o),r=this._eventHandlers;if(s){this._prevKeyHandler=b.on(f,b.bind(this._focusPrevious,this),t,s);}if(u){this._nextKeyHandler=b.on(f,b.bind(this._focusNext,this),t,u);}if(k.opera){r.push(t.on("keypress",this._preventScroll,this));}if(!k.opera){r.push(t.on("keypress",this._fireClick,this));}},_detachEventHandlers:function(){this._detachKeyHandler();var r=this._eventHandlers;if(r){b.Array.each(r,function(s){s.detach();});this._eventHandlers=null;}},_attachEventHandlers:function(){var u=this._descendants,r,s,t;if(u&&u.size()){r=this._eventHandlers||[];s=this.get(o).get("ownerDocument");if(r.length===0){r.push(s.on("focus",this._onDocFocus,this));r.push(s.on("mousedown",this._onDocMouseDown,this));r.push(this.after("keysChange",this._attachKeyHandler));r.push(this.after("descendantsChange",this._initDescendants));r.push(this.after(g,this._afterActiveDescendantChange));t=this.after("focusedChange",b.bind(function(v){if(v.newVal){this._attachKeyHandler();t.detach();}},this));r.push(t);}this._eventHandlers=r;}},_onDocMouseDown:function(u){var w=this.get(o),r=u.target,v=w.contains(r),t,s=function(y){var x=false;if(!y.compareTo(w)){x=this._isDescendant(y)?y:s.call(this,y.get("parentNode"));}return x;};if(v){t=s.call(this,r);if(t){r=t;}else{if(!t&&this.get(e)){this._set(e,false);this._onDocFocus(u);}}}if(v&&this._isDescendant(r)){this.focus(r);}else{if(k.webkit&&this.get(e)&&(!v||(v&&!this._isDescendant(r)))){this._set(e,false);this._onDocFocus(u);}}},_onDocFocus:function(w){var u=this._focusTarget||w.target,s=this.get(e),v=this.get(a),t=this._focusedNode,r;if(this._focusTarget){this._focusTarget=null;}if(this.get(o).contains(u)){r=this._isDescendant(u);if(!s&&r){s=true;}else{if(s&&!r){s=false;}}}else{s=false;}if(v){if(t&&(!t.compareTo(u)||!s)){this._removeFocusClass();}if(r&&s){if(v.fn){u=v.fn(u);u.addClass(v.className);}else{u.addClass(v);}this._focusedNode=u;}}this._set(e,s);},_focusNext:function(s,t){var r=t||this.get(j),u;if(this._isDescendant(s.target)&&(r<=this._lastNodeIndex)){r=r+1;if(r===(this._lastNodeIndex+1)&&this.get(q)){r=0;}u=this._descendants.item(r);if(u){if(u.get("disabled")){this._focusNext(s,r);}else{this.focus(r);}}}this._preventScroll(s);},_focusPrevious:function(s,t){var r=t||this.get(j),u;if(this._isDescendant(s.target)&&r>=0){r=r-1;if(r===-1&&this.get(q)){r=this._lastNodeIndex;}u=this._descendants.item(r);if(u){if(u.get("disabled")){this._focusPrevious(s,r);}else{this.focus(r);}}}this._preventScroll(s);},_afterActiveDescendantChange:function(r){var s=this._descendants.item(r.prevVal);if(s){s.set(n,-1);}s=this._descendants.item(r.newVal);if(s){s.set(n,0);}},initializer:function(r){this.start();},destructor:function(){this.stop();this.get(o).focusManager=null;},focus:function(r){if(h.isUndefined(r)){r=this.get(j);}this.set(j,r,{src:c});var s=this._descendants.item(this.get(j));if(s){s.focus();if(k.opera&&s.get("nodeName").toLowerCase()==="button"){this._focusTarget=s;}}},blur:function(){var r;if(this.get(e)){r=this._descendants.item(this.get(j));if(r){r.blur();this._removeFocusClass();}this._set(e,false,{src:c});}},start:function(){if(this._stopped){this._initDescendants();this._attachEventHandlers();this._stopped=false;}},stop:function(){if(!this._stopped){this._detachEventHandlers();this._descendants=null;this._focusedNode=null;this._lastNodeIndex=0;this._stopped=true;}},refresh:function(){this._initDescendants();if(!this._eventHandlers){this._attachEventHandlers();}}});d.NAME="nodeFocusManager";d.NS="focusManager";b.namespace("Plugin");b.Plugin.NodeFocusManager=d;},"3.5.0",{requires:["attribute","node","plugin","node-event-simulate","event-key","event-focus"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("classnamemanager",function(c){var b="classNamePrefix",d="classNameDelimiter",a=c.config;a[b]=a[b]||"yui3";a[d]=a[d]||"-";c.ClassNameManager=function(){var e=a[b],f=a[d];return{getClassName:c.cached(function(){var g=c.Array(arguments);if(g[g.length-1]!==true){g.unshift(e);}else{g.pop();}return g.join(f);})};}();},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-base",function(b){var g=b.Lang,r=b.Node,e=b.ClassNameManager,w=e.getClassName,M,s=b.cached(function(L){return L.substring(0,1).toUpperCase()+L.substring(1);}),F="content",P="visible",K="hidden",y="disabled",B="focused",d="width",A="height",N="boundingBox",v="contentBox",k="parentNode",m="ownerDocument",x="auto",j="srcNode",I="body",H="tabIndex",q="id",i="render",J="rendered",n="destroyed",a="strings",o="<div></div>",z="Change",p="loading",E="_uiSet",D="",G=function(){},u=true,O=false,t,l={},f=[P,y,A,d,B,H],C=b.UA.webkit,h={};function c(Q){var T=this,L,S,R=T.constructor;T._strs={};T._cssPrefix=R.CSS_PREFIX||w(R.NAME.toLowerCase());Q=Q||{};c.superclass.constructor.call(T,Q);S=T.get(i);if(S){if(S!==u){L=S;}T.render(L);}}c.NAME="widget";t=c.UI_SRC="ui";c.ATTRS=l;l[q]={valueFn:"_guid",writeOnce:u};l[J]={value:O,readOnly:u};l[N]={value:null,setter:"_setBB",writeOnce:u};l[v]={valueFn:"_defaultCB",setter:"_setCB",writeOnce:u};l[H]={value:null,validator:"_validTabIndex"};l[B]={value:O,readOnly:u};l[y]={value:O};l[P]={value:u};l[A]={value:D};l[d]={value:D};l[a]={value:{},setter:"_strSetter",getter:"_strGetter"};l[i]={value:O,writeOnce:u};c.CSS_PREFIX=w(c.NAME.toLowerCase());c.getClassName=function(){return w.apply(e,[c.CSS_PREFIX].concat(b.Array(arguments),true));};M=c.getClassName;c.getByNode=function(L){var S,R,Q=M();L=r.one(L);if(L){L=L.ancestor("."+Q,true);if(L){R=L.get(q);S=h[R];}}return S||null;};b.extend(c,b.Base,{getClassName:function(){return w.apply(e,[this._cssPrefix].concat(b.Array(arguments),true));},initializer:function(L){var Q=this.get(N);if(Q instanceof r){this._mapInstance(Q.get(q));}if(this._applyParser){this._applyParser(L);}},_mapInstance:function(L){if(!(h[L])){h[L]=this;}},destructor:function(){var L=this.get(N),Q;if(L instanceof r){Q=L.get(q);if(Q in h){delete h[Q];}this._destroyBox();}},destroy:function(L){this._destroyAllNodes=L;return c.superclass.destroy.apply(this);},_destroyBox:function(){var R=this.get(N),Q=this.get(v),L=this._destroyAllNodes,S;S=R&&R.compareTo(Q);if(this.UI_EVENTS){this._destroyUIEvents();}this._unbindUI(R);if(L){R.empty();R.remove(u);}else{if(Q){Q.remove(u);}if(!S){R.remove(u);}}},render:function(L){if(!this.get(n)&&!this.get(J)){this.publish(i,{queuable:O,fireOnce:u,defaultTargetOnly:u,defaultFn:this._defRenderFn});this.fire(i,{parentNode:(L)?r.one(L):null});}return this;},_defRenderFn:function(L){this._parentNode=L.parentNode;this.renderer();this._set(J,u);this._removeLoadingClassNames();},renderer:function(){var L=this;L._renderUI();L.renderUI();L._bindUI();L.bindUI();L._syncUI();L.syncUI();},bindUI:G,renderUI:G,syncUI:G,hide:function(){return this.set(P,O);},show:function(){return this.set(P,u);},focus:function(){return this._set(B,u);},blur:function(){return this._set(B,O);},enable:function(){return this.set(y,O);},disable:function(){return this.set(y,u);},_uiSizeCB:function(L){this.get(v).toggleClass(M(F,"expanded"),L);},_renderBox:function(L){var T=this,Q=T.get(v),R=T.get(N),V=T.get(j),S=T.DEF_PARENT_NODE,U=(V&&V.get(m))||R.get(m)||Q.get(m);if(V&&!V.compareTo(Q)&&!Q.inDoc(U)){V.replace(Q);}if(!R.compareTo(Q.get(k))&&!R.compareTo(Q)){if(Q.inDoc(U)){Q.replace(R);}R.appendChild(Q);}L=L||(S&&r.one(S));if(L){L.appendChild(R);}else{if(!R.inDoc(U)){r.one(I).insert(R,0);}}},_setBB:function(L){return this._setBox(this.get(q),L,this.BOUNDING_TEMPLATE);},_setCB:function(L){return(this.CONTENT_TEMPLATE===null)?this.get(N):this._setBox(null,L,this.CONTENT_TEMPLATE);},_defaultCB:function(L){return this.get(j)||null;},_setBox:function(R,Q,L){Q=r.one(Q)||r.create(L);if(!Q.get(q)){Q.set(q,R||b.guid());}return Q;},_renderUI:function(){this._renderBoxClassNames();this._renderBox(this._parentNode);},_renderBoxClassNames:function(){var S=this._getClasses(),L,Q=this.get(N),R;Q.addClass(M());for(R=S.length-3;R>=0;R--){L=S[R];Q.addClass(L.CSS_PREFIX||w(L.NAME.toLowerCase()));}this.get(v).addClass(this.getClassName(F));},_removeLoadingClassNames:function(){var R=this.get(N),L=this.get(v),Q=this.getClassName(p),S=M(p);R.removeClass(S).removeClass(Q);L.removeClass(S).removeClass(Q);},_bindUI:function(){this._bindAttrUI(this._UI_ATTRS.BIND);this._bindDOM();},_unbindUI:function(L){this._unbindDOM(L);},_bindDOM:function(){var L=this.get(N).get(m),Q=c._hDocFocus;if(!Q){Q=c._hDocFocus=L.on("focus",this._onDocFocus,this);Q.listeners=1;}else{Q.listeners++;}if(C){this._hDocMouseDown=L.on("mousedown",this._onDocMouseDown,this);}},_unbindDOM:function(L){var R=c._hDocFocus,Q=this._hDocMouseDown;if(R){if(R.listeners>0){R.listeners--;}else{R.detach();c._hDocFocus=null;}}if(C&&Q){Q.detach();}},_syncUI:function(){this._syncAttrUI(this._UI_ATTRS.SYNC);},_uiSetHeight:function(L){this._uiSetDim(A,L);this._uiSizeCB((L!==D&&L!==x));},_uiSetWidth:function(L){this._uiSetDim(d,L);},_uiSetDim:function(L,Q){this.get(N).setStyle(L,g.isNumber(Q)?Q+this.DEF_UNIT:Q);},_uiSetVisible:function(L){this.get(N).toggleClass(this.getClassName(K),!L);},_uiSetDisabled:function(L){this.get(N).toggleClass(this.getClassName(y),L);},_uiSetFocused:function(R,Q){var L=this.get(N);L.toggleClass(this.getClassName(B),R);if(Q!==t){if(R){L.focus();}else{L.blur();}}},_uiSetTabIndex:function(Q){var L=this.get(N);if(g.isNumber(Q)){L.set(H,Q);}else{L.removeAttribute(H);}},_onDocMouseDown:function(L){if(this._domFocus){this._onDocFocus(L);}},_onDocFocus:function(L){var Q=c.getByNode(L.target),R=c._active;if(R&&(R!==Q)){R._domFocus=false;R._set(B,false,{src:t});c._active=null;}if(Q){Q._domFocus=true;Q._set(B,true,{src:t});c._active=Q;}},toString:function(){return this.name+"["+this.get(q)+"]";},DEF_UNIT:"px",DEF_PARENT_NODE:null,CONTENT_TEMPLATE:o,BOUNDING_TEMPLATE:o,_guid:function(){return b.guid();},_validTabIndex:function(L){return(g.isNumber(L)||g.isNull(L));},_bindAttrUI:function(Q){var R,L=Q.length;for(R=0;R<L;R++){this.after(Q[R]+z,this._setAttrUI);}},_syncAttrUI:function(R){var S,Q=R.length,L;for(S=0;S<Q;S++){L=R[S];this[E+s(L)](this.get(L));}},_setAttrUI:function(L){if(L.target===this){this[E+s(L.attrName)](L.newVal,L.src);
}},_strSetter:function(L){return b.merge(this.get(a),L);},getString:function(L){return this.get(a)[L];},getStrings:function(){return this.get(a);},_UI_ATTRS:{BIND:f,SYNC:f}});b.Widget=c;},"3.5.0",{requires:["attribute","event-focus","base-base","base-pluginhost","node-base","node-style","classnamemanager"],skinnable:true});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-htmlparser",function(f){var e=f.Widget,c=f.Node,d=f.Lang,a="srcNode",b="contentBox";e.HTML_PARSER={};e._buildCfg={aggregates:["HTML_PARSER"]};e.ATTRS[a]={value:null,setter:c.one,getter:"_getSrcNode",writeOnce:true};f.mix(e.prototype,{_getSrcNode:function(g){return g||this.get(b);},_applyParsedConfig:function(i,g,h){return(h)?f.mix(g,h,false):g;},_applyParser:function(g){var i=this,j=i.get(a),h=i._getHtmlParser(),l,k;if(h&&j){f.Object.each(h,function(n,m,p){k=null;if(d.isFunction(n)){k=n.call(i,j);}else{if(d.isArray(n)){k=j.all(n[0]);if(k.isEmpty()){k=null;}}else{k=j.one(n);}}if(k!==null&&k!==undefined){l=l||{};l[m]=k;}});}g=i._applyParsedConfig(j,g,l);},_getHtmlParser:function(){var h=this._getClasses(),k={},g,j;for(g=h.length-1;g>=0;g--){j=h[g].HTML_PARSER;if(j){f.mix(k,j,true);}}return k;}});},"3.5.0",{requires:["widget-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-skin",function(e){var d="boundingBox",b="contentBox",a="skin",c=e.ClassNameManager.getClassName;e.Widget.prototype.getSkinName=function(){var f=this.get(b)||this.get(d),h=new RegExp("\\b"+c(a)+"-(\\S+)"),g;if(f){f.ancestor(function(i){g=i.get("className").match(h);return g;});}return(g)?g[1]:null;};},"3.5.0",{requires:["widget-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-uievents",function(g){var f="boundingBox",e=g.Widget,d="render",a=g.Lang,c=":",b=g.Widget._uievts=g.Widget._uievts||{};g.mix(e.prototype,{_destroyUIEvents:function(){var h=g.stamp(this,true);g.each(b,function(j,i){if(j.instances[h]){delete j.instances[h];if(g.Object.isEmpty(j.instances)){j.handle.detach();if(b[i]){delete b[i];}}}});},UI_EVENTS:g.Node.DOM_EVENTS,_getUIEventNode:function(){return this.get(f);},_createUIEvent:function(i){var l=this._getUIEventNode(),h=(g.stamp(l)+i),k=b[h],j;if(!k){j=l.delegate(i,function(m){var n=e.getByNode(this);if(n){if(n._filterUIEvent(m)){n.fire(m.type,{domEvent:m});}}},"."+g.Widget.getClassName());b[h]=k={instances:{},handle:j};}k.instances[g.stamp(this)]=1;},_filterUIEvent:function(h){return(h.currentTarget.compareTo(h.container)||h.container.compareTo(this._getUIEventNode()));},_getUIEvent:function(j){if(a.isString(j)){var k=this.parseType(j)[1],h,i;if(k){h=k.indexOf(c);if(h>-1){k=k.substring(h+c.length);}if(this.UI_EVENTS[k]){i=k;}}return i;}},_initUIEvent:function(i){var j=this._getUIEvent(i),h=this._uiEvtsInitQueue||{};if(j&&!h[j]){this._uiEvtsInitQueue=h[j]=1;this.after(d,function(){this._createUIEvent(j);delete this._uiEvtsInitQueue[j];});}},on:function(h){this._initUIEvent(h);return e.superclass.on.apply(this,arguments);},publish:function(i,h){var j=this._getUIEvent(i);if(j&&h&&h.defaultFn){this._initUIEvent(j);}return e.superclass.publish.apply(this,arguments);}},true);},"3.5.0",{requires:["widget-base","node-event-delegate"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-child",function(c){var b=c.Lang;function a(){c.after(this._syncUIChild,this,"syncUI");c.after(this._bindUIChild,this,"bindUI");}a.ATTRS={selected:{value:0,validator:b.isNumber},index:{readOnly:true,getter:function(){var e=this.get("parent"),d=-1;if(e){d=e.indexOf(this);}return d;}},parent:{readOnly:true},depth:{readOnly:true,getter:function(){var e=this.get("parent"),d=this.get("root"),f=-1;while(e){f=(f+1);if(e==d){break;}e=e.get("parent");}return f;}},root:{readOnly:true,getter:function(){var d=function(h){var e=h.get("parent"),f=h.ROOT_TYPE,g=e;if(f){g=(e&&c.instanceOf(e,f));}return(g?d(e):h);};return d(this);}}};a.prototype={ROOT_TYPE:null,_getUIEventNode:function(){var d=this.get("root"),e;if(d){e=d.get("boundingBox");}return e;},next:function(f){var e=this.get("parent"),d;if(e){d=e.item((this.get("index")+1));}if(!d&&f){d=e.item(0);}return d;},previous:function(g){var f=this.get("parent"),d=this.get("index"),e;if(f&&d>0){e=f.item([(d-1)]);}if(!e&&g){e=f.item((f.size()-1));}return e;},remove:function(d){var e,f;if(b.isNumber(d)){f=c.WidgetParent.prototype.remove.apply(this,arguments);}else{e=this.get("parent");if(e){f=e.remove(this.get("index"));}}return f;},isRoot:function(){return(this==this.get("root"));},ancestor:function(f){var d=this.get("root"),e;if(this.get("depth")>f){e=this.get("parent");while(e!=d&&e.get("depth")>f){e=e.get("parent");}}return e;},_uiSetChildSelected:function(e){var f=this.get("boundingBox"),d=this.getClassName("selected");if(e===0){f.removeClass(d);}else{f.addClass(d);}},_afterChildSelectedChange:function(d){this._uiSetChildSelected(d.newVal);},_syncUIChild:function(){this._uiSetChildSelected(this.get("selected"));},_bindUIChild:function(){this.after("selectedChange",this._afterChildSelectedChange);}};c.WidgetChild=a;},"3.5.0",{requires:["base-build","widget"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-mousewheel",function(c){var b="DOMMouseScroll",a=function(e){var d=c.Array(e,0,true),f;if(c.UA.gecko){d[0]=b;f=c.config.win;}else{f=c.config.doc;}if(d.length<3){d[2]=f;}else{d.splice(2,0,f);}return d;};c.Env.evt.plugins.mousewheel={on:function(){return c.Event._attach(a(arguments));},detach:function(){return c.Event.detach.apply(c.Event,a(arguments));}};},"3.5.0",{requires:["node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-mouseenter",function(f){var b=f.Env.evt.dom_wrappers,d=f.DOM.contains,c=f.Array,e=function(){},a={proxyType:"mouseover",relProperty:"fromElement",_notify:function(k,i,h){var g=this._node,j=k.relatedTarget||k[i];if(g!==j&&!d(g,j)){h.fire(new f.DOMEventFacade(k,g,b["event:"+f.stamp(g)+k.type]));}},on:function(k,i,j){var h=f.Node.getDOMNode(k),g=[this.proxyType,this._notify,h,null,this.relProperty,j];i.handle=f.Event._attach(g,{facade:false});},detach:function(h,g){g.handle.detach();},delegate:function(l,j,k,i){var h=f.Node.getDOMNode(l),g=[this.proxyType,e,h,null,k];j.handle=f.Event._attach(g,{facade:false});j.handle.sub.filter=i;j.handle.sub.relProperty=this.relProperty;j.handle.sub._notify=this._filterNotify;},_filterNotify:function(j,p,g){p=p.slice();if(this.args){p.push.apply(p,this.args);}var h=f.delegate._applyFilter(this.filter,p,g),q=p[0].relatedTarget||p[0][this.relProperty],o,k,m,n,l;if(h){h=c(h);for(k=0,m=h.length&&(!o||!o.stopped);k<m;++k){l=h[0];if(!d(l,q)){if(!o){o=new f.DOMEventFacade(p[0],l,g);o.container=f.one(g.el);}o.currentTarget=f.one(l);n=p[1].fire(o);if(n===false){break;}}}}return n;},detachDelegate:function(h,g){g.handle.detach();}};f.Event.define("mouseenter",a,true);f.Event.define("mouseleave",f.merge(a,{proxyType:"mouseout",relProperty:"toElement"}),true);},"3.5.0",{requires:["event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-resize",function(a){a.Event.define("windowresize",{on:(a.UA.gecko&&a.UA.gecko<1.91)?function(d,b,c){b._handle=a.Event.attach("resize",function(f){c.fire(f);});}:function(e,c,d){var b=a.config.windowResizeDelay||100;c._handle=a.Event.attach("resize",function(f){if(c._timer){c._timer.cancel();}c._timer=a.later(b,a,function(){d.fire(f);});});},detach:function(c,b){if(b._timer){b._timer.cancel();}b._handle.detach();}});},"3.5.0",{requires:["event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-hover",function(d){var c=d.Lang.isFunction,b=function(){},a={processArgs:function(e){var f=c(e[2])?2:3;return(c(e[f]))?e.splice(f,1)[0]:b;},on:function(i,g,h,f){var e=(g.args)?g.args.slice():[];e.unshift(null);g._detach=i[(f)?"delegate":"on"]({mouseenter:function(j){j.phase="over";h.fire(j);},mouseleave:function(j){var k=g.context||this;e[0]=j;j.type="hover";j.phase="out";g._extra.apply(k,e);}},f);},detach:function(g,e,f){e._detach.detach();}};a.delegate=a.on;a.detachDelegate=a.detach;d.Event.define("hover",a);},"3.5.0",{requires:["event-mouseenter"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-outside",function(b){var a=["blur","change","click","dblclick","focus","keydown","keypress","keyup","mousedown","mousemove","mouseout","mouseover","mouseup","select","submit"];b.Event.defineOutside=function(e,d){d=d||(e+"outside");var c={on:function(h,f,g){f.handle=b.one("doc").on(e,function(i){if(this.isOutside(h,i.target)){i.currentTarget=h;g.fire(i);}},this);},detach:function(h,f,g){f.handle.detach();},delegate:function(i,g,h,f){g.handle=b.one("doc").delegate(e,function(j){if(this.isOutside(i,j.target)){h.fire(j);}},f,this);},isOutside:function(f,g){return g!==f&&!g.ancestor(function(h){return h===f;});}};c.detachDelegate=c.detach;b.Event.define(d,c);};b.Array.each(a,function(c){b.Event.defineOutside(c);});},"3.5.0",{requires:["event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-touch",function(d){var c="scale",a="rotation",b="identifier";d.DOMEventFacade.prototype._touch=function(n,m,o){var g,f,h,k,j;if(n.touches){this.touches=[];j={};for(g=0,f=n.touches.length;g<f;++g){k=n.touches[g];j[d.stamp(k)]=this.touches[g]=new d.DOMEventFacade(k,m,o);}}if(n.targetTouches){this.targetTouches=[];for(g=0,f=n.targetTouches.length;g<f;++g){k=n.targetTouches[g];h=j&&j[d.stamp(k,true)];this.targetTouches[g]=h||new d.DOMEventFacade(k,m,o);}}if(n.changedTouches){this.changedTouches=[];for(g=0,f=n.changedTouches.length;g<f;++g){k=n.changedTouches[g];h=j&&j[d.stamp(k,true)];this.changedTouches[g]=h||new d.DOMEventFacade(k,m,o);}}if(c in n){this[c]=n[c];}if(a in n){this[a]=n[a];}if(b in n){this[b]=n[b];}};if(d.Node.DOM_EVENTS){d.mix(d.Node.DOM_EVENTS,{touchstart:1,touchmove:1,touchend:1,touchcancel:1,gesturestart:1,gesturechange:1,gestureend:1});}},"3.5.0",{requires:["node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-move",function(e){var j=((e.config.win&&("ontouchstart" in e.config.win))&&!(e.UA.chrome&&e.UA.chrome<6))?{start:"touchstart",move:"touchmove",end:"touchend"}:{start:"mousedown",move:"mousemove",end:"mouseup"},x="start",C="move",h="end",l="gesture"+C,a=l+h,i=l+x,B="_msh",m="_mh",w="_meh",r="_dmsh",o="_dmh",c="_dmeh",g="_ms",s="_m",z="minTime",t="minDistance",u="preventDefault",b="button",v="ownerDocument",n="currentTarget",p="target",q="nodeType",k=function(H,F,G){var D=(G)?4:3,E=(F.length>D)?e.merge(F.splice(D,1)[0]):{};if(!(u in E)){E[u]=H.PREVENT_DEFAULT;}return E;},f=function(E,D){return D._extra.root||(E.get(q)===9)?E:E.get(v);},y=function(D,F,E){D.pageX=F.pageX;D.pageY=F.pageY;D.screenX=F.screenX;D.screenY=F.screenY;D.clientX=F.clientX;D.clientY=F.clientY;D[p]=D[p]||F[p];D[n]=D[n]||F[n];D[b]=(E&&E[b])||1;},A=function(E,D){if(D){if(!D.call||D(E)){E.preventDefault();}}},d=e.Event.define;d(i,{on:function(E,D,F){D[B]=E.on(j[x],this._onStart,this,E,D,F);},delegate:function(F,E,H,D){var G=this;E[r]=F.delegate(j[x],function(I){G._onStart(I,F,E,H,true);},D);},detachDelegate:function(F,E,H,D){var G=E[r];if(G){G.detach();E[r]=null;}},detach:function(E,D,G){var F=D[B];if(F){F.detach();D[B]=null;}},processArgs:function(D,E){var F=k(this,D,E);if(!(z in F)){F[z]=this.MIN_TIME;}if(!(t in F)){F[t]=this.MIN_DISTANCE;}return F;},_onStart:function(J,E,P,D,L){if(L){E=J[n];}var F=P._extra,O=true,G=F[z],N=F[t],H=F.button,I=F[u],M=f(E,P),K;if(J.touches){if(J.touches.length===1){y(J,J.touches[0],F);}else{O=false;}}else{O=(H===undefined)||(H===J.button);}if(O){A(J,I);if(G===0||N===0){this._start(J,E,D,F);}else{K=[J.pageX,J.pageY];if(G>0){F._ht=e.later(G,this,this._start,[J,E,D,F]);F._hme=M.on(j[h],e.bind(function(){this._cancel(F);},this));}if(N>0){F._hm=M.on(j[C],e.bind(function(Q){if(Math.abs(Q.pageX-K[0])>N||Math.abs(Q.pageY-K[1])>N){this._start(J,E,D,F);}},this));}}}},_cancel:function(D){if(D._ht){D._ht.cancel();D._ht=null;}if(D._hme){D._hme.detach();D._hme=null;}if(D._hm){D._hm.detach();D._hm=null;}},_start:function(F,D,E,G){if(G){this._cancel(G);}F.type=i;D.setData(g,F);E.fire(F);},MIN_TIME:0,MIN_DISTANCE:0,PREVENT_DEFAULT:false});d(l,{on:function(F,E,H){var D=f(F,E),G=D.on(j[C],this._onMove,this,F,E,H);E[m]=G;},delegate:function(F,E,H,D){var G=this;E[o]=F.delegate(j[C],function(I){G._onMove(I,F,E,H,true);},D);},detach:function(E,D,G){var F=D[m];if(F){F.detach();D[m]=null;}},detachDelegate:function(F,E,H,D){var G=E[o];if(G){G.detach();E[o]=null;}},processArgs:function(D,E){return k(this,D,E);},_onMove:function(J,H,G,I,F){if(F){H=J[n];}var D=G._extra.standAlone||H.getData(g),E=G._extra.preventDefault;if(D){if(J.touches){if(J.touches.length===1){y(J,J.touches[0]);}else{D=false;}}if(D){A(J,E);J.type=l;I.fire(J);}}},PREVENT_DEFAULT:false});d(a,{on:function(G,F,H){var E=f(G,F),D=E.on(j[h],this._onEnd,this,G,F,H);F[w]=D;},delegate:function(F,E,H,D){var G=this;E[c]=F.delegate(j[h],function(I){G._onEnd(I,F,E,H,true);},D);},detachDelegate:function(F,E,H,D){var G=E[c];if(G){G.detach();E[c]=null;}},detach:function(F,E,G){var D=E[w];if(D){D.detach();E[w]=null;}},processArgs:function(D,E){return k(this,D,E);},_onEnd:function(J,H,F,I,E){if(E){H=J[n];}var G=F._extra.standAlone||H.getData(s)||H.getData(g),D=F._extra.preventDefault;if(G){if(J.changedTouches){if(J.changedTouches.length===1){y(J,J.changedTouches[0]);}else{G=false;}}if(G){A(J,D);J.type=a;I.fire(J);H.clearData(g);H.clearData(s);}}},PREVENT_DEFAULT:false});},"3.5.0",{requires:["node-base","event-touch","event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-flick",function(c){var i=((c.config.win&&("ontouchstart" in c.config.win))&&!(c.UA.chrome&&c.UA.chrome<6))?{start:"touchstart",end:"touchend",move:"touchmove"}:{start:"mousedown",end:"mouseup",move:"mousemove"},j="start",m="end",d="move",b="ownerDocument",k="minVelocity",f="minDistance",a="preventDefault",e="_fs",g="_fsh",n="_feh",h="_fmh",l="nodeType";c.Event.define("flick",{on:function(p,o,r){var q=p.on(i[j],this._onStart,this,p,o,r);o[g]=q;},detach:function(q,p,s){var r=p[g],o=p[n];if(r){r.detach();p[g]=null;}if(o){o.detach();p[n]=null;}},processArgs:function(o){var p=(o.length>3)?c.merge(o.splice(3,1)[0]):{};if(!(k in p)){p[k]=this.MIN_VELOCITY;}if(!(f in p)){p[f]=this.MIN_DISTANCE;}if(!(a in p)){p[a]=this.PREVENT_DEFAULT;}return p;},_onStart:function(u,r,x,p){var o=true,w,q,v,t=x._extra.preventDefault,s=u;if(u.touches){o=(u.touches.length===1);u=u.touches[0];}if(o){if(t){if(!t.call||t(u)){s.preventDefault();}}u.flick={time:new Date().getTime()};x[e]=u;w=x[n];v=(r.get(l)===9)?r:r.get(b);if(!w){w=v.on(i[m],c.bind(this._onEnd,this),null,r,x,p);x[n]=w;}x[h]=v.once(i[d],c.bind(this._onMove,this),null,r,x,p);}},_onMove:function(r,p,o,q){var s=o[e];if(s&&s.flick){s.flick.time=new Date().getTime();}},_onEnd:function(C,w,D,s){var A=new Date().getTime(),q=D[e],o=!!q,E=C,r,v,B,y,z,p,x,u,t=D[h];if(t){t.detach();delete D[h];}if(o){if(C.changedTouches){if(C.changedTouches.length===1&&C.touches.length===0){E=C.changedTouches[0];}else{o=false;}}if(o){y=D._extra;B=y[a];if(B){if(!B.call||B(C)){C.preventDefault();}}r=q.flick.time;A=new Date().getTime();v=A-r;z=[E.pageX-q.pageX,E.pageY-q.pageY];if(y.axis){u=y.axis;}else{u=(Math.abs(z[0])>=Math.abs(z[1]))?"x":"y";}p=z[(u==="x")?0:1];x=(v!==0)?p/v:0;if(isFinite(x)&&(Math.abs(p)>=y[f])&&(Math.abs(x)>=y[k])){C.type="flick";C.flick={time:v,distance:p,velocity:x,axis:u,start:q};s.fire(C);}D[e]=null;}}},MIN_VELOCITY:0,MIN_DISTANCE:0,PREVENT_DEFAULT:false});},"3.5.0",{requires:["node-base","event-touch","event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("event-valuechange",function(e){var c="_valuechange",d="value",a,b={POLL_INTERVAL:50,TIMEOUT:10000,_poll:function(k,g){var i=k._node,j=g.e,f=i&&i.value,l=k._data&&k._data[c],h,m;if(!i||!l){b._stopPolling(k);return;}m=l.prevVal;if(f!==m){l.prevVal=f;h={_event:j,currentTarget:(j&&j.currentTarget)||k,newVal:f,prevVal:m,target:(j&&j.target)||k};e.Object.each(l.notifiers,function(n){n.fire(h);});b._refreshTimeout(k);}},_refreshTimeout:function(g,f){if(!g._node){return;}var h=g.getData(c);b._stopTimeout(g);h.timeout=setTimeout(function(){b._stopPolling(g,f);},b.TIMEOUT);},_startPolling:function(h,g,f){if(!h.test("input,textarea")){return;}var i=h.getData(c);if(!i){i={prevVal:h.get(d)};h.setData(c,i);}i.notifiers||(i.notifiers={});if(i.interval){if(f.force){b._stopPolling(h,g);}else{i.notifiers[e.stamp(g)]=g;return;}}i.notifiers[e.stamp(g)]=g;i.interval=setInterval(function(){b._poll(h,i,f);},b.POLL_INTERVAL);b._refreshTimeout(h,g);},_stopPolling:function(g,f){if(!g._node){return;}var h=g.getData(c)||{};clearInterval(h.interval);delete h.interval;b._stopTimeout(g);if(f){h.notifiers&&delete h.notifiers[e.stamp(f)];}else{h.notifiers={};}},_stopTimeout:function(f){var g=f.getData(c)||{};clearTimeout(g.timeout);delete g.timeout;},_onBlur:function(g,f){b._stopPolling(g.currentTarget,f);},_onFocus:function(h,g){var f=h.currentTarget,i=f.getData(c);if(!i){i={};f.setData(c,i);}i.prevVal=f.get(d);b._startPolling(f,g,{e:h});},_onKeyDown:function(g,f){b._startPolling(g.currentTarget,f,{e:g});},_onKeyUp:function(g,f){if(g.charCode===229||g.charCode===197){b._startPolling(g.currentTarget,f,{e:g,force:true});}},_onMouseDown:function(g,f){b._startPolling(g.currentTarget,f,{e:g});},_onSubscribe:function(k,h,j,g){var l,i,f;i={blur:b._onBlur,focus:b._onFocus,keydown:b._onKeyDown,keyup:b._onKeyUp,mousedown:b._onMouseDown};l=j._valuechange={};if(g){l.delegated=true;l.getNodes=function(){return k.all("input,textarea").filter(g);};l.getNodes().each(function(m){if(!m.getData(c)){m.setData(c,{prevVal:m.get(d)});}});j._handles=e.delegate(i,k,g,null,j);}else{if(!k.test("input,textarea")){return;}if(!k.getData(c)){k.setData(c,{prevVal:k.get(d)});}j._handles=k.on(i,null,null,j);}},_onUnsubscribe:function(h,g,f){var i=f._valuechange;f._handles&&f._handles.detach();if(i.delegated){i.getNodes().each(function(j){b._stopPolling(j,f);});}else{b._stopPolling(h,f);}}};a={detach:b._onUnsubscribe,on:b._onSubscribe,delegate:b._onSubscribe,detachDelegate:b._onUnsubscribe,publishConfig:{emitFacade:true}};e.Event.define("valuechange",a);e.Event.define("valueChange",a);e.ValueChange=b;},"3.5.0",{requires:["event-focus","event-synthetic"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("array-extras",function(d){var b=d.Array,a=d.Lang,c=Array.prototype;b.lastIndexOf=a._isNative(c.lastIndexOf)?function(e,g,f){return f||f===0?e.lastIndexOf(g,f):e.lastIndexOf(g);}:function(f,j,h){var e=f.length,g=e-1;if(h||h===0){g=Math.min(h<0?e+h:h,e);}if(g>-1&&e>0){for(;g>-1;--g){if(g in f&&f[g]===j){return g;}}}return -1;};b.unique=function(f,l){var k=0,e=f.length,h=[],m,g;for(;k<e;++k){m=f[k];for(g=h.length;g>-1;--g){if(m===h[g]){break;}}if(g===-1){h.push(m);}}if(l){if(a.isNumber(h[0])){h.sort(b.numericSort);}else{h.sort();}}return h;};b.filter=a._isNative(c.filter)?function(e,g,h){return e.filter(g,h);}:function(g,l,m){var j=0,e=g.length,h=[],k;for(;j<e;++j){if(j in g){k=g[j];if(l.call(m,k,j,g)){h.push(k);}}}return h;};b.reject=function(e,g,h){return b.filter(e,function(k,j,f){return !g.call(h,k,j,f);});};b.every=a._isNative(c.every)?function(e,g,h){return e.every(g,h);}:function(g,j,k){for(var h=0,e=g.length;h<e;++h){if(h in g&&!j.call(k,g[h],h,g)){return false;}}return true;};b.map=a._isNative(c.map)?function(e,g,h){return e.map(g,h);}:function(g,k,l){var j=0,e=g.length,h=g.concat();for(;j<e;++j){if(j in g){h[j]=k.call(l,g[j],j,g);}}return h;};b.reduce=a._isNative(c.reduce)?function(e,i,g,h){return e.reduce(function(l,k,j,f){return g.call(h,l,k,j,f);},i);}:function(h,m,k,l){var j=0,g=h.length,e=m;for(;j<g;++j){if(j in h){e=k.call(l,e,h[j],j,h);}}return e;};b.find=function(g,j,k){for(var h=0,e=g.length;h<e;h++){if(h in g&&j.call(k,g[h],h,g)){return g[h];}}return null;};b.grep=function(e,f){return b.filter(e,function(h,g){return f.test(h);});};b.partition=function(e,h,i){var g={matches:[],rejects:[]};b.each(e,function(j,f){var k=h.call(i,j,f,e)?g.matches:g.rejects;k.push(j);});return g;};b.zip=function(f,e){var g=[];b.each(f,function(i,h){g.push([i,e[h]]);});return g;};},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("querystring-parse",function(e){var b=e.namespace("QueryString"),d=function(f){return function g(l,n){var h,m,k,j,i;if(arguments.length!==2){l=l.split(f);return g(b.unescape(l.shift()),b.unescape(l.join(f)));}l=l.replace(/^\s+|\s+$/g,"");if(e.Lang.isString(n)){n=n.replace(/^\s+|\s+$/g,"");if(!isNaN(n)){m=+n;if(n===m.toString(10)){n=m;}}}h=/(.*)\[([^\]]*)\]$/.exec(l);if(!h){i={};if(l){i[l]=n;}return i;}j=h[2];k=h[1];if(!j){return g(k,[n]);}i={};i[j]=n;return g(k,i);};},c=function(g,f){return((!g)?f:(e.Lang.isArray(g))?g.concat(f):(!e.Lang.isObject(g)||!e.Lang.isObject(f))?[g].concat(f):a(g,f));},a=function(h,f){for(var g in f){if(g&&f.hasOwnProperty(g)){h[g]=c(h[g],f[g]);}}return h;};b.parse=function(g,h,f){return e.Array.reduce(e.Array.map(g.split(h||"&"),d(f||"=")),{},c);};b.unescape=function(f){return decodeURIComponent(f.replace(/\+/g," "));};},"3.5.0",{requires:["array-extras","yui-base"],supersedes:["querystring-parse-simple"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("querystring-stringify",function(d){var c=d.namespace("QueryString"),b=[],a=d.Lang;c.escape=encodeURIComponent;c.stringify=function(k,o,e){var g,j,m,h,f,t,r=o&&o.sep?o.sep:"&",p=o&&o.eq?o.eq:"=",q=o&&o.arrayKey?o.arrayKey:false;if(a.isNull(k)||a.isUndefined(k)||a.isFunction(k)){return e?c.escape(e)+p:"";}if(a.isBoolean(k)||Object.prototype.toString.call(k)==="[object Boolean]"){k=+k;}if(a.isNumber(k)||a.isString(k)){return c.escape(e)+p+c.escape(k);}if(a.isArray(k)){t=[];e=q?e+"[]":e;h=k.length;for(m=0;m<h;m++){t.push(c.stringify(k[m],o,e));}return t.join(r);}for(m=b.length-1;m>=0;--m){if(b[m]===k){throw new Error("QueryString.stringify. Cyclical reference");}}b.push(k);t=[];g=e?e+"[":"";j=e?"]":"";for(m in k){if(k.hasOwnProperty(m)){f=g+m+j;t.push(c.stringify(k[m],o,f));}}b.pop();t=t.join(r);if(!t&&e){return e+"=";}return t;};},"3.5.0",{requires:["yui-base"],supersedes:["querystring-stringify-simple"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("escape",function(c){var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;","`":"&#x60;"},b={html:function(d){return(d+"").replace(/[&<>"'\/`]/g,b._htmlReplacer);},regex:function(d){return(d+"").replace(/[\-$\^*()+\[\]{}|\\,.?\s]/g,"\\$&");},_htmlReplacer:function(d){return a[d];}};b.regexp=b.regex;c.Escape=b;},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("cookie",function(c){var k=c.Lang,i=c.Object,g=null,d=k.isString,n=k.isObject,f=k.isUndefined,e=k.isFunction,h=encodeURIComponent,b=decodeURIComponent,m=c.config.doc;function j(o){throw new TypeError(o);}function l(o){if(!d(o)||o===""){j("Cookie name must be a non-empty string.");}}function a(o){if(!d(o)||o===""){j("Subcookie name must be a non-empty string.");}}c.Cookie={_createCookieString:function(q,t,r,p){p=p||{};var v=h(q)+"="+(r?h(t):t),o=p.expires,u=p.path,s=p.domain;if(n(p)){if(o instanceof Date){v+="; expires="+o.toUTCString();}if(d(u)&&u!==""){v+="; path="+u;}if(d(s)&&s!==""){v+="; domain="+s;}if(p.secure===true){v+="; secure";}}return v;},_createCookieHashString:function(o){if(!n(o)){j("Cookie._createCookieHashString(): Argument must be an object.");}var p=[];i.each(o,function(r,q){if(!e(r)&&!f(r)){p.push(h(q)+"="+h(String(r)));}});return p.join("&");},_parseCookieHash:function(s){var r=s.split("&"),t=g,q={};if(s.length){for(var p=0,o=r.length;p<o;p++){t=r[p].split("=");q[b(t[0])]=b(t[1]);}}return q;},_parseCookieString:function(w,y){var x={};if(d(w)&&w.length>0){var o=(y===false?function(z){return z;}:b),u=w.split(/;\s/g),v=g,p=g,r=g;for(var q=0,s=u.length;q<s;q++){r=u[q].match(/([^=]+)=/i);if(r instanceof Array){try{v=b(r[1]);p=o(u[q].substring(r[1].length+1));}catch(t){}}else{v=b(u[q]);p="";}x[v]=p;}}return x;},_setDoc:function(o){m=o;},exists:function(o){l(o);var p=this._parseCookieString(m.cookie,true);return p.hasOwnProperty(o);},get:function(p,o){l(p);var s,q,r;if(e(o)){r=o;o={};}else{if(n(o)){r=o.converter;}else{o={};}}s=this._parseCookieString(m.cookie,!o.raw);q=s[p];if(f(q)){return g;}if(!e(r)){return q;}else{return r(q);}},getSub:function(o,q,p){var r=this.getSubs(o);if(r!==g){a(q);if(f(r[q])){return g;}if(!e(p)){return r[q];}else{return p(r[q]);}}else{return g;}},getSubs:function(o){l(o);var p=this._parseCookieString(m.cookie,false);if(d(p[o])){return this._parseCookieHash(p[o]);}return g;},remove:function(p,o){l(p);o=c.merge(o||{},{expires:new Date(0)});return this.set(p,"",o);},removeSub:function(p,s,o){l(p);a(s);o=o||{};var r=this.getSubs(p);if(n(r)&&r.hasOwnProperty(s)){delete r[s];if(!o.removeIfEmpty){return this.setSubs(p,r,o);}else{for(var q in r){if(r.hasOwnProperty(q)&&!e(r[q])&&!f(r[q])){return this.setSubs(p,r,o);}}return this.remove(p,o);}}else{return"";}},set:function(p,q,o){l(p);if(f(q)){j("Cookie.set(): Value cannot be undefined.");}o=o||{};var r=this._createCookieString(p,q,!o.raw,o);m.cookie=r;return r;},setSub:function(p,r,q,o){l(p);a(r);if(f(q)){j("Cookie.setSub(): Subcookie value cannot be undefined.");}var s=this.getSubs(p);if(!n(s)){s={};}s[r]=q;return this.setSubs(p,s,o);},setSubs:function(p,q,o){l(p);if(!n(q)){j("Cookie.setSubs(): Cookie value must be an object.");}var r=this._createCookieString(p,this._createCookieHashString(q),false,o);m.cookie=r;return r;}};},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("transition",function(b){var i="",h="",f=b.config.doc,r="documentElement",s="transition",k="Transition",m,j,p,a,n,c,l,t,q={},g=["Webkit","Moz"],e={Webkit:"webkitTransitionEnd"},d=function(){this.init.apply(this,arguments);};d._toCamel=function(u){u=u.replace(/-([a-z])/gi,function(w,v){return v.toUpperCase();});return u;};d._toHyphen=function(u){u=u.replace(/([A-Z]?)([a-z]+)([A-Z]?)/g,function(y,x,w,v){var z=((x)?"-"+x.toLowerCase():"")+w;if(v){z+="-"+v.toLowerCase();}return z;});return u;};d.SHOW_TRANSITION="fadeIn";d.HIDE_TRANSITION="fadeOut";d.useNative=false;b.Array.each(g,function(v){var u=v+k;if(u in f[r].style){i=v;h=d._toHyphen(v)+"-";d.useNative=true;d.supported=true;d._VENDOR_PREFIX=v;}});k=i+k;m=i+"TransitionProperty";j=h+"transition-property";p=h+"transition-duration";a=h+"transition-timing-function";n=h+"transition-delay";c="transitionend";l="on"+i.toLowerCase()+"transitionend";c=e[i]||c;t=i+"Transform";d.fx={};d.toggles={};d._hasEnd={};d._reKeywords=/^(?:node|duration|iterations|easing|delay|on|onstart|onend)$/i;b.Node.DOM_EVENTS[c]=1;d.NAME="transition";d.DEFAULT_EASING="ease";d.DEFAULT_DURATION=0.5;d.DEFAULT_DELAY=0;d._nodeAttrs={};d.prototype={constructor:d,init:function(v,u){var w=this;w._node=v;if(!w._running&&u){w._config=u;v._transition=w;w._duration=("duration" in u)?u.duration:w.constructor.DEFAULT_DURATION;w._delay=("delay" in u)?u.delay:w.constructor.DEFAULT_DELAY;w._easing=u.easing||w.constructor.DEFAULT_EASING;w._count=0;w._running=false;}return w;},addProperty:function(v,x){var A=this,y=this._node,C=b.stamp(y),B=b.one(y),F=d._nodeAttrs[C],z,E,u,D,w;if(!F){F=d._nodeAttrs[C]={};}D=F[v];if(x&&x.value!==undefined){w=x.value;}else{if(x!==undefined){w=x;x=q;}}if(typeof w==="function"){w=w.call(B,B);}if(D&&D.transition){if(D.transition!==A){D.transition._count--;}}A._count++;u=((typeof x.duration!="undefined")?x.duration:A._duration)||0.0001;F[v]={value:w,duration:u,delay:(typeof x.delay!="undefined")?x.delay:A._delay,easing:x.easing||A._easing,transition:A};z=b.DOM.getComputedStyle(y,v);E=(typeof w==="string")?z:parseFloat(z);if(d.useNative&&E===w){setTimeout(function(){A._onNativeEnd.call(y,{propertyName:v,elapsedTime:u});},u*1000);}},removeProperty:function(w){var v=this,u=d._nodeAttrs[b.stamp(v._node)];if(u&&u[w]){delete u[w];v._count--;}},initAttrs:function(v){var u,w=this._node;if(v.transform&&!v[t]){v[t]=v.transform;delete v.transform;}for(u in v){if(v.hasOwnProperty(u)&&!d._reKeywords.test(u)){this.addProperty(u,v[u]);if(w.style[u]===""){b.DOM.setStyle(w,u,b.DOM.getComputedStyle(w,u));}}}},run:function(y){var x=this,v=x._node,u=x._config,w={type:"transition:start",config:u};if(!x._running){x._running=true;if(u.on&&u.on.start){u.on.start.call(b.one(v),w);}x.initAttrs(x._config);x._callback=y;x._start();}return x;},_start:function(){this._runNative();},_prepDur:function(u){u=parseFloat(u);return u+"s";},_runNative:function(w){var C=this,x=C._node,E=b.stamp(x),v=x.style,A=x.ownerDocument.defaultView.getComputedStyle(x),I=d._nodeAttrs[E],y="",J=A[d._toCamel(j)],H=j+": ",B=p+": ",G=a+": ",D=n+": ",z,F,u;if(J!=="all"){H+=J+",";B+=A[d._toCamel(p)]+",";G+=A[d._toCamel(a)]+",";D+=A[d._toCamel(n)]+",";}for(u in I){z=d._toHyphen(u);F=I[u];if((F=I[u])&&F.transition===C){if(u in x.style){B+=C._prepDur(F.duration)+",";D+=C._prepDur(F.delay)+",";G+=(F.easing)+",";H+=z+",";y+=z+": "+F.value+"; ";}else{this.removeProperty(u);}}}H=H.replace(/,$/,";");B=B.replace(/,$/,";");G=G.replace(/,$/,";");D=D.replace(/,$/,";");if(!d._hasEnd[E]){x.addEventListener(c,C._onNativeEnd,"");d._hasEnd[E]=true;}v.cssText+=H+B+G+D+y;},_end:function(u){var y=this,w=y._node,A=y._callback,v=y._config,x={type:"transition:end",config:v,elapsedTime:u},z=b.one(w);y._running=false;y._callback=null;if(w){if(v.on&&v.on.end){setTimeout(function(){v.on.end.call(z,x);if(A){A.call(z,x);}},1);}else{if(A){setTimeout(function(){A.call(z,x);},1);}}}},_endNative:function(u){var v=this._node,w=v.ownerDocument.defaultView.getComputedStyle(v,"")[d._toCamel(j)];u=d._toHyphen(u);if(typeof w==="string"){w=w.replace(new RegExp("(?:^|,\\s)"+u+",?"),",");w=w.replace(/^,|,$/,"");v.style[k]=w;}},_onNativeEnd:function(B){var x=this,A=b.stamp(x),u=B,v=d._toCamel(u.propertyName),E=u.elapsedTime,D=d._nodeAttrs[A],C=D[v],y=(C)?C.transition:null,z,w;if(y){y.removeProperty(v);y._endNative(v);w=y._config[v];z={type:"propertyEnd",propertyName:v,elapsedTime:E,config:w};if(w&&w.on&&w.on.end){w.on.end.call(b.one(x),z);}if(y._count<=0){y._end(E);x.style[m]="";}}},destroy:function(){var v=this,u=v._node;if(u){u.removeEventListener(c,v._onNativeEnd,false);v._node=null;}}};b.Transition=d;b.TransitionNative=d;b.Node.prototype.transition=function(w,v,A){var u=d._nodeAttrs[b.stamp(this._node)],y=(u)?u.transition||null:null,x,z;if(typeof w==="string"){if(typeof v==="function"){A=v;v=null;}x=d.fx[w];if(v&&typeof v!=="boolean"){v=b.clone(v);for(z in x){if(x.hasOwnProperty(z)){if(!(z in v)){v[z]=x[z];}}}}else{v=x;}}else{A=v;v=w;}if(y&&!y._running){y.init(this,v);}else{y=new d(this._node,v);}y.run(A);return this;};b.Node.prototype.show=function(v,u,w){this._show();if(v&&b.Transition){if(typeof v!=="string"&&!v.push){if(typeof u==="function"){w=u;u=v;}v=d.SHOW_TRANSITION;}this.transition(v,u,w);}return this;};var o=function(v,u,w){return function(){if(u){u.call(v);}if(w){w.apply(v._node,arguments);}};};b.Node.prototype.hide=function(v,u,w){if(v&&b.Transition){if(typeof u==="function"){w=u;u=null;}w=o(this,this._hide,w);if(typeof v!=="string"&&!v.push){if(typeof u==="function"){w=u;u=v;}v=d.HIDE_TRANSITION;}this.transition(v,u,w);}else{this._hide();}return this;};b.NodeList.prototype.transition=function(v,y){var u=this._nodes,w=0,x;while((x=u[w++])){b.one(x).transition(v,y);}return this;};b.Node.prototype.toggleView=function(v,u,w){this._toggles=this._toggles||[];w=arguments[arguments.length-1];if(typeof v=="boolean"){u=v;v=null;}v=v||b.Transition.DEFAULT_TOGGLE;if(typeof u=="undefined"&&v in this._toggles){u=!this._toggles[v];}u=(u)?1:0;if(u){this._show();
}else{w=o(this,this._hide,w);}this._toggles[v]=u;this.transition(b.Transition.toggles[v][u],w);return this;};b.NodeList.prototype.toggleView=function(w,u,z){var v=this._nodes,x=0,y;while((y=v[x++])){b.one(y).toggleView(w,u,z);}return this;};b.mix(d.fx,{fadeOut:{opacity:0,duration:0.5,easing:"ease-out"},fadeIn:{opacity:1,duration:0.5,easing:"ease-in"},sizeOut:{height:0,width:0,duration:0.75,easing:"ease-out"},sizeIn:{height:function(u){return u.get("scrollHeight")+"px";},width:function(u){return u.get("scrollWidth")+"px";},duration:0.5,easing:"ease-in",on:{start:function(){var u=this.getStyle("overflow");if(u!=="hidden"){this.setStyle("overflow","hidden");this._transitionOverflow=u;}},end:function(){if(this._transitionOverflow){this.setStyle("overflow",this._transitionOverflow);delete this._transitionOverflow;}}}}});b.mix(d.toggles,{size:["sizeOut","sizeIn"],fade:["fadeOut","fadeIn"]});d.DEFAULT_TOGGLE="fade";},"3.5.0",{requires:["node-style"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("querystring-stringify-simple",function(c){var b=c.namespace("QueryString"),a=encodeURIComponent;b.stringify=function(j,k){var d=[],h=k&&k.arrayKey?true:false,g,f,e;for(g in j){if(j.hasOwnProperty(g)){if(c.Lang.isArray(j[g])){for(f=0,e=j[g].length;f<e;f++){d.push(a(h?g+"[]":g)+"="+a(j[g][f]));}}else{d.push(a(g)+"="+a(j[g]));}}}return d.join("&");};},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("io-base",function(a){var h=["start","complete","end","success","failure","progress"],b=["status","statusText","responseText","responseXML"],f=a.config.win,g=0;function c(j){var k=this;k._uid="io:"+g++;k._init(j);a.io._map[k._uid]=k;}c.prototype={_id:0,_headers:{"X-Requested-With":"XMLHttpRequest"},_timeout:{},_init:function(k){var m=this,l,j;m.cfg=k||{};a.augment(m,a.EventTarget);for(l=0,j=h.length;l<j;++l){m.publish("io:"+h[l],a.merge({broadcast:1},k));m.publish("io-trn:"+h[l],k);}},_create:function(k,p){var o=this,n={id:a.Lang.isNumber(p)?p:o._id++,uid:o._uid},m=k.xdr?k.xdr.use:null,l=k.form&&k.form.upload?"iframe":null,j;if(m==="native"){m=a.UA.ie?"xdr":null;}j=m||l;n=j?a.merge(a.IO.customTransport(j),n):a.merge(a.IO.defaultTransport(),n);if(n.notify){k.notify=function(r,q,s){o.notify(r,q,s);};}if(!j){if(f&&f.FormData&&k.data instanceof FormData){n.c.upload.onprogress=function(q){o.progress(n,q,k);};n.c.onload=function(q){o.load(n,q,k);};n.c.onerror=function(q){o.error(n,q,k);};n.upload=true;}}return n;},_destroy:function(j){if(f&&!j.notify&&!j.xdr){if(d&&!j.upload){j.c.onreadystatechange=null;}else{if(j.upload){j.c.upload.onprogress=null;j.c.onload=null;j.c.onerror=null;}else{if(a.UA.ie&&!j.e){j.c.abort();}}}}j=j.c=null;},_evt:function(n,k,j){var p=this,l,q=j["arguments"],r=p.cfg.emitFacade,m="io:"+n,o="io-trn:"+n;this.detach(o);if(k.e){k.c={status:0,statusText:k.e};}l=[r?{id:k.id,data:k.c,cfg:j,"arguments":q}:k.id];if(!r){if(n===h[0]||n===h[2]){if(q){l.push(q);}}else{if(k.evt){l.push(k.evt);}else{l.push(k.c);}if(q){l.push(q);}}}l.unshift(m);p.fire.apply(p,l);if(j.on){l[0]=o;p.once(o,j.on[n],j.context||a);p.fire.apply(p,l);}},start:function(k,j){this._evt(h[0],k,j);},complete:function(k,j){this._evt(h[1],k,j);},end:function(k,j){this._evt(h[2],k,j);this._destroy(k);},success:function(k,j){this._evt(h[3],k,j);this.end(k,j);},failure:function(k,j){this._evt(h[4],k,j);this.end(k,j);},progress:function(l,k,j){l.evt=k;this._evt(h[5],l,j);},load:function(l,k,j){l.evt=k.target;this._evt(h[1],l,j);},error:function(l,k,j){l.evt=k;this._evt(h[4],l,j);},_retry:function(l,k,j){this._destroy(l);j.xdr.use="flash";return this.send(k,j,l.id);},_concat:function(j,k){j+=(j.indexOf("?")===-1?"?":"&")+k;return j;},setHeader:function(j,k){if(k){this._headers[j]=k;}else{delete this._headers[j];}},_setHeaders:function(k,j){j=a.merge(this._headers,j);a.Object.each(j,function(m,l){if(m!=="disable"){k.setRequestHeader(l,j[l]);}});},_startTimeout:function(k,j){var l=this;l._timeout[k.id]=setTimeout(function(){l._abort(k,"timeout");},j);},_clearTimeout:function(j){clearTimeout(this._timeout[j]);delete this._timeout[j];},_result:function(m,k){var j;try{j=m.c.status;}catch(l){j=0;}if(j>=200&&j<300||j===304||j===1223){this.success(m,k);}else{this.failure(m,k);}},_rS:function(k,j){var l=this;if(k.c.readyState===4){if(j.timeout){l._clearTimeout(k.id);}setTimeout(function(){l.complete(k,j);l._result(k,j);},0);}},_abort:function(k,j){if(k&&k.c){k.e=j;k.c.abort();}},send:function(l,m,k){var n,j,q,r,v,p,t=this,w=l,o={};m=m?a.Object(m):{};n=t._create(m,k);j=m.method?m.method.toUpperCase():"GET";v=m.sync;p=m.data;if((a.Lang.isObject(p)&&!p.nodeType)&&!n.upload){p=a.QueryString.stringify(p);}if(m.form){if(m.form.upload){return t.upload(n,l,m);}else{p=t._serialize(m.form,p);}}if(p){switch(j){case"GET":case"HEAD":case"DELETE":w=t._concat(w,p);p="";break;case"POST":case"PUT":m.headers=a.merge({"Content-Type":"application/x-www-form-urlencoded; charset=UTF-8"},m.headers);break;}}if(n.xdr){return t.xdr(w,n,m);}else{if(n.notify){return n.c.send(n,l,m);}}if(!v&&!n.upload){n.c.onreadystatechange=function(){t._rS(n,m);};}try{n.c.open(j,w,!v,m.username||null,m.password||null);t._setHeaders(n.c,m.headers||{});t.start(n,m);if(m.xdr&&m.xdr.credentials){if(!a.UA.ie){n.c.withCredentials=true;}}n.c.send(p);if(v){for(q=0,r=b.length;q<r;++q){o[b[q]]=n.c[b[q]];}o.getAllResponseHeaders=function(){return n.c.getAllResponseHeaders();};o.getResponseHeader=function(u){return n.c.getResponseHeader(u);};t.complete(n,m);t._result(n,m);return o;}}catch(s){if(n.xdr){return t._retry(n,l,m);}else{t.complete(n,m);t._result(n,m);}}if(m.timeout){t._startTimeout(n,m.timeout);}return{id:n.id,abort:function(){return n.c?t._abort(n,"abort"):false;},isInProgress:function(){return n.c?(n.c.readyState%4):false;},io:t};}};a.io=function(k,j){var l=a.io._map["io:0"]||new c();return l.send.apply(l,[k,j]);};a.io.header=function(j,k){var l=a.io._map["io:0"]||new c();l.setHeader(j,k);};a.IO=c;a.io._map={};var d=f&&f.XMLHttpRequest,i=f&&f.XDomainRequest,e=f&&f.ActiveXObject;a.mix(a.IO,{_default:"xhr",defaultTransport:function(k){if(k){a.IO._default=k;}else{var j={c:a.IO.transports[a.IO._default](),notify:a.IO._default==="xhr"?false:true};return j;}},transports:{xhr:function(){return d?new XMLHttpRequest():e?new ActiveXObject("Microsoft.XMLHTTP"):null;},xdr:function(){return i?new XDomainRequest():null;},iframe:function(){return{};},flash:null,nodejs:null},customTransport:function(k){var j={c:a.IO.transports[k]()};j[(k==="xdr"||k==="flash")?"xdr":"notify"]=true;return j;}});a.mix(a.IO.prototype,{notify:function(k,l,j){var m=this;switch(k){case"timeout":case"abort":case"transport error":l.c={status:0,statusText:k};k="failure";default:m[k].apply(m,[l,j]);}}});},"3.5.0",{requires:["event-custom-base","querystring-stringify-simple"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("datatype-xml-parse",function(b){var a=b.Lang;b.mix(b.namespace("DataType.XML"),{parse:function(f){var d=null;if(a.isString(f)){try{if(!a.isUndefined(ActiveXObject)){d=new ActiveXObject("Microsoft.XMLDOM");d.async=false;d.loadXML(f);}}catch(c){try{if(!a.isUndefined(DOMParser)){d=new DOMParser().parseFromString(f,"text/xml");}}catch(g){}}}if((a.isNull(d))||(a.isNull(d.documentElement))||(d.documentElement.nodeName==="parsererror")){}return d;}});b.namespace("Parsers").xml=b.DataType.XML.parse;},"3.5.0");/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("io-xdr",function(a){var k=a.publish("io:xdrReady",{fireOnce:true}),e={},g={},j=a.config.doc,l=a.config.win,f=l&&l.XDomainRequest;function h(m,q,d){var n='<object id="io_swf" type="application/x-shockwave-flash" data="'+m+'" width="0" height="0">'+'<param name="movie" value="'+m+'">'+'<param name="FlashVars" value="yid='+q+"&uid="+d+'">'+'<param name="allowScriptAccess" value="always">'+"</object>",p=j.createElement("div");j.body.appendChild(p);p.innerHTML=n;}function b(p,m,n){if(m==="flash"){p.c.responseText=decodeURI(p.c.responseText);}if(n==="xml"){p.c.responseXML=a.DataType.XML.parse(p.c.responseText);}return p;}function i(d,m){return d.c.abort(d.id,m);}function c(d){return f?g[d.id]!==4:d.c.isInProgress(d.id);}a.mix(a.IO.prototype,{_transport:{},_ieEvt:function(n,q){var p=this,m=n.id,d="timeout";n.c.onprogress=function(){g[m]=3;};n.c.onload=function(){g[m]=4;p.xdrResponse("success",n,q);};n.c.onerror=function(){g[m]=4;p.xdrResponse("failure",n,q);};if(q[d]){n.c.ontimeout=function(){g[m]=4;p.xdrResponse(d,n,q);};n.c[d]=q[d];}},xdr:function(d,m,p){var n=this;if(p.xdr.use==="flash"){e[m.id]=p;l.setTimeout(function(){try{m.c.send(d,{id:m.id,uid:m.uid,method:p.method,data:p.data,headers:p.headers});}catch(o){n.xdrResponse("transport error",m,p);delete e[m.id];}},a.io.xdr.delay);}else{if(f){n._ieEvt(m,p);m.c.open(p.method||"GET",d);m.c.send(p.data);}else{m.c.send(d,m,p);}}return{id:m.id,abort:function(){return m.c?i(m,p):false;},isInProgress:function(){return m.c?c(m.id):false;},io:n};},xdrResponse:function(q,s,v){v=e[s.id]?e[s.id]:v;var t=this,n=f?g:e,p=v.xdr.use,r=v.xdr.dataType;switch(q){case"start":t.start(s,v);break;case"success":t.success(b(s,p,r),v);delete n[s.id];break;case"timeout":case"abort":case"transport error":s.c={status:0,statusText:q};case"failure":t.failure(b(s,p,r),v);delete n[s.id];break;}},_xdrReady:function(m,d){a.fire(k,m,d);},transport:function(d){if(d.id==="flash"){h(a.UA.ie?d.src+"?d="+new Date().valueOf().toString():d.src,a.id,d.uid);a.IO.transports.flash=function(){return j.getElementById("io_swf");};}}});a.io.xdrReady=function(n,d){var m=a.io._map[d];a.io.xdr.delay=0;m._xdrReady.apply(m,[n,d]);};a.io.xdrResponse=function(d,m,p){var n=a.io._map[m.uid];n.xdrResponse.apply(n,[d,m,p]);};a.io.transport=function(m){var d=a.io._map["io:0"]||new a.IO();m.uid=d._uid;d.transport.apply(d,[m]);};a.io.xdr={delay:100};},"3.5.0",{requires:["io-base","datatype-xml-parse"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("io-form",function(b){var a=encodeURIComponent;b.mix(b.IO.prototype,{_serialize:function(w,B){var q=[],y=w.useDisabled||false,A=0,g=(typeof w.id==="string")?w.id:w.id.getAttribute("id"),t,r,k,z,u,p,x,l,m,h;if(!g){g=b.guid("io:");w.id.setAttribute("id",g);}r=b.config.doc.getElementById(g);for(p=0,x=r.elements.length;p<x;++p){t=r.elements[p];u=t.disabled;k=t.name;if(y?k:k&&!u){k=a(k)+"=";z=a(t.value);switch(t.type){case"select-one":if(t.selectedIndex>-1){h=t.options[t.selectedIndex];q[A++]=k+a(h.attributes.value&&h.attributes.value.specified?h.value:h.text);}break;case"select-multiple":if(t.selectedIndex>-1){for(l=t.selectedIndex,m=t.options.length;l<m;++l){h=t.options[l];if(h.selected){q[A++]=k+a(h.attributes.value&&h.attributes.value.specified?h.value:h.text);}}}break;case"radio":case"checkbox":if(t.checked){q[A++]=k+z;}break;case"file":case undefined:case"reset":case"button":break;case"submit":default:q[A++]=k+z;}}}return B?q.join("&")+"&"+B:q.join("&");}},true);},"3.5.0",{requires:["io-base","node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("io-upload-iframe",function(g){var b=g.config.win,f=g.config.doc,c=(f.documentMode&&f.documentMode>=8),a=decodeURIComponent;function h(j,l,k){var d=g.Node.create('<iframe src="#" id="io_iframe'+j.id+'" name="io_iframe'+j.id+'" />');d._node.style.position="absolute";d._node.style.top="-1000px";d._node.style.left="-1000px";g.one("body").appendChild(d);g.on("load",function(){k._uploadComplete(j,l);},"#io_iframe"+j.id);}function e(d){g.Event.purgeElement("#io_iframe"+d,false);g.one("body").removeChild(g.one("#io_iframe"+d));}g.mix(g.IO.prototype,{_addData:function(p,n){if(g.Lang.isObject(n)){n=g.QueryString.stringify(n);}var q=[],d=n.split("="),k,j;for(k=0,j=d.length-1;k<j;k++){q[k]=f.createElement("input");q[k].type="hidden";q[k].name=a(d[k].substring(d[k].lastIndexOf("&")+1));q[k].value=(k+1===j)?a(d[k+1]):a(d[k+1].substring(0,(d[k+1].lastIndexOf("&"))));p.appendChild(q[k]);}return q;},_removeData:function(k,m){var j,d;for(j=0,d=m.length;j<d;j++){k.removeChild(m[j]);}},_setAttrs:function(i,j,d){i.setAttribute("action",d);i.setAttribute("method","POST");i.setAttribute("target","io_iframe"+j);i.setAttribute(g.UA.ie&&!c?"encoding":"enctype","multipart/form-data");},_resetAttrs:function(i,d){g.Object.each(d,function(j,k){if(j){i.setAttribute(k,j);}else{i.removeAttribute(k);}});},_startUploadTimeout:function(d,j){var i=this;i._timeout[d.id]=b.setTimeout(function(){d.status=0;d.statusText="timeout";i.complete(d,j);i.end(d,j);},j.timeout);},_clearUploadTimeout:function(i){var d=this;b.clearTimeout(d._timeout[i]);delete d._timeout[i];},_uploadComplete:function(m,q){var n=this,l=g.one("#io_iframe"+m.id).get("contentWindow.document"),i=l.one("body"),k;if(q.timeout){n._clearUploadTimeout(m.id);}try{if(i){k=i.one("pre:first-child");m.c.responseText=k?k.get("text"):i.get("text");}else{m.c.responseXML=l._node;}}catch(j){m.e="upload failure";}n.complete(m,q);n.end(m,q);b.setTimeout(function(){e(m.id);},0);},_upload:function(l,j,n){var m=this,k=(typeof n.form.id==="string")?f.getElementById(n.form.id):n.form.id,i={action:k.getAttribute("action"),target:k.getAttribute("target")},d;m._setAttrs(k,l.id,j);if(n.data){d=m._addData(k,n.data);}if(n.timeout){m._startUploadTimeout(l,n);}k.submit();m.start(l,n);if(n.data){m._removeData(k,d);}m._resetAttrs(k,i);return{id:l.id,abort:function(){l.status=0;l.statusText="abort";if(g.one("#io_iframe"+l.id)){e(l.id);m.complete(l,n);m.end(l,n);}else{return false;}},isInProgress:function(){return g.one("#io_iframe"+l.id)?true:false;},io:m};},upload:function(i,d,j){h(i,j,this);return this._upload(i,d,j);}});},"3.5.0",{requires:["io-base","node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("queue-promote",function(a){a.mix(a.Queue.prototype,{indexOf:function(b){return a.Array.indexOf(this._q,b);},promote:function(c){var b=this.indexOf(c);if(b>-1){this._q.unshift(this._q.splice(b,1)[0]);}},remove:function(c){var b=this.indexOf(c);if(b>-1){this._q.splice(b,1);}}});},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("io-queue",function(b){var c=b.io._map["io:0"]||new b.IO();b.mix(b.IO.prototype,{_q:new b.Queue(),_qActiveId:null,_qInit:false,_qState:1,_qShift:function(){var e=this,d=e._q.next();e._qActiveId=d.id;e._qState=0;e.send(d.uri,d.cfg,d.id);},queue:function(d,g){var f=this,e={uri:d,cfg:g,id:this._id++};if(!f._qInit){b.on("io:complete",function(i,h){f._qNext(i);},f);f._qInit=true;}f._q.add(e);if(f._qState===1){f._qShift();}return e;},_qNext:function(e){var d=this;d._qState=1;if(d._qActiveId===e&&d._q.size()>0){d._qShift();}},qPromote:function(d){this._q.promote(d);},qRemove:function(d){this._q.remove(d);},qStart:function(){var d=this;d._qState=1;if(d._q.size()>0){d._qShift();}},qStop:function(){this._qState=0;},qSize:function(){return this._q.size();}},true);function a(d,e){return c.queue.apply(c,[d,e]);}a.start=function(){c.qStart();};a.stop=function(){c.qStop();};a.promote=function(d){c.qPromote(d);};a.remove=function(d){c.qRemove(d);};a.size=function(){c.qSize();};b.io.queue=a;},"3.5.0",{requires:["io-base","queue-promote"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("json-parse",function(b){function k(e){return(b.config.win||this||{})[e];}var j=k("JSON"),l=(Object.prototype.toString.call(j)==="[object JSON]"&&j),f=!!l,o=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,m=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,d=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,g=/(?:^|:|,)(?:\s*\[)+/g,p=/[^\],:{}\s]/,n=function(e){return"\\u"+("0000"+(+(e.charCodeAt(0))).toString(16)).slice(-4);},c=function(r,e){var q=function(x,u){var t,s,w=x[u];if(w&&typeof w==="object"){for(t in w){if(w.hasOwnProperty(t)){s=q(w,t);if(s===undefined){delete w[t];}else{w[t]=s;}}}}return e.call(x,u,w);};return typeof e==="function"?q({"":r},""):r;},h=function(q,e){q=q.replace(o,n);if(!p.test(q.replace(m,"@").replace(d,"]").replace(g,""))){return c(eval("("+q+")"),e);}throw new SyntaxError("JSON.parse");};b.namespace("JSON").parse=function(q,e){if(typeof q!=="string"){q+="";}return l&&b.JSON.useNativeParse?l.parse(q,e):h(q,e);};function a(q,e){return q==="ok"?true:e;}if(l){try{f=(l.parse('{"ok":false}',a)).ok;}catch(i){f=false;}}b.JSON.useNativeParse=f;},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("json-stringify",function(b){var j=(b.config.win||{}).JSON,N=b.Lang,p=N.isFunction,I=N.isObject,v=N.isArray,k=Object.prototype.toString,C=(k.call(j)==="[object JSON]"&&j),F=!!C,D="undefined",r="object",A="null",L="string",B="number",x="boolean",l="date",E={"undefined":D,"string":L,"[object String]":L,"number":B,"[object Number]":B,"boolean":x,"[object Boolean]":x,"[object Date]":l,"[object RegExp]":r},g="",q="{",a="}",y="[",i="]",s=",",c=",\n",m="\n",G=":",h=": ",u='"',d=/[\x00-\x07\x0b\x0e-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,n=[[/\\/g,"\\\\"],[/\"/g,'\\"'],[/\x08/g,"\\b"],[/\x09/g,"\\t"],[/\x0a/g,"\\n"],[/\x0c/g,"\\f"],[/\x0d/g,"\\r"]],t=n.length,f={},o,H;function O(P){var e=typeof P;return E[e]||E[k.call(P)]||(e===r?(P?r:A):D);}function K(e){if(!f[e]){f[e]="\\u"+("0000"+(+(e.charCodeAt(0))).toString(16)).slice(-4);o[e]=0;}if(++o[e]===H){n.push([new RegExp(e,"g"),f[e]]);t=n.length;}return f[e];}function w(Q){var e,P;for(e=0;e<t;e++){P=n[e];Q=Q.replace(P[0],P[1]);}return u+Q.replace(d,K)+u;}function z(e,P){return e.replace(/^/gm,P);}function J(P,X,e){if(P===undefined){return undefined;}var R=p(X)?X:null,W=k.call(e).match(/String|Number/)||[],Y=b.JSON.dateToString,V=[],T,S,U;o={};H=b.JSON.charCacheThreshold;if(R||!v(X)){X=undefined;}if(X){T={};for(S=0,U=X.length;S<U;++S){T[X[S]]=true;}X=T;}e=W[0]==="Number"?new Array(Math.min(Math.max(0,e),10)+1).join(" "):(e||g).slice(0,10);function Q(ab,ah){var af=ab[ah],aj=O(af),ae=[],ad=e?h:G,ac,aa,ai,Z,ag;if(I(af)&&p(af.toJSON)){af=af.toJSON(ah);}else{if(aj===l){af=Y(af);}}if(p(R)){af=R.call(ab,ah,af);}if(af!==ab[ah]){aj=O(af);}switch(aj){case l:case r:break;case L:return w(af);case B:return isFinite(af)?af+g:A;case x:return af+g;case A:return A;default:return undefined;}for(aa=V.length-1;aa>=0;--aa){if(V[aa]===af){throw new Error("JSON.stringify. Cyclical reference");}}ac=v(af);V.push(af);if(ac){for(aa=af.length-1;aa>=0;--aa){ae[aa]=Q(af,aa)||A;}}else{ai=X||af;aa=0;for(Z in ai){if(ai.hasOwnProperty(Z)){ag=Q(af,Z);if(ag){ae[aa++]=w(Z)+ad+ag;}}}}V.pop();if(e&&ae.length){return ac?y+m+z(ae.join(c),e)+m+i:q+m+z(ae.join(c),e)+m+a;}else{return ac?y+ae.join(s)+i:q+ae.join(s)+a;}}return Q({"":P},"");}if(C){try{F=("0"===C.stringify(0));}catch(M){F=false;}}b.mix(b.namespace("JSON"),{useNativeStringify:F,dateToString:function(P){function e(Q){return Q<10?"0"+Q:Q;}return P.getUTCFullYear()+"-"+e(P.getUTCMonth()+1)+"-"+e(P.getUTCDate())+"T"+e(P.getUTCHours())+G+e(P.getUTCMinutes())+G+e(P.getUTCSeconds())+"Z";},stringify:function(Q,e,P){return C&&b.JSON.useNativeStringify?C.stringify(Q,e,P):J(Q,e,P);},charCacheThreshold:100});},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("intl",function(d){var b={},a="yuiRootLang",e="yuiActiveLang",c=[];d.mix(d.namespace("Intl"),{_mod:function(f){if(!b[f]){b[f]={};}return b[f];},setLang:function(g,j){var i=this._mod(g),f=i[e],h=!!i[j];if(h&&j!==f){i[e]=j;this.fire("intl:langChange",{module:g,prevVal:f,newVal:(j===a)?"":j});}return h;},getLang:function(f){var g=this._mod(f)[e];return(g===a)?"":g;},add:function(g,h,f){h=h||a;this._mod(g)[h]=f;this.setLang(g,h);},get:function(h,g,j){var f=this._mod(h),i;j=j||f[e];i=f[j]||{};return(g)?i[g]:d.merge(i);},getAvailableLangs:function(h){var f=d.Env._loader,g=f&&f.moduleInfo[h],i=g&&g.lang;return(i)?i.concat():c;}});d.augment(d.Intl,d.EventTarget);d.Intl.publish("intl:langChange",{emitFacade:true});},"3.5.0",{requires:["event-custom","intl-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("substitute",function(c){var g=c.Lang,e="dump",h=" ",b="{",i="}",j=/(~-(\d+)-~)/g,a=/\{LBRACE\}/g,d=/\{RBRACE\}/g,f=function(B,m,u,l){var r,q,p,z,y,A,x=[],n,t,w=B.length;for(;;){r=B.lastIndexOf(b,w);if(r<0){break;}q=B.indexOf(i,r);if(r+1>=q){break;}n=B.substring(r+1,q);z=n;A=null;p=z.indexOf(h);if(p>-1){A=z.substring(p+1);z=z.substring(0,p);}y=m[z];if(u){y=u(z,y,A);}if(g.isObject(y)){if(!c.dump){y=y.toString();}else{if(g.isArray(y)){y=c.dump(y,parseInt(A,10));}else{A=A||"";t=A.indexOf(e);if(t>-1){A=A.substring(4);}if(y.toString===Object.prototype.toString||t>-1){y=c.dump(y,parseInt(A,10));}else{y=y.toString();}}}}else{if(g.isUndefined(y)){y="~-"+x.length+"-~";x.push(n);}}B=B.substring(0,r)+y+B.substring(q+1);if(!l){w=r-1;}}return B.replace(j,function(s,o,k){return b+x[parseInt(k,10)]+i;}).replace(a,b).replace(d,i);};c.substitute=f;g.substitute=f;},"3.5.0",{optional:["dump"],requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("datatype-date-parse",function(b){var a=b.Lang;b.mix(b.namespace("DataType.Date"),{parse:function(d){var c=null;if(!(a.isDate(d))){c=new Date(d);}else{return c;}if(a.isDate(c)&&(c!="Invalid Date")&&!isNaN(c)){return c;}else{return null;}}});b.namespace("Parsers").date=b.DataType.Date.parse;},"3.5.0");/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("lang/datatype-date-format_en-US",function(a){a.Intl.add("datatype-date-format","en-US",{"a":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"A":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"b":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"B":["January","February","March","April","May","June","July","August","September","October","November","December"],"c":"%a, %b %d, %Y %l:%M:%S %p %Z","p":["AM","PM"],"P":["am","pm"],"x":"%m/%d/%y","X":"%l:%M:%S %p"});},"3.5.0");/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("datatype-date-format",function(d){var a=function(e,g,f){if(typeof f==="undefined"){f=10;}g=g.toString();for(;parseInt(e,10)<f&&f>1;f/=10){e=g+e;}return e.toString();};var c={formats:{a:function(f,e){return e.a[f.getDay()];},A:function(f,e){return e.A[f.getDay()];},b:function(f,e){return e.b[f.getMonth()];},B:function(f,e){return e.B[f.getMonth()];},C:function(e){return a(parseInt(e.getFullYear()/100,10),0);},d:["getDate","0"],e:["getDate"," "],g:function(e){return a(parseInt(c.formats.G(e)%100,10),0);},G:function(g){var h=g.getFullYear();var f=parseInt(c.formats.V(g),10);var e=parseInt(c.formats.W(g),10);if(e>f){h++;}else{if(e===0&&f>=52){h--;}}return h;},H:["getHours","0"],I:function(f){var e=f.getHours()%12;return a(e===0?12:e,0);},j:function(i){var h=new Date(""+i.getFullYear()+"/1/1 GMT");var f=new Date(""+i.getFullYear()+"/"+(i.getMonth()+1)+"/"+i.getDate()+" GMT");var e=f-h;var g=parseInt(e/60000/60/24,10)+1;return a(g,0,100);},k:["getHours"," "],l:function(f){var e=f.getHours()%12;return a(e===0?12:e," ");},m:function(e){return a(e.getMonth()+1,0);},M:["getMinutes","0"],p:function(f,e){return e.p[f.getHours()>=12?1:0];},P:function(f,e){return e.P[f.getHours()>=12?1:0];},s:function(f,e){return parseInt(f.getTime()/1000,10);},S:["getSeconds","0"],u:function(e){var f=e.getDay();return f===0?7:f;},U:function(h){var e=parseInt(c.formats.j(h),10);var g=6-h.getDay();var f=parseInt((e+g)/7,10);return a(f,0);},V:function(h){var g=parseInt(c.formats.W(h),10);var e=(new Date(""+h.getFullYear()+"/1/1")).getDay();var f=g+(e>4||e<=1?0:1);if(f===53&&(new Date(""+h.getFullYear()+"/12/31")).getDay()<4){f=1;}else{if(f===0){f=c.formats.V(new Date(""+(h.getFullYear()-1)+"/12/31"));}}return a(f,0);},w:"getDay",W:function(h){var e=parseInt(c.formats.j(h),10);var g=7-c.formats.u(h);var f=parseInt((e+g)/7,10);return a(f,0,10);},y:function(e){return a(e.getFullYear()%100,0);},Y:"getFullYear",z:function(g){var f=g.getTimezoneOffset();var e=a(parseInt(Math.abs(f/60),10),0);var h=a(Math.abs(f%60),0);return(f>0?"-":"+")+e+h;},Z:function(e){var f=e.toString().replace(/^.*:\d\d( GMT[+-]\d+)? \(?([A-Za-z ]+)\)?\d*$/,"$2").replace(/[a-z ]/g,"");if(f.length>4){f=c.formats.z(e);}return f;},"%":function(e){return"%";}},aggregates:{c:"locale",D:"%m/%d/%y",F:"%Y-%m-%d",h:"%b",n:"\n",r:"%I:%M:%S %p",R:"%H:%M",t:"\t",T:"%H:%M:%S",x:"locale",X:"locale"},format:function(o,j){j=j||{};if(!d.Lang.isDate(o)){return d.Lang.isValue(o)?o:"";}var n,e,i,g,m;n=j.format||d.config.dateFormat||"%Y-%m-%d";i=d.Lang.isUndefined(d.config.lang)&&(d.Lang.isValue(j.locale)||d.Lang.isValue(d.config.locale));if(i){g=j.locale||d.config.locale;m=d.DataType.Date.Locale;g=g.replace(/_/g,"-");if(!m[g]){var h=g.replace(/-[a-zA-Z]+$/,"");if(h in m){g=h;}else{if(d.config.locale in m){g=d.config.locale;}else{g="en";}}}e=m[g];}else{e=d.Intl.get("datatype-date-format");}var k=function(q,p){if(i&&p==="r"){return e[p];}var r=c.aggregates[p];return(r==="locale"?e[p]:r);};var f=function(q,p){var r=c.formats[p];switch(d.Lang.type(r)){case"string":return o[r]();case"function":return r.call(o,o,e);case"array":if(d.Lang.type(r[0])==="string"){return a(o[r[0]](),r[1]);}default:return p;}};while(n.match(/%[cDFhnrRtTxX]/)){n=n.replace(/%([cDFhnrRtTxX])/g,k);}var l=n.replace(/%([aAbBCdegGHIjklmMpPsSuUVwWyYzZ%])/g,f);k=f=undefined;return l;}};d.mix(d.namespace("DataType.Date"),c);var b={a:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],A:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],b:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],B:["January","February","March","April","May","June","July","August","September","October","November","December"],c:"%a %d %b %Y %T %Z",p:["AM","PM"],P:["am","pm"],r:"%I:%M:%S %p",x:"%d/%m/%y",X:"%T"};d.namespace("DataType.Date.Locale");d.DataType.Date.Locale["en"]=b;d.DataType.Date.Locale["en-US"]=d.merge(b,{c:"%a %d %b %Y %I:%M:%S %p %Z",x:"%m/%d/%Y",X:"%I:%M:%S %p"});d.DataType.Date.Locale["en-GB"]=d.merge(b,{r:"%l:%M:%S %P %Z"});d.DataType.Date.Locale["en-AU"]=d.merge(b);},"3.5.0",{lang:["ar","ar-JO","ca","ca-ES","da","da-DK","de","de-AT","de-DE","el","el-GR","en","en-AU","en-CA","en-GB","en-IE","en-IN","en-JO","en-MY","en-NZ","en-PH","en-SG","en-US","es","es-AR","es-BO","es-CL","es-CO","es-EC","es-ES","es-MX","es-PE","es-PY","es-US","es-UY","es-VE","fi","fi-FI","fr","fr-BE","fr-CA","fr-FR","hi","hi-IN","id","id-ID","it","it-IT","ja","ja-JP","ko","ko-KR","ms","ms-MY","nb","nb-NO","nl","nl-BE","nl-NL","pl","pl-PL","pt","pt-BR","ro","ro-RO","ru","ru-RU","sv","sv-SE","th","th-TH","tr","tr-TR","vi","vi-VN","zh-Hans","zh-Hans-CN","zh-Hant","zh-Hant-HK","zh-Hant-TW"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-stdmod",function(b){var f=b.Lang,q=b.Node,x=b.UA,e=b.Widget,d="",J="hd",G="bd",j="ft",D="header",M="body",K="footer",N="fillHeight",m="stdmod",u="Node",I="Content",C="firstChild",h="childNodes",n="ownerDocument",v="contentBox",z="height",F="offsetHeight",y="auto",l="headerContentChange",B="bodyContentChange",o="footerContentChange",r="fillHeightChange",t="heightChange",O="contentUpdate",w="renderUI",E="bindUI",g="syncUI",H="_applyParsedConfig",s=b.Widget.UI_SRC;function P(L){this._stdModNode=this.get(v);b.before(this._renderUIStdMod,this,w);b.before(this._bindUIStdMod,this,E);b.before(this._syncUIStdMod,this,g);}P.HEADER=D;P.BODY=M;P.FOOTER=K;P.AFTER="after";P.BEFORE="before";P.REPLACE="replace";var k=P.HEADER,A=P.BODY,p=P.FOOTER,a=k+I,c=p+I,i=A+I;P.ATTRS={headerContent:{value:null},footerContent:{value:null},bodyContent:{value:null},fillHeight:{value:P.BODY,validator:function(L){return this._validateFillHeight(L);}}};P.HTML_PARSER={headerContent:function(L){return this._parseStdModHTML(k);},bodyContent:function(L){return this._parseStdModHTML(A);},footerContent:function(L){return this._parseStdModHTML(p);}};P.SECTION_CLASS_NAMES={header:e.getClassName(J),body:e.getClassName(G),footer:e.getClassName(j)};P.TEMPLATES={header:'<div class="'+P.SECTION_CLASS_NAMES[k]+'"></div>',body:'<div class="'+P.SECTION_CLASS_NAMES[A]+'"></div>',footer:'<div class="'+P.SECTION_CLASS_NAMES[p]+'"></div>'};P.prototype={_syncUIStdMod:function(){var L=this._stdModParsed;if(!L||!L[a]){this._uiSetStdMod(k,this.get(a));}if(!L||!L[i]){this._uiSetStdMod(A,this.get(i));}if(!L||!L[c]){this._uiSetStdMod(p,this.get(c));}this._uiSetFillHeight(this.get(N));},_renderUIStdMod:function(){this._stdModNode.addClass(e.getClassName(m));this._renderStdModSections();this.after(l,this._afterHeaderChange);this.after(B,this._afterBodyChange);this.after(o,this._afterFooterChange);},_renderStdModSections:function(){if(f.isValue(this.get(a))){this._renderStdMod(k);}if(f.isValue(this.get(i))){this._renderStdMod(A);}if(f.isValue(this.get(c))){this._renderStdMod(p);}},_bindUIStdMod:function(){this.after(r,this._afterFillHeightChange);this.after(t,this._fillHeight);this.after(O,this._fillHeight);},_afterHeaderChange:function(L){if(L.src!==s){this._uiSetStdMod(k,L.newVal,L.stdModPosition);}},_afterBodyChange:function(L){if(L.src!==s){this._uiSetStdMod(A,L.newVal,L.stdModPosition);}},_afterFooterChange:function(L){if(L.src!==s){this._uiSetStdMod(p,L.newVal,L.stdModPosition);}},_afterFillHeightChange:function(L){this._uiSetFillHeight(L.newVal);},_validateFillHeight:function(L){return !L||L==P.BODY||L==P.HEADER||L==P.FOOTER;},_uiSetFillHeight:function(R){var Q=this.getStdModNode(R);var L=this._currFillNode;if(L&&Q!==L){L.setStyle(z,d);}if(Q){this._currFillNode=Q;}this._fillHeight();},_fillHeight:function(){if(this.get(N)){var L=this.get(z);if(L!=d&&L!=y){this.fillHeight(this._currFillNode);}}},_uiSetStdMod:function(S,R,L){if(f.isValue(R)){var Q=this.getStdModNode(S,true);this._addStdModContent(Q,R,L);this.set(S+I,this._getStdModContent(S),{src:s});}else{this._eraseStdMod(S);}this.fire(O);},_renderStdMod:function(R){var L=this.get(v),Q=this._findStdModSection(R);if(!Q){Q=this._getStdModTemplate(R);}this._insertStdModSection(L,R,Q);this[R+u]=Q;return this[R+u];},_eraseStdMod:function(Q){var L=this.getStdModNode(Q);if(L){L.remove(true);delete this[Q+u];}},_insertStdModSection:function(L,S,R){var Q=L.get(C);if(S===p||!Q){L.appendChild(R);}else{if(S===k){L.insertBefore(R,Q);}else{var T=this[p+u];if(T){L.insertBefore(R,T);}else{L.appendChild(R);}}}},_getStdModTemplate:function(L){return q.create(P.TEMPLATES[L],this._stdModNode.get(n));},_addStdModContent:function(R,Q,L){switch(L){case P.BEFORE:L=0;break;case P.AFTER:L=undefined;break;default:L=P.REPLACE;}R.insert(Q,L);},_getPreciseHeight:function(R){var L=(R)?R.get(F):0,S="getBoundingClientRect";if(R&&R.hasMethod(S)){var Q=R.invoke(S);if(Q){L=Q.bottom-Q.top;}}return L;},_findStdModSection:function(L){return this.get(v).one("> ."+P.SECTION_CLASS_NAMES[L]);},_parseStdModHTML:function(Q){var L=this._findStdModSection(Q);if(L){if(!this._stdModParsed){this._stdModParsed={};b.before(this._applyStdModParsedConfig,this,H);}this._stdModParsed[Q+I]=1;return L.get("innerHTML");}return null;},_applyStdModParsedConfig:function(S,L,R){var Q=this._stdModParsed;if(Q){Q[a]=!(a in L)&&(a in Q);Q[i]=!(i in L)&&(i in Q);Q[c]=!(c in L)&&(c in Q);}},_getStdModContent:function(L){return(this[L+u])?this[L+u].get(h):null;},setStdModContent:function(R,Q,L){this.set(R+I,Q,{stdModPosition:L});},getStdModNode:function(R,Q){var L=this[R+u]||null;if(!L&&Q){L=this._renderStdMod(R);}return L;},fillHeight:function(Q){if(Q){var V=this.get(v),W=[this.headerNode,this.bodyNode,this.footerNode],L,X,Y=0,T=0,S=false;for(var U=0,R=W.length;U<R;U++){L=W[U];if(L){if(L!==Q){Y+=this._getPreciseHeight(L);}else{S=true;}}}if(S){if(x.ie||x.opera){Q.set(F,0);}X=V.get(F)-parseInt(V.getComputedStyle("paddingTop"),10)-parseInt(V.getComputedStyle("paddingBottom"),10)-parseInt(V.getComputedStyle("borderBottomWidth"),10)-parseInt(V.getComputedStyle("borderTopWidth"),10);if(f.isNumber(X)){T=X-Y;if(T>=0){Q.set(F,T);}}}}}};b.WidgetStdMod=P;},"3.5.0",{requires:["base-build","widget"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-position",function(a){var i=a.Lang,l=a.Widget,n="xy",j="position",g="positioned",k="boundingBox",h="relative",m="renderUI",f="bindUI",d="syncUI",c=l.UI_SRC,e="xyChange";function b(o){this._posNode=this.get(k);a.after(this._renderUIPosition,this,m);a.after(this._syncUIPosition,this,d);a.after(this._bindUIPosition,this,f);}b.ATTRS={x:{setter:function(o){this._setX(o);},getter:function(){return this._getX();},lazyAdd:false},y:{setter:function(o){this._setY(o);},getter:function(){return this._getY();},lazyAdd:false},xy:{value:[0,0],validator:function(o){return this._validateXY(o);}}};b.POSITIONED_CLASS_NAME=l.getClassName(g);b.prototype={_renderUIPosition:function(){this._posNode.addClass(b.POSITIONED_CLASS_NAME);},_syncUIPosition:function(){var o=this._posNode;if(o.getStyle(j)===h){this.syncXY();}this._uiSetXY(this.get(n));},_bindUIPosition:function(){this.after(e,this._afterXYChange);},move:function(){var o=arguments,p=(i.isArray(o[0]))?o[0]:[o[0],o[1]];this.set(n,p);},syncXY:function(){this.set(n,this._posNode.getXY(),{src:c});},_validateXY:function(o){return(i.isArray(o)&&i.isNumber(o[0])&&i.isNumber(o[1]));},_setX:function(o){this.set(n,[o,this.get(n)[1]]);},_setY:function(o){this.set(n,[this.get(n)[0],o]);},_getX:function(){return this.get(n)[0];},_getY:function(){return this.get(n)[1];},_afterXYChange:function(o){if(o.src!=c){this._uiSetXY(o.newVal);}},_uiSetXY:function(o){this._posNode.setXY(o);}};a.WidgetPosition=b;},"3.5.0",{requires:["base-build","node-screen","widget"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-position-align",function(a){var f=a.Lang,d="align",b="alignOn",g="visible",i="boundingBox",e="offsetWidth",j="offsetHeight",h="region",k="viewportRegion";function c(l){if(!this._posNode){a.error("WidgetPosition needs to be added to the Widget, "+"before WidgetPositionAlign is added");}a.after(this._bindUIPosAlign,this,"bindUI");a.after(this._syncUIPosAlign,this,"syncUI");}c.ATTRS={align:{value:null},centered:{setter:"_setAlignCenter",lazyAdd:false,value:false},alignOn:{value:[],validator:a.Lang.isArray}};c.TL="tl";c.TR="tr";c.BL="bl";c.BR="br";c.TC="tc";c.RC="rc";c.BC="bc";c.LC="lc";c.CC="cc";c.prototype={_posAlignUIHandles:null,destructor:function(){this._detachPosAlignUIHandles();},_bindUIPosAlign:function(){this.after("alignChange",this._afterAlignChange);this.after("alignOnChange",this._afterAlignOnChange);this.after("visibleChange",this._syncUIPosAlign);},_syncUIPosAlign:function(){var l=this.get(d);this._uiSetVisiblePosAlign(this.get(g));if(l){this._uiSetAlign(l.node,l.points);}},align:function(m,l){if(arguments.length){this.set(d,{node:m,points:l});}else{this._syncUIPosAlign();}return this;},centered:function(l){return this.align(l,[c.CC,c.CC]);},_setAlignCenter:function(l){if(l){this.set(d,{node:l===true?null:l,points:[c.CC,c.CC]});}return l;},_uiSetAlign:function(o,n){if(!f.isArray(n)||n.length!==2){a.error("align: Invalid Points Arguments");return;}var m=this._getRegion(o),l,p,q;if(!m){return;}l=n[0];p=n[1];switch(p){case c.TL:q=[m.left,m.top];break;case c.TR:q=[m.right,m.top];break;case c.BL:q=[m.left,m.bottom];break;case c.BR:q=[m.right,m.bottom];break;case c.TC:q=[m.left+Math.floor(m.width/2),m.top];break;case c.BC:q=[m.left+Math.floor(m.width/2),m.bottom];break;case c.LC:q=[m.left,m.top+Math.floor(m.height/2)];break;case c.RC:q=[m.right,m.top+Math.floor(m.height/2)];break;case c.CC:q=[m.left+Math.floor(m.width/2),m.top+Math.floor(m.height/2)];break;default:break;}if(q){this._doAlign(l,q[0],q[1]);}},_uiSetVisiblePosAlign:function(l){if(l){this._attachPosAlignUIHandles();}else{this._detachPosAlignUIHandles();}},_attachPosAlignUIHandles:function(){if(this._posAlignUIHandles){return;}var n=this.get(i),m=a.bind(this._syncUIPosAlign,this),l=[];a.Array.each(this.get(b),function(r){var q=r.eventName,p=a.one(r.node)||n;if(q){l.push(p.on(q,m));}});this._posAlignUIHandles=l;},_detachPosAlignUIHandles:function(){var l=this._posAlignUIHandles;if(l){new a.EventHandle(l).detach();this._posAlignUIHandles=null;}},_doAlign:function(m,l,p){var o=this._posNode,n;switch(m){case c.TL:n=[l,p];break;case c.TR:n=[l-o.get(e),p];break;case c.BL:n=[l,p-o.get(j)];break;case c.BR:n=[l-o.get(e),p-o.get(j)];break;case c.TC:n=[l-(o.get(e)/2),p];break;case c.BC:n=[l-(o.get(e)/2),p-o.get(j)];break;case c.LC:n=[l,p-(o.get(j)/2)];break;case c.RC:n=[l-o.get(e),p-(o.get(j)/2)];break;case c.CC:n=[l-(o.get(e)/2),p-(o.get(j)/2)];break;default:break;}if(n){this.move(n);}},_getRegion:function(m){var l;if(!m){l=this._posNode.get(k);}else{m=a.Node.one(m);if(m){l=m.get(h);}}return l;},_afterAlignChange:function(l){var m=l.newVal;if(m){this._uiSetAlign(m.node,m.points);}},_afterAlignOnChange:function(l){this._detachPosAlignUIHandles();if(this.get(g)){this._attachPosAlignUIHandles();}}};a.WidgetPositionAlign=c;},"3.5.0",{requires:["widget-position"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-stack",function(e){var m=e.Lang,s=e.UA,B=e.Node,f=e.Widget,A="zIndex",o="shim",y="visible",C="boundingBox",v="renderUI",g="bindUI",r="syncUI",p="offsetWidth",d="offsetHeight",l="parentNode",a="firstChild",w="ownerDocument",h="width",u="height",k="px",n="shimdeferred",D="shimresize",x="visibleChange",c="widthChange",j="heightChange",z="shimChange",b="zIndexChange",i="contentUpdate",q="stacked";function t(E){this._stackNode=this.get(C);this._stackHandles={};e.after(this._renderUIStack,this,v);e.after(this._syncUIStack,this,r);e.after(this._bindUIStack,this,g);}t.ATTRS={shim:{value:(s.ie==6)},zIndex:{value:0,setter:"_setZIndex"}};t.HTML_PARSER={zIndex:function(E){return this._parseZIndex(E);}};t.SHIM_CLASS_NAME=f.getClassName(o);t.STACKED_CLASS_NAME=f.getClassName(q);t.SHIM_TEMPLATE='<iframe class="'+t.SHIM_CLASS_NAME+'" frameborder="0" title="Widget Stacking Shim" src="javascript:false" tabindex="-1" role="presentation"></iframe>';t.prototype={_syncUIStack:function(){this._uiSetShim(this.get(o));this._uiSetZIndex(this.get(A));},_bindUIStack:function(){this.after(z,this._afterShimChange);this.after(b,this._afterZIndexChange);},_renderUIStack:function(){this._stackNode.addClass(t.STACKED_CLASS_NAME);},_parseZIndex:function(E){var F;if(!E.inDoc()||E.getStyle("position")==="static"){F="auto";}else{F=E.getComputedStyle("zIndex");}return F==="auto"?null:F;},_setZIndex:function(E){if(m.isString(E)){E=parseInt(E,10);}if(!m.isNumber(E)){E=0;}return E;},_afterShimChange:function(E){this._uiSetShim(E.newVal);},_afterZIndexChange:function(E){this._uiSetZIndex(E.newVal);},_uiSetZIndex:function(E){this._stackNode.setStyle(A,E);},_uiSetShim:function(E){if(E){if(this.get(y)){this._renderShim();}else{this._renderShimDeferred();}if(s.ie==6){this._addShimResizeHandlers();}}else{this._destroyShim();}},_renderShimDeferred:function(){this._stackHandles[n]=this._stackHandles[n]||[];var F=this._stackHandles[n],E=function(G){if(G.newVal){this._renderShim();}};F.push(this.on(x,E));},_addShimResizeHandlers:function(){this._stackHandles[D]=this._stackHandles[D]||[];var F=this.sizeShim,E=this._stackHandles[D];E.push(this.after(x,F));E.push(this.after(c,F));E.push(this.after(j,F));E.push(this.after(i,F));},_detachStackHandles:function(E){var F=this._stackHandles[E],G;if(F&&F.length>0){while((G=F.pop())){G.detach();}}},_renderShim:function(){var E=this._shimNode,F=this._stackNode;if(!E){E=this._shimNode=this._getShimTemplate();F.insertBefore(E,F.get(a));this._detachStackHandles(n);this.sizeShim();}},_destroyShim:function(){if(this._shimNode){this._shimNode.get(l).removeChild(this._shimNode);this._shimNode=null;this._detachStackHandles(n);this._detachStackHandles(D);}},sizeShim:function(){var F=this._shimNode,E=this._stackNode;if(F&&s.ie===6&&this.get(y)){F.setStyle(h,E.get(p)+k);F.setStyle(u,E.get(d)+k);}},_getShimTemplate:function(){return B.create(t.SHIM_TEMPLATE,this._stackNode.get(w));}};e.WidgetStack=t;},"3.5.0",{requires:["base-build","widget"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("widget-position-constrain",function(c){var f="constrain",d="constrain|xyChange",b="constrainChange",n="preventOverlap",e="align",o="",g="bindUI",i="xy",a="x",m="y",j=c.Node,p="viewportRegion",l="region",k;function h(q){if(!this._posNode){c.error("WidgetPosition needs to be added to the Widget, before WidgetPositionConstrain is added");}c.after(this._bindUIPosConstrained,this,g);}h.ATTRS={constrain:{value:null,setter:"_setConstrain"},preventOverlap:{value:false}};k=h._PREVENT_OVERLAP={x:{"tltr":1,"blbr":1,"brbl":1,"trtl":1},y:{"trbr":1,"tlbl":1,"bltl":1,"brtr":1}};h.prototype={getConstrainedXY:function(t,s){s=s||this.get(f);var r=this._getRegion((s===true)?null:s),q=this._posNode.get(l);return[this._constrain(t[0],a,q,r),this._constrain(t[1],m,q,r)];},constrain:function(u,r){var t,q,s=r||this.get(f);if(s){t=u||this.get(i);q=this.getConstrainedXY(t,s);if(q[0]!==t[0]||q[1]!==t[1]){this.set(i,q,{constrained:true});}}},_setConstrain:function(q){return(q===true)?q:j.one(q);},_constrain:function(q,r,z,s){if(s){if(this.get(n)){q=this._preventOverlap(q,r,z,s);}var v=(r==a),y=(v)?s.width:s.height,u=(v)?z.width:z.height,t=(v)?s.left:s.top,w=(v)?s.right-u:s.bottom-u;if(q<t||q>w){if(u<y){if(q<t){q=t;}else{if(q>w){q=w;}}}else{q=t;}}}return q;},_preventOverlap:function(r,s,C,t){var w=this.get(e),B=(s===a),z,v,u,y,A,q;if(w&&w.points&&k[s][w.points.join(o)]){v=this._getRegion(w.node);if(v){z=(B)?C.width:C.height;u=(B)?v.left:v.top;y=(B)?v.right:v.bottom;A=(B)?v.left-t.left:v.top-t.top;q=(B)?t.right-v.right:t.bottom-v.bottom;}if(r>u){if(q<z&&A>z){r=u-z;}}else{if(A<z&&q>z){r=y;}}}return r;},_bindUIPosConstrained:function(){this.after(b,this._afterConstrainChange);this._enableConstraints(this.get(f));},_afterConstrainChange:function(q){this._enableConstraints(q.newVal);},_enableConstraints:function(q){if(q){this.constrain();this._cxyHandle=this._cxyHandle||this.on(d,this._constrainOnXYChange);}else{if(this._cxyHandle){this._cxyHandle.detach();this._cxyHandle=null;}}},_constrainOnXYChange:function(q){if(!q.constrained){q.newVal=this.getConstrainedXY(q.newVal);}},_getRegion:function(q){var r;if(!q){r=this._posNode.get(p);}else{q=j.one(q);if(q){r=q.get(l);}}return r;}};c.WidgetPositionConstrain=h;},"3.5.0",{requires:["widget-position"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("overlay",function(a){a.Overlay=a.Base.create("overlay",a.Widget,[a.WidgetStdMod,a.WidgetPosition,a.WidgetStack,a.WidgetPositionAlign,a.WidgetPositionConstrain]);},"3.5.0",{requires:["widget","widget-stdmod","widget-position","widget-stack","widget-position-align","widget-position-constrain"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("yui-throttle",function(a){
/*! Based on work by Simon Willison: http://gist.github.com/292562 */
a.throttle=function(c,b){b=(b)?b:(a.config.throttleTime||150);if(b===-1){return(function(){c.apply(null,arguments);});}var d=a.Lang.now();return(function(){var e=a.Lang.now();if(e-d>b){d=e;c.apply(null,arguments);}});};},"3.5.0",{requires:["yui-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-ddm-base",function(b){var a=function(){a.superclass.constructor.apply(this,arguments);};a.NAME="ddm";a.ATTRS={dragCursor:{value:"move"},clickPixelThresh:{value:3},clickTimeThresh:{value:1000},throttleTime:{value:-1},dragMode:{value:"point",setter:function(c){this._setDragMode(c);return c;}}};b.extend(a,b.Base,{_createPG:function(){},_active:null,_setDragMode:function(c){if(c===null){c=b.DD.DDM.get("dragMode");}switch(c){case 1:case"intersect":return 1;case 2:case"strict":return 2;case 0:case"point":return 0;}return 0;},CSS_PREFIX:b.ClassNameManager.getClassName("dd"),_activateTargets:function(){},_drags:[],activeDrag:false,_regDrag:function(c){if(this.getDrag(c.get("node"))){return false;}if(!this._active){this._setupListeners();}this._drags.push(c);return true;},_unregDrag:function(e){var c=[];b.each(this._drags,function(f,d){if(f!==e){c[c.length]=f;}});this._drags=c;},_setupListeners:function(){this._createPG();this._active=true;var c=b.one(b.config.doc);c.on("mousemove",b.throttle(b.bind(this._move,this),this.get("throttleTime")));c.on("mouseup",b.bind(this._end,this));},_start:function(){this.fire("ddm:start");this._startDrag();},_startDrag:function(){},_endDrag:function(){},_dropMove:function(){},_end:function(){if(this.activeDrag){this._endDrag();this.fire("ddm:end");this.activeDrag.end.call(this.activeDrag);this.activeDrag=null;}},stopDrag:function(){if(this.activeDrag){this._end();}return this;},_move:function(c){if(this.activeDrag){this.activeDrag._move.call(this.activeDrag,c);this._dropMove();}},cssSizestoObject:function(d){var c=d.split(" ");switch(c.length){case 1:c[1]=c[2]=c[3]=c[0];break;case 2:c[2]=c[0];c[3]=c[1];break;case 3:c[3]=c[1];break;}return{top:parseInt(c[0],10),right:parseInt(c[1],10),bottom:parseInt(c[2],10),left:parseInt(c[3],10)};},getDrag:function(d){var c=false,e=b.one(d);if(e instanceof b.Node){b.each(this._drags,function(g,f){if(e.compareTo(g.get("node"))){c=g;}});}return c;},swapPosition:function(d,c){d=b.DD.DDM.getNode(d);c=b.DD.DDM.getNode(c);var f=d.getXY(),e=c.getXY();d.setXY(e);c.setXY(f);return d;},getNode:function(c){if(c instanceof b.Node){return c;}if(c&&c.get){if(b.Widget&&(c instanceof b.Widget)){c=c.get("boundingBox");}else{c=c.get("node");}}else{c=b.one(c);}return c;},swapNode:function(e,c){e=b.DD.DDM.getNode(e);c=b.DD.DDM.getNode(c);var f=c.get("parentNode"),d=c.get("nextSibling");if(d==e){f.insertBefore(e,c);}else{if(c==e.get("nextSibling")){f.insertBefore(c,e);}else{e.get("parentNode").replaceChild(c,e);f.insertBefore(e,d);}}return e;}});b.namespace("DD");b.DD.DDM=new a();},"3.5.0",{skinnable:false,requires:["node","base","yui-throttle","classnamemanager"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-drag",function(d){var e=d.DD.DDM,r="node",g="dragging",m="dragNode",c="offsetHeight",k="offsetWidth",h="drag:mouseDown",b="drag:afterMouseDown",f="drag:removeHandle",l="drag:addHandle",p="drag:removeInvalid",q="drag:addInvalid",j="drag:start",i="drag:end",n="drag:drag",o="drag:align",a=function(t){this._lazyAddAttrs=false;a.superclass.constructor.apply(this,arguments);var s=e._regDrag(this);if(!s){d.error("Failed to register node, already in use: "+t.node);}};a.NAME="drag";a.START_EVENT="mousedown";a.ATTRS={node:{setter:function(s){if(this._canDrag(s)){return s;}var t=d.one(s);if(!t){d.error("DD.Drag: Invalid Node Given: "+s);}return t;}},dragNode:{setter:function(s){if(this._canDrag(s)){return s;}var t=d.one(s);if(!t){d.error("DD.Drag: Invalid dragNode Given: "+s);}return t;}},offsetNode:{value:true},startCentered:{value:false},clickPixelThresh:{value:e.get("clickPixelThresh")},clickTimeThresh:{value:e.get("clickTimeThresh")},lock:{value:false,setter:function(s){if(s){this.get(r).addClass(e.CSS_PREFIX+"-locked");}else{this.get(r).removeClass(e.CSS_PREFIX+"-locked");}return s;}},data:{value:false},move:{value:true},useShim:{value:true},activeHandle:{value:false},primaryButtonOnly:{value:true},dragging:{value:false},parent:{value:false},target:{value:false,setter:function(s){this._handleTarget(s);return s;}},dragMode:{value:null,setter:function(s){return e._setDragMode(s);}},groups:{value:["default"],getter:function(){if(!this._groups){this._groups={};}var s=[];d.each(this._groups,function(u,t){s[s.length]=t;});return s;},setter:function(s){this._groups={};d.each(s,function(u,t){this._groups[u]=true;},this);return s;}},handles:{value:null,setter:function(s){if(s){this._handles={};d.each(s,function(u,t){var w=u;if(u instanceof d.Node||u instanceof d.NodeList){w=u._yuid;}this._handles[w]=u;},this);}else{this._handles=null;}return s;}},bubbles:{setter:function(s){this.addTarget(s);return s;}},haltDown:{value:true}};d.extend(a,d.Base,{_canDrag:function(s){if(s&&s.setXY&&s.getXY&&s.test&&s.contains){return true;}return false;},_bubbleTargets:d.DD.DDM,addToGroup:function(s){this._groups[s]=true;e._activateTargets();return this;},removeFromGroup:function(s){delete this._groups[s];e._activateTargets();return this;},target:null,_handleTarget:function(s){if(d.DD.Drop){if(s===false){if(this.target){e._unregTarget(this.target);this.target=null;}return false;}else{if(!d.Lang.isObject(s)){s={};}s.bubbleTargets=("bubbleTargets" in s)?s.bubbleTargets:d.Object.values(this._yuievt.targets);s.node=this.get(r);s.groups=s.groups||this.get("groups");this.target=new d.DD.Drop(s);}}else{return false;}},_groups:null,_createEvents:function(){this.publish(h,{defaultFn:this._defMouseDownFn,queuable:false,emitFacade:true,bubbles:true,prefix:"drag"});this.publish(o,{defaultFn:this._defAlignFn,queuable:false,emitFacade:true,bubbles:true,prefix:"drag"});this.publish(n,{defaultFn:this._defDragFn,queuable:false,emitFacade:true,bubbles:true,prefix:"drag"});this.publish(i,{defaultFn:this._defEndFn,preventedFn:this._prevEndFn,queuable:false,emitFacade:true,bubbles:true,prefix:"drag"});var s=[b,f,l,p,q,j,"drag:drophit","drag:dropmiss","drag:over","drag:enter","drag:exit"];d.each(s,function(u,t){this.publish(u,{type:u,emitFacade:true,bubbles:true,preventable:false,queuable:false,prefix:"drag"});},this);},_ev_md:null,_startTime:null,_endTime:null,_handles:null,_invalids:null,_invalidsDefault:{"textarea":true,"input":true,"a":true,"button":true,"select":true},_dragThreshMet:null,_fromTimeout:null,_clickTimeout:null,deltaXY:null,startXY:null,nodeXY:null,lastXY:null,actXY:null,realXY:null,mouseXY:null,region:null,_handleMouseUp:function(s){this.fire("drag:mouseup");this._fixIEMouseUp();if(e.activeDrag){e._end();}},_fixDragStart:function(s){s.preventDefault();},_ieSelectFix:function(){return false;},_ieSelectBack:null,_fixIEMouseDown:function(s){if(d.UA.ie){this._ieSelectBack=d.config.doc.body.onselectstart;d.config.doc.body.onselectstart=this._ieSelectFix;}},_fixIEMouseUp:function(){if(d.UA.ie){d.config.doc.body.onselectstart=this._ieSelectBack;}},_handleMouseDownEvent:function(s){this.fire(h,{ev:s});},_defMouseDownFn:function(t){var s=t.ev;this._dragThreshMet=false;this._ev_md=s;if(this.get("primaryButtonOnly")&&s.button>1){return false;}if(this.validClick(s)){this._fixIEMouseDown(s);if(this.get("haltDown")){s.halt();}else{s.preventDefault();}this._setStartPosition([s.pageX,s.pageY]);e.activeDrag=this;this._clickTimeout=d.later(this.get("clickTimeThresh"),this,this._timeoutCheck);}this.fire(b,{ev:s});},validClick:function(w){var v=false,z=false,s=w.target,u=null,t=null,x=null,y=false;if(this._handles){d.each(this._handles,function(A,B){if(A instanceof d.Node||A instanceof d.NodeList){if(!v){x=A;if(x instanceof d.Node){x=new d.NodeList(A._node);}x.each(function(C){if(C.contains(s)){v=true;}});}}else{if(d.Lang.isString(B)){if(s.test(B+", "+B+" *")&&!u){u=B;v=true;}}}});}else{z=this.get(r);if(z.contains(s)||z.compareTo(s)){v=true;}}if(v){if(this._invalids){d.each(this._invalids,function(A,B){if(d.Lang.isString(B)){if(s.test(B+", "+B+" *")){v=false;}}});}}if(v){if(u){t=w.currentTarget.all(u);y=false;t.each(function(B,A){if((B.contains(s)||B.compareTo(s))&&!y){y=true;this.set("activeHandle",B);}},this);}else{this.set("activeHandle",this.get(r));}}return v;},_setStartPosition:function(s){this.startXY=s;this.nodeXY=this.lastXY=this.realXY=this.get(r).getXY();if(this.get("offsetNode")){this.deltaXY=[(this.startXY[0]-this.nodeXY[0]),(this.startXY[1]-this.nodeXY[1])];}else{this.deltaXY=[0,0];}},_timeoutCheck:function(){if(!this.get("lock")&&!this._dragThreshMet&&this._ev_md){this._fromTimeout=this._dragThreshMet=true;this.start();this._alignNode([this._ev_md.pageX,this._ev_md.pageY],true);}},removeHandle:function(t){var s=t;if(t instanceof d.Node||t instanceof d.NodeList){s=t._yuid;}if(this._handles[s]){delete this._handles[s];this.fire(f,{handle:t});}return this;},addHandle:function(t){if(!this._handles){this._handles={};}var s=t;
if(t instanceof d.Node||t instanceof d.NodeList){s=t._yuid;}this._handles[s]=t;this.fire(l,{handle:t});return this;},removeInvalid:function(s){if(this._invalids[s]){this._invalids[s]=null;delete this._invalids[s];this.fire(p,{handle:s});}return this;},addInvalid:function(s){if(d.Lang.isString(s)){this._invalids[s]=true;this.fire(q,{handle:s});}return this;},initializer:function(s){this.get(r).dd=this;if(!this.get(r).get("id")){var t=d.stamp(this.get(r));this.get(r).set("id",t);}this.actXY=[];this._invalids=d.clone(this._invalidsDefault,true);this._createEvents();if(!this.get(m)){this.set(m,this.get(r));}this.on("initializedChange",d.bind(this._prep,this));this.set("groups",this.get("groups"));},_prep:function(){this._dragThreshMet=false;var s=this.get(r);s.addClass(e.CSS_PREFIX+"-draggable");s.on(a.START_EVENT,d.bind(this._handleMouseDownEvent,this));s.on("mouseup",d.bind(this._handleMouseUp,this));s.on("dragstart",d.bind(this._fixDragStart,this));},_unprep:function(){var s=this.get(r);s.removeClass(e.CSS_PREFIX+"-draggable");s.detachAll("mouseup");s.detachAll("dragstart");s.detachAll(a.START_EVENT);this.mouseXY=[];this.deltaXY=[0,0];this.startXY=[];this.nodeXY=[];this.lastXY=[];this.actXY=[];this.realXY=[];},start:function(){if(!this.get("lock")&&!this.get(g)){var t=this.get(r),s,u,v;this._startTime=(new Date()).getTime();e._start();t.addClass(e.CSS_PREFIX+"-dragging");this.fire(j,{pageX:this.nodeXY[0],pageY:this.nodeXY[1],startTime:this._startTime});t=this.get(m);v=this.nodeXY;s=t.get(k);u=t.get(c);if(this.get("startCentered")){this._setStartPosition([v[0]+(s/2),v[1]+(u/2)]);}this.region={"0":v[0],"1":v[1],area:0,top:v[1],right:v[0]+s,bottom:v[1]+u,left:v[0]};this.set(g,true);}return this;},end:function(){this._endTime=(new Date()).getTime();if(this._clickTimeout){this._clickTimeout.cancel();}this._dragThreshMet=this._fromTimeout=false;if(!this.get("lock")&&this.get(g)){this.fire(i,{pageX:this.lastXY[0],pageY:this.lastXY[1],startTime:this._startTime,endTime:this._endTime});}this.get(r).removeClass(e.CSS_PREFIX+"-dragging");this.set(g,false);this.deltaXY=[0,0];return this;},_defEndFn:function(s){this._fixIEMouseUp();this._ev_md=null;},_prevEndFn:function(s){this._fixIEMouseUp();this.get(m).setXY(this.nodeXY);this._ev_md=null;this.region=null;},_align:function(s){this.fire(o,{pageX:s[0],pageY:s[1]});},_defAlignFn:function(s){this.actXY=[s.pageX-this.deltaXY[0],s.pageY-this.deltaXY[1]];},_alignNode:function(s){this._align(s);this._moveNode();},_moveNode:function(s){var t=[],u=[],w=this.nodeXY,v=this.actXY;t[0]=(v[0]-this.lastXY[0]);t[1]=(v[1]-this.lastXY[1]);u[0]=(v[0]-this.nodeXY[0]);u[1]=(v[1]-this.nodeXY[1]);this.region={"0":v[0],"1":v[1],area:0,top:v[1],right:v[0]+this.get(m).get(k),bottom:v[1]+this.get(m).get(c),left:v[0]};this.fire(n,{pageX:v[0],pageY:v[1],scroll:s,info:{start:w,xy:v,delta:t,offset:u}});this.lastXY=v;},_defDragFn:function(s){if(this.get("move")){if(s.scroll){s.scroll.node.set("scrollTop",s.scroll.top);s.scroll.node.set("scrollLeft",s.scroll.left);}this.get(m).setXY([s.pageX,s.pageY]);this.realXY=[s.pageX,s.pageY];}},_move:function(u){if(this.get("lock")){return false;}else{this.mouseXY=[u.pageX,u.pageY];if(!this._dragThreshMet){var t=Math.abs(this.startXY[0]-u.pageX),s=Math.abs(this.startXY[1]-u.pageY);if(t>this.get("clickPixelThresh")||s>this.get("clickPixelThresh")){this._dragThreshMet=true;this.start();this._alignNode([u.pageX,u.pageY]);}}else{if(this._clickTimeout){this._clickTimeout.cancel();}this._alignNode([u.pageX,u.pageY]);}}},stopDrag:function(){if(this.get(g)){e._end();}return this;},destructor:function(){this._unprep();if(this.target){this.target.destroy();}e._unregDrag(this);}});d.namespace("DD");d.DD.Drag=a;},"3.5.0",{skinnable:false,requires:["dd-ddm-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-constrain",function(b){var l="dragNode",n="offsetHeight",e="offsetWidth",q="host",f="tickXArray",o="tickYArray",p=b.DD.DDM,d="top",j="right",m="bottom",c="left",k="view",h=null,i="drag:tickAlignX",g="drag:tickAlignY",a=function(r){this._lazyAddAttrs=false;a.superclass.constructor.apply(this,arguments);};a.NAME="ddConstrained";a.NS="con";a.ATTRS={host:{},stickX:{value:false},stickY:{value:false},tickX:{value:false},tickY:{value:false},tickXArray:{value:false},tickYArray:{value:false},gutter:{value:"0",setter:function(r){return b.DD.DDM.cssSizestoObject(r);}},constrain:{value:k,setter:function(r){var s=b.one(r);if(s){r=s;}return r;}},constrain2region:{setter:function(s){return this.set("constrain",s);}},constrain2node:{setter:function(r){return this.set("constrain",b.one(r));}},constrain2view:{setter:function(r){return this.set("constrain",k);}},cacheRegion:{value:true}};h={_lastTickXFired:null,_lastTickYFired:null,initializer:function(){this._createEvents();this.get(q).on("drag:end",b.bind(this._handleEnd,this));this.get(q).on("drag:start",b.bind(this._handleStart,this));this.get(q).after("drag:align",b.bind(this.align,this));this.get(q).after("drag:drag",b.bind(this.drag,this));},destructor:function(){if(this._cacheHandle){this._cacheHandle.detach();}this._cacheHandle=null;},_createEvents:function(){var r=this;var s=[i,g];b.each(s,function(u,t){this.publish(u,{type:u,emitFacade:true,bubbles:true,queuable:false,prefix:"drag"});},this);},_handleEnd:function(){this._lastTickYFired=null;this._lastTickXFired=null;},_handleStart:function(){this.resetCache();},_regionCache:null,_cacheHandle:null,_cacheRegion:function(){this._regionCache=this.get("constrain").get("region");},resetCache:function(){this._regionCache=null;},_getConstraint:function(){var r=this.get("constrain"),s=this.get("gutter"),t;if(r){if(r instanceof b.Node){if(!this._regionCache){this._cacheHandle=b.on("resize",b.bind(this._cacheRegion,this),b.config.win);this._cacheRegion();}t=b.clone(this._regionCache);if(!this.get("cacheRegion")){this.resetCache();}}else{if(b.Lang.isObject(r)){t=b.clone(r);}}}if(!r||!t){r=k;}if(r===k){t=this.get(q).get(l).get("viewportRegion");}b.each(s,function(u,v){if((v==j)||(v==m)){t[v]-=u;}else{t[v]+=u;}});return t;},getRegion:function(w){var u={},v=null,s=null,t=this.get(q);u=this._getConstraint();if(w){v=t.get(l).get(n);s=t.get(l).get(e);u[j]=u[j]-s;u[m]=u[m]-v;}return u;},_checkRegion:function(s){var u=s,w=this.getRegion(),v=this.get(q),x=v.get(l).get(n),t=v.get(l).get(e);if(u[1]>(w[m]-x)){s[1]=(w[m]-x);}if(w[d]>u[1]){s[1]=w[d];}if(u[0]>(w[j]-t)){s[0]=(w[j]-t);}if(w[c]>u[0]){s[0]=w[c];}return s;},inRegion:function(t){t=t||this.get(q).get(l).getXY();var s=this._checkRegion([t[0],t[1]]),r=false;if((t[0]===s[0])&&(t[1]===s[1])){r=true;}return r;},align:function(){var u=this.get(q),s=[u.actXY[0],u.actXY[1]],t=this.getRegion(true);if(this.get("stickX")){s[1]=(u.startXY[1]-u.deltaXY[1]);}if(this.get("stickY")){s[0]=(u.startXY[0]-u.deltaXY[0]);}if(t){s=this._checkRegion(s);}s=this._checkTicks(s,t);u.actXY=s;},drag:function(v){var u=this.get(q),s=this.get("tickX"),t=this.get("tickY"),r=[u.actXY[0],u.actXY[1]];if((b.Lang.isNumber(s)||this.get(f))&&(this._lastTickXFired!==r[0])){this._tickAlignX();this._lastTickXFired=r[0];}if((b.Lang.isNumber(t)||this.get(o))&&(this._lastTickYFired!==r[1])){this._tickAlignY();this._lastTickYFired=r[1];}},_checkTicks:function(y,w){var v=this.get(q),x=(v.startXY[0]-v.deltaXY[0]),u=(v.startXY[1]-v.deltaXY[1]),s=this.get("tickX"),t=this.get("tickY");if(s&&!this.get(f)){y[0]=p._calcTicks(y[0],x,s,w[c],w[j]);}if(t&&!this.get(o)){y[1]=p._calcTicks(y[1],u,t,w[d],w[m]);}if(this.get(f)){y[0]=p._calcTickArray(y[0],this.get(f),w[c],w[j]);}if(this.get(o)){y[1]=p._calcTickArray(y[1],this.get(o),w[d],w[m]);}return y;},_tickAlignX:function(){this.fire(i);},_tickAlignY:function(){this.fire(g);}};b.namespace("Plugin");b.extend(a,b.Base,h);b.Plugin.DDConstrained=a;b.mix(p,{_calcTicks:function(y,x,u,w,v){var s=((y-x)/u),t=Math.floor(s),r=Math.ceil(s);if((t!==0)||(r!==0)){if((s>=t)&&(s<=r)){y=(x+(u*t));if(w&&v){if(y<w){y=(x+(u*(t+1)));}if(y>v){y=(x+(u*(t-1)));}}}}return y;},_calcTickArray:function(z,A,y,v){var s=0,w=A.length,u=0,t,r,x;if(!A||(A.length===0)){return z;}else{if(A[0]>=z){return A[0];}else{for(s=0;s<w;s++){u=(s+1);if(A[u]&&A[u]>=z){t=z-A[s];r=A[u]-z;x=(r>t)?A[s]:A[u];if(y&&v){if(x>v){if(A[s]){x=A[s];}else{x=A[w-1];}}}return x;}}return A[A.length-1];}}}});},"3.5.0",{skinnable:false,requires:["dd-drag"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("slider-base",function(c){var b=c.Attribute.INVALID_VALUE;function a(){a.superclass.constructor.apply(this,arguments);}c.SliderBase=c.extend(a,c.Widget,{initializer:function(){this.axis=this.get("axis");this._key={dim:(this.axis==="y")?"height":"width",minEdge:(this.axis==="y")?"top":"left",maxEdge:(this.axis==="y")?"bottom":"right",xyIndex:(this.axis==="y")?1:0};this.publish("thumbMove",{defaultFn:this._defThumbMoveFn,queuable:true});},renderUI:function(){var d=this.get("contentBox");this.rail=this.renderRail();this._uiSetRailLength(this.get("length"));this.thumb=this.renderThumb();this.rail.appendChild(this.thumb);d.appendChild(this.rail);d.addClass(this.getClassName(this.axis));},renderRail:function(){var e=this.getClassName("rail","cap",this._key.minEdge),d=this.getClassName("rail","cap",this._key.maxEdge);return c.Node.create(c.substitute(this.RAIL_TEMPLATE,{railClass:this.getClassName("rail"),railMinCapClass:e,railMaxCapClass:d}));},_uiSetRailLength:function(d){this.rail.setStyle(this._key.dim,d);},renderThumb:function(){this._initThumbUrl();var d=this.get("thumbUrl");return c.Node.create(c.substitute(this.THUMB_TEMPLATE,{thumbClass:this.getClassName("thumb"),thumbShadowClass:this.getClassName("thumb","shadow"),thumbImageClass:this.getClassName("thumb","image"),thumbShadowUrl:d,thumbImageUrl:d,thumbAriaLabelId:this.getClassName("label",c.guid())}));},_onThumbClick:function(d){this.thumb.focus();},bindUI:function(){var d=this.get("boundingBox"),f=(!c.UA.opera)?"down:":"press:",e=f+"38,40,33,34,35,36",h=f+"37,39",g=f+"37+meta,39+meta";d.on("key",this._onDirectionKey,e,this);d.on("key",this._onLeftRightKey,h,this);d.on("key",this._onLeftRightKeyMeta,g,this);this.thumb.on("click",this._onThumbClick,this);this._bindThumbDD();this._bindValueLogic();this.after("disabledChange",this._afterDisabledChange);this.after("lengthChange",this._afterLengthChange);},_incrMinor:function(){this.set("value",(this.get("value")+this.get("minorStep")));},_decrMinor:function(){this.set("value",(this.get("value")-this.get("minorStep")));},_incrMajor:function(){this.set("value",(this.get("value")+this.get("majorStep")));},_decrMajor:function(){this.set("value",(this.get("value")-this.get("majorStep")));},_setToMin:function(d){this.set("value",this.get("min"));},_setToMax:function(d){this.set("value",this.get("max"));},_onDirectionKey:function(d){d.preventDefault();if(this.get("disabled")===false){switch(d.charCode){case 38:this._incrMinor();break;case 40:this._decrMinor();break;case 36:this._setToMin();break;case 35:this._setToMax();break;case 33:this._incrMajor();break;case 34:this._decrMajor();break;}}},_onLeftRightKey:function(d){d.preventDefault();if(this.get("disabled")===false){switch(d.charCode){case 37:this._decrMinor();break;case 39:this._incrMinor();break;}}},_onLeftRightKeyMeta:function(d){d.preventDefault();if(this.get("disabled")===false){switch(d.charCode){case 37:this._setToMin();break;case 39:this._setToMax();break;}}},_bindThumbDD:function(){var d={constrain:this.rail};d["stick"+this.axis.toUpperCase()]=true;this._dd=new c.DD.Drag({node:this.thumb,bubble:false,on:{"drag:start":c.bind(this._onDragStart,this)},after:{"drag:drag":c.bind(this._afterDrag,this),"drag:end":c.bind(this._afterDragEnd,this)}});this._dd.plug(c.Plugin.DDConstrained,d);},_bindValueLogic:function(){},_uiMoveThumb:function(e,d){if(this.thumb){this.thumb.setStyle(this._key.minEdge,e+"px");d||(d={});d.offset=e;this.fire("thumbMove",d);}},_onDragStart:function(d){this.fire("slideStart",{ddEvent:d,originEvent:d});},_afterDrag:function(f){var g=f.info.xy[this._key.xyIndex],d=f.target.con._regionCache[this._key.minEdge];this.fire("thumbMove",{offset:(g-d),ddEvent:f,originEvent:f});},_afterDragEnd:function(d){this.fire("slideEnd",{ddEvent:d,originEvent:d});},_afterDisabledChange:function(d){this._dd.set("lock",d.newVal);},_afterLengthChange:function(d){if(this.get("rendered")){this._uiSetRailLength(d.newVal);this.syncUI();}},syncUI:function(){this._dd.con.resetCache();this._syncThumbPosition();this.thumb.set("aria-valuemin",this.get("min"));this.thumb.set("aria-valuemax",this.get("max"));},_syncThumbPosition:function(){},_setAxis:function(d){d=(d+"").toLowerCase();return(d==="x"||d==="y")?d:b;},_setLength:function(e){e=(e+"").toLowerCase();var f=parseFloat(e,10),d=e.replace(/[\d\.\-]/g,"")||this.DEF_UNIT;return f>0?(f+d):b;},_initThumbUrl:function(){if(!this.get("thumbUrl")){var e=this.getSkinName()||"sam",d=c.config.realBase||c.config.base;if(d.indexOf("http://yui.yahooapis.com/combo")===0){d="http://yui.yahooapis.com/"+c.version+"/build/";}this.set("thumbUrl",d+"slider-base/assets/skins/"+e+"/thumb-"+this.axis+".png");}},BOUNDING_TEMPLATE:"<span></span>",CONTENT_TEMPLATE:"<span></span>",RAIL_TEMPLATE:'<span class="{railClass}">'+'<span class="{railMinCapClass}"></span>'+'<span class="{railMaxCapClass}"></span>'+"</span>",THUMB_TEMPLATE:'<span class="{thumbClass}" aria-labelledby="{thumbAriaLabelId}" aria-valuetext="" aria-valuemax="" aria-valuemin="" aria-valuenow="" role="slider" tabindex="0">'+'<img src="{thumbShadowUrl}" '+'alt="Slider thumb shadow" '+'class="{thumbShadowClass}">'+'<img src="{thumbImageUrl}" '+'alt="Slider thumb" '+'class="{thumbImageClass}">'+"</span>"},{NAME:"sliderBase",ATTRS:{axis:{value:"x",writeOnce:true,setter:"_setAxis",lazyAdd:false},length:{value:"150px",setter:"_setLength"},thumbUrl:{value:null,validator:c.Lang.isString}}});},"3.5.0",{requires:["widget","substitute","dd-constrain","event-key"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("slider-value-range",function(f){var b="min",e="max",d="value",c=Math.round;function a(){this._initSliderValueRange();}f.SliderValueRange=f.mix(a,{prototype:{_factor:1,_initSliderValueRange:function(){},_bindValueLogic:function(){this.after({minChange:this._afterMinChange,maxChange:this._afterMaxChange,valueChange:this._afterValueChange});},_syncThumbPosition:function(){this._calculateFactor();this._setPosition(this.get(d));},_calculateFactor:function(){var j=this.get("length"),h=this.thumb.getStyle(this._key.dim),i=this.get(b),g=this.get(e);j=parseFloat(j)||150;h=parseFloat(h)||15;this._factor=(g-i)/(j-h);},_defThumbMoveFn:function(g){if(g.source!=="set"){this.set(d,this._offsetToValue(g.offset));}},_offsetToValue:function(h){var g=c(h*this._factor)+this.get(b);return c(this._nearestValue(g));},_valueToOffset:function(g){var h=c((g-this.get(b))/this._factor);return h;},getValue:function(){return this.get(d);},setValue:function(g){return this.set(d,g);},_afterMinChange:function(g){this._verifyValue();this._syncThumbPosition();},_afterMaxChange:function(g){this._verifyValue();this._syncThumbPosition();},_verifyValue:function(){var h=this.get(d),g=this._nearestValue(h);if(h!==g){this.set(d,g);}},_afterValueChange:function(g){var h=g.newVal;this._setPosition(h,{source:"set"});this.thumb.set("aria-valuenow",h);this.thumb.set("aria-valuetext",h);},_setPosition:function(h,g){this._uiMoveThumb(this._valueToOffset(h),g);},_validateNewMin:function(g){return f.Lang.isNumber(g);},_validateNewMax:function(g){return f.Lang.isNumber(g);},_setNewValue:function(g){return c(this._nearestValue(g));},_nearestValue:function(j){var i=this.get(b),g=this.get(e),h;h=(g>i)?g:i;i=(g>i)?i:g;g=h;return(j<i)?i:(j>g)?g:j;}},ATTRS:{min:{value:0,validator:"_validateNewMin"},max:{value:100,validator:"_validateNewMax"},minorStep:{value:1},majorStep:{value:10},value:{value:0,setter:"_setNewValue"}}},true);},"3.5.0",{requires:["slider-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("clickable-rail",function(b){function a(){this._initClickableRail();}b.ClickableRail=b.mix(a,{prototype:{_initClickableRail:function(){this._evtGuid=this._evtGuid||(b.guid()+"|");this.publish("railMouseDown",{defaultFn:this._defRailMouseDownFn});this.after("render",this._bindClickableRail);this.on("destroy",this._unbindClickableRail);},_bindClickableRail:function(){this._dd.addHandle(this.rail);this.rail.on(this._evtGuid+b.DD.Drag.START_EVENT,b.bind(this._onRailMouseDown,this));},_unbindClickableRail:function(){if(this.get("rendered")){var c=this.get("contentBox"),d=c.one("."+this.getClassName("rail"));d.detach(this.evtGuid+"*");}},_onRailMouseDown:function(c){if(this.get("clickableRail")&&!this.get("disabled")){this.fire("railMouseDown",{ev:c});this.thumb.focus();}},_defRailMouseDownFn:function(k){k=k.ev;var c=this._resolveThumb(k),g=this._key.xyIndex,h=parseFloat(this.get("length"),10),f,d,j;if(c){f=c.get("dragNode");d=parseFloat(f.getStyle(this._key.dim),10);j=this._getThumbDestination(k,f);j=j[g]-this.rail.getXY()[g];j=Math.min(Math.max(j,0),(h-d));this._uiMoveThumb(j,{source:"rail"});k.target=this.thumb.one("img")||this.thumb;c._handleMouseDownEvent(k);}},_resolveThumb:function(c){return this._dd;},_getThumbDestination:function(g,f){var d=f.get("offsetWidth"),c=f.get("offsetHeight");return[(g.pageX-Math.round((d/2))),(g.pageY-Math.round((c/2)))];}},ATTRS:{clickableRail:{value:true,validator:b.Lang.isBoolean}}},true);},"3.5.0",{requires:["slider-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("range-slider",function(a){a.Slider=a.Base.build("slider",a.SliderBase,[a.SliderValueRange,a.ClickableRail]);},"3.5.0",{requires:["slider-base","clickable-rail","slider-value-range"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-plugin",function(d){var b=function(f){if(d.Widget&&f.host instanceof d.Widget){f.node=f.host.get("boundingBox");f.widget=f.host;}else{f.node=f.host;f.widget=false;}b.superclass.constructor.call(this,f);},a="drag:start",c="drag:drag",e="drag:end";b.NAME="dd-plugin";b.NS="dd";d.extend(b,d.DD.Drag,{_widgetHandles:null,_widget:undefined,_stoppedPosition:undefined,_usesWidgetPosition:function(g){var f=false;if(g){f=(g.hasImpl&&g.hasImpl(d.WidgetPosition))?true:false;}return f;},_checkEvents:function(){if(this._widget){if(this.proxy){if(this._widgetHandles.length>0){this._removeWidgetListeners();}}else{if(this._widgetHandles.length===0){this._attachWidgetListeners();}}}},_removeWidgetListeners:function(){d.Array.each(this._widgetHandles,function(f){f.detach();});this._widgetHandles=[];},_attachWidgetListeners:function(){if(this._usesWidgetPosition(this._widget)){this._widgetHandles.push(this.on(c,this._setWidgetCoords));this._widgetHandles.push(this.on(e,this._updateStopPosition));}},initializer:function(f){this._widgetHandles=[];this._widget=f.widget;this.on(a,this._checkEvents);this._attachWidgetListeners();},_setWidgetCoords:function(i){var h=this._stoppedPosition||i.target.nodeXY,f=i.target.realXY,g=[f[0]-h[0],f[1]-h[1]];if(g[0]!==0&&g[1]!==0){this._widget.set("xy",f);}else{if(g[0]===0){this._widget.set("y",f[1]);}else{if(g[1]===0){this._widget.set("x",f[0]);}}}},_updateStopPosition:function(f){this._stoppedPosition=f.target.realXY;}});d.namespace("Plugin");d.Plugin.Drag=b;},"3.5.0",{skinnable:false,optional:["dd-constrain","dd-proxy"],requires:["dd-drag"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-base",function(b){var c="running",n="startTime",l="elapsedTime",j="start",i="tween",m="end",d="node",k="paused",o="reverse",h="iterationCount",a=Number;var f={},e;b.Anim=function(){b.Anim.superclass.constructor.apply(this,arguments);b.Anim._instances[b.stamp(this)]=this;};b.Anim.NAME="anim";b.Anim._instances={};b.Anim.RE_DEFAULT_UNIT=/^width|height|top|right|bottom|left|margin.*|padding.*|border.*$/i;b.Anim.DEFAULT_UNIT="px";b.Anim.DEFAULT_EASING=function(q,p,s,r){return s*q/r+p;};b.Anim._intervalTime=20;b.Anim.behaviors={left:{get:function(q,p){return q._getOffset(p);}}};b.Anim.behaviors.top=b.Anim.behaviors.left;b.Anim.DEFAULT_SETTER=function(t,u,w,x,z,s,v,y){var q=t._node,r=q._node,p=v(z,a(w),a(x)-a(w),s);if(r&&(r.style||r.attributes)){if(u in r.style||u in b.DOM.CUSTOM_STYLES){y=y||"";q.setStyle(u,p+y);}else{if(r.attributes[u]){q.setAttribute(u,p);}}}else{if(q.set){q.set(u,p);}}};b.Anim.DEFAULT_GETTER=function(s,p){var r=s._node,q=r._node,t="";if(q&&(q.style||q.attributes)){if(p in q.style||p in b.DOM.CUSTOM_STYLES){t=r.getComputedStyle(p);}else{if(q.attributes[p]){t=r.getAttribute(p);}}}else{if(r.get){t=r.get(p);}}return t;};b.Anim.ATTRS={node:{setter:function(p){if(p){if(typeof p=="string"||p.nodeType){p=b.one(p);}}this._node=p;if(!p){}return p;}},duration:{value:1},easing:{value:b.Anim.DEFAULT_EASING,setter:function(p){if(typeof p==="string"&&b.Easing){return b.Easing[p];}}},from:{},to:{},startTime:{value:0,readOnly:true},elapsedTime:{value:0,readOnly:true},running:{getter:function(){return !!f[b.stamp(this)];},value:false,readOnly:true},iterations:{value:1},iterationCount:{value:0,readOnly:true},direction:{value:"normal"},paused:{readOnly:true,value:false},reverse:{value:false}};b.Anim.run=function(){var q=b.Anim._instances;for(var p in q){if(q[p].run){q[p].run();}}};b.Anim.pause=function(){for(var p in f){if(f[p].pause){f[p].pause();}}b.Anim._stopTimer();};b.Anim.stop=function(){for(var p in f){if(f[p].stop){f[p].stop();}}b.Anim._stopTimer();};b.Anim._startTimer=function(){if(!e){e=setInterval(b.Anim._runFrame,b.Anim._intervalTime);}};b.Anim._stopTimer=function(){clearInterval(e);e=0;};b.Anim._runFrame=function(){var p=true;for(var q in f){if(f[q]._runFrame){p=false;f[q]._runFrame();}}if(p){b.Anim._stopTimer();}};b.Anim.RE_UNITS=/^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/;var g={run:function(){if(this.get(k)){this._resume();}else{if(!this.get(c)){this._start();}}return this;},pause:function(){if(this.get(c)){this._pause();}return this;},stop:function(p){if(this.get(c)||this.get(k)){this._end(p);}return this;},_added:false,_start:function(){this._set(n,new Date()-this.get(l));this._actualFrames=0;if(!this.get(k)){this._initAnimAttr();}f[b.stamp(this)]=this;b.Anim._startTimer();this.fire(j);},_pause:function(){this._set(n,null);this._set(k,true);delete f[b.stamp(this)];this.fire("pause");},_resume:function(){this._set(k,false);f[b.stamp(this)]=this;this._set(n,new Date()-this.get(l));b.Anim._startTimer();this.fire("resume");},_end:function(p){var q=this.get("duration")*1000;if(p){this._runAttrs(q,q,this.get(o));}this._set(n,null);this._set(l,0);this._set(k,false);delete f[b.stamp(this)];this.fire(m,{elapsed:this.get(l)});},_runFrame:function(){var u=this._runtimeAttr.duration,r=new Date()-this.get(n),q=this.get(o),p=(r>=u),s,v;this._runAttrs(r,u,q);this._actualFrames+=1;this._set(l,r);this.fire(i);if(p){this._lastFrame();}},_runAttrs:function(A,z,w){var x=this._runtimeAttr,r=b.Anim.behaviors,y=x.easing,p=z,u=false,q,s,v;if(A>=z){u=true;}if(w){A=z-A;p=0;}for(v in x){if(x[v].to){q=x[v];s=(v in r&&"set" in r[v])?r[v].set:b.Anim.DEFAULT_SETTER;if(!u){s(this,v,q.from,q.to,A,z,y,q.unit);}else{s(this,v,q.from,q.to,p,z,y,q.unit);}}}},_lastFrame:function(){var p=this.get("iterations"),q=this.get(h);q+=1;if(p==="infinite"||q<p){if(this.get("direction")==="alternate"){this.set(o,!this.get(o));}this.fire("iteration");}else{q=0;this._end();}this._set(n,new Date());this._set(h,q);},_initAnimAttr:function(){var w=this.get("from")||{},v=this.get("to")||{},p={duration:this.get("duration")*1000,easing:this.get("easing")},r=b.Anim.behaviors,u=this.get(d),t,s,q;b.each(v,function(A,y){if(typeof A==="function"){A=A.call(this,u);}s=w[y];if(s===undefined){s=(y in r&&"get" in r[y])?r[y].get(this,y):b.Anim.DEFAULT_GETTER(this,y);}else{if(typeof s==="function"){s=s.call(this,u);}}var x=b.Anim.RE_UNITS.exec(s);var z=b.Anim.RE_UNITS.exec(A);s=x?x[1]:s;q=z?z[1]:A;t=z?z[2]:x?x[2]:"";if(!t&&b.Anim.RE_DEFAULT_UNIT.test(y)){t=b.Anim.DEFAULT_UNIT;}if(!s||!q){b.error('invalid "from" or "to" for "'+y+'"',"Anim");return;}p[y]={from:s,to:q,unit:t};},this);this._runtimeAttr=p;},_getOffset:function(q){var s=this._node,t=s.getComputedStyle(q),r=(q==="left")?"getX":"getY",u=(q==="left")?"setX":"setY";if(t==="auto"){var p=s.getStyle("position");if(p==="absolute"||p==="fixed"){t=s[r]();s[u](t);}else{t=0;}}return t;},destructor:function(){delete b.Anim._instances[b.stamp(this)];}};b.extend(b.Anim,b.Base,g);},"3.5.0",{requires:["base-base","node-style"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-color",function(b){var a=Number;b.Anim.behaviors.color={set:function(f,d,i,h,c,g,e){i=b.Color.re_RGB.exec(b.Color.toRGB(i));h=b.Color.re_RGB.exec(b.Color.toRGB(h));if(!i||i.length<3||!h||h.length<3){b.error("invalid from or to passed to color behavior");}f._node.setStyle(d,"rgb("+[Math.floor(e(c,a(i[1]),a(h[1])-a(i[1]),g)),Math.floor(e(c,a(i[2]),a(h[2])-a(i[2]),g)),Math.floor(e(c,a(i[3]),a(h[3])-a(i[3]),g))].join(", ")+")");},get:function(d,c){var e=d._node.getComputedStyle(c);e=(e==="transparent")?"rgb(255, 255, 255)":e;return e;}};b.each(["backgroundColor","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],function(c,d){b.Anim.behaviors[c]=b.Anim.behaviors.color;});},"3.5.0",{requires:["anim-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-xy",function(b){var a=Number;b.Anim.behaviors.xy={set:function(f,d,i,h,c,g,e){f._node.setXY([e(c,a(i[0]),a(h[0])-a(i[0]),g),e(c,a(i[1]),a(h[1])-a(i[1]),g)]);},get:function(c){return c._node.getXY();}};},"3.5.0",{requires:["anim-base","node-screen"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-curve",function(a){a.Anim.behaviors.curve={set:function(f,c,i,h,b,g,e){i=i.slice.call(i);h=h.slice.call(h);var d=e(b,0,100,g)/100;h.unshift(i);f._node.setXY(a.Anim.getBezier(h,d));},get:function(c,b){return c._node.getXY();}};a.Anim.getBezier=function(f,e){var g=f.length;var d=[];for(var c=0;c<g;++c){d[c]=[f[c][0],f[c][1]];}for(var b=1;b<g;++b){for(c=0;c<g-b;++c){d[c][0]=(1-e)*d[c][0]+e*d[parseInt(c+1,10)][0];d[c][1]=(1-e)*d[c][1]+e*d[parseInt(c+1,10)][1];}}return[d[0][0],d[0][1]];};},"3.5.0",{requires:["anim-xy"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-easing",function(b){var a={easeNone:function(f,e,h,g){return h*f/g+e;},easeIn:function(f,e,h,g){return h*(f/=g)*f+e;},easeOut:function(f,e,h,g){return -h*(f/=g)*(f-2)+e;},easeBoth:function(f,e,h,g){if((f/=g/2)<1){return h/2*f*f+e;}return -h/2*((--f)*(f-2)-1)+e;},easeInStrong:function(f,e,h,g){return h*(f/=g)*f*f*f+e;},easeOutStrong:function(f,e,h,g){return -h*((f=f/g-1)*f*f*f-1)+e;},easeBothStrong:function(f,e,h,g){if((f/=g/2)<1){return h/2*f*f*f*f+e;}return -h/2*((f-=2)*f*f*f-2)+e;},elasticIn:function(g,e,k,j,f,i){var h;if(g===0){return e;}if((g/=j)===1){return e+k;}if(!i){i=j*0.3;}if(!f||f<Math.abs(k)){f=k;h=i/4;}else{h=i/(2*Math.PI)*Math.asin(k/f);}return -(f*Math.pow(2,10*(g-=1))*Math.sin((g*j-h)*(2*Math.PI)/i))+e;},elasticOut:function(g,e,k,j,f,i){var h;if(g===0){return e;}if((g/=j)===1){return e+k;}if(!i){i=j*0.3;}if(!f||f<Math.abs(k)){f=k;h=i/4;}else{h=i/(2*Math.PI)*Math.asin(k/f);}return f*Math.pow(2,-10*g)*Math.sin((g*j-h)*(2*Math.PI)/i)+k+e;},elasticBoth:function(g,e,k,j,f,i){var h;if(g===0){return e;}if((g/=j/2)===2){return e+k;}if(!i){i=j*(0.3*1.5);}if(!f||f<Math.abs(k)){f=k;h=i/4;}else{h=i/(2*Math.PI)*Math.asin(k/f);}if(g<1){return -0.5*(f*Math.pow(2,10*(g-=1))*Math.sin((g*j-h)*(2*Math.PI)/i))+e;}return f*Math.pow(2,-10*(g-=1))*Math.sin((g*j-h)*(2*Math.PI)/i)*0.5+k+e;},backIn:function(f,e,i,h,g){if(g===undefined){g=1.70158;}if(f===h){f-=0.001;}return i*(f/=h)*f*((g+1)*f-g)+e;},backOut:function(f,e,i,h,g){if(typeof g==="undefined"){g=1.70158;}return i*((f=f/h-1)*f*((g+1)*f+g)+1)+e;},backBoth:function(f,e,i,h,g){if(typeof g==="undefined"){g=1.70158;}if((f/=h/2)<1){return i/2*(f*f*(((g*=(1.525))+1)*f-g))+e;}return i/2*((f-=2)*f*(((g*=(1.525))+1)*f+g)+2)+e;},bounceIn:function(f,e,h,g){return h-b.Easing.bounceOut(g-f,0,h,g)+e;},bounceOut:function(f,e,h,g){if((f/=g)<(1/2.75)){return h*(7.5625*f*f)+e;}else{if(f<(2/2.75)){return h*(7.5625*(f-=(1.5/2.75))*f+0.75)+e;}else{if(f<(2.5/2.75)){return h*(7.5625*(f-=(2.25/2.75))*f+0.9375)+e;}}}return h*(7.5625*(f-=(2.625/2.75))*f+0.984375)+e;},bounceBoth:function(f,e,h,g){if(f<g/2){return b.Easing.bounceIn(f*2,0,h,g)*0.5+e;}return b.Easing.bounceOut(f*2-g,0,h,g)*0.5+h*0.5+e;}};b.Easing=a;},"3.5.0",{requires:["anim-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-node-plugin",function(b){var a=function(c){c=(c)?b.merge(c):{};c.node=c.host;a.superclass.constructor.apply(this,arguments);};a.NAME="nodefx";a.NS="fx";b.extend(a,b.Anim);b.namespace("Plugin");b.Plugin.NodeFX=a;},"3.5.0",{requires:["node-pluginhost","anim-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("anim-scroll",function(b){var a=Number;b.Anim.behaviors.scroll={set:function(f,g,i,j,k,e,h){var d=f._node,c=([h(k,a(i[0]),a(j[0])-a(i[0]),e),h(k,a(i[1]),a(j[1])-a(i[1]),e)]);if(c[0]){d.set("scrollLeft",c[0]);}if(c[1]){d.set("scrollTop",c[1]);}},get:function(d){var c=d._node;return[c.get("scrollLeft"),c.get("scrollTop")];}};},"3.5.0",{requires:["anim-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-ddm",function(a){a.mix(a.DD.DDM,{_pg:null,_debugShim:false,_activateTargets:function(){},_deactivateTargets:function(){},_startDrag:function(){if(this.activeDrag&&this.activeDrag.get("useShim")){this._pg_activate();this._activateTargets();}},_endDrag:function(){this._pg_deactivate();this._deactivateTargets();},_pg_deactivate:function(){this._pg.setStyle("display","none");},_pg_activate:function(){if(!this._pg){this._createPG();}var b=this.activeDrag.get("activeHandle"),c="auto";if(b){c=b.getStyle("cursor");}if(c=="auto"){c=this.get("dragCursor");}this._pg_size();this._pg.setStyles({top:0,left:0,display:"block",opacity:((this._debugShim)?".5":"0"),cursor:c});},_pg_size:function(){if(this.activeDrag){var c=a.one("body"),e=c.get("docHeight"),d=c.get("docWidth");this._pg.setStyles({height:e+"px",width:d+"px"});}},_createPG:function(){var d=a.Node.create("<div></div>"),b=a.one("body"),c;d.setStyles({top:"0",left:"0",position:"absolute",zIndex:"9999",overflow:"hidden",backgroundColor:"red",display:"none",height:"5px",width:"5px"});d.set("id",a.stamp(d));d.addClass(a.DD.DDM.CSS_PREFIX+"-shim");b.prepend(d);this._pg=d;this._pg.on("mousemove",a.throttle(a.bind(this._move,this),this.get("throttleTime")));this._pg.on("mouseup",a.bind(this._end,this));c=a.one("win");a.on("window:resize",a.bind(this._pg_size,this));c.on("scroll",a.bind(this._pg_size,this));}},true);},"3.5.0",{skinnable:false,requires:["dd-ddm-base","event-resize"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-ddm-drop",function(a){a.mix(a.DD.DDM,{_noShim:false,_activeShims:[],_hasActiveShim:function(){if(this._noShim){return true;}return this._activeShims.length;},_addActiveShim:function(b){this._activeShims[this._activeShims.length]=b;},_removeActiveShim:function(c){var b=[];a.each(this._activeShims,function(e,d){if(e._yuid!==c._yuid){b[b.length]=e;}});this._activeShims=b;},syncActiveShims:function(b){a.later(0,this,function(c){var d=((c)?this.targets:this._lookup());a.each(d,function(f,e){f.sizeShim.call(f);},this);},b);},mode:0,POINT:0,INTERSECT:1,STRICT:2,useHash:true,activeDrop:null,validDrops:[],otherDrops:{},targets:[],_addValid:function(b){this.validDrops[this.validDrops.length]=b;return this;},_removeValid:function(b){var c=[];a.each(this.validDrops,function(e,d){if(e!==b){c[c.length]=e;}});this.validDrops=c;return this;},isOverTarget:function(c){if(this.activeDrag&&c){var g=this.activeDrag.mouseXY,f,b=this.activeDrag.get("dragMode"),e,d=c.shim;if(g&&this.activeDrag){e=this.activeDrag.region;if(b==this.STRICT){return this.activeDrag.get("dragNode").inRegion(c.region,true,e);}else{if(c&&c.shim){if((b==this.INTERSECT)&&this._noShim){f=((e)?e:this.activeDrag.get("node"));return c.get("node").intersect(f,c.region).inRegion;}else{if(this._noShim){d=c.get("node");}return d.intersect({top:g[1],bottom:g[1],left:g[0],right:g[0]},c.region).inRegion;}}else{return false;}}}else{return false;}}else{return false;}},clearCache:function(){this.validDrops=[];this.otherDrops={};this._activeShims=[];},_activateTargets:function(){this._noShim=true;this.clearCache();a.each(this.targets,function(c,b){c._activateShim([]);if(c.get("noShim")==true){this._noShim=false;}},this);this._handleTargetOver();},getBestMatch:function(f,d){var c=null,e=0,b;a.each(f,function(i,h){var g=this.activeDrag.get("dragNode").intersect(i.get("node"));i.region.area=g.area;if(g.inRegion){if(g.area>e){e=g.area;c=i;}}},this);if(d){b=[];a.each(f,function(h,g){if(h!==c){b[b.length]=h;}},this);return[c,b];}else{return c;}},_deactivateTargets:function(){var b=[],c,e=this.activeDrag,d=this.activeDrop;if(e&&d&&this.otherDrops[d]){if(!e.get("dragMode")){b=this.otherDrops;delete b[d];}else{c=this.getBestMatch(this.otherDrops,true);d=c[0];b=c[1];}e.get("node").removeClass(this.CSS_PREFIX+"-drag-over");if(d){d.fire("drop:hit",{drag:e,drop:d,others:b});e.fire("drag:drophit",{drag:e,drop:d,others:b});}}else{if(e&&e.get("dragging")){e.get("node").removeClass(this.CSS_PREFIX+"-drag-over");e.fire("drag:dropmiss",{pageX:e.lastXY[0],pageY:e.lastXY[1]});}else{}}this.activeDrop=null;a.each(this.targets,function(g,f){g._deactivateShim([]);},this);},_dropMove:function(){if(this._hasActiveShim()){this._handleTargetOver();}else{a.each(this.otherDrops,function(c,b){c._handleOut.apply(c,[]);});}},_lookup:function(){if(!this.useHash||this._noShim){return this.validDrops;}var b=[];a.each(this.validDrops,function(d,c){if(d.shim&&d.shim.inViewportRegion(false,d.region)){b[b.length]=d;}});return b;},_handleTargetOver:function(){var b=this._lookup();a.each(b,function(d,c){d._handleTargetOver.call(d);},this);},_regTarget:function(b){this.targets[this.targets.length]=b;},_unregTarget:function(c){var b=[],d;a.each(this.targets,function(f,e){if(f!=c){b[b.length]=f;}},this);this.targets=b;d=[];a.each(this.validDrops,function(f,e){if(f!==c){d[d.length]=f;}});this.validDrops=d;},getDrop:function(c){var b=false,d=a.one(c);if(d instanceof a.Node){a.each(this.targets,function(f,e){if(d.compareTo(f.get("node"))){b=f;}});}return b;}},true);},"3.5.0",{skinnable:false,requires:["dd-ddm"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-proxy",function(h){var f=h.DD.DDM,b="node",c="dragNode",a="host",d=true,e,g=function(i){g.superclass.constructor.apply(this,arguments);};g.NAME="DDProxy";g.NS="proxy";g.ATTRS={host:{},moveOnEnd:{value:d},hideOnEnd:{value:d},resizeFrame:{value:d},positionProxy:{value:d},borderStyle:{value:"1px solid #808080"},cloneNode:{value:false}};e={_hands:null,_init:function(){if(!f._proxy){f._createFrame();h.on("domready",h.bind(this._init,this));return;}if(!this._hands){this._hands=[];}var k,j,l=this.get(a),i=l.get(c);if(i.compareTo(l.get(b))){if(f._proxy){l.set(c,f._proxy);}}h.each(this._hands,function(m){m.detach();});k=f.on("ddm:start",h.bind(function(){if(f.activeDrag===l){f._setFrame(l);}},this));j=f.on("ddm:end",h.bind(function(){if(l.get("dragging")){if(this.get("moveOnEnd")){l.get(b).setXY(l.lastXY);}if(this.get("hideOnEnd")){l.get(c).setStyle("display","none");}if(this.get("cloneNode")){l.get(c).remove();l.set(c,f._proxy);}}},this));this._hands=[k,j];},initializer:function(){this._init();},destructor:function(){var i=this.get(a);h.each(this._hands,function(j){j.detach();});i.set(c,i.get(b));},clone:function(){var i=this.get(a),k=i.get(b),j=k.cloneNode(true);delete j._yuid;j.setAttribute("id",h.guid());j.setStyle("position","absolute");k.get("parentNode").appendChild(j);i.set(c,j);return j;}};h.namespace("Plugin");h.extend(g,h.Base,e);h.Plugin.DDProxy=g;h.mix(f,{_createFrame:function(){if(!f._proxy){f._proxy=d;var j=h.Node.create("<div></div>"),i=h.one("body");j.setStyles({position:"absolute",display:"none",zIndex:"999",top:"-999px",left:"-999px"});i.prepend(j);j.set("id",h.guid());j.addClass(f.CSS_PREFIX+"-proxy");f._proxy=j;}},_setFrame:function(j){var m=j.get(b),l=j.get(c),i,k="auto";i=f.activeDrag.get("activeHandle");if(i){k=i.getStyle("cursor");}if(k=="auto"){k=f.get("dragCursor");}l.setStyles({visibility:"hidden",display:"block",cursor:k,border:j.proxy.get("borderStyle")});if(j.proxy.get("cloneNode")){l=j.proxy.clone();}if(j.proxy.get("resizeFrame")){l.setStyles({height:m.get("offsetHeight")+"px",width:m.get("offsetWidth")+"px"});}if(j.proxy.get("positionProxy")){l.setXY(j.nodeXY);}l.setStyle("visibility","visible");}});},"3.5.0",{skinnable:false,requires:["dd-drag"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-drop",function(a){var b="node",g=a.DD.DDM,f="offsetHeight",c="offsetWidth",i="drop:over",h="drop:enter",d="drop:exit",e=function(){this._lazyAddAttrs=false;e.superclass.constructor.apply(this,arguments);a.on("domready",a.bind(function(){a.later(100,this,this._createShim);},this));g._regTarget(this);};e.NAME="drop";e.ATTRS={node:{setter:function(j){var k=a.one(j);if(!k){a.error("DD.Drop: Invalid Node Given: "+j);}return k;}},groups:{value:["default"],getter:function(){if(!this._groups){this._groups={};}var j=[];a.each(this._groups,function(m,l){j[j.length]=l;});return j;},setter:function(j){this._groups={};a.each(j,function(m,l){this._groups[m]=true;},this);return j;}},padding:{value:"0",setter:function(j){return g.cssSizestoObject(j);}},lock:{value:false,setter:function(j){if(j){this.get(b).addClass(g.CSS_PREFIX+"-drop-locked");}else{this.get(b).removeClass(g.CSS_PREFIX+"-drop-locked");}return j;}},bubbles:{setter:function(j){this.addTarget(j);return j;}},useShim:{value:true,setter:function(j){a.DD.DDM._noShim=!j;return j;}}};a.extend(e,a.Base,{_bubbleTargets:a.DD.DDM,addToGroup:function(j){this._groups[j]=true;return this;},removeFromGroup:function(j){delete this._groups[j];return this;},_createEvents:function(){var j=[i,h,d,"drop:hit"];a.each(j,function(m,l){this.publish(m,{type:m,emitFacade:true,preventable:false,bubbles:true,queuable:false,prefix:"drop"});},this);},_valid:null,_groups:null,shim:null,region:null,overTarget:null,inGroup:function(j){this._valid=false;var k=false;a.each(j,function(m,l){if(this._groups[m]){k=true;this._valid=true;}},this);return k;},initializer:function(j){a.later(100,this,this._createEvents);var k=this.get(b),l;if(!k.get("id")){l=a.stamp(k);k.set("id",l);}k.addClass(g.CSS_PREFIX+"-drop");this.set("groups",this.get("groups"));},destructor:function(){g._unregTarget(this);if(this.shim&&(this.shim!==this.get(b))){this.shim.detachAll();this.shim.remove();this.shim=null;}this.get(b).removeClass(g.CSS_PREFIX+"-drop");this.detachAll();},_deactivateShim:function(){if(!this.shim){return false;}this.get(b).removeClass(g.CSS_PREFIX+"-drop-active-valid");this.get(b).removeClass(g.CSS_PREFIX+"-drop-active-invalid");this.get(b).removeClass(g.CSS_PREFIX+"-drop-over");if(this.get("useShim")){this.shim.setStyles({top:"-999px",left:"-999px",zIndex:"1"});}this.overTarget=false;},_activateShim:function(){if(!g.activeDrag){return false;}if(this.get(b)===g.activeDrag.get(b)){return false;}if(this.get("lock")){return false;}var j=this.get(b);if(this.inGroup(g.activeDrag.get("groups"))){j.removeClass(g.CSS_PREFIX+"-drop-active-invalid");j.addClass(g.CSS_PREFIX+"-drop-active-valid");g._addValid(this);this.overTarget=false;if(!this.get("useShim")){this.shim=this.get(b);}this.sizeShim();}else{g._removeValid(this);j.removeClass(g.CSS_PREFIX+"-drop-active-valid");j.addClass(g.CSS_PREFIX+"-drop-active-invalid");}},sizeShim:function(){if(!g.activeDrag){return false;}if(this.get(b)===g.activeDrag.get(b)){return false;}if(this.get("lock")){return false;}if(!this.shim){a.later(100,this,this.sizeShim);return false;}var o=this.get(b),m=o.get(f),k=o.get(c),r=o.getXY(),q=this.get("padding"),j,n,l;k=k+q.left+q.right;m=m+q.top+q.bottom;r[0]=r[0]-q.left;r[1]=r[1]-q.top;if(g.activeDrag.get("dragMode")===g.INTERSECT){j=g.activeDrag;n=j.get(b).get(f);l=j.get(b).get(c);m=(m+n);k=(k+l);r[0]=r[0]-(l-j.deltaXY[0]);r[1]=r[1]-(n-j.deltaXY[1]);}if(this.get("useShim")){this.shim.setStyles({height:m+"px",width:k+"px",top:r[1]+"px",left:r[0]+"px"});}this.region={"0":r[0],"1":r[1],area:0,top:r[1],right:r[0]+k,bottom:r[1]+m,left:r[0]};},_createShim:function(){if(!g._pg){a.later(10,this,this._createShim);return;}if(this.shim){return;}var j=this.get("node");if(this.get("useShim")){j=a.Node.create('<div id="'+this.get(b).get("id")+'_shim"></div>');j.setStyles({height:this.get(b).get(f)+"px",width:this.get(b).get(c)+"px",backgroundColor:"yellow",opacity:".5",zIndex:"1",overflow:"hidden",top:"-900px",left:"-900px",position:"absolute"});g._pg.appendChild(j);j.on("mouseover",a.bind(this._handleOverEvent,this));j.on("mouseout",a.bind(this._handleOutEvent,this));}this.shim=j;},_handleTargetOver:function(){if(g.isOverTarget(this)){this.get(b).addClass(g.CSS_PREFIX+"-drop-over");g.activeDrop=this;g.otherDrops[this]=this;if(this.overTarget){g.activeDrag.fire("drag:over",{drop:this,drag:g.activeDrag});this.fire(i,{drop:this,drag:g.activeDrag});}else{if(g.activeDrag.get("dragging")){this.overTarget=true;this.fire(h,{drop:this,drag:g.activeDrag});g.activeDrag.fire("drag:enter",{drop:this,drag:g.activeDrag});g.activeDrag.get(b).addClass(g.CSS_PREFIX+"-drag-over");}}}else{this._handleOut();}},_handleOverEvent:function(){this.shim.setStyle("zIndex","999");g._addActiveShim(this);},_handleOutEvent:function(){this.shim.setStyle("zIndex","1");g._removeActiveShim(this);},_handleOut:function(j){if(!g.isOverTarget(this)||j){if(this.overTarget){this.overTarget=false;if(!j){g._removeActiveShim(this);}if(g.activeDrag){this.get(b).removeClass(g.CSS_PREFIX+"-drop-over");g.activeDrag.get(b).removeClass(g.CSS_PREFIX+"-drag-over");this.fire(d,{drop:this,drag:g.activeDrag});g.activeDrag.fire("drag:exit",{drop:this,drag:g.activeDrag});delete g.otherDrops[this];}}}}});a.DD.Drop=e;},"3.5.0",{skinnable:false,requires:["dd-ddm-drop","dd-drag"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-scroll",function(b){var h=function(){h.superclass.constructor.apply(this,arguments);},c,d,l="host",a="buffer",j="parentScroll",g="windowScroll",i="scrollTop",f="scrollLeft",e="offsetWidth",k="offsetHeight";h.ATTRS={parentScroll:{value:false,setter:function(m){if(m){return m;}return false;}},buffer:{value:30,validator:b.Lang.isNumber},scrollDelay:{value:235,validator:b.Lang.isNumber},host:{value:null},windowScroll:{value:false,validator:b.Lang.isBoolean},vertical:{value:true,validator:b.Lang.isBoolean},horizontal:{value:true,validator:b.Lang.isBoolean}};b.extend(h,b.Base,{_scrolling:null,_vpRegionCache:null,_dimCache:null,_scrollTimer:null,_getVPRegion:function(){var m={},o=this.get(j),u=this.get(a),s=this.get(g),y=((s)?[]:o.getXY()),v=((s)?"winWidth":e),q=((s)?"winHeight":k),x=((s)?o.get(i):y[1]),p=((s)?o.get(f):y[0]);m={top:x+u,right:(o.get(v)+p)-u,bottom:(o.get(q)+x)-u,left:p+u};this._vpRegionCache=m;return m;},initializer:function(){var m=this.get(l);m.after("drag:start",b.bind(this.start,this));m.after("drag:end",b.bind(this.end,this));m.on("drag:align",b.bind(this.align,this));b.one("win").on("scroll",b.bind(function(){this._vpRegionCache=null;},this));},_checkWinScroll:function(A){var z=this._getVPRegion(),m=this.get(l),o=this.get(g),t=m.lastXY,n=false,F=this.get(a),s=this.get(j),H=s.get(i),v=s.get(f),x=this._dimCache.w,C=this._dimCache.h,u=t[1]+C,y=t[1],E=t[0]+x,q=t[0],G=y,p=q,B=H,D=v;if(this.get("horizontal")){if(q<=z.left){n=true;p=t[0]-((o)?F:0);D=v-F;}if(E>=z.right){n=true;p=t[0]+((o)?F:0);D=v+F;}}if(this.get("vertical")){if(u>=z.bottom){n=true;G=t[1]+((o)?F:0);B=H+F;}if(y<=z.top){n=true;G=t[1]-((o)?F:0);B=H-F;}}if(B<0){B=0;G=t[1];}if(D<0){D=0;p=t[0];}if(G<0){G=t[1];}if(p<0){p=t[0];}if(A){m.actXY=[p,G];m._moveNode({node:s,top:B,left:D});if(!B&&!D){this._cancelScroll();}}else{if(n){this._initScroll();}else{this._cancelScroll();}}},_initScroll:function(){this._cancelScroll();this._scrollTimer=b.Lang.later(this.get("scrollDelay"),this,this._checkWinScroll,[true],true);},_cancelScroll:function(){this._scrolling=false;if(this._scrollTimer){this._scrollTimer.cancel();delete this._scrollTimer;}},align:function(m){if(this._scrolling){this._cancelScroll();m.preventDefault();}if(!this._scrolling){this._checkWinScroll();}},_setDimCache:function(){var m=this.get(l).get("dragNode");this._dimCache={h:m.get(k),w:m.get(e)};},start:function(){this._setDimCache();},end:function(m){this._dimCache=null;this._cancelScroll();}});b.namespace("Plugin");c=function(){c.superclass.constructor.apply(this,arguments);};c.ATTRS=b.merge(h.ATTRS,{windowScroll:{value:true,setter:function(m){if(m){this.set(j,b.one("win"));}return m;}}});b.extend(c,h,{initializer:function(){this.set("windowScroll",this.get("windowScroll"));}});c.NAME=c.NS="winscroll";b.Plugin.DDWinScroll=c;d=function(){d.superclass.constructor.apply(this,arguments);};d.ATTRS=b.merge(h.ATTRS,{node:{value:false,setter:function(m){var o=b.one(m);if(!o){if(m!==false){b.error("DDNodeScroll: Invalid Node Given: "+m);}}else{this.set(j,o);}return o;}}});b.extend(d,h,{initializer:function(){this.set("node",this.get("node"));}});d.NAME=d.NS="nodescroll";b.Plugin.DDNodeScroll=d;b.DD.Scroll=h;},"3.5.0",{skinnable:false,optional:["dd-proxy"],requires:["dd-drag"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-drop-plugin",function(a){var b=function(c){c.node=c.host;b.superclass.constructor.apply(this,arguments);};b.NAME="dd-drop-plugin";b.NS="drop";a.extend(b,a.DD.Drop);a.namespace("Plugin");a.Plugin.Drop=b;},"3.5.0",{skinnable:false,requires:["dd-drop"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("dd-delegate",function(e){var d=function(f){d.superclass.constructor.apply(this,arguments);},c="container",b="nodes",a=e.Node.create("<div>Temp Node</div>");e.extend(d,e.Base,{_bubbleTargets:e.DD.DDM,dd:null,_shimState:null,_handles:null,_onNodeChange:function(f){this.set("dragNode",f.newVal);},_afterDragEnd:function(f){e.DD.DDM._noShim=this._shimState;this.set("lastNode",this.dd.get("node"));this.get("lastNode").removeClass(e.DD.DDM.CSS_PREFIX+"-dragging");this.dd._unprep();this.dd.set("node",a);},_delMouseDown:function(h){var g=h.currentTarget,f=this.dd;if(g.test(this.get(b))&&!g.test(this.get("invalid"))){this._shimState=e.DD.DDM._noShim;e.DD.DDM._noShim=true;this.set("currentNode",g);f.set("node",g);if(f.proxy){f.set("dragNode",e.DD.DDM._proxy);}else{f.set("dragNode",g);}f._prep();f.fire("drag:mouseDown",{ev:h});}},_onMouseEnter:function(f){this._shimState=e.DD.DDM._noShim;e.DD.DDM._noShim=true;},_onMouseLeave:function(f){e.DD.DDM._noShim=this._shimState;},initializer:function(g){this._handles=[];var h=this.get("dragConfig")||{},f=this.get(c);h.node=a.cloneNode(true);h.bubbleTargets=this;if(this.get("handles")){h.handles=this.get("handles");}this.dd=new e.DD.Drag(h);this.dd.after("drag:end",e.bind(this._afterDragEnd,this));this.dd.on("dragNodeChange",e.bind(this._onNodeChange,this));this.dd.after("drag:mouseup",function(){this._unprep();});this._handles.push(e.delegate(e.DD.Drag.START_EVENT,e.bind(this._delMouseDown,this),f,this.get(b)));this._handles.push(e.on("mouseenter",e.bind(this._onMouseEnter,this),f));this._handles.push(e.on("mouseleave",e.bind(this._onMouseLeave,this),f));e.later(50,this,this.syncTargets);e.DD.DDM.regDelegate(this);},syncTargets:function(){if(!e.Plugin.Drop||this.get("destroyed")){return;}var g,f,h;if(this.get("target")){g=e.one(this.get(c)).all(this.get(b));f=this.dd.get("groups");h=this.get("dragConfig");if(h&&"groups" in h){f=h.groups;}g.each(function(j){this.createDrop(j,f);},this);}return this;},createDrop:function(h,f){var g={useShim:false,bubbleTargets:this};if(!h.drop){h.plug(e.Plugin.Drop,g);}h.drop.set("groups",f);return h;},destructor:function(){if(this.dd){this.dd.destroy();}if(e.Plugin.Drop){var f=e.one(this.get(c)).all(this.get(b));f.unplug(e.Plugin.Drop);}e.each(this._handles,function(g){g.detach();});}},{NAME:"delegate",ATTRS:{container:{value:"body"},nodes:{value:".dd-draggable"},invalid:{value:"input, select, button, a, textarea"},lastNode:{value:a},currentNode:{value:a},dragNode:{value:a},over:{value:false},target:{value:false},dragConfig:{value:null},handles:{value:null}}});e.mix(e.DD.DDM,{_delegates:[],regDelegate:function(f){this._delegates.push(f);},getDelegate:function(g){var f=null;g=e.one(g);e.each(this._delegates,function(h){if(g.test(h.get(c))){f=h;}},this);return f;}});e.namespace("DD");e.DD.Delegate=d;},"3.5.0",{skinnable:false,requires:["dd-drag","event-mouseenter","dd-drop-plugin"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("jsonp",function(c){var b=c.Lang.isFunction;function a(){this._init.apply(this,arguments);}a.prototype={_init:function(d,f){this.url=d;this._requests={};this._timeouts={};f=(b(f))?{on:{success:f}}:f||{};var e=f.on||{};if(!e.success){e.success=this._defaultCallback(d,f);}this._config=c.merge({context:this,args:[],format:this._format,allowCache:false},f,{on:e});},_defaultCallback:function(){},send:function(){var d=this,g=c.Array(arguments,0,true),f=d._config,h=d._proxy||c.guid(),e;if(f.allowCache){d._proxy=h;}if(d._requests[h]===undefined){d._requests[h]=0;}if(d._timeouts[h]===undefined){d._timeouts[h]=0;}d._requests[h]++;g.unshift(d.url,"YUI.Env.JSONP."+h);e=f.format.apply(d,g);if(!f.on.success){return d;}function i(k,j){return(b(k))?function(n){var m=true,l="_requests";if(j){++d._timeouts[h];--d._requests[h];}else{if(!d._requests[h]){m=false;l="_timeouts";}--d[l][h];}if(!d._requests[h]&&!d._timeouts[h]){delete YUI.Env.JSONP[h];}if(m){k.apply(f.context,[n].concat(f.args));}}:null;}YUI.Env.JSONP[h]=i(f.on.success);c.Get.script(e,{onFailure:i(f.on.failure),onTimeout:i(f.on.timeout,true),timeout:f.timeout,charset:f.charset,attributes:f.attributes});return d;},_format:function(d,e){return d.replace(/\{callback\}/,e);}};c.JSONPRequest=a;c.jsonp=function(d,f){var e=new c.JSONPRequest(d,f);return e.send.apply(e,c.Array(arguments,2,true));};if(!YUI.Env.JSONP){YUI.Env.JSONP={};}},"3.5.0",{requires:["get","oop"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("jsonp-url",function(d){var a=d.JSONPRequest,c=d.Object.getValue,b=function(){};d.mix(a.prototype,{_pattern:/\bcallback=(.*?)(?=&|$)/i,_template:"callback={callback}",_defaultCallback:function(g){var f=g.match(this._pattern),j=[],h=0,e,k,l;if(f){e=f[1].replace(/\[(['"])(.*?)\1\]/g,function(m,i,n){j[h]=n;return".@"+(h++);}).replace(/\[(\d+)\]/g,function(m,i){j[h]=parseInt(i,10)|0;return".@"+(h++);}).replace(/^\./,"");if(!/[^\w\.\$@]/.test(e)){k=e.split(".");for(h=k.length-1;h>=0;--h){if(k[h].charAt(0)==="@"){k[h]=j[parseInt(k[h].substr(1),10)];}}l=c(d.config.win,k)||c(d,k)||c(d,k.slice(1));}}return l||b;},_format:function(e,g){var h=this._template.replace(/\{callback\}/,g),f;if(this._pattern.test(e)){return e.replace(this._pattern,h);}else{f=e.slice(-1);if(f!=="&"&&f!=="?"){e+=(e.indexOf("?")>-1)?"&":"?";}return e+h;}}},true);},"3.5.0",{requires:["jsonp"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("history-base",function(b){var i=b.Lang,e=b.Object,l=YUI.namespace("Env.History"),m=b.Array,n=b.config.doc,f=n.documentMode,j=b.config.win,c={merge:true},h="change",a="add",g="replace";function d(){this._init.apply(this,arguments);}b.augment(d,b.EventTarget,null,null,{emitFacade:true,prefix:"history",preventable:false,queueable:true});if(!l._state){l._state={};}function k(o){return i.type(o)==="object";}d.NAME="historyBase";d.SRC_ADD=a;d.SRC_REPLACE=g;d.html5=!!(j.history&&j.history.pushState&&j.history.replaceState&&("onpopstate" in j||b.UA.gecko>=2)&&(!b.UA.android||b.UA.android>=2.4));d.nativeHashChange=("onhashchange" in j||"onhashchange" in n)&&(!f||f>7);b.mix(d.prototype,{_init:function(p){var o;p=this._config=p||{};this.force=!!p.force;o=this._initialState=this._initialState||p.initialState||null;this.publish(h,{broadcast:2,defaultFn:this._defChangeFn});if(o){this.replace(o);}},add:function(){var o=m(arguments,0,true);o.unshift(a);return this._change.apply(this,o);},addValue:function(p,r,o){var q={};q[p]=r;return this._change(a,q,o);},get:function(p){var q=l._state,o=k(q);if(p){return o&&e.owns(q,p)?q[p]:undefined;}else{return o?b.mix({},q,true):q;}},replace:function(){var o=m(arguments,0,true);o.unshift(g);return this._change.apply(this,o);},replaceValue:function(p,r,o){var q={};q[p]=r;return this._change(g,q,o);},_change:function(q,p,o){o=o?b.merge(c,o):c;if(o.merge&&k(p)&&k(l._state)){p=b.merge(l._state,p);}this._resolveChanges(q,p,o);return this;},_fireEvents:function(q,p,o){this.fire(h,{_options:o,changed:p.changed,newVal:p.newState,prevVal:p.prevState,removed:p.removed,src:q});e.each(p.changed,function(s,r){this._fireChangeEvent(q,r,s);},this);e.each(p.removed,function(s,r){this._fireRemoveEvent(q,r,s);},this);},_fireChangeEvent:function(q,o,p){this.fire(o+"Change",{newVal:p.newVal,prevVal:p.prevVal,src:q});},_fireRemoveEvent:function(q,o,p){this.fire(o+"Remove",{prevVal:p,src:q});},_resolveChanges:function(u,s,p){var t={},o,r=l._state,q={};s||(s={});p||(p={});if(k(s)&&k(r)){e.each(s,function(v,w){var x=r[w];if(v!==x){t[w]={newVal:v,prevVal:x};o=true;}},this);e.each(r,function(w,v){if(!e.owns(s,v)||s[v]===null){delete s[v];q[v]=w;o=true;}},this);}else{o=s!==r;}if(o||this.force){this._fireEvents(u,{changed:t,newState:s,prevState:r,removed:q},p);}},_storeState:function(p,o){l._state=o||{};},_defChangeFn:function(o){this._storeState(o.src,o.newVal,o._options);}},true);b.HistoryBase=d;},"3.5.0",{requires:["event-custom-complex"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("history-html5",function(g){var b=g.HistoryBase,c=g.Lang,f=g.config.win,d=g.config.useHistoryHTML5,h="popstate",e=b.SRC_REPLACE;function a(){a.superclass.constructor.apply(this,arguments);}g.extend(a,b,{_init:function(i){var j=f.history.state;i||(i={});if(i.initialState&&c.type(i.initialState)==="object"&&c.type(j)==="object"){this._initialState=g.merge(i.initialState,j);}else{this._initialState=j;}g.on("popstate",this._onPopState,f,this);a.superclass._init.apply(this,arguments);},_storeState:function(k,j,i){if(k!==h){f.history[k===e?"replaceState":"pushState"](j,i.title||g.config.doc.title||"",i.url||null);}a.superclass._storeState.apply(this,arguments);},_onPopState:function(i){this._resolveChanges(h,i._event.state||null);}},{NAME:"historyhtml5",SRC_POPSTATE:h});if(!g.Node.DOM_EVENTS.popstate){g.Node.DOM_EVENTS.popstate=1;}g.HistoryHTML5=a;if(d===true||(d!==false&&b.html5)){g.History=a;}},"3.5.0",{optional:["json"],requires:["event-base","history-base","node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("history-hash",function(a){var c=a.HistoryBase,f=a.Lang,l=a.Array,j=a.Object,k=YUI.namespace("Env.HistoryHash"),b="hash",e,d,i,h=a.config.win,m=a.config.useHistoryHTML5;function g(){g.superclass.constructor.apply(this,arguments);}a.extend(g,c,{_init:function(n){var o=g.parseHash();n=n||{};this._initialState=n.initialState?a.merge(n.initialState,o):o;a.after("hashchange",a.bind(this._afterHashChange,this),h);g.superclass._init.apply(this,arguments);},_change:function(p,o,n){j.each(o,function(r,q){if(f.isValue(r)){o[q]=r.toString();}});return g.superclass._change.call(this,p,o,n);},_storeState:function(q,p){var o=g.decode,n=g.createHash(p);g.superclass._storeState.apply(this,arguments);if(q!==b&&o(g.getHash())!==o(n)){g[q===c.SRC_REPLACE?"replaceHash":"setHash"](n);}},_afterHashChange:function(n){this._resolveChanges(b,g.parseHash(n.newHash),{});}},{NAME:"historyHash",SRC_HASH:b,hashPrefix:"",_REGEX_HASH:/([^\?#&]+)=([^&]+)/g,createHash:function(p){var n=g.encode,o=[];j.each(p,function(r,q){if(f.isValue(r)){o.push(n(q)+"="+n(r));}});return o.join("&");},decode:function(n){return decodeURIComponent(n.replace(/\+/g," "));},encode:function(n){return encodeURIComponent(n).replace(/%20/g,"+");},getHash:(a.UA.gecko?function(){var n=a.getLocation(),p=/#(.*)$/.exec(n.href),q=p&&p[1]||"",o=g.hashPrefix;return o&&q.indexOf(o)===0?q.replace(o,""):q;}:function(){var n=a.getLocation(),p=n.hash.substring(1),o=g.hashPrefix;return o&&p.indexOf(o)===0?p.replace(o,""):p;}),getUrl:function(){return location.href;},parseHash:function(q){var n=g.decode,r,u,s,o,p={},t=g.hashPrefix,v;q=f.isValue(q)?q:g.getHash();if(t){v=q.indexOf(t);if(v===0||(v===1&&q.charAt(0)==="#")){q=q.replace(t,"");}}s=q.match(g._REGEX_HASH)||[];for(r=0,u=s.length;r<u;++r){o=s[r].split("=");p[n(o[0])]=n(o[1]);}return p;},replaceHash:function(p){var n=a.getLocation(),o=n.href.replace(/#.*$/,"");if(p.charAt(0)==="#"){p=p.substring(1);}n.replace(o+"#"+(g.hashPrefix||"")+p);},setHash:function(o){var n=a.getLocation();if(o.charAt(0)==="#"){o=o.substring(1);}n.hash=(g.hashPrefix||"")+o;}});e=k._notifiers;if(!e){e=k._notifiers=[];}a.Event.define("hashchange",{on:function(p,n,o){if(p.compareTo(h)||p.compareTo(a.config.doc.body)){e.push(o);}},detach:function(q,o,p){var n=l.indexOf(e,p);if(n!==-1){e.splice(n,1);}}});d=g.getHash();i=g.getUrl();if(c.nativeHashChange){a.Event.attach("hashchange",function(p){var n=g.getHash(),o=g.getUrl();l.each(e.concat(),function(q){q.fire({_event:p,oldHash:d,oldUrl:i,newHash:n,newUrl:o});});d=n;i=o;},h);}else{if(!k._hashPoll){k._hashPoll=a.later(50,null,function(){var o=g.getHash(),n,p;if(d!==o){p=g.getUrl();n={oldHash:d,oldUrl:i,newHash:o,newUrl:p};d=o;i=p;l.each(e.concat(),function(q){q.fire(n);});}},null,true);}}a.HistoryHash=g;if(m===false||(!a.History&&m!==true&&(!c.html5||!a.HistoryHTML5))){a.History=g;}},"3.5.0",{requires:["event-synthetic","history-base","yui-later"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("history-hash-ie",function(f){if(f.UA.ie&&!f.HistoryBase.nativeHashChange){var b=f.Do,c=YUI.namespace("Env.HistoryHash"),a=f.HistoryHash,d=c._iframe,e=f.config.win;a.getIframeHash=function(){if(!d||!d.contentWindow){return"";}var g=a.hashPrefix,h=d.contentWindow.location.hash.substr(1);return g&&h.indexOf(g)===0?h.replace(g,""):h;};a._updateIframe=function(h,g){var i=d&&d.contentWindow&&d.contentWindow.document,j=i&&i.location;if(!i||!j){return;}if(g){j.replace(h.charAt(0)==="#"?h:"#"+h);}else{i.open().close();j.hash=h;}};b.before(a._updateIframe,a,"replaceHash",a,true);if(!d){f.on("domready",function(){var g=a.getHash();d=c._iframe=f.Node.getDOMNode(f.Node.create('<iframe src="javascript:0" style="display:none" height="0" width="0" tabindex="-1" title="empty"/>'));f.config.doc.documentElement.appendChild(d);a._updateIframe(g||"#");f.on("hashchange",function(h){g=h.newHash;if(a.getIframeHash()!==g){a._updateIframe(g);}},e);f.later(50,null,function(){var h=a.getIframeHash();if(h!==g){a.setHash(h);}},null,true);});}}},"3.5.0",{requires:["history-hash","node-base"]});/*
YUI 3.5.0 (build 5089)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
YUI.add("router",function(h){var c=h.HistoryHash,b=h.QueryString,f=h.Array,g=h.config.win,e=[],d="ready";function a(){a.superclass.constructor.apply(this,arguments);}h.Router=h.extend(a,h.Base,{_regexPathParam:/([:*])([\w\-]+)?/g,_regexUrlQuery:/\?([^#]*).*$/,_regexUrlOrigin:/^(?:[^\/#?:]+:\/\/|\/\/)[^\/]*/,initializer:function(j){var i=this;i._html5=i.get("html5");i._routes=[];i._url=i._getURL();i._setRoutes(j&&j.routes?j.routes:i.get("routes"));if(i._html5){i._history=new h.HistoryHTML5({force:true});h.after("history:change",i._afterHistoryChange,i);}else{h.on("hashchange",i._afterHistoryChange,g,i);}i.publish(d,{defaultFn:i._defReadyFn,fireOnce:true,preventable:false});i.once("initializedChange",function(){h.once("load",function(){setTimeout(function(){i.fire(d,{dispatched:!!i._dispatched});},20);});});},destructor:function(){if(this._html5){h.detach("history:change",this._afterHistoryChange,this);}else{h.detach("hashchange",this._afterHistoryChange,g);}},dispatch:function(){this.once(d,function(){this._ready=true;if(this._html5&&this.upgrade()){return;}else{this._dispatch(this._getPath(),this._getURL());}});return this;},getPath:function(){return this._getPath();},hasRoute:function(i){if(!this._hasSameOrigin(i)){return false;}return !!this.match(this.removeRoot(i)).length;},match:function(i){return f.filter(this._routes,function(j){return i.search(j.regex)>-1;});},removeRoot:function(j){var i=this.get("root");j=j.replace(this._regexUrlOrigin,"");if(i&&j.indexOf(i)===0){j=j.substring(i.length);}return j.charAt(0)==="/"?j:"/"+j;},replace:function(i){return this._queue(i,true);},route:function(j,k){var i=[];this._routes.push({callback:k,keys:i,path:j,regex:this._getRegex(j,i)});return this;},save:function(i){return this._queue(i);},upgrade:function(){if(!this._html5){return false;}var i=c.getHash();if(i&&i.charAt(0)==="/"){this.once(d,function(){this.replace(i);});return true;}return false;},_decode:function(i){return decodeURIComponent(i.replace(/\+/g," "));},_dequeue:function(){var i=this,j;if(!YUI.Env.windowLoaded){h.once("load",function(){i._dequeue();});return this;}j=e.shift();return j?j():this;},_dispatch:function(n,k,o){var j=this,i=j.match(n),m,l;j._dispatching=j._dispatched=true;if(!i||!i.length){j._dispatching=false;return j;}m=j._getRequest(n,k,o);l=j._getResponse(m);m.next=function(q){var s,r,p;if(q){h.error(q);}else{if((p=i.shift())){r=p.regex.exec(n);s=typeof p.callback==="string"?j[p.callback]:p.callback;if(r.length===p.keys.length+1){m.params=f.hash(p.keys,r.slice(1));}else{m.params=r.concat();}s.call(j,m,l,m.next);}}};m.next();j._dispatching=false;return j._dequeue();},_getHashPath:function(){return c.getHash().replace(this._regexUrlQuery,"");},_getOrigin:function(){var i=h.getLocation();return i.origin||(i.protocol+"//"+i.host);},_getPath:function(){var i=(!this._html5&&this._getHashPath())||h.getLocation().pathname;return this.removeRoot(i);},_getQuery:function(){var i=h.getLocation(),k,j;if(this._html5){return i.search.substring(1);}k=c.getHash();j=k.match(this._regexUrlQuery);return k&&j?j[1]:i.search.substring(1);},_getRegex:function(j,i){if(j instanceof RegExp){return j;}if(j==="*"){return(/.*/);}j=j.replace(this._regexPathParam,function(l,k,m){if(!m){return k==="*"?".*":l;}i.push(m);return k==="*"?"(.*?)":"([^/]*)";});return new RegExp("^"+j+"$");},_getRequest:function(j,i,k){return{path:j,query:this._parseQuery(this._getQuery()),url:i,src:k};},_getResponse:function(j){var i=function(){return j.next.apply(this,arguments);};i.req=j;return i;},_getRoutes:function(){return this._routes.concat();},_getURL:function(){return h.getLocation().toString();},_hasSameOrigin:function(j){var i=((j&&j.match(this._regexUrlOrigin))||[])[0];if(i&&i.indexOf("//")===0){i=h.getLocation().protocol+i;}return !i||i===this._getOrigin();},_joinURL:function(j){var i=this.get("root");j=this.removeRoot(j);if(j.charAt(0)==="/"){j=j.substring(1);}return i&&i.charAt(i.length-1)==="/"?i+j:i+"/"+j;},_parseQuery:b&&b.parse?b.parse:function(m){var n=this._decode,p=m.split("&"),l=0,k=p.length,j={},o;for(;l<k;++l){o=p[l].split("=");if(o[0]){j[n(o[0])]=n(o[1]||"");}}return j;},_queue:function(){var j=arguments,i=this;e.push(function(){if(i._html5){if(h.UA.ios&&h.UA.ios<5){i._save.apply(i,j);}else{setTimeout(function(){i._save.apply(i,j);},1);}}else{i._dispatching=true;i._save.apply(i,j);}return i;});return !this._dispatching?this._dequeue():this;},_save:function(j,k){var i=typeof j==="string";if(i&&!this._hasSameOrigin(j)){h.error("Security error: The new URL must be of the same origin as the current URL.");return this;}this._ready=true;if(this._html5){this._history[k?"replace":"add"](null,{url:i?this._joinURL(j):j});}else{i&&(j=this.removeRoot(j));if(j===c.getHash()){this._dispatch(this._getPath(),this._getURL());}else{c[k?"replaceHash":"setHash"](j);}}return this;},_setRoutes:function(i){this._routes=[];f.each(i,function(j){this.route(j.path,j.callback);},this);return this._routes.concat();},_afterHistoryChange:function(k){var i=this,m=k.src,j=i._url,l=i._getURL();i._url=l;if(m==="popstate"&&(!i._ready||j.replace(/#.*$/,"")===l.replace(/#.*$/,""))){return;}i._dispatch(i._getPath(),l,m);},_defReadyFn:function(i){this._ready=true;}},{NAME:"router",ATTRS:{html5:{valueFn:function(){return h.Router.html5;},writeOnce:"initOnly"},root:{value:""},routes:{value:[],getter:"_getRoutes",setter:"_setRoutes"}},html5:h.HistoryBase.html5&&(!h.UA.android||h.UA.android>=3)});h.Controller=h.Router;},"3.5.0",{optional:["querystring-parse"],requires:["array-extras","base-build","history"]});YUI.add('supra.dd-ddm', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/*
	 * Overwrite Y.DD.DDM shim activation to allow having separate shim for each document
	 * because of iframes
	 */
	Supra.mix(Y.DD.DDM, {
		
		// Preserve original functions
		_pg_activateOriginal: Y.DD.DDM._pg_activate,
		_createPGOriginal: Y.DD.DDM._createPG,
		
		/**
		 * Document body to which _pg belongs to
		 * @private
		 */
		_pg_body: null,
		
		/**
		 * List of all _pg elements and their document bodies
		 * @private
		 */
		_pg_list: [],
		
		
		/**
		 * Add document to the list of documents to which shim should
		 * be added
		 */
		regDoc: function (doc) {
			var list = this._pg_list,
				i = 0,
				ii = list.length,
				body = doc.body,
				original = Y.config.doc,
				_pg = this._pg,
				object = null;
			
			for (; i<ii; i++) {
				if (list[i]._pg_body === body) {
					// Already exists
					return;
				}
			}
			
			// If registering other document than this then reset _pg
			if (doc !== original) {
				this._pg = null;
			}
			
			// Add to the list
			list.push({
				'_pg': this._pg,
				'_pg_doc': doc,
				'_pg_body': doc.body
			});
			
			// Set up listeners
			Y.config.doc = doc;
			Y.DD.DDM._setupListeners();
			Y.config.doc = original;
			
			// If registering other document than this then restore correct _pg 
			if (doc !== original) {
				this._pg = null;
				this._pg_set(original);
			}
		},
		
		/**
		 * Remove document from the list of documents
		 */
		unregDoc: function (doc) {
			var list = this._pg_list,
				i = 0,
				ii = list.length,
				body = doc.body;
			
			// To be sure all targets are deactivated
			//this._deactivateTargets();
			
			for (; i<ii; i++) {
				if (list[i]._pg_body === body) {
					if (body === this._pg_body) {
						// Set new document
						this._pg_set(document);
					}
					list.splice(i, 1);
					return;
				}
			}
		},
		
		/**
		 * Activates the shim for document in which active drag element is inside
		 * if document was added using addDoc()
		 * 
		 * @private
		 */
		_pg_activate: function () {
			var node = this.activeDrag.get('node'),
				doc  = node.getDOMNode().ownerDocument,
				original_doc = Y.config.doc,
				//doc  = document,
				//original_doc = document,
				body = doc.body,
				create = false;
			
			// If current pg owner document body doesn't match then search
			// for existing from the list
			if (this._pg_body !== body) {
				this._pg_set(doc);
			}
			
			this._pg_activateOriginal();
			
			// Restore original document in config after _pg has been created
			Y.config.doc = original_doc;
		},
		
		/**
		 * Finds document in the list of registered documents
		 * 
		 * @param {Object} doc Document
		 * @returns {Object} Object with document, body and shim node
		 * @private
		 */
		_pg_find: function (doc) {
			var list = this._pg_list,
				i = 0,
				ii = list.length,
				body = doc.body;
			
			for (; i<ii; i++) {
				if (list[i]._pg_body === body) {
					return list[i];
				}
			}
			
			return null;
		},
		
		/**
		 * Set document as active
		 * 
		 * @param {Object} doc Document element
		 * @private
		 */
		_pg_set: function (doc) {
			var item = this._pg_find(doc);
			if (item) {
				// Found a match
				this._pg_body = item._pg_body;
				this._pg = item._pg;
				
				// Update document
				Y.config.doc = item._pg_doc;
			}
		},
		
		/**
		 * Create shim element and save it in the registered document list
		 * 
		 * @private
		 */
		_createPG: function () {
			this._createPGOriginal();
			
			// Save _pg element
			this._pg_find(Y.config.doc)._pg = this._pg;
		}
		
	});
	
	// Register self immediatelly
	Y.DD.DDM.regDoc(Y.config.doc);
	
}, YUI.version, {'requires': ['dd-ddm']});/**
 * Adds on('exist', ...) event to YUI Event class
 * 
 * Usage:
 * 		//Event handler function will be called when AppList object will exist
 * 		Y.on('exist', function () {...}, 'Supra.Dashboard.AppList');
 */
YUI.add('supra.event', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//If already defined, then exit
	if (Y.Event.onExist) return;
	
	var Event = Y.Event;
	var _exist = [];
	var _original_load = Event._load;
	var _retryCount = 0;
	
	Event._exist_interval = null;
	Event.onExist = function(id, fn, p_obj, p_override, checkContent, compat) {

        var a = Y.Array(id), i, existHandle;

        for (i=0; i<a.length; i=i+1) {
            _exist.push({ 
                id:         a[i], 
                fn:         fn, 
                obj:        p_obj, 
                override:   p_override, 
                checkReady: checkContent,
                compat:     compat 
            });
        }
        _retryCount = this.POLL_RETRYS;

        // We want the first test to be immediate, but async
        setTimeout(Y.bind(Event._poll_exist, Event), 0);

        existHandle = new Y.EventHandle({

            _delete: function() {
                // set by the event system for lazy DOM listeners
                if (existHandle.handle) {
                    existHandle.handle.detach();
					return;
                }

                var i, j;

                // otherwise try to remove the onAvailable listener(s)
                for (i = 0; i < a.length; i++) {
                    for (j = 0; j < _exist.length; j++) {
                        if (a[i] === _exist[j].id) {
                            _exist.splice(j, 1);
                        }
                    }
                }
            }

        });

        return existHandle;
    };
	
	Event._poll_exist = function() {
        if (this.locked) {
            return;
        }

        this.locked = true;

        // keep trying until after the page is loaded.  We need to 
        // check the page load state prior to trying to bind the 
        // elements so that we can be certain all elements have been 
        // tested appropriately
        var i, len, item, el, notExist, executeItem,
            tryAgain = true;

        if (!tryAgain) {
            tryAgain = (_retryCount > 0);
        }

        // onAvailable
        notExist = [];

        executeItem = function (el, item) {
            var context, ov = item.override;
            if (item.compat) {
                if (item.override) {
                    if (ov === true) {
                        context = item.obj;
                    } else {
                        context = ov;
                    }
                } else {
                    context = el;
                }
                item.fn.call(context, item.obj);
            } else {
                context = item.obj || el;
                item.fn.apply(context, (Y.Lang.isArray(ov)) ? ov : []);
            }
        };

        // onAvailable
        for (i=0,len=_exist.length; i<len; ++i) {
            item = _exist[i];
            if (item && !item.checkReady) {

                // el = (item.compat) ? Y.DOM.byId(item.id) : Y.one(item.id);
                var obj_id = item.id.split('.');
				var targ = window;
				for(var k=0,kk=obj_id.length; k<kk; k++) {
					if (obj_id[k] in targ) {
						targ = targ[obj_id[k]];
					} else {
						targ = null;
						notExist.push(item);
						break;
					}
				}
				
				if (targ) {
					executeItem(el, item);
                    _exist[i] = null;
				}
            }
        }
		
        _retryCount = (notExist.length === 0) ? 0 : _retryCount - 1;

        if (tryAgain) {
            // we may need to strip the nulled out items here
            this.startExistInterval();
        } else {
            clearInterval(this._exist_interval);
            this._exist_interval = null;
        }

        this.locked = false;

        return;

    };
		
	Event.startExistInterval = function() {
        if (!Event._exist_interval) {
			Event._exist_interval = setInterval(Y.bind(Event._poll_exist, Event), Event.POLL_INTERVAL);
        }
    };
		
	Event._load = function () {
		_original_load.apply(this, arguments);
		Event._poll_exist();
	};
	
	
	//Add plugin
	Y.Env.evt.plugins.exist = {
	    on: function(type, fn, id, o) {
	        var a = arguments.length > 4 ?  Y.Array(arguments, 4, true) : [];
	        return Y.Event.onExist.call(Y.Event, id, fn, o, a);
	    }
	};

}, YUI.version, {requires:['event-custom-base']});YUI().add("supra.io", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var ERROR_INVALID_RESPONSE = 'Error occured, please try again later';
	
	Supra.io = function (url, cfg, permissions, callback, context) {
		var io = null;
		
		//Clone args object to make sure it's unchanged
		var args = [url, cfg, permissions, callback, context];
		
		//Check optional arguments
		var normal = Supra.io.normalizeArguments(url, cfg, permissions, callback, context);
		url         = normal[0];
		cfg         = normal[1];
		permissions = normal[2];
		callback    = normal[3];
		context     = normal[4];
		
		//Success and failure methods are overwritten, save references to originals
		cfg.on._success = cfg.on.success;
		cfg.on._failure = cfg.on.failure;
		cfg.on._complete = cfg.on.complete;
		cfg.on.complete = null;
		cfg._data = cfg.data;
		cfg._url = url;
		cfg.deferred = cfg.deferred || new Supra.Deferred();
		
		//Add session id to data
		if (!('data' in cfg) || !Y.Lang.isObject(cfg.data)) {
			cfg._data = cfg.data = {};
		}
		
		//Convert Supra.Form into data
		if (cfg.data.isInstanceOf && cfg.data.isInstanceOf('form')) {
			cfg.data = cfg.data.getSaveValues();
		}
		
		var sid_name = Supra.data.get('sessionName', null),
			sid_id = Supra.data.get('sessionId', null);
			
		if (sid_name && sid_id) {
			cfg.data[sid_name] = sid_id;
		}
		
		//Add permissions to the request
		if (cfg.permissions) {
			cfg.data = Supra.mix({
				'_check-permissions': cfg.permissions
			}, cfg.data);
			
			//Make sure Supra.Permission.request doesn't do another request
			Supra.Permission.setIsLoading(cfg.permissions)
		}
		
		//Convert object into string compatible with PHP
		cfg.data = Supra.io.serializeIntoString(cfg.data);
		
		//Set callbacks
		cfg.on.success = function (transaction, response) {
			
			if (cfg.transportMethod != 'jsonp') {
				// Second argument is data as string
				var response = Supra.io.parseResponse(url, cfg, response.responseText);
			} else {
				// First argument is data as object/array/etc
				var response = Supra.io.parseResponse(url, cfg, transaction);
			}
			return Supra.io.handleResponse(cfg, response);

		};
		cfg.on.failure = function (transaction, response) {

			if (cfg.transportMethod != 'jsonp') {
				// XHR request
				if (response.status == 401) {
					//Authentication error, session expired
					Y.log('Session expired', 'info');
					
					var pre_filter_message = response.getResponseHeader('X-Authentication-Pre-Filter-Message');
					var pre_filter_redirect_url = response.getResponseHeader('X-Authentication-Pre-Filter-Redirect');
					
					//If there is authentication message then this was login request
					//which shouldn't be queued
					if (!pre_filter_message) {
						Supra.io.loginRequestQueue.add(args);
					}
					
					return Supra.io.handleResponse(cfg, {
						'status': response.status,
						'success': false,
						'data': null,
						'error_message': pre_filter_message,
						'redirect_url': pre_filter_redirect_url
					});
					
				} else {
					//Invalid response
					Y.log('Request to "' + url + '" failed', 'debug');
					
					if (response.responseText) {
						
						var response = Supra.io.parseResponse(url, cfg, response.responseText);
						response.status = false;
						
						return Supra.io.handleResponse(cfg, response);
						
					} else {
						
						return Supra.io.handleResponse(cfg, {
							'status': 0,
							'success': false,
							'data': null,
							'error_message': ERROR_INVALID_RESPONSE
						});
					}
					
				}
			} else {
				// JSONP request
				Y.log('Request to "' + url + '" failed', 'debug');
				
				return Supra.io.handleResponse(cfg, {
					'status': 0,
					'success': false,
					'data': null,
					'error_message': ERROR_INVALID_RESPONSE
				});
			}
		};
		
		if (cfg.transportMethod === 'jsonp' && cfg.method === 'post') {
			// Trying to send jsonp POST request, currently not supported!
			// Invalid request
			Y.log('Request to "' + url + '" failed, because POST request can not be sent through JSONP', 'debug');
			
			io.supra_cfg = cfg;
			io._abort = io.abort;
			io.abort = Supra.io.abort;
			
			// Apply promise functionality to io object
			cfg.deferred.promise(io);
			
			io.rejectWith(cfg.context, [null, false]);
		} else {
			io = Y[cfg.transportMethod](url, cfg);
			
			io.supra_cfg = cfg;
			io._abort = io.abort;
			io.abort = Supra.io.abort;
			
			// Apply promise functionality to io object
			cfg.deferred.promise(io);
		}
		
		return io;
	};
	
	/**
	 * Abort request without showing an error message
	 */
	Supra.io.abort = function () {
		if (this.supra_cfg) {
			this.supra_cfg.suppress_errors = true;
		}
		this._abort();
	};
	
	/**
	 * Normalize Supra.io arguments
	 * 
	 * @return Array with normalized arguments
	 * @type {Array}
	 * @private
	 */
	Supra.io.normalizeArguments = function (url, cfg, permissions, callback, context) {
		//Check optional arguments
		if (Y.Lang.isArray(cfg)) {
			//cfg argument missing
			context = callback;
			callback = permissions;
			permissions = cfg;
			cfg = {};
		} else if (Y.Lang.isFunction(cfg)) {
			//cfg and permissions arguments missing
			callback = cfg;
			context = permissions;
			cfg = {};
			permissions = null;
		} else if (Y.Lang.isFunction(permissions)) {
			//permissions argument missing
			context = callback;
			callback = permissions;
			permissions = null;
		} else if (Y.Lang.isObject(permissions) && !Y.Lang.isArray(permissions)) {
			//permissions and callback arguments missing
			context = permissions;
			callback = null;
			permissions = null;
		} else if (Y.Lang.isObject(callback)) {
			context = callback;
			callback = null;
		}
		
		//Normalize permissions
		if (!Y.Lang.isArray(permissions)) {
			permissions = null;
		}
		
		//Configuration
		if (!Y.Lang.isObject(cfg)) {
			cfg = {};
		}
		
		var cfg_new = {
			'type': 'json',
			'data': null,
			'permissions': permissions,
			'sync': false,
			'context': context,
			'suppress_errors': false,
			'transportMethod': 'io',
			'on': {
				'success': callback,
				'failure': null,
				'complete': null
			}
		};
		
		//External request ?
		if (url.indexOf('http') == 0 && url.indexOf(document.location.protocol + '//' + document.location.hostname) == -1) {
			cfg_new.type = 'jsonplain';
			cfg_new.transportMethod = 'jsonp';
			cfg_new.method = 'get';
		}
		
		//Save context and remove from config to avoid traversing them on Supra.mix
		context = cfg.context || cfg_new.context;
		cfg.context = cfg_new.context = null;
		
		Supra.mix(cfg_new, cfg, true);
		
		//Restore context
		cfg.context = cfg_new.context = context;
		
		//Remove traversing in url, eq  /folder/folder/../something
		url = url.replace(/\/[^\/\?]+\/\.\.\//i, '/');
		
		return [url, cfg_new, permissions, callback, context];
	};
	
	/**
	 * Parse response and check for correct format
	 * 
	 * @param {Object} cfg Request configuration
	 * @param {String} responseText Response text
	 * @return Parsed response
	 * @type {Object}
	 * @private
	 */
	Supra.io.parseResponse = function (url, cfg, responseText) {
		var data = null,
			response = {'status': false, 'data': null};
		
		//Localization, unless in configuration skipIntl is set
		if (responseText.indexOf && responseText.indexOf('{#') !== -1 && (!cfg || !cfg.skipIntl)) {
			responseText = Supra.Intl.replace(responseText, 'json');
		}
		
		try {
			switch((cfg.type || '').toLowerCase()) {
				case 'json':
					data = typeof responseText === 'object' ? responseText : Y.JSON.parse(responseText);
					Supra.mix(response, data);
					break;
				case 'jsonplain':
					data = typeof responseText === 'object' ? responseText : Y.JSON.parse(responseText);
					Supra.mix(response, {'status': true, 'data': data});
					break;
				default:
					response = {'status': true, 'data': responseText};
					break;
			}
			
			if (!response.status && !response.error_message) {
				//Request didn't completed successfully and there is no message,
				//show default error message
				response.error_message = ERROR_INVALID_RESPONSE;
			}
			
		} catch (e) {
			Y.log('Unable to parse "' + url + '" request response: invalid JSON', 'debug');
			response.error_message = ERROR_INVALID_RESPONSE;
		}
		
		return response;
	};
	
	/**
	 * Handle response.
	 * Show error message, confirmation window and call success or failure callbacks
	 * 
	 * @param {Object} cfg Request configuration
	 * @param {Object} response Response object
	 * @private
	 */
	Supra.io.handleResponse = function (cfg, response) {
		//Show login/password form
		if (response.status == 401) {
			
			if (response.redirect_url) {
				return this.handleRedirect(cfg, response);
			}
			
			if (Supra.Manager) {
				Supra.Manager.executeAction('Login', response);
			}
			
			return;
		}
		
		//Show error message
		if (response.error_message) {
			this.handleErrorMessage(cfg, response);
		
		//Show warning messages
		} else if (response.warning_message) {
			this.handleWarningMessage(cfg, response);
		}
		
		//Show confirmation message
		if (response.confirmation) {
			return this.handleConfirmationMessage(cfg, response);
		}
		
		//Handle permissions
		if (response.permissions) {
			Supra.Permission.add(response.permissions, cfg.permissions);
		}
		
		//Missing callbacks, ignore
		if (!cfg || !cfg.on) return null;
		
		//Call callbacks
		var fn  = response.status ? cfg.on._success : cfg.on._failure,
			ret = null,
			deferred = cfg.deferred;
		
		if (Y.Lang.isFunction(cfg.on._complete)) {
			cfg.on._complete.apply(cfg.context, [response.data, response.status]);
		}
		
		if (Y.Lang.isFunction(fn)) {
			ret = fn.apply(cfg.context, [response.data, response.status]);
		}
		
		//Deferred
		if (response.status) {
			deferred.resolveWith(cfg.context, [response.data, response.status]);
		} else {
			deferred.rejectWith(cfg.context, [response.data, response.status]);
		}
		
		delete(cfg.permissions);
		delete(cfg._data);
		delete(cfg.data);
		delete(cfg.on._success);
		delete(cfg.on._failure);
		delete(cfg.on.success);
		delete(cfg.on.failure);
		delete(cfg.on._complete);
		delete(cfg.on.complete);
		delete(cfg.deferred);
		
		return ret;
	};
	
	/**
	 * Handle error message parameter
	 * Show error message
	 * 
	 * @param {Object} request Request configuration
	 * @param {Object} response Request response
	 * @private
	 */
	Supra.io.handleErrorMessage = function (cfg, response) {
		//No error or warning messages when "suppress_errors" parameter is set
		if (cfg.suppress_errors) return;
		
		Supra.Manager.executeAction('Confirmation', {
		    'message': response.error_message,
		    'useMask': true,
		    'buttons': [
		        {'id': 'delete', 'label': 'OK'}
		    ]
		});
	};
	
	/**
	 * Handle warning message parameter
	 * Show warning message
	 * 
	 * @param {Object} request Request configuration
	 * @param {Object} response Request response
	 * @private
	 */
	Supra.io.handleWarningMessage = function (cfg, response) {
		//No error or warning messages when "suppress_errors" parameter is set
		if (cfg.suppress_errors) return;
		
		var message,
			single;
		
		if (Y.Lang.isArray(response.warning_message)) {
			
			message = response.warning_message;

			if(message.length == 0) {
				return;
			}
			else if(message.lenght == 1) {
				
				single = true;
				message = message.shift();
			}
			else if (message.length > 1) {
				
				single = false;
				message = '{#error.warnings#}<ul><li>' + message.join('</li><li>') + '</li></ul>';
			}
		} 
		
		Supra.Manager.executeAction('Confirmation', {
			'message': message,
			'align': single ? 'center' : 'left',
			'useMask': true,
			'buttons': [
				{'id': 'delete', 'label': 'OK'}
			]
		});
	};
	
	/**
	 * Handle confirmation message parameter
	 * Show confirmation message
	 * 
	 * @param {Object} request Request configuration
	 * @param {Object} response Request response
	 * @private
	 */
	Supra.io.handleConfirmationMessage = function (cfg, response) {
		Supra.Manager.executeAction('Confirmation', {
		    'message': response.confirmation.question,
		    'useMask': true,
		    'buttons': [
		    	{'id': 'yes', 'context': this, 'click': function () { this.handleConfirmationResult(1, cfg, response); }},
		    	{'id': 'no',  'context': this, 'click': function () { this.handleConfirmationResult(0, cfg, response); }}
		    ]
		});
	};
	
	/**
	 * Handle redirect response
	 * 
	 * @param {Object} request Request configuration
	 * @param {Object} response Request response
	 * @private
	 */
	Supra.io.handleRedirect = function (cfg, response) {
		// Note: this may not go through if user is editing page
		document.location = response.redirect_url;
	};
	
	/**
	 * On message confirm or deny send same request again and add answer to
	 * the data
	 * 
	 * @param {Number} answer Confirmation message answer
	 * @param {Object} request Request configuration
	 * @param {Object} response Request response
	 * @private
	 */
	Supra.io.handleConfirmationResult = function (answer, cfg, response) {
		
		// Wrong answer, do nothing
		if (response.confirmation.answer != null && response.confirmation.answer != answer) {
			if (cfg.on._complete) {
				cfg.on._complete.apply(cfg.context, [null, false]);
			}
			return;
		}
		
		var url = cfg._url;
		
		//Restore original values
		cfg.on.success  = cfg.on._success;
		cfg.on.failure  = cfg.on._failure;
		cfg.on.complete = cfg.on._complete;
		cfg.data        = cfg._data;
		
		delete(cfg.on._success);
		delete(cfg.on._failure);
		delete(cfg.on._complete);
		delete(cfg._data);
		delete(cfg._url);
		
		//Add answer to the request
		if (!('data' in cfg) || !Y.Lang.isObject(cfg.data)) {
			cfg.data = {};
		}
		if (!('_confirmation' in cfg.data)) {
			cfg.data['_confirmation'] = {};
		}
		
		cfg.data['_confirmation'][response.confirmation.id] = answer;
		
		//Run request again
		Supra.io(url, cfg);
	};
	
	
	/**
	 * 
	 * @param {Object} obj
	 * @param {Object} prefix
	 */
	Supra.io.serialize = function (obj, prefix) {
		if (!Y.Lang.isObject(obj) && !Y.Lang.isArray(obj)) return obj;
		var o = {}, name = null;
		
		// Advanced encoding
		if (obj && typeof obj.toURIComponent === 'function') {
			obj = obj.toURIComponent();
			
			if (obj === undefined) {
				return {}; // do not convert
			}
		}
		
		for(var i in obj) {
			if (obj.hasOwnProperty(i)) {
				// Advanced encoding
				if (obj[i] && typeof obj[i].toURIComponent === 'function') {
					obj[i] = obj[i].toURIComponent();
					
					if (obj[i] === undefined) {
						continue; // do not convert
					}
				}
				
				name = (prefix ? prefix + '[' + encodeURIComponent(i) + ']' : encodeURIComponent(i));
				
				if (Y.Lang.isDate(obj[i])) {
					//Automatically format date to Y-m-d
					o[name] = encodeURIComponent(Y.DataType.Date.reformat(obj[i], 'raw', 'in_datetime'));
				} else if (Y.Lang.isObject(obj[i]) || Y.Lang.isArray(obj[i])) {
					Supra.mix(o, this.serialize(obj[i], name));
				} else {
					//Null or undefined shouldn't be sent to server-side, because they are received as strings
					o[name] = encodeURIComponent(obj[i] === null || obj[i] === undefined ? '' : obj[i]);
				}
			}
		}
		
		return o;
	};
	
	/**
	 * Serialize data into string
	 * 
	 * @param {Object} obj
	 * @return Serialized data
	 * @type {String}
	 */
	Supra.io.serializeIntoString = function (obj) {
		if (!Y.Lang.isObject(obj) && !Y.Lang.isArray(obj)) return obj;
		var obj = Supra.io.serialize(obj), o = [];
		
		for(var i in obj) {
			o[o.length] = i + '=' + obj[i];
		}
		
		return o.join('&');
	};
	
	/**
	 * Queue of requests which resulted in 401 responses
	 */
	Supra.io.loginRequestQueue = {
		'queue': [],
		
		/**
		 * Add request to the queue
		 * 
		 * @param {Array} args Request arguments
		 */
		'add': function (args) {
			this.queue.push(args);
		},
		
		/**
		 * Execute all requests from queue
		 */
		'run': function () {
			var queue = this.queue;
			this.queue = [];
			
			for(var i=0,ii=queue.length; i<ii; i++) {
				Supra.io.apply(Supra.io, queue[i]);
			}
		}
	};
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ["io", "json", "jsonp", "jsonp-url"]});YUI.add('supra.intl', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Intl = Supra.Intl = {
		
		/**
		 * Data filename
		 * @type {String}
		 * @private
		 */
		FILENAME: 'lang',
		
		/**
		 * Default locale which filename shouldn't have a prefix
		 * @type {String}
		 * @private
		 */
		DEFAULT_NON_PREFIXED_LOCALE: 'en',
		
		/**
		 * Internationalized data
		 * @type {Object}
		 * @private
		 */
		data: {},
		
		/**
		 * Paths for which Intl data is loaded
		 * @type {Object}
		 * @private
		 */
		loaded: {},
		
		/**
		 * List of Intl data which is being loaded
		 * @type {Object}
		 * @private
		 */
		loading: {},
		
		/**
		 * Callbacks
		 * @type {Object}
		 * @private
		 */
		callbacks: {},
		
		
		/**
		 * Add internationalization
		 * 
		 * @param {Object} data Data
		 */
		add: function (data /* Data */) {
			
			//Add to data
			Supra.mix(this.data, data || {}, true);
			
			//Add to Y.Intl
			for(var ns in data) {
				Supra.Y.Intl.add(ns, '', data[ns]);
			}
		},
		
		/**
		 * Returns true if internationalization data is already loaded
		 * 
		 * @param {String} app_path Application path
		 * @return True if already loaded
		 * @type {Boolean}
		 */
		isLoaded: function (app_path /* Application path */) {
			return this.loaded[app_path];
		},
		
		/**
		 * Load internationalization data
		 * 
		 * @param {String} app_path Application path
		 * @param {String} requestURI Request URI
		 * @param {Function} callback Optional. Callback function
		 * @param {Object} context Optional. Callback execution context
		 */
		load: function (app_path /* Application path*/, requestURI /* Request URI */, callback /* Callback */, context /* Context */) {
			Supra.io(requestURI, {
				'context': this,
				'on': {
					'complete': function (data, status) {
						this.loading[app_path] = false;
						this.loaded[app_path] = true;
						
						if (data) this.add(data);
						
						//Execute callbacks
						var callbacks = this.callbacks[app_path];
						if (callbacks) {
							delete(this.callbacks[app_path]);
							for(var i=0,ii=callbacks.length; i<ii; i++) {
								callbacks[i][0].call(callbacks[i][1], data);
							}
						}
					}
				}
			});
			
		},
		
		/**
		 * Load internationalization data for application
		 * 
		 * @param {String} app_path Application path
		 * @param {Function} callback Optional. Callback function
		 * @param {Object} context Optional. Callback execution context
		 */
		loadAppData: function (app_path /* Application path */, callback /* Callback */, context /* Context */) {
			if (this.loaded[app_path]) {
				//Call callback
				if (Y.Lang.isFunction(callback)) {
					callback.call(context || window, this.data);
				}
				//Skip
				return;
			}
			
			//Add callback to the list
			if (Y.Lang.isFunction(callback)) {
				if (!this.callbacks[app_path]) this.callbacks[app_path] = [];
				this.callbacks[app_path].push([callback, context || window]);
			}
			
			//Already loading, skip
			if (this.loading[app_path]) return;
			this.loading[app_path] = true;
			
			var locale = Supra.data.get('lang', ''),
				prefix = '',
				uri    = app_path + '/';
			
			if (locale && locale != this.DEFAULT_NON_PREFIXED_LOCALE) {
				prefix = '.' + locale;
			}
			
			uri += this.FILENAME + prefix + '.json';
			
			this.load(app_path, uri, callback ,context);
		},
		
		/**
		 * Returns internationalized string
		 * 
		 * @param {Array} ns Namespace
		 * @param {Object} data Optional. Data to check against
		 * @return Internationalized string
		 * @type {String}
		 */
		get: function (ns /* Namespace */, data /* Data to check against */) {
			var obj = data || this.data,
				i = 0,
				ii = ns.length;
			
			for(; i<ii; i++) {
				obj = obj[ns[i]];
				if (obj === undefined) {
					//If data exists then already checked against Y.Intl
					if (data) return null;
					return this.get(ns.slice(1), Y.Intl.get(ns[0]));
				}
			}
			
			return obj;
		},
		
		/**
		 * Replace all occurances of {#...#} with internationalized strings
		 * 
		 * @param {String} template Template
		 * @param {String} escape Escape type
		 * @return Internationalized template
		 * @type {String}
		 */
		replace: function (template /* Template */, escape /* Escape type */) {
			var self = this,
				template = template || '';
			
			if (template.indexOf('#') == -1) {
				return template;
			}
			
			return template.replace(/{#([^#]+)#}/g, function (all, key) {
				var key = Y.Lang.trim(key),
					ret = self.get(key.split('.')) || all;
				
				if (escape == 'json') { //Escape as JSON string without leading and trailing quotes
					ret = Y.JSON.stringify(ret).replace(/^"|"$/g, '');
				} else if (escape == 'html') {
					ret = Y.Escape.html(ret);
				}
				
				return ret;
			});
		}
	};
	
	//Since this object has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
	
}, YUI.version, {'requires': ['intl', 'supra.io']});YUI().add("supra.lang", function (Y) {
	//Invoke strict mode
	"use strict";
	
	//If already defined, then exit
	if (Y.Lang.toArray) return;
	
	//Shortcuts
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var WINDOW = window.constructor;
	var DOCUMENT = document.constructor;
	
	
	
	/**
	 * Convert Object into Array
	 * 
	 * @param {Object} obj
	 * @return Array
	 * @type {Array}
	 */
	Y.Lang.toArray = function (obj) {
		if ('length' in obj) {
			return [].slice.call(obj, 0);
		} else {
			var arr = [], ii=0;
			for(var i in obj) {
				if (obj.hasOwnProperty(i)) arr[ii++] = obj[i];
			}
			return arr;
		}
	};
	
	/**
	 * Returns true if obj is Object and not Array, Function, document or window
	 * 
	 * @param {Object} obj
	 * @return True if obj is plain object
	 * @type {Boolean}
	 */
	Y.Lang.isPlainObject = function (obj) {
		if (obj &&									//not empty
			Y.Lang.isObject(obj, true) &&			//is object and not function
			!obj.nodeType &&						//not HTMLElement
			!Y.Lang.isArray(obj) &&					//not array
			!(obj instanceof DOCUMENT) &&			//not document
			!(obj instanceof WINDOW)) {				//not window
			
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwnProperty.call(obj, "constructor") &&
				!hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
			
			return true;
			
		}
		return false;
	};
	
	/**
	 * Returns true if obj is widget instance
	 * 
	 * @param {Object} obj Object to check
	 * 
	 */
	Y.Lang.isWidget = function (obj, classname) {
		if (obj && Y.Lang.isObject(obj) && !Y.Lang.isPlainObject(obj) && obj.isInstanceOf) {
			
			if (classname) {
				return obj.isInstanceOf(classname);
			}
			
			return true;
		}
		
		return false;
	};
	
	/**
	 * Compare if two objects has all the same properties
	 * 
	 * @param {Object} o1
	 * @param {Object} o2
	 * @private
	 */
	Y.Lang.compareObjects = function (o1, o2) {
		var o1_size = 0,
			o2_size = 0,
			v1 = null,
			v2 = null;
			key = null;
		
		for(key in o2) o2_size++;
		
		for(key in o1) {
			if (!(key in o2)) return false;
			v1 = o1[key];
			v2 = o2[key];
			
			if ((Y.Lang.isArray(v1) && Y.Lang.isArray(v2)) || (Y.Lang.isObject(v1) && Y.Lang.isObject(v2))) {
				if (!Y.Lang.compareObjects(v1, v2)) return false;
			} else {
				if (v1 !== v2) return false;
			}
			
			o1_size++;
		}
		
		return o1_size == o2_size;
	};
	
	/**
	 * Convert all invalid characters into url compatible form
	 * 
	 * @param {String} str String to convert
	 * @returns {String} Converted string
	 */
	Y.Lang.toPath = function (str) {
		str = String(str || '');
		
		// Convert non-ASCII characters
		var map = Y.Lang.toPath.map,
			i = 0,
			ii = str.length,
			out = '',
			chr = '';
		
		for (; i<ii; i++) {
			chr = str[i];
			out += (chr in map ? map[chr] : chr);
		}
		
		str = out.toLowerCase();
		
		// Replace invalid characters with dash
		str = str.replace(/[^a-z0-9\-]/g, '-');
		
		// Remove invalid first and last characters
		str = str.replace(/(^[^a-z0-9]+|[^a-z0-9]+$)/g, '');
		
		// remove repeated characters
		str = str.replace(/([\-\_])[\-\_]+/g, '$1');
		
		return str;
	};
	
	/**
	 * Non-ASCII to ASCII character map
	 * @type {Object}
	 * @private
	 */
	Y.Lang.toPath.map = {'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'Ae', 'Å': 'A', 'Æ': 'A', 'Ā': 'A', 'Ą': 'A', 'Ă': 'A', 'Ç': 'C', 'Ć': 'C', 'Č': 'C', 'Ĉ': 'C', 'Ċ': 'C', 'Ď': 'D', 'Đ': 'D', 'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E', 'Ē': 'E', 'Ę': 'E', 'Ě': 'E', 'Ĕ': 'E', 'Ė': 'E', 'Ĝ': 'G', 'Ğ': 'G', 'Ġ': 'G', 'Ģ': 'G', 'Ĥ': 'H', 'Ħ': 'H', 'Ì': 'I', 'Í': 'I', 'Î': 'I', 'Ï': 'I', 'Ī': 'I', 'Ĩ': 'I', 'Ĭ': 'I', 'Į': 'I', 'İ': 'I', 'Ĳ': 'IJ', 'Ĵ': 'J', 'Ķ': 'K', 'Ľ': 'K', 'Ĺ': 'K', 'Ļ': 'K', 'Ŀ': 'K', 'Ł': 'L', 'Ñ': 'N', 'Ń': 'N', 'Ň': 'N', 'Ņ': 'N', 'Ŋ': 'N', 'Ò': 'O', 'Ó': 'O', 'Ô': 'O', 'Õ': 'O', 'Ö': 'Oe', 'Ø': 'O', 'Ō': 'O', 'Ő': 'O', 'Ŏ': 'O', 'Œ': 'OE', 'Ŕ': 'R', 'Ř': 'R', 'Ŗ': 'R', 'Ś': 'S', 'Ş': 'S', 'Ŝ': 'S', 'Ș': 'S', 'Š': 'S', 'Ť': 'T', 'Ţ': 'T', 'Ŧ': 'T', 'Ț': 'T', 'Ù': 'U', 'Ú': 'U', 'Û': 'U', 'Ü': 'Ue', 'Ū': 'U', 'Ů': 'U', 'Ű': 'U', 'Ŭ': 'U', 'Ũ': 'U', 'Ų': 'U', 'Ŵ': 'W', 'Ŷ': 'Y', 'Ÿ': 'Y', 'Ý': 'Y', 'Ź': 'Z', 'Ż': 'Z', 'Ž': 'Z', 'à': 'a', 'á': 'a', 'â': 'a', 'ã': 'a', 'ä': 'ae', 'ā': 'a', 'ą': 'a', 'ă': 'a', 'å': 'a', 'æ': 'ae', 'ç': 'c', 'ć': 'c', 'č': 'c', 'ĉ': 'c', 'ċ': 'c', 'ď': 'd', 'đ': 'd', 'è': 'e', 'é': 'e', 'ê': 'e', 'ë': 'e', 'ē': 'e', 'ę': 'e', 'ě': 'e', 'ĕ': 'e', 'ė': 'e', 'ƒ': 'f', 'ĝ': 'g', 'ğ': 'g', 'ġ': 'g', 'ģ': 'g', 'ĥ': 'h', 'ħ': 'h', 'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i', 'ī': 'i', 'ĩ': 'i', 'ĭ': 'i', 'į': 'i', 'ı': 'i', 'ĳ': 'ij', 'ĵ': 'j', 'ķ': 'k', 'ĸ': 'k', 'ł': 'l', 'ľ': 'l', 'ĺ': 'l', 'ļ': 'l', 'ŀ': 'l', 'ñ': 'n', 'ń': 'n', 'ň': 'n', 'ņ': 'n', 'ŉ': 'n', 'ŋ': 'n', 'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'oe', 'ø': 'o', 'ō': 'o', 'ő': 'o', 'ŏ': 'o', 'œ': 'oe', 'ŕ': 'r', 'ř': 'r', 'ŗ': 'r', 'ś': 's', 'š': 's', 'ť': 't', 'ù': '', 'ú': '', 'û': '', 'ü': 'ue', 'ū': '', 'ů': '', 'ű': '', 'ŭ': '', 'ũ': '', 'ų': '', 'ŵ': 'w', 'ÿ': 'y', 'ý': 'y', 'ŷ': 'y', 'ż': 'z', 'ź': 'z', 'ž': 'z', 'ß': 'ss', 'ſ': 'ss', 'Α': 'A', 'Ά': 'A', 'Ἀ': 'A', 'Ἁ': 'A', 'Ἂ': 'A', 'Ἃ': 'A', 'Ἄ': 'A', 'Ἅ': 'A', 'Ἆ': 'A', 'Ἇ': 'A', 'ᾈ': 'A', 'ᾉ': 'A', 'ᾊ': 'A', 'ᾋ': 'A', 'ᾌ': 'A', 'ᾍ': 'A', 'ᾎ': 'A', 'ᾏ': 'A', 'Ᾰ': 'A', 'Ᾱ': 'A', 'Ὰ': 'A', 'Ά': 'A', 'ᾼ': 'A', 'Β': 'B', 'Γ': 'G', 'Δ': 'D', 'Ε': 'E', 'Έ': 'E', 'Ἐ': 'E', 'Ἑ': 'E', 'Ἒ': 'E', 'Ἓ': 'E', 'Ἔ': 'E', 'Ἕ': 'E', 'Έ': 'E', 'Ὲ': 'E', 'Ζ': 'Z', 'Η': 'I', 'Ή': 'I', 'Ἠ': 'I', 'Ἡ': 'I', 'Ἢ': 'I', 'Ἣ': 'I', 'Ἤ': 'I', 'Ἥ': 'I', 'Ἦ': 'I', 'Ἧ': 'I', 'ᾘ': 'I', 'ᾙ': 'I', 'ᾚ': 'I', 'ᾛ': 'I', 'ᾜ': 'I', 'ᾝ': 'I', 'ᾞ': 'I', 'ᾟ': 'I', 'Ὴ': 'I', 'Ή': 'I', 'ῌ': 'I', 'Θ': 'TH', 'Ι': 'I', 'Ί': 'I', 'Ϊ': 'I', 'Ἰ': 'I', 'Ἱ': 'I', 'Ἲ': 'I', 'Ἳ': 'I', 'Ἴ': 'I', 'Ἵ': 'I', 'Ἶ': 'I', 'Ἷ': 'I', 'Ῐ': 'I', 'Ῑ': 'I', 'Ὶ': 'I', 'Ί': 'I', 'Κ': 'K', 'Λ': 'L', 'Μ': 'M', 'Ν': 'N', 'Ξ': 'KS', 'Ο': 'O', 'Ό': 'O', 'Ὀ': 'O', 'Ὁ': 'O', 'Ὂ': 'O', 'Ὃ': 'O', 'Ὄ': 'O', 'Ὅ': 'O', 'Ὸ': 'O', 'Ό': 'O', 'Π': 'P', 'Ρ': 'R', 'Ῥ': 'R', 'Σ': 'S', 'Τ': 'T', 'Υ': 'Y', 'Ύ': 'Y', 'Ϋ': 'Y', 'Ὑ': 'Y', 'Ὓ': 'Y', 'Ὕ': 'Y', 'Ὗ': 'Y', 'Ῠ': 'Y', 'Ῡ': 'Y', 'Ὺ': 'Y', 'Ύ': 'Y', 'Φ': 'F', 'Χ': 'X', 'Ψ': 'PS', 'Ω': 'O', 'Ώ': 'O', 'Ὠ': 'O', 'Ὡ': 'O', 'Ὢ': 'O', 'Ὣ': 'O', 'Ὤ': 'O', 'Ὥ': 'O', 'Ὦ': 'O', 'Ὧ': 'O', 'ᾨ': 'O', 'ᾩ': 'O', 'ᾪ': 'O', 'ᾫ': 'O', 'ᾬ': 'O', 'ᾭ': 'O', 'ᾮ': 'O', 'ᾯ': 'O', 'Ὼ': 'O', 'Ώ': 'O', 'ῼ': 'O', 'α': 'a', 'ά': 'a', 'ἀ': 'a', 'ἁ': 'a', 'ἂ': 'a', 'ἃ': 'a', 'ἄ': 'a', 'ἅ': 'a', 'ἆ': 'a', 'ἇ': 'a', 'ᾀ': 'a', 'ᾁ': 'a', 'ᾂ': 'a', 'ᾃ': 'a', 'ᾄ': 'a', 'ᾅ': 'a', 'ᾆ': 'a', 'ᾇ': 'a', 'ὰ': 'a', 'ά': 'a', 'ᾰ': 'a', 'ᾱ': 'a', 'ᾲ': 'a', 'ᾳ': 'a', 'ᾴ': 'a', 'ᾶ': 'a', 'ᾷ': 'a', 'β': 'b', 'γ': 'g', 'δ': 'd', 'ε': 'e', 'έ': 'e', 'ἐ': 'e', 'ἑ': 'e', 'ἒ': 'e', 'ἓ': 'e', 'ἔ': 'e', 'ἕ': 'e', 'ὲ': 'e', 'έ': 'e', 'ζ': 'z', 'η': 'i', 'ή': 'i', 'ἠ': 'i', 'ἡ': 'i', 'ἢ': 'i', 'ἣ': 'i', 'ἤ': 'i', 'ἥ': 'i', 'ἦ': 'i', 'ἧ': 'i', 'ᾐ': 'i', 'ᾑ': 'i', 'ᾒ': 'i', 'ᾓ': 'i', 'ᾔ': 'i', 'ᾕ': 'i', 'ᾖ': 'i', 'ᾗ': 'i', 'ὴ': 'i', 'ή': 'i', 'ῂ': 'i', 'ῃ': 'i', 'ῄ': 'i', 'ῆ': 'i', 'ῇ': 'i', 'θ': 'th', 'ι': 'i', 'ί': 'i', 'ϊ': 'i', 'ΐ': 'i', 'ἰ': 'i', 'ἱ': 'i', 'ἲ': 'i', 'ἳ': 'i', 'ἴ': 'i', 'ἵ': 'i', 'ἶ': 'i', 'ἷ': 'i', 'ὶ': 'i', 'ί': 'i', 'ῐ': 'i', 'ῑ': 'i', 'ῒ': 'i', 'ΐ': 'i', 'ῖ': 'i', 'ῗ': 'i', 'κ': 'k', 'λ': 'l', 'μ': 'm', 'ν': 'n', 'ξ': 'ks', 'ο': 'o', 'ό': 'o', 'ὀ': 'o', 'ὁ': 'o', 'ὂ': 'o', 'ὃ': 'o', 'ὄ': 'o', 'ὅ': 'o', 'ὸ': 'o', 'ό': 'o', 'π': 'p', 'ρ': 'r', 'ῤ': 'r', 'ῥ': 'r', 'σ': 's', 'ς': 's', 'τ': 't', 'υ': 'y', 'ύ': 'y', 'ϋ': 'y', 'ΰ': 'y', 'ὐ': 'y', 'ὑ': 'y', 'ὒ': 'y', 'ὓ': 'y', 'ὔ': 'y', 'ὕ': 'y', 'ὖ': 'y', 'ὗ': 'y', 'ὺ': 'y', 'ύ': 'y', 'ῠ': 'y', 'ῡ': 'y', 'ῢ': 'y', 'ΰ': 'y', 'ῦ': 'y', 'ῧ': 'y', 'φ': 'f', 'χ': 'x', 'ψ': 'ps', 'ω': 'o', 'ώ': 'o', 'ὠ': 'o', 'ὡ': 'o', 'ὢ': 'o', 'ὣ': 'o', 'ὤ': 'o', 'ὥ': 'o', 'ὦ': 'o', 'ὧ': 'o', 'ᾠ': 'o', 'ᾡ': 'o', 'ᾢ': 'o', 'ᾣ': 'o', 'ᾤ': 'o', 'ᾥ': 'o', 'ᾦ': 'o', 'ᾧ': 'o', 'ὼ': 'o', 'ώ': 'o', 'ῲ': 'o', 'ῳ': 'o', 'ῴ': 'o', 'ῶ': 'o', 'ῷ': 'o', '¨': '', '΅': '', '᾿': '', '῾': '', '῍': '', '῝': '', '῎': '', '῞': '', '῏': '', '῟': '', '῀': '', '῁': '', '΄': '', '΅': '', '`': '', '῭': '', 'ͺ': '', '᾽': '', 'А': 'A', 'Б': 'B', 'В': 'V', 'Г': 'G', 'Д': 'D', 'Е': 'E', 'Ё': 'E', 'Ж': 'ZH', 'З': 'Z', 'И': 'I', 'Й': 'I', 'К': 'K', 'Л': 'L', 'М': 'M', 'Н': 'N', 'О': 'O', 'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T', 'У': 'U', 'Ф': 'F', 'Х': 'KH', 'Ц': 'TS', 'Ч': 'CH', 'Ш': 'SH', 'Щ': 'SHCH', 'Ы': 'Y', 'Э': 'E', 'Ю': 'YU', 'Я': 'YA', 'а': 'A', 'б': 'B', 'в': 'V', 'г': 'G', 'д': 'D', 'е': 'E', 'ё': 'E', 'ж': 'ZH', 'з': 'Z', 'и': 'I', 'й': 'I', 'к': 'K', 'л': 'L', 'м': 'M', 'н': 'N', 'о': 'O', 'п': 'P', 'р': 'R', 'с': 'S', 'т': 'T', 'у': 'U', 'ф': 'F', 'х': 'KH', 'ц': 'TS', 'ч': 'CH', 'ш': 'SH', 'щ': 'SHCH', 'ы': 'Y', 'э': 'E', 'ю': 'YU', 'я': 'YA', 'Ъ': '', 'ъ': '', 'Ь': '', 'ь': '', 'ð': 'd', 'Ð': 'D', 'þ': 'th', 'Þ': 'TH', 'ა': 'a', 'ბ': 'b', 'გ': 'g', 'დ': 'd', 'ე': 'e', 'ვ': 'v', 'ზ': 'z', 'თ': 't', 'ი': 'i', 'კ': 'k', 'ლ': 'l', 'მ': 'm', 'ნ': 'n', 'ო': 'o', 'პ': 'p', 'ჟ': 'zh', 'რ': 'r', 'ს': 's', 'ტ': 't', 'უ': '', 'ფ': 'p', 'ქ': 'k', 'ღ': 'gh', 'ყ': 'q', 'შ': 'sh', 'ჩ': 'ch', 'ც': 'ts', 'ძ': 'dz', 'წ': 'ts', 'ჭ': 'ch', 'ხ': 'kh', 'ჯ': 'j', 'ჰ': 'h' };

}, YUI.version);YUI.add('supra.lipsum', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Lorem ipsum text generator
	 */
	var Lipsum = {
		
		/**
		 * List of words
		 * @type {Array}
		 * @private
		 */
		LIPSUM: [
	        "lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipiscing", "elit", "ut", "aliquam,", "purus", "sit", "amet", "luctus", "venenatis,", "lectus", "magna", "fringilla", "urna,", "porttitor", "rhoncus", "dolor", "purus", "non", "enim", "praesent", "elementum", "facilisis", "leo,", "vel", "fringilla", "est", "ullamcorper", "eget", "nulla", "facilisi", "etiam", "dignissim", "diam", "quis", "enim", "lobortis", "scelerisque", "fermentum", "dui", "faucibus", "in", "ornare", "quam", "viverra", "orci", "sagittis", "eu", "volutpat", "odio", "facilisis", "mauris", "sit", "amet", "massa", "vitae", "tortor", "condimentum", "lacinia", "quis", "vel", "eros", "donec", "ac", "odio", "tempor", "orci", "dapibus", "ultrices", "in", "iaculis", "nunc", "sed", "augue", "lacus,", "viverra", "vitae", "congue", "eu,", "consequat", "ac", "felis", "donec", "et", "odio", "pellentesque", "diam", "volutpat", "commodo", "sed", "egestas", "egestas", "fringilla", "phasellus", "faucibus", "scelerisque", "eleifend", "donec", "pretium", "vulputate", "sapien", "nec", "sagittis", "aliquam", "malesuada", "bibendum", "arcu", "vitae", "elementum",
	        "curabitur", "vitae", "nunc", "sed", "velit", "dignissim", "sodales", "ut", "eu", "sem", "integer", "vitae", "justo", "eget", "magna", "fermentum", "iaculis", "eu", "non", "diam", "phasellus", "vestibulum", "lorem", "sed", "risus", "ultricies", "tristique", "nulla", "aliquet", "enim", "tortor,", "at", "auctor", "urna", "nunc", "id", "cursus", "metus", "aliquam", "eleifend", "mi", "in", "nulla", "posuere", "sollicitudin", "aliquam", "ultrices", "sagittis", "orci,", "a", "scelerisque", "purus", "semper", "eget", "duis", "at", "tellus", "at", "urna", "condimentum", "mattis", "pellentesque", "id", "nibh", "tortor,", "id", "aliquet", "lectus", "proin", "nibh", "nisl,", "condimentum", "id", "venenatis", "a,", "condimentum", "vitae", "sapien", "pellentesque", "habitant", "morbi", "tristique", "senectus", "et", "netus", "et", "malesuada", "fames", "ac", "turpis", "egestas", "sed", "tempus,", "urna", "et", "pharetra", "pharetra,", "massa", "massa", "ultricies", "mi,", "quis", "hendrerit", "dolor", "magna", "eget", "est", "lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipiscing", "elit", "pellentesque", "habitant", "morbi", "tristique", "senectus", "et", "netus", "et", "malesuada", "fames", "ac", "turpis", "egestas", "integer", "eget", "aliquet", "nibh", "praesent", "tristique", "magna", "sit", "amet", "purus", "gravida", "quis", "blandit", "turpis", "cursus", "in", "hac", "habitasse", "platea", "dictumst", "quisque", "sagittis,", "purus", "sit", "amet", "volutpat", "consequat,", "mauris", "nunc", "congue", "nisi,", "vitae", "suscipit", "tellus", "mauris", "a", "diam",
	        "maecenas", "sed", "enim", "ut", "sem", "viverra", "aliquet", "eget", "sit", "amet", "tellus", "cras", "adipiscing", "enim", "eu", "turpis", "egestas", "pretium", "aenean", "pharetra,", "magna", "ac", "placerat", "vestibulum,", "lectus", "mauris", "ultrices", "eros,", "in", "cursus", "turpis", "massa", "tincidunt", "dui", "ut", "ornare", "lectus", "sit", "amet", "est", "placerat", "in", "egestas", "erat", "imperdiet", "sed", "euismod", "nisi", "porta", "lorem", "mollis", "aliquam", "ut", "porttitor", "leo", "a", "diam", "sollicitudin", "tempor", "id", "eu", "nisl", "nunc", "mi", "ipsum,", "faucibus", "vitae", "aliquet", "nec,", "ullamcorper", "sit", "amet", "risus", "nullam", "eget", "felis", "eget", "nunc", "lobortis", "mattis", "aliquam", "faucibus", "purus", "in", "massa", "tempor", "nec", "feugiat", "nisl", "pretium", "fusce", "id", "velit", "ut", "tortor", "pretium", "viverra", "suspendisse", "potenti", "nullam", "ac", "tortor", "vitae", "purus", "faucibus", "ornare", "suspendisse", "sed", "nisi", "lacus,", "sed", "viverra", "tellus", "in", "hac", "habitasse", "platea", "dictumst", "vestibulum", "rhoncus", "est", "pellentesque", "elit", "ullamcorper", "dignissim", "cras", "tincidunt", "lobortis", "feugiat", "vivamus", "at", "augue", "eget", "arcu", "dictum", "varius", "duis", "at", "consectetur", "lorem",
	        "donec", "massa", "sapien,", "faucibus", "et", "molestie", "ac,", "feugiat", "sed", "lectus", "vestibulum", "mattis", "ullamcorper", "velit", "sed", "ullamcorper", "morbi", "tincidunt", "ornare", "massa,", "eget", "egestas", "purus", "viverra", "accumsan", "in", "nisl", "nisi,", "scelerisque", "eu", "ultrices", "vitae,", "auctor", "eu", "augue", "ut", "lectus", "arcu,", "bibendum", "at", "varius", "vel,", "pharetra", "vel", "turpis", "nunc", "eget", "lorem", "dolor,", "sed", "viverra", "ipsum", "nunc", "aliquet", "bibendum", "enim,", "facilisis", "gravida", "neque", "convallis", "a", "cras", "semper", "auctor", "neque,", "vitae", "tempus", "quam", "pellentesque", "nec", "nam", "aliquam", "sem", "et", "tortor", "consequat", "id", "porta", "nibh", "venenatis", "cras", "sed", "felis", "eget", "velit", "aliquet", "sagittis", "id", "consectetur", "purus", "ut", "faucibus", "pulvinar", "elementum", "integer", "enim", "neque,", "volutpat", "ac", "tincidunt", "vitae,", "semper", "quis", "lectus", "nulla", "at", "volutpat", "diam", "ut", "venenatis", "tellus", "in", "metus", "vulputate", "eu", "scelerisque", "felis", "imperdiet", "proin", "fermentum", "leo", "vel", "orci", "porta", "non", "pulvinar", "neque", "laoreet", "suspendisse", "interdum", "consectetur", "libero,", "id", "faucibus", "nisl", "tincidunt", "eget", "nullam", "non", "nisi", "est,", "sit", "amet", "facilisis", "magna",
	        "etiam", "tempor,", "orci", "eu", "lobortis", "elementum,", "nibh", "tellus", "molestie", "nunc,", "non", "blandit", "massa", "enim", "nec", "dui", "nunc", "mattis", "enim", "ut", "tellus", "elementum", "sagittis", "vitae", "et", "leo", "duis", "ut", "diam", "quam", "nulla", "porttitor", "massa", "id", "neque", "aliquam", "vestibulum", "morbi", "blandit", "cursus", "risus,", "at", "ultrices", "mi", "tempus", "imperdiet", "nulla", "malesuada", "pellentesque", "elit", "eget", "gravida", "cum", "sociis", "natoque", "penatibus", "et", "magnis", "dis", "parturient", "montes,", "nascetur", "ridiculus", "mus", "mauris", "vitae", "ultricies", "leo", "integer", "malesuada", "nunc", "vel", "risus", "commodo", "viverra", "maecenas", "accumsan,", "lacus", "vel", "facilisis", "volutpat,", "est", "velit", "egestas", "dui,", "id", "ornare", "arcu", "odio", "ut", "sem", "nulla", "pharetra", "diam", "sit", "amet", "nisl", "suscipit", "adipiscing", "bibendum", "est", "ultricies", "integer", "quis", "auctor", "elit",
	        "sed", "vulputate", "mi", "sit", "amet", "mauris", "commodo", "quis", "imperdiet", "massa", "tincidunt", "nunc", "pulvinar", "sapien", "et", "ligula", "ullamcorper", "malesuada", "proin", "libero", "nunc,", "consequat", "interdum", "varius", "sit", "amet,", "mattis", "vulputate", "enim", "nulla", "aliquet", "porttitor", "lacus,", "luctus", "accumsan", "tortor", "posuere", "ac", "ut", "consequat", "semper", "viverra", "nam", "libero", "justo,", "laoreet", "sit", "amet", "cursus", "sit", "amet,", "dictum", "sit", "amet", "justo", "donec", "enim", "diam,", "vulputate", "ut", "pharetra", "sit", "amet,", "aliquam", "id", "diam", "maecenas", "ultricies", "mi", "eget", "mauris", "pharetra", "et", "ultrices", "neque", "ornare", "aenean", "euismod", "elementum", "nisi,", "quis", "eleifend", "quam", "adipiscing", "vitae", "proin", "sagittis,", "nisl", "rhoncus", "mattis", "rhoncus,", "urna", "neque", "viverra", "justo,", "nec", "ultrices", "dui", "sapien", "eget", "mi", "proin", "sed", "libero", "enim,", "sed", "faucibus", "turpis", "in", "eu", "mi", "bibendum", "neque", "egestas", "congue", "quisque", "egestas", "diam", "in", "arcu", "cursus", "euismod", "quis", "viverra", "nibh", "cras", "pulvinar", "mattis", "nunc,", "sed", "blandit", "libero", "volutpat", "sed", "cras", "ornare", "arcu", "dui", "vivamus", "arcu", "felis,", "bibendum", "ut", "tristique", "et,", "egestas", "quis", "ipsum", "suspendisse", "ultrices", "gravida", "dictum",
	        "fusce", "ut", "placerat", "orci", "nulla", "pellentesque", "dignissim", "enim,", "sit", "amet", "venenatis", "urna", "cursus", "eget", "nunc", "scelerisque", "viverra", "mauris,", "in", "aliquam", "sem", "fringilla", "ut", "morbi", "tincidunt", "augue", "interdum", "velit", "euismod", "in", "pellentesque", "massa", "placerat", "duis", "ultricies", "lacus", "sed", "turpis", "tincidunt", "id", "aliquet", "risus", "feugiat", "in", "ante", "metus,", "dictum", "at", "tempor", "commodo,", "ullamcorper", "a", "lacus", "vestibulum", "sed", "arcu", "non", "odio", "euismod", "lacinia", "at", "quis", "risus", "sed", "vulputate", "odio", "ut", "enim", "blandit", "volutpat", "maecenas", "volutpat", "blandit", "aliquam", "etiam", "erat", "velit,", "scelerisque", "in", "dictum", "non,", "consectetur", "a", "erat", "nam", "at", "lectus", "urna", "duis", "convallis", "convallis", "tellus,", "id", "interdum", "velit", "laoreet", "id", "donec", "ultrices", "tincidunt", "arcu,", "non", "sodales", "neque", "sodales", "ut", "etiam", "sit", "amet", "nisl", "purus,", "in", "mollis", "nunc",
	        "sed", "id", "semper", "risus", "in", "hendrerit", "gravida", "rutrum", "quisque", "non", "tellus", "orci,", "ac", "auctor", "augue", "mauris", "augue", "neque,", "gravida", "in", "fermentum", "et,", "sollicitudin", "ac", "orci", "phasellus", "egestas", "tellus", "rutrum", "tellus", "pellentesque", "eu", "tincidunt", "tortor", "aliquam", "nulla", "facilisi", "cras", "fermentum,", "odio", "eu", "feugiat", "pretium,", "nibh", "ipsum", "consequat", "nisl,", "vel", "pretium", "lectus", "quam", "id", "leo", "in", "vitae", "turpis", "massa", "sed", "elementum", "tempus", "egestas", "sed", "sed", "risus", "pretium", "quam", "vulputate", "dignissim", "suspendisse", "in", "est", "ante", "in", "nibh", "mauris,", "cursus", "mattis", "molestie", "a,", "iaculis", "at", "erat",
	        "pellentesque", "adipiscing", "commodo", "elit,", "at", "imperdiet", "dui", "accumsan", "sit", "amet", "nulla", "facilisi", "morbi", "tempus", "iaculis", "urna,", "id", "volutpat", "lacus", "laoreet", "non", "curabitur", "gravida", "arcu", "ac", "tortor", "dignissim", "convallis", "aenean", "et", "tortor", "at", "risus", "viverra", "adipiscing", "at", "in", "tellus", "integer", "feugiat", "scelerisque", "varius", "morbi", "enim", "nunc,", "faucibus", "a", "pellentesque", "sit", "amet,", "porttitor", "eget", "dolor", "morbi", "non", "arcu", "risus,", "quis", "varius", "quam", "quisque", "id", "diam", "vel", "quam", "elementum", "pulvinar", "etiam", "non", "quam", "lacus", "suspendisse", "faucibus", "interdum", "posuere", "lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipiscing", "elit", "duis", "tristique", "sollicitudin", "nibh", "sit", "amet", "commodo", "nulla", "facilisi",
	        "nullam", "vehicula", "ipsum", "a", "arcu", "cursus", "vitae", "congue", "mauris", "rhoncus", "aenean", "vel", "elit", "scelerisque", "mauris", "pellentesque", "pulvinar", "pellentesque", "habitant", "morbi", "tristique", "senectus", "et", "netus", "et", "malesuada", "fames", "ac", "turpis", "egestas", "maecenas", "pharetra", "convallis", "posuere", "morbi", "leo", "urna,", "molestie", "at", "elementum", "eu,", "facilisis", "sed", "odio", "morbi", "quis", "commodo", "odio", "aenean", "sed", "adipiscing", "diam", "donec", "adipiscing", "tristique", "risus", "nec", "feugiat", "in", "fermentum", "posuere", "urna", "nec", "tincidunt", "praesent", "semper", "feugiat", "nibh", "sed", "pulvinar", "proin", "gravida", "hendrerit", "lectus", "a", "molestie"
	    ],
	    
	    /**
	     * Generates random word
	     * 
	     * @returns {String} Random word
	     */
	    word: function () {
	    	return this.LIPSUM[this.rand(0, this.LIPSUM.length)];
	    },
		
		/**
		 * Generates number of words
		 * Options:
		 *   {Number} count Number of words to generate
		 *   {Number} variation Number of words by how many count will be increased/decreased (choosen by random)
		 *   {Boolean} capitalize If true then all words will be capitalized
		 *   {Boolean} uppercase If true then all words will be uppercase
		 * 
		 * @param {Object} options Number of words or options
		 * @returns {String} Generated string
		 */
		sentence: function (options) {
			if (typeof options === 'number') {
				options = {'count': options, 'variation': 0, 'capitalize': false, 'uppercase': false, 'punctuation': false};
			} else {
				options = Supra.mix({'count': 8, 'variation': 3, 'capitalize': false, 'uppercase': false, 'punctuation': false}, options);
			}
			
			var rand  = options.variation ? this.rand(-options.variation, options.variation) : 0, 
				count = Math.max(1, options.count + rand),
				i = 0,
				words_list = this.LIPSUM,
				words_count = words_list.length,
				word = null,
				output = [];
			
			for (; i<count; i++) {
				word = words_list[this.rand(0, words_count)];
				
				if (options.capitalize || i == 0) {
					word = word[0].toUpperCase() + word.substr(1);
				}
				if (options.uppercase) {
					word = word.toUpperCase();
				}
				
				output.push(word);
			}
			
			output = output.join(' ');
			
			if (!options.punctuation) {
				return output.replace(/\.|\,/g, '')
			} else {
				return output.replace(/\,$/, '') + '.';
			}
		},
		
		/**
		 * Generate number of sentences (default is 10 to 20) using 5 to 10 words per sentence
		 * Options:
		 *   {Number} count Number of sentences to generate
		 *   {Number} variation Number of sentences by how many count will be increased/decreased (choosen by random)
		 * 
		 * @param {Object} options Number of words or options
		 * @returns {String} Generated string
		 */
		paragraph: function (options) {
			if (typeof options === 'number') {
				options = {'count': options, 'variation': 0};
			} else {
				options = Supra.mix({'count': 15, 'variation': 5}, options);
			}
			
			var rand  = options.variation ? this.rand(-options.variation, options.variation) : 0, 
				count = Math.max(1, options.count + rand),
				i = 0,
				output = [];
			
			for (; i<count; i++) {
				output.push(this.sentence({'punctuation': true}));
			}
			
			return output.join(' ');
		},
		
		/**
		 * Generates HTML with lorem content
		 */
		html: function (options) {
			options = Supra.mix({
				'h1': false,
				'h2': true,
				'h3': true,
				'paragraph': true,
				'list': true
			}, options);
			
			var output = [];
			
			if (options.h1) {
				output.push('<h1>' + this.sentence({'count': 5, 'variation': 2}) + '</h1>');
				if (options.paragraph) output.push('<p>' + this.paragraph() + '</p>');
			}
			if (options.h2) {
				output.push('<h2>' + this.sentence({'count': 5, 'variation': 2}) + '</h2>');
				if (options.paragraph) output.push('<p>' + this.paragraph() + '</p>');
			}
			if (options.h3) {
				output.push('<h3>' + this.sentence({'count': 5, 'variation': 2}) + '</h3>');
				if (options.paragraph) output.push('<p>' + this.paragraph() + '</p>');
			}
			if (options.list) {
				output.push(
					'<ul>\n' +
					'	<li>' + this.sentence() + '</li>\n' +
					'	<li>' + this.sentence() + '</li>\n' +
					'	<li>' + this.sentence() + '</li>\n' +
					'	<li>' + this.sentence() + '</li>\n' +
					'	<li>' + this.sentence() + '</li>\n' +
					'</ul>'
				);
			}
			return output.join('\n');
		},
		
		/**
		 * Generates placeholder image
		 * 
		 * @param {Object} options Image options
		 * @returns {String} Base-64 encoded image or image url
		 */
		image: function (options) {
			// @TODO
		},
		
		/**
		 * Creates random number
		 * 
		 * @param {Number} min Minimal number
		 * @param {Number} max Maximal number
		 * @returns {Number} Random number between min and max
		 */
		rand: function (min, max) {
			min = min || 0;
			var r = Math.random();
			return Math.round(r * (max - min) + min);
		}
		
	};
	
	Supra.Lipsum = Lipsum;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version);/*
 * Add color parsing and formatting
 */
YUI.add('supra.datatype-image', function(Y) {
	//Invoke strict mode
	"use strict";
	
	var Image = Y.namespace("DataType.Image");
	
	Image.parse = function (value) {
		// Parse image information
		if (value && value.sizes) {
			// Add crop information
			value = {
				'image': value,
				'crop_left': 0,
				'crop_top': 0,
				'crop_width': value.sizes.original.width,
				'crop_height': value.sizes.original.height,
				'size_width': value.sizes.original.width,
				'size_height': value.sizes.original.height
			};
		} else if (!value) {
			value = {
				'image': null,
				'crop_left': 0,
				'crop_top': 0,
				'crop_width': 0,
				'crop_height': 0,
				'size_width': 0,
				'size_height': 0
			};
		}
		
		return value;
	};
	
	/**
	 * Format image value by stripping out
	 */
	Image.format = function (value) {
		// Strip image information and replace with id
		if (value.image && value.image.sizes) {
			value.image = value.image.id;
		}
		
		// Make sure crop values are numbers
		if ('crop_left' in value || 'crop_top' in value || 'crop_width' in value || 'crop_height' in value) {
			if (!value.crop_left) value.crop_left = 0;
			if (!value.crop_top) value.crop_top = 0;
			if (!value.crop_width) value.crop_width = value.size_width || 0;
			if (!value.crop_height) value.crop_height = value.size_height || 0;
		}
		
		return value;
	};
	
	/**
	 * Recalculate crop and image size
	 * 
	 * @param {Object} data Image data
	 * @param {Object} options Resize options
	 */
	Image.resize = function (data, options) {
		options = Supra.mix({
			// Try to fill container, valid values are "horizontal", "vertical", "both" and false
			'fill': 'horizontal',
			
			// Node which to use for calculations
			'node': null,
			// If node matches filter value then traverse up the tree to find correct node
			'nodeFilter': '.supra-image, .supra-icon, .supra-image-inner, img',
			
			// If node is not set then this will be used
			'maxCropWidth': 0,
			// If node is not set then this will be used
			'maxCropHeight': 0,
			
			// If crop size changed then also change image size proportionally
			'scale': false
		}, options);
		
		// Find closest node fulfilling filter
		var node = options.node;
		if (node && options.nodeFilter) {
			// Inline nodes take children width, not full
			while (node.test(options.nodeFilter) || node.getStyle('display') == 'inline') {
				node = node.ancestor();
			}
		}
		
		var size = data.image.sizes.original,
			ratio = size.width / size.height,
			coef = 0,
			
			size_width = data.size_width || size.width,
			size_height = data.size_height || size.height,
			crop_left = data.crop_left || 0,
			crop_top = data.crop_top || 0,
			crop_width = data.crop_width || size.width,
			crop_height = data.crop_height || size.height,
			
			size_max_width = size.width,
			size_max_height = size.height,
			crop_min_width = 32,
			crop_min_height = 32,
			crop_max_width = size_max_width,
			crop_max_height = size_max_height,
			
			node_width  = (node ? node.getAttribute('width')  || node.getInnerWidth() : 0)  || options.maxCropWidth || 0,
			node_height = (node ? node.getAttribute('height') || node.getInnerHeight() : 0) || options.maxCropHeight || 0;
		
		// Calculate maximal and miminal widths and heights base on node size
		if (node_width && options.fill === 'horizontal') {
			crop_width = crop_max_width = Math.min(size.width, node_width);
			
			// If crop changed then scale, etc.
			if (crop_width != data.crop_width) {
				if (options.scale) {
					// Change also crop height and size height
					coef = crop_width / data.crop_width;
					
					crop_left   = Math.floor(data.crop_left * coef);
					crop_top    = Math.floor(data.crop_top * coef);
					crop_height = Math.floor(data.crop_height * coef);
					size_width  = Math.floor(data.size_width * coef);
					size_height = Math.floor(data.size_height * coef);
				}
				
				// Validate size
				if (size_width > size_max_width) {
					size_width = size_max_width;
				}
				if (size_height > size_max_height) {
					size_height = size_max_height;
				}
				
				// Validate crop positions
				if (crop_height + crop_top > size_height) {
					crop_top = size_height - crop_height;
					
					if (crop_top < 0) {
						size_height -= crop_top; // increases size_height
						size_width = Math.floor(size_height * ratio);
						crop_top = 0;
						
						if (size_height > size_max_height) {
							// Image not large enough, reduce crop height
							crop_height -= (size_height - size_max_height);
							size_height = size_max_height;
							size_width = size_max_width;
						}
					}
				}
				if (crop_width + crop_left > size_width) {
					crop_left = size_width - crop_width;
					
					if (crop_left < 0) {
						size_width -= crop_left; // increases size_width
						size_height = Math.floor(size_width / ratio);
						crop_left = 0;
						
						if (size_width > size_max_width) {
							// Image not large enough, reduce crop width
							crop_width -= (size_width - size_max_width);
							size_width = size_max_width;
							size_height = size_max_height;
						}
					}
				}
			}
		}
		
		return Supra.mix({}, data, {
			'crop_left': crop_left,
			'crop_top': crop_top,
			'crop_width': crop_width,
			'crop_height': crop_height,
			'size_width': size_width,
			'size_height': size_height
		});
	};
	
}, YUI.version);/*
 * Add color parsing and formatting
 */
YUI.add('supra.datatype-icon', function(Y) {
	//Invoke strict mode
	"use strict";
	
	var Icon = Y.namespace("DataType.Icon");
	
	/**
	 * Icon data object
	 * 
	 * @param {Object} data Icon data or icon instance which should be cloned
	 */
	Y.DataType.Icon = Icon = function (data) {
		if (data instanceof Icon) {
			this.set(data.toJSON());
		} else if (data) {
			this.set(data);
		}
	};
	
	Icon.prototype = {
		
		/**
		 * Icon id
		 * @type {String}
		 */
		id: null,
		
		/**
		 * Type, should be used only when same property name is used for image and icon
		 * @type {String}
		 */
		type: null,
		
		/**
		 * Icon width
		 * @type {Number}
		 */
		width: 64,
		
		/**
		 * Icon height
		 * @type {Number}
		 */
		height: 64,
		
		/**
		 * Icon color
		 * @type {String}
		 */
		color: '',
		
		/**
		 * Icon align position
		 * @type {String}
		 */
		align: '',
		
		
		// Data properties
		
		/**
		 * Icon SVG source
		 * @type {String}
		 */
		svg: '',
		
		/**
		 * Icon SVG source path
		 * @type {String}
		 */
		svg_path: '',
		
		/**
		 * Icon Image path
		 * @type {String}
		 */
		icon_path: '',
		
		/**
		 * Icon title
		 * @type {String}
		 */
		title: '',
		
		/**
		 * Icon keywords for search
		 * @type {String}
		 */
		keywords: '',
		
		/**
		 * Icon category
		 * @type {String}
		 */
		category: '',
		
		
		// Private
		
		/**
		 * SVG icon DOM element
		 * @type {Object}
		 * @private
		 */
		_domNode: null,
		
		/**
		 * Promise object
		 * @type {Object}
		 * @private
		 */
		_promise: null,
		
		
		/**
		 * Load icon SVG data
		 * Returns deferred object, to which when resolved is passed SVG data
		 * 
		 * @returns {Object} Deferred object
		 */
		load: function () {
			if (!this._promise) {
				var deferred = new Supra.Deferred(),
					promise = this._promise = deferred.promise();
				
				if (this.svg) {
					deferred.resolveWith(this, [this.svg]);
				} else if (this.svg_path) {
					Supra.io(this.svg_path, {
						'type': 'html'
					})
						.done(function (svg) {
							this.svg = svg;
							deferred.resolveWith(this, [svg]);
						}, this)
						.fail(function () {
							deferred.rejectWith(this, [null]);
						});
				} else {
					deferred.rejectWith(this, [null]);
				}
			}
			
			return this._promise;
		},
		
		/**
		 * Returns true if all icon data is set
		 * 
		 * @returns {Boolean} True if all icon data is set, otherwise false
		 */
		isDataComplete: function () {
			return !!this.svg;
		},
		
		/**
		 * Update icon properties
		 * 
		 * @param {Object} data Icon data
		 * @private
		 */
		set: function (key, value) {
			if (key && typeof key === 'object') {
				
				// Don't copy functions if passed in object with them
				for (var k in key) {
					if (typeof key[k] !== 'function') {
						this[k] = key[k];
					}
				}
				
				if ('svg' in key) {
					// SVG changed, DOM node is not valid representation of it anymore
					this._domNode = null;
				}
			} else if (typeof key === 'string') {
				this[key] = value;
				
				if (key === 'svg') {
					// SVG changed, DOM node is not valid representation of it anymore
					this._domNode = null;
				}
			}
		},
		
		/**
		 * Render icon into DOM
		 * 
		 * @param {Object} node Container node into which to render or SVG node which to replace
		 * @returns {Object} Promise object, on resolve SVG element element is passed as argument
		 */
		render: function (node) {
			var deferred = new Supra.Deferred(),
				promise  = deferred.promise();
			
			if (!node) {
				deferred.rejectWith(this, []);
				return promise;
			}
			
			if (node.tagName) {
				node = Y.Node(node);
			}
			if (node.test) {
				var svg = this.getDOMNode(),
					ysvg = null;
				
				if (!svg) {
					// Load SVG data and then call render again
					this.load()
						.done(function (svg) {
							this.render(node)
								.done(function (svg) {
									deferred.resolveWith(this, [svg]);
								}, this)
								.fail(function () {
									deferred.rejectWith(this, []);
								});
						}, this)
						.fail(function () {
							deferred.rejectWith(this, []);
						});
					
				} else {
					// We have SVG element, render
					if (node.get('tagName').toUpperCase() === 'SVG') {
						node.empty();
						
						// append <g /> element
						this._renderAppend(svg.childNodes, node, true);
						 
						node.setAttribute('version', '1.1');
						node.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
						node.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
						node.setAttribute('x', '0px');
						node.setAttribute('y', '0px');
						node.setAttribute('viewBox', '0 0 512 512');
						node.setAttribute('enable-background', 'new 0 0 512 512');
						node.setAttribute('xml:space', 'preserve');
						svg = node.getDOMNode();
					} else {
						svg = svg.cloneNode();
						this._renderAppend([svg], node, false);
					}
					
					// Style
					svg.setAttribute('width', (this.width ? this.width + 'px' : ''));
					svg.setAttribute('height', (this.height ? this.height + 'px' : ''));
					svg.style.fill = (this.color ? this.color : '');
					
					// ClassName
					ysvg = Y.Node(svg);
					ysvg.removeClass('align-left')
						.removeClass('align-right')
						.removeClass('align-middle');
					
					if (this.align) {
						ysvg.addClass('align-' + this.align);
					}
					
					deferred.resolveWith(this, [svg]);
				}
			} else {
				deferred.rejectWith(this, []);
			}
			
			return promise;
		},
		
		/**
		 * Returns SVG HTML
		 * 
		 * @param {Object} attr Additional attributes
		 * @param {Boolean} force Returns empty SVG even if there is not SVG data
		 * @returns {String} HTML
		 */
		toHTML: function (attr, force) {
			if (!this.svg && !force) return '';
			attr = attr || {};
			
			var svg = this.svg || '',
				attrs_str = '',
				html = '',
				key = null;
			
			attr.width = attr.width || this.width;
			attr.height = attr.height || this.height;
			attr.style = (attr.style || '') + (this.color ? ' fill: ' + this.color + ';' : '');
			attr.classname = (attr.classname || '') + (this.align ? ' align-' + this.align : '');
			
			for (key in attr) {
				attrs_str += key + '="' + attr[key] + '" ';
			}
			
			return '<svg ' + attrs_str + 'version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve">' + svg + '</svg>';
		},
		
		/**
		 * @private
		 */
		_renderAppend: function (nodes, target, clone_children) {
			var i = 0,
				ii = nodes.length,
				cloned = null;
			
			for (; i<ii; i++) {
				if (nodes[i].cloneNode) {
					if (clone_children !== false) {
						cloned = nodes[i].cloneNode();
					} else {
						cloned = nodes[i];
					}
					
					if (target.append) {
						// Y.Node
						target.append(cloned);
					} else {
						// HTMLElement
						target.appendChild(cloned);
					}
					
					if (nodes[i].childNodes && nodes[i].childNodes.length) {
						this._renderAppend(nodes[i].childNodes, cloned, true);
					}
				}
			}
		},
		
		/**
		 * Returns SVG DOM node
		 */
		getDOMNode: function () {
			if (this._domNode) return this._domNode;
			if (!this.svg) return null;
			
			var div = document.createElement('div');
			div.innerHTML = this.toHTML();
			
			this._domNode = div.firstChild; // SVG element
			return this._domNode;
		},
		
		/**
		 * Returns only data which should be encoded§
		 * 
		 * @returns {Object} All properties which should be encoded
		 */
		toURIComponent: function () {
			// Icon is not set, then send empty string
			var obj = '';
			
			if (this.id) {
				obj = {
					'id': this.id,
					'width': this.width,
					'height': this.height,
					'color': this.color,
					'align': this.align
				};
				if (this.type) {
					obj['type'] = this.type;
				}
			}
			
			return obj;
		},
		
		/**
		 * Returns JSON object
		 * 
		 * @returns {Object} All properties which should be JSON encoded
		 */
		toJSON: function () {
			return {
				'id': this.id,
				'type': this.type,
				
				'width': this.width,
				'height': this.height,
				'color': this.color,
				'align': this.align,
				
				'svg': this.svg,
				'title': this.title,
				'keywords': this.keywords,
				'category': this.category,
				
				'svg_path': this.svg_path,
				'icon_path': this.icon_path
			};
		}
		
	};
	
	Icon.parse = function (value) {
		return new Icon(value);
	};
	
	Icon.format = function (value) {
		return new Icon(value);
	};
	
}, YUI.version);/*
 * Add custom date format support to Y.DataType.Date.parse
 * Example:
 * 		Y.DateType.Date.parse('2001-05-22', {format: '%Y-%d-%m'})
 * 		Y.Parsers.date('2001/05/22 11:22 PM', {format: '%Y/%d/%m %H:%M %p'})
 */
YUI.add('supra.datatype-date-parse', function(Y) {
	//Invoke strict mode
	"use strict";
	
	var LANG = Y.Lang,
		Dt = Y.DataType.Date;
	
	var regex_d = /^\s*(\d{2})/,
		regex_e = /^\s*(\d{1,2})/,
		regex_m = /^\s*(\d{2})/,
		regex_y = /^\s*(\d{2})/,
		regex_Y = /^\s*(\d{4})/,
		regex_C = /^\s*(\d{1,2})/,
		regex_H = /^\s*(\d{2})/,
		regex_I = /^\s*(\d{2})/,
		regex_l = /^\s*(\d{1,2})/,
		regex_p = /^\s*(PM|AM)/,
		regex_P = /^\s*(pm|am)/,
		regex_k = /^\s*(\d{1,2})/,
		regex_M = /^\s*(\d{2})/,
		regex_S = /^\s*(\d{2})/,
		regex_s = /^\s*(\d+)/;
	 
	/**
	 * Formats
	 */
	Dt.reverseformats = {
		
		//Date: 03
		d: function (str, out) {
			if (!regex_d.test(str)) return null;
			var m = str.match(regex_d);
			out.date = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		//Date: 3
		e: function (str) {
			if (!regex_e.test(str)) return null;
			var m = str.match(regex_e)[1];
			out.date = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		
		//Month: 06
		m: function (str, out) {
			if (!regex_m.test(str)) return null;
			var m = str.match(regex_m);
			out.month = parseInt(m[1], 10) - 1;
			return str.replace(m[0], '');
		},
		
		//Year: 11
		y: function (str, out) {
			if (!regex_y.test(str)) return null;
			var m = str.match(regex_y);
			out.year = parseInt(m[1], 10) + 2000;
			return str.replace(m[0], '');
		},
		//Full year: 2011
		Y: function (str, out) {
			if (!regex_Y.test(str)) return null;
			var m = str.match(regex_Y);
			out.year = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		//Century: 20
		C: function (str, out) {
			if (!regex_C.test(str)) return null;
			var m = str.match(regex_C);
			out.year += parseInt(m[1], 10) * 100;
			return str.replace(m[0], '');
		},
		
		//Hours: 03
		H: function (str, out) {
			if (!regex_H.test(str)) return null;
			var m = str.match(regex_H);
			out.hours = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		//Hours: 3
		k: function (str, out) {
			if (!regex_k.test(str)) return null;
			var m = str.match(regex_k);
			out.hours = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		//Hours: 00-12
		I: function (str, out) {
			if (!regex_I.test(str)) return null;
			var m = str.match(regex_I);
			out.hours = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		//Hours: 0-12
		l: function (str, out) {
			if (!regex_l.test(str)) return null;
			var m = str.match(regex_l);
			out.hours = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		
		//Hours: PM
		p: function (str, out) {
			if (!regex_p.test(str)) return null;
			var m = str.match(regex_p);
			out.hours += (m[1] == 'PM' ? 12 : 0);
			return str.replace(m[0], '');
		},
		//Hours: pm
		P: function (str, out) {
			if (!regex_p.test(str)) return null;
			var m = str.match(regex_p);
			out.hours += (m[1] == 'pm' ? 12 : 0);
			return str.replace(m[0], '');
		},
		
		//Minutes: 03
		M: function (str, out) {
			if (!regex_M.test(str)) return null;
			var m = str.match(regex_M);
			out.minutes = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		
		//Seconds: 03
		S: function (str, out) {
			if (!regex_S.test(str)) return null;
			var m = str.match(regex_S);
			out.seconds = parseInt(m[1], 10);
			return str.replace(m[0], '');
		},
		
		//Timestamp in seconds: 1308145753
		s: function (str, out) {
			if (!regex_s.test(str)) return null;
			var m = str.match(regex_s),
				d = new Date(parseInt(m[1], 10));
			out.year = d.getFullYear();
			out.month = d.getMonth();
			out.date = d.getDate();
			out.hours = d.getHours();
			out.minutes = d.getMinutes();
			out.seconds = d.getSeconds();
			return str.replace(m[0], '');
		}
		
	};
		
	/**
	 * Converts data to type Date.
	 *
	 * @method parse
	 * @param data {String | Number} Data to convert
	 * @return {Date} A Date, or null.
	 */
	Y.namespace("Parsers").date = Dt.parse = function(data, oConfig) {
		
	    if(LANG.isDate(data)) {
	        return data;
	    } else if (typeof data === 'string' && (data.indexOf('UTC') !== -1 || data.indexOf('GMT') !== -1)) {
			// Allow simple UTC or GMT values
			var raw = new Date(data);
			if(LANG.isDate(raw)) {
				return raw;
			}
		}
	
		oConfig = oConfig || {};
		var format = oConfig.format || Y.config.dateFormat  || "%Y-%m-%d",
			aggs = Dt.aggregates,
			formats = Dt.reverseformats,
			started = false;
	
		//Replace aggregates
		for(var i in aggs) format = format.replace('%' + i, aggs[i]);
	
		//Replace formats
		var str = data.replace(/^\s+|\s$/g, ''),
			empty = new Date(0,0,0,0,0,0),
			out = {
				'year': empty.getFullYear(),
				'month': empty.getMonth(),
				'date': empty.getDate(),
				'hours': empty.getHours(),
				'minutes': empty.getMinutes(),
				'seconds': empty.getSeconds()
			};
	
		for(var i=0,ii=format.length; i<ii; i++) {
			if (format[i] == '%') {
				if (i+1 < ii && format[i+1] in formats) {
					str = formats[format[i+1]](str, out);
					//If nothing was found then date is invalid
					if (str === null) return;
				}
				i++;
			} else if (format[i] == str[0]) {
				str = str.substr(1);
				started = true;
			} else if (started) {
				//If parsing has started and unexpected char found then date is invalid
				//Try using built in parser
				return new Date(data);
			} else {
				//If parsing hasn't started yet, then ignore
				str = str.substr(1);
			}
		}
	
		//Validate
		var d = new Date(out.year, out.month, out.date, out.hours, out.minutes, out.seconds);
		if (d.getFullYear() != out.year ||
			d.getMonth() != out.month ||
			d.getDate() != out.date ||
			d.getHours() != out.hours ||
			d.getMinutes() != out.minutes ||
			d.getSeconds() != out.seconds) return null;
	
		return d;
	};

}, YUI.version, {requires:['datatype-date']});
/*
 * Add custom date format support to Y.DataType.Date.parse
 * Example:
 * 		Y.DateType.Date.parse('2001-05-22', {format: '%Y-%d-%m'})
 * 		Y.Parsers.date('2001/05/22 11:22 PM', {format: '%Y/%d/%m %H:%M %p'})
 */
YUI.add('supra.datatype-date-reformat', function(Y) {
	//Invoke strict mode
	"use strict";
	
	var LANG = Y.Lang,
		Dt = Y.DataType.Date;
	
	/**
	 * Converts data to type Date.
	 * Supported formats: 'raw', 'FORMAT', 'in_date', 'in_time', 'in_time_short', 'in_datetime', 'out_date', 'out_time', 'out_time_short', 'out_datetime', 'out_datetime_short'
	 *
	 * @method parse
	 * @param data {String | Number} Data to convert
	 * @param from {String} Optional. From format, default is out_format
	 * @param to {String} Optional. To format, default is out_format
	 * @return {Date} A Date, or null.
	 */
	Dt.reformat = function(data, from, to) {
	    var date = null;
	    if (!data) return null;
	    
	    if (from == 'raw') {
	    	date = Y.Lang.isDate(data) ? data : null;
	    } else {
	    	date = Dt.parse(data, {'format': Dt.stringToFormat(from || 'out_date')});
	    }
	    
	    if (date) {
	    	if (to == 'raw') {
	    		return date;
	    	} else {
	    		return Dt.format(date, {'format': Dt.stringToFormat(to || 'out_date')});
	    	}
	    }
	    
	    return null;
	};
	
	/**
	 * Returns formatted string with time difference
	 * 
	 * @param {String} date Date
	 * @param format {String} Optional. Date format
	 * @return Date in pretty format
	 * @type {String}
	 */
	Dt.since = function (date, format, template) {
		var diff = 0;
		
		if (typeof date !== 'number') {
			date = Dt.reformat(date, format || 'in_datetime', 'raw');
			if (!date) return;
			
			diff = ~~(((+new Date()) - date.getTime()) / 1000);
		} else {
			diff = date;
		}
		 
		var day_diff = ~~(diff / 86400),
			cache = '',
			name = '',
			tpl = '',
			data = {'n': 1};
		
		if (day_diff == 0) {
			
			if (diff == 1) {
				data.n = 1;
				name = 'second';
			} else if (diff < 60) {
				data.n = ~~diff;
				name = 'seconds';
			} else if (diff < 120) {
				data.n = 1;
				name = 'minute';
			} else if (diff < 3600) {
				data.n = ~~(diff / 60);
				name = 'minutes';
			} else if (diff < 7200) {
				data.n = 1;
				name = 'hour';
			} else {
				data.n = ~~(diff / 3600);
				name = 'hours';
			}
			
		} else if (day_diff == 1) {
			data.n = 1;
			name = 'day';
		} else if (day_diff < 31) {
			data.n = day_diff;
			name = 'days';
		} else if (day_diff < 62) {
			data.n = 1;
			name = 'month';
		} else if (day_diff < 366) {
			data.n = ~~(day_diff / 31);
			name = 'months';
		} else if (day_diff < 732) {
			data.n = 1;
			name = 'year';
		} else {
			data.n = ~~(day_diff / 366);
			name = 'years';
		}
		
		tpl = Supra.Intl.get(['date', name]) || ('{{ n }} ' + name);
		
		if (template) {
			tpl = template.replace(/{{\s*n\s*}}/, tpl);
		} else {
			tpl = (Supra.Intl.get(['date', 'ago']) || '{{ n }} ago').replace(/{{\s*n\s*}}/, tpl);
		}
		
		tpl = Supra.Template.compile(tpl, 'datatype.date.since.' + name);
		
		return tpl(data);
	};
	
	Dt.stringToFormat = function (str) {
		switch(str) {
			case 'in_date':
				return '%Y-%m-%d';
			case 'in_time':
				return '%H:%M:%S';
			case 'in_time_short':
				return '%H:%M';
			case 'in_datetime':
				return '%Y-%m-%d %H:%M:%S';
			case 'in_datetime_short':
				return '%Y-%m-%d %H:%M';
			case 'out_date':
				return Supra.data.get('dateFormat');
			case 'out_time':
				return Supra.data.get('timeFormat');
			case 'out_time_short':
				return Supra.data.get('timeFormatShort');
			case 'out_datetime':
				return Supra.data.get('dateFormat') + ' ' + Supra.data.get('timeFormat');
			case 'out_datetime_short':
				return Supra.data.get('dateFormat') + ' ' + Supra.data.get('timeFormatShort');
			default:
				return str;
		}
	};

}, YUI.version, {requires:['datatype-date']});
YUI.add('supra.base', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Extends Y.Base with additional functionality
	 */
	function BaseExtension () {
	};
	
	BaseExtension.prototype = {
		isInstanceOf: function (classname) {
			var classes = this._getClasses();
				classname = classname.toLowerCase();
				
			for(var i=0,ii=classes.length; i<ii; i++) {
				if (classes[i].NAME.toLowerCase() == classname) return true;
			}
			return false;
		}
	};
	
	//Extend base
	Y.Base.mix(Y.Base, [BaseExtension]);
	
	/**
	 * Extends Y.Node with additional functionality
	 */
	function NodeExtension () {
	};
	
	NodeExtension.prototype = {
		isInstanceOf: function (classname) {
			var source = this,
				target = Y[classname] || Supra[classname];
			
			return target ? source instanceof target : false;
		},
		
		/**
		 * Returns node or closest ancestor matching selector
		 * 
		 * @param {String} selector CSS selector
		 * @return Y.Node matching selector
		 * @type {Object}
		 */
		closest: function (selector) {
			if (typeof selector == 'string') {
				return this.test(selector) ? this : this.ancestor(selector);
			} else {
				var node = Y.one(selector),
					self = this;
				
				while(self && !node.compareTo(self)) {
					self = self.ancestor();
				}
				
				return self;
			}
		},
		
		/**
		 * Returns node width without padding and border
		 * 
		 * @returns {Number} Inner width
		 */
		getInnerWidth: function () {
			var width = this.get('offsetWidth'),
				padding = (parseInt(this.getStyle('paddingLeft'), 10) || 0) + (parseInt(this.getStyle('paddingRight'), 10) || 0),
				//margin = (parseInt(this.getStyle('marginLeft'), 10) || 0) + (parseInt(this.getStyle('marginRight'), 10) || 0),
				border = (parseInt(this.getStyle('borderLeftWidth'), 10) || 0) + (parseInt(this.getStyle('borderRightWidth'), 10) || 0);
			
			return Math.max(0, width - padding - border);
		},
		
		/**
		 * Returns node height without padding and border
		 * 
		 * @returns {Number} Inner height
		 */
		getInnerHeight: function () {
			var height = this.get('offsetHeight'),
				padding = (parseInt(this.getStyle('paddingTop'), 10) || 0) + (parseInt(this.getStyle('paddingBottom'), 10) || 0),
				//margin = (parseInt(this.getStyle('marginTop'), 10) || 0) + (parseInt(this.getStyle('marginBottom'), 10) || 0),
				border = (parseInt(this.getStyle('borderTopWidth'), 10) || 0) + (parseInt(this.getStyle('borderBottomWidth'), 10) || 0);
			
			return Math.max(0, height - padding - border);
		}
	};
	
	//Extend Node and NodeList
	Y.Base.mix(Y.Node, [NodeExtension]);
	Y.Base.mix(Y.NodeList, [NodeExtension]);
	
}, YUI.version, {'requires': ['base', 'node']});YUI.add('supra.button', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Button (config) {
		Button.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Button.NAME = 'button';
	Button.CSS_PREFIX = 'su-' + Button.NAME;
	
	Button.ATTRS = {
		buttonId: {
			value: null
		},
		nodeWrapper: {
			value: null
		},
		nodeButton: {
			value: null
		},
		nodeLabel: {
			value: null
		},
		nodeLoading: {
			value: null
		},
		label: {
			value: '',
			setter: '_setLabel'
		},
		title: {
			value: '',
			setter: '_setTitle'
		},
		type: {
			value: 'push'		// Valid types are 'push', 'toggle'
		},
		/**
		 * Button style:
		 * "small", "small-gray", "small-blue", "mid", "mid-blue", "group"
		 */
		style: {
			value: 'small',
			setter: '_setStyle'
		},
		disabled: {
			value: false,
			setter: '_setDisabled'
		},
		loading: {
			value: false,
			setter: '_setLoading'
		},
		down: {
			value: false,
			setter: '_setDown'
		},
		visible: {
			value: true,
			setter: '_setVisible'
		},
		icon: {
			value: null,
			setter: '_setIcon'
		},
		
		
		/**
		 * Group style if style is "group":
		 * "mid" or "no-labels"
		 */
		groupStyle: {
			value: '',
			setter: '_setGroupStyle'
		},
		/**
		 * Icon image style style is "group":
		 * "normal", "center", "fill", "button" or "html"
		 */
		iconStyle: {
			value: 'normal',
			setter: '_setIconStyle'
		},
		
		/**
		 * Icon background color if style is "group" and iconStyle is "html"
		 */
		iconBackgroundColor: {
			value: 'transparent'
		},
		
		/**
		 * Icon HTML if style is "group" and iconStyle is "html"
		 */
		iconHTML: {
			value: ''
		},
		
		/**
		 * Icon CSS if style is "group" and iconStyle is "html"
		 */
		iconCSS: {
			value: ''
		}
	},
	
	Button.CLASS_NAME = Y.ClassNameManager.getClassName(Button.NAME);
	
	/* 
     * The HTML_PARSER static constant is used by the Widget base class to populate 
     * the configuration for the button instance from markup already on the page.
     *
     * The Button class attempts to set the label, style, disabled, wrapper element of the Button widget if it
     * finds the appropriate elements on the page
     */
    Button.HTML_PARSER = {
        nodeButton: function (srcNode) {
			var tag = srcNode.get('tagName');
			
			if (tag == 'INPUT' || tag == 'BUTTON') {
				this.set('nodeButton', srcNode);
				return srcNode;
			} else {
				var node = srcNode.one('BUTTON,INPUT');
				if (!node) {
					node = Y.Node.create('<button type="button">' + Y.Escape.html(Supra.Intl.replace(this.get('label') || '')) + '</button>');
					this.get('contentBox').append(node);
				}
				
				this.set('nodeButton', node);
				return node;
			}
		},
		nodeWrapper: function (srcNode) {
			var tag = srcNode.get('tagName');
			if (tag != 'INPUT' && tag != 'BUTTON') {
				this.set('nodeWrapper', srcNode);
				return srcNode;
			};
			return null;
		},
		nodeLabel: function (srcNode) {
			// find SPAN inside button
			var btn = this.get('nodeButton');
			if (btn) {
				var label = btn.one('p');
				if (label) {
					this.set('nodeLabel', label);
					return;
				}
			}
			
			this.set('nodeLabel', btn);
		},
		disabled: function (srcNode) {
			var btn = this.get('nodeButton');
			if (btn) {
				var disabled = btn.get('disabled') ? true : false;
				return disabled;
			}
		},
		label: function (srcNode) {
			var label = this.get('nodeLabel'),
				text = null;
			
			if (label) {
				text = label.get('innerHTML');
			}
			return text || this.get('label') || ' ';
        },
		style: function (srcNode) {
			var button = this.get('nodeButton'),
				style = null;
			
			if (button) {
				style = button.getAttribute('suStyle');
			}
			
			return style || 'small';
		},
		type: function (srcNode) {
			var button = this.get('nodeButton'),
				type = null;
			
			if (button) {
				type = button.getAttribute('suType');
			}
			
			return type || 'push';
		},
		icon: function (srcNode) {
			var button = this.get('nodeButton'),
				icon = null;
			
			if (button) {
				icon = button.getAttribute('suIcon');
			}
			
			return icon;
		},
		down: function (srcNode) {
			var button = this.get('nodeButton'),
				down = false;
			
			if (button) {
				down = (button.getAttribute('suDown') === 'true');
			}
			
			return down;
		},
		
		iconStyle: function (srcNode) {
			var button = this.get('nodeButton'),
				style = null;
			
			if (button) {
				style = button.getAttribute('suIconStyle') || undefined;
			}
		},
		
		groupStyle: function (srcNode) {
			var button = this.get('nodeButton'),
				style = null;
			
			if (button) {
				style = button.getAttribute('suGroupStyle') || '';
			}
		},
		
		iconBackgroundColor: function (srcNode) {
			var button = this.get('nodeButton'),
				style = button.getAttribute('suIconBackgroundColor');
			
			if (button && style) {
				return style;
			}
		}

    };
	
	Y.extend(Button, Y.Widget, {
		
		/**
		 * Icon template
		 * @type {String}
		 */
		ICON_TEMPLATE: '<img src="" alt="" />',
		
		ICON_TEMPLATE_GROUP: '<span class="img"><img src="" alt="" /></span>',
		
		/**
		 * Label template
		 * @type {String}
		 */
		LABEL_TEMPLATE: '<p></p>',
		
		initializer: function () {
			
		},
		
		destructor: function () {
			
		},
		
		renderUI : function() {
			//Add DIV around button
			if (!this.get('nodeWrapper')) {
				var btn = this.get('nodeButton');
				var nodeWrapper = Y.Node.create('<div></div>');
				btn.ancestor().appendChild(nodeWrapper);
				nodeWrapper.appendChild(btn);
			}
			
			//Add label inside button
			var btn = this.get('nodeButton');
			if (btn) {
				if (!this.get('nodeLabel') || this.get('nodeLabel').get('tagName') != 'P') {
					var tpl = Y.Node.create(this._getLabelTemplate()),
						p = tpl.test('P') ? tpl : tpl.one('P');
					
					p.set('innerHTML', Y.Escape.html(Supra.Intl.replace(this.get('label') || '')));
					
					btn.set('innerHTML', '');
					btn.appendChild(tpl);
					
					this.set('nodeLabel', p);
				}
				
				//Title attribute
				btn.setAttribute('title', this.get('title') || '');
				
				//Buttons with group or toolbar style doesn't have labels, use "title" attribute
				if ((this.get('style') == 'group' || this.get('style') == 'toolbar') && this.get('icon')) {
					this.set('title', this.get('title') || this.get('label') || '');
				}
				
				if (!btn.getAttribute('type')) {
					btn.setAttribute('type', 'button');
				}
			}
			
			//ClassName
			if (btn) {
				var className = btn.getAttribute('className').replace(/\s?su-button-content\s?/, '');
				
				if (className) {
					btn.removeClass(className);
					this.get('boundingBox').addClass(className);
				}
			}
			
			if (this.get('down')) {
				this.set('down', true);
			}
			
			if (this.get('disabled')) {
				this.set('disabled', true);
			}
			
			if (this.get('icon')) {
				this.set('icon', this.get('icon'));
			}
		},
		
		syncUI: function () {
			this._syncUIStyle();
			
			//Change label if needed
			var label = this.get('nodeLabel');
			if (label && label.get('value') != this.get('label')) {
				label.set('value', this.get('label'));
			}
		},
		
		bindUI: function () {
			this.on('mousedown', this._onMouseDown, this);
			this.on('mouseup', this._onMouseUp, this);
			this.on('mouseover', this._onMouseOver, this);
			this.on('mouseout', this._onMouseOut, this);
			
			this.get('contentBox').on('click', this._onDisabledPreventClick, this);
			this.get('boundingBox').on('click', this._onDisabledPreventClick, this);
			
			this.on('click', this._onClick, this);
		},
		
		
		/* ---------------------------- Label ---------------------------- */
		
		
		/**
		 * Returns button label template
		 * 
		 * @return Label template
		 * @type {String}
		 * @private
		 */
		_getLabelTemplate: function (definition) {
			if (this.get('style') == 'group') {
				if (this.get('iconStyle') == 'html') {
					return '<div class="su-button-bg"><div>' + (this.get('iconHTML') || '') + '</div><p></p></div>';
				} else {
					return '<div class="su-button-bg"><div style="' + this._getButtonBackgroundStyle(this.get('icon')) + '"></div><p></p></div>';
				}
			} else {
				return this.LABEL_TEMPLATE;
			}
		},
		
		/**
		 * Returns button background style
		 * 
		 * @param {Object} definition Button definition
		 * @return Background CSS style
		 * @type {String}
		 * @private
		 */
		_getButtonBackgroundStyle: function (icon, asObject) {
			var color = this.get('iconBackgroundColor'),
				image = '',
				style = '';
			
			if (icon) {
				if (this.get('iconStyle') == 'button') {
					image = 'url(' + icon + '), url(' + icon + '), url(' + icon + ')';
				} else {
					image = 'url(' + icon + ')';
				}
			}
			
			if (asObject) {
				style = {
					'backgroundColor': color,
					'backgroundImage': image
				};
			} else {
				style = 'background-color: ' + color + '; background-image: ' + image + ';';
			}
			
			return style;
		},
		
		
		/* ---------------------------- ... ---------------------------- */
		
		
		_syncUIStyle: function (name, add) {
			var box = this.get('boundingBox');
			if (box) {
				var style = this.get('style');
				if (style) box.addClass(this.getClassName(style));
				
				var style = this.get('groupStyle');
				if (style) box.addClass(this.getClassName('group', style));
				
				var icon_style = this.get('iconStyle');
				if (style && icon_style) {
					box.addClass(this.getClassName('group', style, icon_style));
				}
			}
		},
		_setDisabled: function (disabled) {
			var btn = this.get('nodeButton');
			if (btn) {
				btn.set('disabled', disabled);
			}
		},
		_setLoading: function (loading) {
			var box = this.get('boundingBox');
			
			if (box) {
				if (loading && !this.get('nodeLoading')) {
					var node = Y.Node.create('<span class="loading-icon"></span>');
					this.get('nodeLabel').insert(node, 'after');
					this.set('nodeLoading', node);
				}
				
				box.toggleClass(this.getClassName('loading'), loading);
			}
			
			this.set('disabled', loading);
			return loading;
		},
		
		_setStyle: function (new_style) {
			var box = this.get('boundingBox');
			if (!box) return new_style;
			
			var old_style = this.get('style');
			if (new_style == old_style) return;
			
			if (box) {
				if (old_style) box.removeClass(this.getClassName(old_style));
				if (new_style) box.addClass(this.getClassName(new_style));
			}
		},
		
		_setGroupStyle: function (new_style) {
			var box = this.get('boundingBox');
			if (!box) return new_style;
			
			var old_style = this.get('groupStyle'),
				icon_style = this.get('iconStyle');
			
			if (new_style == old_style) return;
			
			if (box) {
				if (old_style) {
					box.removeClass(this.getClassName('group', old_style));
					if (icon_style) {
						box.removeClass(this.getClassName('group', old_style, icon_style));
					}
				}
				if (new_style) {
					box.addClass(this.getClassName('group', new_style));
					if (icon_style) {
						box.addClass(this.getClassName('group', new_style, icon_style));
					}
				}
			}
		},
		
		_setIconStyle: function (new_style) {
			var box = this.get('boundingBox');
			if (!box) return new_style;
			
			var group_style = this.get('groupStyle'),
				old_style = this.get('iconStyle');
			
			if (new_style == old_style) return;
			
			if (box) {
				if (old_style) box.removeClass(this.getClassName('group', group_style, old_style));
				if (new_style) box.addClass(this.getClassName('group', group_style, new_style));
			}
		},
		
		_setDown: function (down) {
			var box = this.get('boundingBox');
			if (!box) return !!down;
			if (down == this.get('down')) return !!down;
			
			if (box) {
				box.toggleClass(this.getClassName('down'), down);
				box.removeClass(this.getClassName('mouse-hover'));
			} 
			
			return !!down;
		},
		
		_setLabel: function (label) {
			var labelNode = this.get('nodeLabel'),
				escaped = null,
				node = null;
			
			if (labelNode) {
				label = label ? Supra.Intl.replace(label) : '';
				escaped = label ? Y.Escape.html(label) : '&nbsp;';
				labelNode.set('innerHTML', escaped);
				
				//Buttons with group style doesn't have labels, use "title" attribute
				if (this.get('style') == 'group' && this.get('icon')) {
					this.set('title', label);
				}
			}
		},
		
		_setTitle: function (title) {
			var btn = this.get('nodeButton');
			if (btn) {
				btn.setAttribute('title', title || '');
			}
			
			return title || '';
		},
		
		_setVisible: function (visible) {
			var box = this.get('boundingBox');
			if (box) box.toggleClass('hidden', !visible);
			return visible;
		},
		
		_setIcon: function (value) {
			
			if (this.get('style') == 'group') {
				if (this.get('iconStyle') != 'html') {
					var node = this.get('contentBox').one('.su-button-bg > div'),
						styles = null;
					
					if (node) {
						styles = this._getButtonBackgroundStyle(value, true);
						node.setStyles(styles);
					}
				}
			} else {
				var img = this.get('contentBox').one('img');
				if (!img) {
					if (!value) return value;
					var button = this.get('nodeButton');
					if (!button) return value;
					
					var template = this.get('style') == 'group' ? this.ICON_TEMPLATE_GROUP : this.ICON_TEMPLATE;
					var node = Y.Node.create(template);
					button.prepend(node);
					
					img = node.test('img') ? node : node.one('img');
					img.setAttribute('src', value);
				} else {
					if (!value) {
						img.remove();
						return value;
					}
					img.setAttribute('src', value);
				}
			}
			
			return value;
		},
		
		_onMouseDown: function () {
			if (this.get('disabled')) return;
			var box = this.get('boundingBox');
			if (box) {
				box.addClass(this.getClassName('mouse-down'));
			}
		},
		
		_onMouseUp: function () {
			if (this.get('disabled')) return;
			var box = this.get('boundingBox');
			if (box) {
				box.removeClass(this.getClassName('mouse-down'));
				box.toggleClass(this.getClassName('down'), this.get('down'));
				
				if (this.get('down')) {
					box.removeClass(this.getClassName('mouse-hover'));
				}
			}
		},
		
		_onMouseOver: function () {
			if (this.get('disabled')) return;
			var box = this.get('boundingBox');
			if (box) box.addClass(this.getClassName('mouse-hover'));
		},
		
		_onMouseOut: function () {
			if (this.get('disabled')) return;
			var box = this.get('boundingBox');
			if (box) {
				box.removeClass(this.getClassName('mouse-down'));
				box.removeClass(this.getClassName('mouse-hover'));
			}
		},
		
		_onDisabledPreventClick: function (evt) {
			if (this.get('disabled')) evt.halt(true);
		},
		
		_onClick: function (evt) {
			if (this.get('disabled')) return evt.halt(true);
			if (this.get('type') == 'toggle') {
				var down = !this.get('down');
				this.set('down', down);
			}
		},
		
		addClass: function () {
			var box = this.get('boundingBox');
			if (box) box.addClass.apply(box, arguments);
			return this;
		},
		
		removeClass: function () {
			var box = this.get('boundingBox');
			if (box) box.removeClass.apply(box, arguments);
			return this;
		},
		
		toggleClass: function () {
			var box = this.get('boundingBox');
			if (box) box.toggleClass.apply(box, arguments);
			return this;
		},
		
		hasClass: function () {
			var box = this.get('boundingBox');
			if (box) return box.hasClass.apply(box, arguments);
			return false;
		}
	});
	
	Supra.Button = Button;
	
	//Since this Widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
	
}, YUI.version, {'requires': ['node-focusmanager', 'widget', 'widget-child']});/**
 * Plugin to link button and input so that button represents input value
 */
YUI.add('supra.button-plugin-input', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var Button = Supra.Button;
	
	/**
	 * Folder rename plugin
	 * Saves item properties when they change
	 */
	function Plugin (config) {
		Plugin.superclass.constructor.apply(this, arguments);
	}
	
	Plugin.NAME = 'input';
	Plugin.NS = 'input';
	
	Plugin.ATTRS = {
		
		/**
		 * Default label when input doesn't return any
		 * @type {String}
		 */
		'defaultLabel': {
			value: ''
		},
		
		/**
		 * Input which value is binded with this 
		 * @type {Object}
		 */
		'input': {
			value: null
		},
		
		/**
		 * Formatter function
		 * @type {Function}
		 */
		'formatter': {
			value: null
		}
	};
	
	Y.extend(Plugin, Y.Plugin.Base, {
		
		/**
		 * Initialize plugin
		 */
		initializer: function () {
			var input = this.get('input'),
				button = this.get('host');
			
			if (input.isInstanceOf('input')) {
				if (input.getValueData) {
					// We can get detailed data from input
					input.after('change', this.onSelectChange, this);
					input.after('valuesChange', this.onSelectChange, this);
				} else {
					// We don't know how to handle this, try guessing
					input.after('change', this.onInputChange, this);
				}
			}
		},
		
		/**
		 * Select input changed, update button UI
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		onSelectChange: function (event) {
			var button = this.get('host'),
				input  = this.get('input'),
				value  = event.value,
				data   = null,
				type   = typeof value;
			
			if (type === 'null' || type === 'undefined') {
				value = input.get('value');
				type  = typeof value;
			}
			
			data = input.getValueData(value);
			
			if (data) {
				this.syncUI({
					'label': data.title || this.get('defaultLabel'),
					'icon': data.icon,
					'button': button,
					'input': input
				});
			}
		},
		
		/**
		 * Select input changed, update button UI
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		onInputChange: function (event) {
			var button = this.get('host'),
				input  = this.get('input'),
				value  = event.value,
				type   = typeof value;
			
			if (type === 'null' || type === 'undefined') {
				value = input.get('value');
				type  = typeof value;
			}
			
			if (type === 'null' || type === 'undefined') {
				value = '';
			} else if (type !== 'string' && type !== 'number') {
				if (value.title) {
					// File or image
					value = value.title;
				} else {
					value = '';
				}
			}
			
			this.syncUI({
				'label': value || this.get('defaultLabel'),
				'button': button,
				'input': input
			});
		},
		
		/**
		 * Update button UI
		 * 
		 * @param {Object} data Data for button
		 */
		syncUI: function (data) {
			var formatter = this.get('formatter');
			
			if (!Y.Lang.isFunction(formatter)) {
				formatter = this.defaultFormatter;
			}
			
			formatter(data);
		},
		
		/**
		 * Default formatter
		 * 
		 * @param {Object} data Data for button
		 */
		defaultFormatter: function (data) {
			if ('label' in data) {
				data.button.set('label', data.label);
			}
			if ('icon' in data) {
				data.button.set('icon',  data.icon || '');
			}
		}
		
	});
	
	
	Supra.Button.PluginInput = Plugin;
	
	//Since this Widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['plugin']});YUI.add('supra.panel', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var KEY_ESCAPE = 27;
	
	var ARROW_CLASSNAMES = {
		'L': 'left',
		'R': 'right',
		'T': 'top',
		'B': 'bottom',
		'C': 'center'
	};
	
	/**
	 * Panel class
	 * 
	 * @extends Y.Overlay, Y.Widget
	 * @param {Object} config Attribute values
	 */
	function Panel (config) {
		Panel.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Panel.NAME = 'panel';
	Panel.CSS_PREFIX = 'su-' + Panel.NAME;
	Panel.CLASS_NAME = Y.ClassNameManager.getClassName(Panel.NAME);
	
	Panel.ARROW_L = 'L';
	Panel.ARROW_R = 'R';
	Panel.ARROW_T = 'T';
	Panel.ARROW_B = 'B';
	Panel.ARROW_C = 'C';
	
	/*
	 * Panel attributes, default attribute values
	 */
	Panel.ATTRS = {
		/**
		 * Arrow visibility
		 */
		arrowVisible: {
			value: false,
			setter: '_setArrowVisible'
		},
		
		/**
		 * Arrow position
		 */
		arrowPosition: {
			value: ['T', 'C'],
			setter: '_setArrowPosition'
		},
		
		/**
		 * Arrow alignment
		 */
		arrowAlign: {
			value: null,
			setter: '_arrowAlign'
		},
		
		/**
		 * Align target
		 */
		alignTarget: {
			value: null
		},
		
		/**
		 * Align position
		 */
		alignPosition: {
			value: null,
			setter: '_setAlignPosition'
		},
		
		/**
		 * Close button visibility
		 */
		closeVisible: {
			value: false,
			setter: '_setCloseVisible'
		},
		
		/**
		 * Automatically close when clicked outside
		 */
		autoClose: {
			value: false
		},
		
		/**
		 * Close when user presses return key
		 */
		closeOnEscapeKey: {
			value: false
		},
		
		/**
		 * UI style, ("", "dark")
		 */
		style: {
			value: ''
		},
		
		/**
		 * Mask all other content
		 */
		useMask: {
			value: false,
			setter: '_useMask'
		}
	};
	
	Y.extend(Panel, Y.Overlay, {
		/**
		 * Arrow node (Y.Node instance)
		 * @type {Object}
		 * @private
		 */
		_arrow: null,
		
		/**
		 * Close button node (Y.Node instance)
		 * @type {Object}
		 * @private
		 */
		_close: null,
		
		/**
		 * Fade animation (Y.Anim instance)
		 * @type {Object}
		 * @private
		 */
		_fade_anim: null,
		
		/**
		 * Document click handler
		 * @type {Object}
		 * @private
		 */
		_on_click: null,
		
		/**
		 * Arrow template
		 * @type {String}
		 * @private
		 */
		ARROW_TEMPLATE: '<div></div>',
		
		/**
		 * Arrow classname
		 * @type {String}
		 * @private
		 */
		ARROW_CLASSNAME: 'arrow',
		
		/**
		 * Arrow offset from corners
		 * @type {Number}
		 * @private
		 */
		ARROW_OFFSET: 20,
		
		/**
		 * Content padding, used to calculate arrow / node position
		 * @type {Number}
		 * @private
		 */
		CONTENT_PADDING: 10,
		
		/**
		 * Close button template
		 * @type {String}
		 * @private
		 */
		CLOSE_TEMPLATE: '<button type="button">Close</button>',
		
		/**
		 * Close button classname
		 * @type {String}
		 * @private
		 */
		CLOSE_CLASSNAME: 'close',
		
		/**
		 * useMask attribute setter
		 * Use mask to cover all other content
		 * 
		 * @param {Boolean} useMask
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_useMask: function (useMask) {
			var maskNode = this.get('maskNode');
			
			if (useMask) {
				if (!maskNode) {
					var classname = this.getClassName('mask'),
						body = new Y.Node(document.body);
					
					if (!this.get('visible')) classname += ' hidden';
					
					maskNode = Y.Node.create('<div class="' + classname + '"></div>');
					maskNode.setStyle('zIndex', this.get('zIndex'));
					body.prepend(maskNode);
					
					this.set('maskNode', maskNode);
				}
			} else {
				if (maskNode) {
					maskNode.remove();
					this.set('maskNode', null);
				}
			}
			
			return useMask;
		},
		
		/**
		 * 
		 */
		_handleStyleChange: function (e) {
			var node = this.get('boundingBox'),
				className = '';
			
			if (e.prevVal) {
				className = this.getClassName('style', e.prevVal);
				node.removeClass(className);
			}
			if (e.newVal) {
				className = this.getClassName('style', e.newVal);
				node.addClass(className);
			}
		},
		
		/**
		 * Set arrow visiblity.
		 * Creates arrow node if it doesn't exist
		 * 
		 * @param {Boolean} visible
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setArrowVisible: function (visible) {
			if (visible) {
				if (this._arrow) {
					this._arrow.removeClass('hidden');
				} else {
					var pos = this.get('arrowPosition');
					
					this._arrow = Y.Node.create(this.ARROW_TEMPLATE);
					this._arrow.addClass(this.getClassName(this.ARROW_CLASSNAME));
					this.get('boundingBox').addClass(this.getClassName(this.ARROW_CLASSNAME, ARROW_CLASSNAMES[pos[0]]));
					this.get('contentBox').prepend(this._arrow);
				}
				
				this._syncArrowPosition();
			} else {
				if (this._arrow) this._arrow.addClass('hidden');
			}
			
			return visible;
		},
		
		/**
		 * Set arrow position
		 * 
		 * @param {Array} position
		 * @return New value
		 * @type {Array}
		 * @private
		 */
		_setArrowPosition: function (pos) {
			var old = this.get('arrowPosition') || ['T', 'C'];
			if (!Y.Lang.isArray(pos) &&
				pos.length != 2 && (
				pos[0] != 'L' ||
				pos[0] != 'R' ||
				pos[0] != 'T' ||
				pos[0] != 'B'))
			{
					return old;
			}
			
			if (old[0] != pos[0] && this._arrow) {
				var boundingBox = this.get('boundingBox');
				var classname = this.getClassName(this.ARROW_CLASSNAME, ARROW_CLASSNAMES[old[0]]);
				boundingBox.removeClass(classname);
				
				classname = this.getClassName(this.ARROW_CLASSNAME, ARROW_CLASSNAMES[pos[0]]);
				boundingBox.addClass(classname);
			}
			
			return pos;
		},
		
		/**
		 * Set align position
		 * 
		 * @param {String} position Align position
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setAlignPosition: function (position) {
			switch(position) {
				case 'L':
					this.set('arrowPosition', ['L', 'C']);
					this.set('align', {'node': this.get('alignTarget'), 'points': [Y.WidgetPositionAlign.LC, Y.WidgetPositionAlign.RC]});
					this.set('arrowAlign', this.get('alignTarget'));
					break;
				case 'R':
					this.set('arrowPosition', ['R', 'C']);
					this.set('align', {'node': this.get('alignTarget'), 'points': [Y.WidgetPositionAlign.RC, Y.WidgetPositionAlign.LC]});
					this.set('arrowAlign', this.get('alignTarget'));
					break;
				case 'T':
					this.set('arrowPosition', ['T', 'C']);
					this.set('align', {'node': this.get('alignTarget'), 'points': [Y.WidgetPositionAlign.TC, Y.WidgetPositionAlign.BC]});
					this.set('arrowAlign', this.get('alignTarget'));
					break;
				case 'B':
					this.set('arrowPosition', ['B', 'C']);
					this.set('align', {'node': this.get('alignTarget'), 'points': [Y.WidgetPositionAlign.BC, Y.WidgetPositionAlign.TC]});
					this.set('arrowAlign', this.get('alignTarget'));
					break;
			}
		},
		
		/**
		 * Update arrow position
		 * 
		 * @private
		 */
		_syncArrowPosition: function () {
			if (!this.get('arrowVisible')) return;
			
			this._arrow.setStyle('top', null);
			
			var target = this.get('arrowAlign');
			if (target) {
				this._arrowAlign(target);
			}
			
			var position = this.get('arrowPosition');
			var offset = 0;
			
			if (position[0] == 'L' || position[0] == 'R') {
				//Arrow is positioned on the left or right side of the panel
				
				switch(position[1]) {
					//Arrow should be near left/right top corner
					case 'T': offset = this.ARROW_OFFSET; break;
					//Arrow should be near left/right bottom corner
					case 'B': offset = this.get('boundingBox').get('offsetHeight') - this._arrow.get('offsetHeight') - this.ARROW_OFFSET; break;
					//Arrow should be vertically centered
					case 'C': offset = ~~((this.get('boundingBox').get('offsetHeight') - this._arrow.get('offsetHeight')) / 2); break;
					//Arrow position is set in pixels
					default: offset = parseInt(position[1], 10) || 0;
				}
				this._arrow.setStyle('top', offset + 'px');
			} else {
				//Arrow is positioned at the top or bottom of the panel
				switch(position[1]) {
					case 'L': offset = this.ARROW_OFFSET; break;
					case 'R': offset = this.get('boundingBox').get('offsetWidth') - this._arrow.get('offsetWidth') - this.ARROW_OFFSET; break;
					case 'C': offset = ~~((this.get('boundingBox').get('offsetWidth') - this._arrow.get('offsetWidth')) / 2); break;
					//Arrow position is set in pixels
					default: offset = parseInt(position[1], 10) || 0;
				}
				
				this._arrow.setStyle('left', offset + 'px');
			}
		},
		
		/**
		 * Set close button visibility
		 * Creates button if it doesn't exist
		 * 
		 * @param {Boolean} value
		 * @return New visibility value
		 * @type {Boolean}
		 * @private
		 */
		_setCloseVisible: function (value) {
			if (value) {
				if (this._close) {
					this._close.set('visible', true);
				} else {
					var btn = Y.Node.create(this.CLOSE_TEMPLATE);
					this.get('contentBox').prepend(btn);
					
					this._close = new Supra.Button({
						srcNode: btn,
						style: this.CLOSE_CLASSNAME
					});
					this._close.render();
					
					this._close.on('click', function () {
						this.hide();
					}, this);
				}
			} else if (this._close) {
				this._close.set('visible', false);
			}
			
			return !!value;
		},
		
		/**
		 * Align arrow to element
		 * 
		 * @param {Object} target
		 * @private
		 */
		_arrowAlign: function (target) {
			if (!this.get('arrowVisible') || !target) return this;
			
			//Create Y.Node from HTMLElement 
			if (target.nodeType) target = new Y.Node(target);
			
			//If widgets then get bounding box 
			else if (!(target instanceof Y.Node) && 'isInstanceOf' in target && target.isInstanceOf('widget')) target = target.get('boundingBox');
			
			var position = this.get('arrowPosition'), box = this.get('boundingBox'),
				host_offset = 0, host_size = 0,
				target_offset = 0, target_size = 0,
				style_attr = 'left', offset = null;
			
			if (position[0] == 'L' || position[0] == 'R') {
				//Arrow is positioned on the left or right side of panel
				host_offset = box.getY();
				host_size = box.get('offsetHeight');
				target_size = target.get('offsetHeight');
				target_offset = target.getY() + ~~(target_size / 2 - this.CONTENT_PADDING / 2);
				style_attr = 'top';
			} else {
				//Arrow is positioned at the top or bottom of panel
				host_offset = box.getX();
				host_size = box.get('offsetWidth');
				target_size = target.get('offsetWidth');
				target_offset = target.getX() + ~~(target_size / 2 - this.CONTENT_PADDING / 2);
			}
			
			offset = Math.min(Math.max(this.ARROW_OFFSET, target_offset - host_offset), host_size);
			position[1] = offset;
			
			this.set('arrowPosition', position);
			this._arrow.setStyle(style_attr, offset + 'px');
			
			return target;
		},
		
		/**
		 * Align the given point on the widget, with the XY page co-ordinates provided.
         *
         * @param {String} widgetPoint Supported point constant (e.g. WidgetPositionAlign.TL)
         * @param {Number} x X page co-ordinate to align to
         * @param {Number} y Y page co-ordinate to align to
         * @private
		 */
		_doAlign: function (widgetPoint, x, y) {
			var arrowVisible  = this.get('arrowVisible'),
				arrowAlign    = this.get('arrowAlign'),
				arrowPosition = this.get('arrowPosition');
			
			if (arrowVisible && arrowAlign && arrowPosition) {
				switch (arrowPosition[0]) {
					case 'L':
						x += 17;
						break;
					case 'R':
						x -= 17;
						break;
					case 'T':
						y += 17;
						break;
					case 'B':
						y -= 17;
						break;
				}
			}
			
			Panel.superclass._doAlign.call(this, widgetPoint, x, y);
		},
		
		/**
		 * Align arrow to point at target element
		 * 
		 * @param {HTMLElement} target Target element
		 * @return Panel instance
		 * @type {Object}
		 */
		arrowAlign: function (target) {
			this.set('arrowAlign', target);
		},
		
		/**
		 * Set close button visibility
		 * 
		 * @param {Boolean} visible
		 * @return Panel instance
		 * @type {Object}
		 */
		setCloseVisible: function (visible) {
			this.set('closeVisible', visible);
			return this;
		},
		
		/**
		 * Set arrow position
		 * 
		 * @param {Array} position
		 */
		setArrowPosition: function (position) {
			this.set('arrowPosition', position);
			return this;
		},
		
		/**
		 * Set arrow visibility
		 * 
		 * @param {Boolean} visible
		 * @return Panel instance
		 * @type {Object}
		 */
		setArrowVisible: function (visible) {
			this.set('arrowVisible', visible);
			return this;
		},
		
		renderUI: function () {
			Panel.superclass.renderUI.apply(this, arguments);
			
			this.get('contentBox').removeClass('hidden').setAttribute('tabindex', 0);
			
			if (this.get('closeVisible')) {
				this._setCloseVisible(true);
			}
			
			if (this.get('arrowVisible')) {
				this._setArrowVisible(this.get('arrowVisible'));
			}
			if (this.get('style')) {
				this._handleStyleChange({'newVal': this.get('style'), 'prevVal': ''});
			}
			
			Supra.immediate(this, this.syncUI);
		},
		
		bindUI: function () {
			Panel.superclass.bindUI.apply(this, arguments);
			
			//On visible change show/hide mask
			this.on('visibleChange', function (evt) {
				var maskNode = this.get('maskNode');
				if (evt.newVal != evt.prevVal) {
					if (maskNode) {
						if (evt.newVal) {
							maskNode.removeClass('hidden');
						} else {
							maskNode.addClass('hidden');
						}
					}
					
					if (!evt.newVal && this._on_click) {
						this._on_click.detach();
						this._on_click = null;
					}
				}
			}, this);
			
			//On zIndex change update mask
			this.on('zIndexChange', function (evt) {
				var maskNode = this.get('maskNode');
				if (maskNode) {
					maskNode.setStyle('zIndex', evt.newVal);
				}
			});
			
			//Before destroy remove mask
			this.before('destroy', function () {
				var maskNode = this.get('maskNode');
				if (maskNode) maskNode.remove();
				
				//Remove animation if it exists
				if (this._fade_anim) {
					this._fade_anim.destroy();
					delete(this._fade_anim);
				}
			});
			
			//On style change update it
			this.on('styleChange', this._handleStyleChange, this);
			
			this.get('contentBox').on('keydown', this.onKeyDown, this);
		},
		
		syncUI: function () {
			Panel.superclass.syncUI.apply(this, arguments);
			this._syncArrowPosition();
			
			//Update position
			var position = this.get('alignPosition');
			if (position) {
				this._setAlignPosition(position);
			}
		},
		
		/**
		 * Handle key down
		 * 
		 * @private 
		 */
		onKeyDown: function (e) {
			if (e.keyCode == KEY_ESCAPE && this.get('closeOnEscapeKey')) {
				this.hide();
			}
		},
		
		/**
		 * Hide panel
		 */
		hide: function () {
			this.get('boundingBox').addClass('su-panel-hidden');
			Panel.superclass.hide.apply(this, arguments);
			
			return this;
		},
		
		/**
		 * Check if user clicked outside panel
		 * 
		 * @param {Event} event Event facade object
		 * @private
		 */
		validateClick: function (event) {
			if (this.get('autoClose')) {
				var target = event.target.closest('div.su-panel');
				if (!target || !target.compareTo(this.get('boundingBox'))) {
					this.hide();
				}
			}
		},
		
		/**
		 * Show panel
		 */
		show: function () {
			this.get('boundingBox').removeClass('su-panel-hidden');
			
			Panel.superclass.show.apply(this, arguments);
			
			this.syncUI();
			
			Supra.immediate(this, function () {
				this.syncUI();
				
				//Auto hide when clicked outside panel
				if (this.get('visible') && this.get('autoClose')) {
					this._on_click = Y.one(document).on('click', this.validateClick, this);
				}
			});
			
			this.get('contentBox').focus();
			
			return this;
		},
		
		/**
		 * Fade in
		 */
		fadeIn: function () {
			var bounding_box = this.get('boundingBox');
			bounding_box.setStyle('opacity', 0);
			
			this.show();
			
			var from = {opacity: 0},
				to   = {opacity: 1},
				pos  = this.get('alignPosition');
			
			if (this.get('arrowVisible')) {
				switch(pos) {
					case 'L':
						from['margin-left'] = '-18px';
						to['margin-left'] = '0';
						break;
					case 'R':
						from['margin-left'] = '18px';
						to['margin-left'] = '0';
						break;
					case 'T':
						from['margin-top'] = '-18px';
						to['margin-top'] = '0';
						break;
					case 'B':
						from['margin-top'] = '18px';
						to['margin-top'] = '0';
						break;
				}
			}
			
			if (this._fade_anim) {
				this._fade_anim.stop(true);
				this._fade_anim.set('from', from);
				this._fade_anim.set('to', to);
			} else {
				this._fade_anim = new Y.Anim({
					'node': bounding_box,
					'from': from,
					'to': to,
					'duration': 0.25,
					'easing': Y.Easing.easeOut
				});
			}
			
			this._fade_anim.run();
		},
		
		/**
		 * Fade out
		 */
		fadeOut: function () {
			var bounding_box = this.get('boundingBox');
			bounding_box.setStyle('opacity', 1);
			this.show();
			
			if (this._fade_anim) {
				this._fade_anim.stop(true);
				this._fade_anim.set('from', {opacity: 1});
				this._fade_anim.set('to', {opacity: 0});
			} else {
				this._fade_anim = new Y.Anim({
					'node': bounding_box,
					'from': {opacity: 1},
					'to': {opacity: 0},
					'duration': 0.25,
					'easing': Y.Easing.easeOut
				});
			}
			
			//this._fade_anim.once('end', this.hide, this);
			this._fade_anim.run();
		},
		
		/**
		 * Add classname to panels most outer element
		 * 
		 * @param {String} classname
		 */
		addClass: function (classname) {
			var box = this.get('boundingBox');
			if (box) box.addClass(classname);
			return this;
		},
		
		/**
		 * Add or remove classname to panels most outer element
		 * 
		 * @param {String} classname
		 */
		toggleClass: function (classname, value) {
			var box = this.get('boundingBox');
			if (box) box.toggleClass(classname, value);
			return this;
		},
		
		/**
		 * Remove classname from panels most outer element
		 * 
		 * @param {String} classname
		 */
		removeClass: function (classname) {
			var box = this.get('boundingBox');
			if (box) box.removeClass(classname);
			return this;
		},
		
		/**
		 * Returns if panels most outer element has clasname
		 * 
		 * @param {String} classname
		 * @return True if panels most outer element has classname, otherwise false
		 * @type {Boolean}
		 */
		hasClass: function (classname) {
			var box = this.get('boundingBox');
			if (box) return box.hasClass(classname);
			return false;
		}
	});
	
	Supra.Panel = Panel;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['overlay', 'supra.button']});YUI.add("supra.permission", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var REQUEST_URI = "/check-permissions";
	
	Supra.Permission = {
		
		/**
		 * Permission list
		 * @type {Object}
		 * @private
		 */
		permissions: {},
		
		/**
		 * List of IDs loading
		 * @type {Object}
		 * @private
		 */
		loading: {},
		
		/**
		 * Permission load listeners. Array where each item is object in
		 * format {"callback": ..., "context": ..., "dependancies": [...]}
		 * @type {Array}
		 * @private
		 */
		listeners: [],
		
		
		/**
		 * Returns all permision values which needs to be loaded
		 * 
		 * @param {Array} permissions List of permissions
		 * @return Permissions which are not loaded yet
		 * @type {Object}
		 */
		diff: function (args) {
			if (!Y.Lang.isArray(args)) {
				args = [args];
			}
			
			var permissions = this.permissions,
				loading     = this.loading,
				item        = null,
				id          = null,
				i           = 0,
				ii          = args.length,
				output      = [];
			
			for(; i<ii; i++) {
				item = args[i];
				id = item.type + '_' + item.id;
				
				if (!permissions[id] || loading[id]) {
					output.push(item)
				}
			}
			
			return output;
		},
		
		/**
		 * Returns single value or null if not found
		 * 
		 * @param {String} type Permission object type
		 * @param {String} id Permission object id
		 * @param {String} key Optional sub-key
		 * @param {Object} default_value Default value
		 * @return Permission values
		 * @type {Object}
		 */
		get: function (type, id, key, default_value) {
			var permissions = this.permissions,
				loading     = this.loading,
				id          = type + '_' + id;
			
			if (permissions[id]) {
				var obj = permissions[id].value;
				if (key) {
					if (obj && key in obj) {
						return obj[key];
					}
				} else {
					if (obj) {
						return obj;
					}
				}
			}
			
			return default_value !== undefined ? default_value : null;
		},
		
		/**
		 * Returns all permission values or null if any of the permissions
		 * is not known
		 * 
		 * @param {Array} permissions List of permissions
		 * @return Permission values if all permissions are known
		 * @type {Object}
		 */
		getPermissions: function (args) {
			if (!Y.Lang.isArray(args)) {
				args = [args];
			}
			
			var permissions = this.permissions,
				loading     = this.loading,
				item        = null,
				id          = null,
				i           = 0,
				ii          = args.length,
				output      = {};
			
			for(; i<ii; i++) {
				item = args[i];
				id = item.type + '_' + item.id;
				
				if (permissions[id] && !loading[id]) {
					output[item.type] = output[item.type] || {};
					output[item.type][item.id] = permissions[id].value;
				} else {
					return null;
				}
			}
			
			return output;
		},
		
		/**
		 * Request permissions
		 * 
		 * @param {Array} permissions List of permissions
		 * @param {Function} callback Callback function, optional
		 * @param {Object} context Callback function execution context, optional
		 */
		request: function (permissions, callback, context) {
			//If all permissions already are known, execute callback immediately
			var data = this.getPermissions(permissions),
				diff = null;

			if (data) {
				if (Y.Lang.isFunction(callback)) {
					callback.call(context || this, data);
				}
				return;
			} else {
				diff = this.diff(permissions);
			}

			//Wait till permissions are loaded and execute callback
			this.done(permissions, diff, callback, context);

			//Load permissions
			Supra.io(Supra.Manager.Loader.getDynamicPath() + REQUEST_URI, {'suppress_errors': true, 'method': 'post'}, diff);
		},
		
		/**
		 * Add event listener for permission loading
		 * To callback will be passed object in following format
		 * {page: {111: ..., 222: ...}}
		 * 
		 * @param {Array} permissions List of permissions
		 * @param {Function} callback Callback function, optional
		 * @param {Object} context Callback function execution context, optional
		 */
		done: function (permissions, diff, callback, context) {
			var dependancies = [],
				i = 0,
				ii = diff.length;
			
			for(; i<ii; i++) {
				dependancies[dependancies.length] = diff[i].type + '_' + diff[i].id;
			}
			
			this.listeners.push({
				"callback": callback,
				"context": context,
				"permissions": permissions,
				"dependancies": dependancies
			});
		},
		
		/**
		 * Set list of permissions as loading
		 * 
		 * @param {Array} permissions List of permission definitions
		 */
		setIsLoading: function (permissions) {
			var i       = 0,
				ii      = permissions.length,
				item    = null,
				id      = null,
				loading = this.loading;
			
			for(; i<ii; i++) {
				item = permissions[i];
				id = item.type + '_' + item.id;
				loading[id] = true;
			}
		},
		
		/**
		 * Add permissions
		 * 
		 * @param {Array} data List of permission values
		 * @param {Array} args List of permission definitions
		 */
		add: function (data, args) {
			var listeners   = this.listeners,
			    listener    = null,
				l           = 0,
				index       = 0,
				callbacks   = [],
				output      = null,
				
				permissions = this.permissions,
				i           = 0,
				ii          = args.length,
				
				loading     = this.loading,
				item        = null,
				id          = null;
			
			for(; i<ii; i++) {
				item = args[i];
				id = item.type + '_' + item.id;
				
				permissions[id] = args[i];
				permissions[id].value = data[i];
				
				delete(loading[id]);
				
				//Check listeners
				for(l=listeners.length-1; l>=0; l--) {
					listener = listeners[l];
					index = Y.Array.indexOf(listener.dependancies, id);
					
					if (index != -1) {
						if (listener.dependancies.length > 1) {
							//More than 1 dependancy left
							listener.dependancies.splice(index, 1);
						} else {
							//All dependancies has been resolved
							callbacks.push(listener);
							listeners.splice(l, 1);
						}
					}
				}
			}
			
			//Callbacks
			for(i=0,ii=callbacks.length; i<ii; i++) {
				output = this.getPermissions(callbacks[i].permissions);
				callbacks[i].callback.call(callbacks[i].context, output);
			}
		}
		
	};
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version);YUI().add("supra.io-session", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var PING_INTERVAL = 60000;
	var PING_URI = '/check-session';
	
	/**
	 * Supra.session pings server at specific interval to keep
	 * server-side session alive
	 */
	Supra.session = {
		/**
		 * Timeout handler
		 * @type {Object}
		 * @private
		 */
		timeout_handler: null,
		
		/**
		 * Has there been any activity since last ping
		 * @type {Boolean}
		 * @private
		 */
		activity: false,
		
		/**
		 * Mouse event listener
		 * @type {Object}
		 * @private
		 */
		activity_mouse_listener: null,
		
		/**
		 * Key event listener
		 * @type {Object}
		 * @private
		 */
		activity_key_listener: null,
		
		
		/**
		 * Ping server
		 */
		ping: function () {
			if (this.timeout_handler) return;
			this.timeout_handler = Y.later(PING_INTERVAL, this, this._pingRequest, null, true);
			
			this.activity = false;
			this._addActivityListeners();
		},
		
		/**
		 * Cancel server pinging
		 */
		cancelPing: function () {
			if (this.timeout_handler) {
				this.timeout_handler.cancel();
				this.timeout_handler = null;
				
				this.activity = false;
				this._removeActivityListeners();
			}
		},
		
		/**
		 * Remove activity event listeners
		 * 
		 * @private
		 */
		_removeActivityListeners: function () {
			if (this.activity_mouse_listener) {
				this.activity_mouse_listener.detach();
				this.activity_key_listener.detach();
				
				this.activity_mouse_listener = null;
				this.activity_key_listener = null;
			}
		},
		
		/**
		 * Add activity event listenesr
		 * 
		 * @private
		 */
		_addActivityListeners: function () {
			if (!this.activity_mouse_listener) {
				var doc = new Y.Node(document);
				this.activity_mouse_listener = doc.on('click', this.triggerActivity, this);
				this.activity_key_listener = doc.on('keydown', this.triggerActivity, this);
			}
		},
		
		/**
		 * Change activity state
		 */
		triggerActivity: function () {
			this.activity = true;
			this._removeActivityListeners();
		},
		
		/**
		 * Execute ping request
		 * 
		 * @private
		 */
		_pingRequest: function () {
			Supra.io(Supra.Manager.Loader.getDynamicPath() + PING_URI, {
				'data': {
					'activity': this.activity
				}
			});
			
			//Add activity event listeners
			this.activity = false;
			this._addActivityListeners();
		}
	};
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ["io"]});/**
 * Extension to load CSS files
 * Needed because Y.Get.css doesn't 
 */
YUI().add("supra.io-css", function (Y) {
	//Invoke strict mode
	"use strict";
	
	Supra.io.css = function (url, cfg) {
		//Only webkit and gecko has this issue
		if (!Y.UA.webkit && !Y.UA.gecko) return Y.Get.css(url, cfg);
		
		var callback = cfg.onSuccess,
			context = cfg.context || window,
			styleSheets = document.styleSheets,
			args = null,
			itterations = 200;
		
		var check = function () {
			if (!args) args = arguments;
			
			for(var i=0,ii=styleSheets.length; i<ii; i++) {
				if (styleSheets[i].href && styleSheets[i].href.indexOf(url) != -1) {
					if (Y.Lang.isFunction(callback)) {
						callback.apply(context, args);
					}
					return;
				}
			}
			
			itterations--;
			if (itterations == 0) {
				if (Y.Lang.isFunction(cfg.onTimeout)) {
					cfg.onTimeout.call(context);
				}
			} else {
				setTimeout(check, 16);
			}
		};
		
		cfg = Supra.mix(cfg || {}, {
			'onSuccess': check
		});
		
		return Y.Get.css(url, cfg);
	};
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ["supra.io"]});YUI.add('supra.template-compiler', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Template compiler
	 * Syntax based on http://www.twig-project.org/
	 */
	var C = {
		
		/**
		 * Compile template string into function
		 */
		'compile': function (tpl, opt) {
			
			//Initialize
			var opt = opt || {};
			opt = Options = {
				//Remove CDATA tags
				'stripCDATA': !!opt.stripCDATA,
				
				//Basic validation if all tags are closed. Performance penalty!
				'validate': !!opt.validate
			};
			
			Stack = [];
			
			//Data is saved in _d variable, output is in p
			var body = 'var _c=Supra.TemplateCompiler,_d=Supra.mix({Math:Math,Date:Date,Y:Supra.Y,Supra:Supra},data||{}),t=null,_f=_c.filters,_fn=_c.functions,' 
					 + 'p=\'';
			
			//Remove tab and new line whitespaces
			tpl = tpl.replace(REG_WHITESPACE, ' ');
			
			//Replace single quotes with new line which was previously removed
			tpl = tpl.replace(REG_TEXT, function (all, start, text, end) {
				return start + text.split('\'').join('\r') + end;
			});
			
			//Strip CDATA
			if (opt.stripCDATA) {
				tpl = tpl.replace(REG_CDATA_OPEN, '').replace(REG_CDATA_CLOSE, '');
			}
			
			//Parse variables, expressions, blocks
			tpl = this.compileString(tpl);
			
			//Restore quotes
			tpl = tpl.split('\r').join('\\\'');
			
			//Finalize function body
			body += tpl + '\';return p;';
			
			//Remove extra spaces
			body = body.replace(/\s+/g, ' ');
			
			//Validate
			if (opt.validate && Stack.length) {
				throw new Error('Error_Syntax: missing closing tags for "' + Stack.join('", "') + '"');
			}
			
			//Clean up
			Options = null;
			Stack = null;
			
			return new Function('data', body);
		},
		
		/**
		 * Compile part of the template
		 */
		'compileString': function (tpl) {
			var compileVar = this.compileVar,
				compileExpression = this.compileExpression,
				compilerExpressions = this.compilerExpressions;
			
			//Strip comments
			tpl = tpl.replace(REG_COMMENTS, '');
			
			//Compile variables
			tpl = tpl.replace(REG_VAR, function (all, expression) {
				return '\'+(' + compileVar(expression, true) + ')+\'';
			});
			
			//Compile expressions
			tpl = tpl.replace(REG_EXPR, function (all, identifier, expression) {
				all = compileExpression(identifier, expression || '', compilerExpressions[identifier]);
				return (all ? '\';' + all + 'p+=\'' : '');
			});
			
			return tpl;
		},
		
		/**
		 * Convert variables into JS compatible format
		 * 
		 * @param {String} variable Variable string
		 * @param {Boolean} output Prevent 'undefined' or 'null' in output
		 * @return Converted variable string
		 * @type {String}
		 * @private
		 */
		'compileVar': function (variable, output) {
			var _variable = variable = variable.trim();
			
			//Extract strings
			var strings = variable.match(REG_VAR_STRING), len = strings ? strings.length : 0;
			for(var i=0; i<len; i++) variable = variable.replace(strings[i], '\'$_' + i + '\'');
			
			//Trim whitespaces around , : { } ( )
			//because of { "x": 12, "y": $_s1 }
			variable = variable.replace(REG_VAR_TRIM, '$1');
			
			//Convert functions
			if (variable.indexOf('(') != -1) {
				variable = variable.replace(REG_VAR_FN, '$1_fn.$2');
			}
			
			//Add data object namespace to variables, KEY -> _d.KEY
			variable = variable.replace(REG_VAR_DATA, '$1_d.$2');
			
			//Fix filters, KEY|FILTER -> _f.FILTER(KEY)
			var limit = 100;
			while (limit && REG_CHECK_MODIFIERS.test(variable)) {
				variable = variable.replace(REG_VAR_MODIFIERS, function (all, variable, filter, params_, params) {
					return '_f.' + filter + '(' + variable + (params ? ',' + params : '') + ')';
				});
				
				//Debug information
				if (Options.validate) {
					limit--;
					if (!limit) {
						throw new Error('Error_Syntax: can\'t parse filters in "' + _variable + '"');
						break;
					}
				}
			}
			
			//Restore strings
			for(var i=0; i<len; i++) variable = variable.replace('\'$_' + i + '\'', strings[i]);
			
			if (output) {
				//Check if need to protect from outputing undefined or null
				return '(t=' + variable + ')||t===0?t:\'\'';
			} else {
				return variable;
			}
		},
		
		/**
		 * Convert expression into JS compatible format
		 * 
		 * @param {String} expr Expression string
		 * @return Converted expression string
		 * @type {String}
		 * @private
		 */
		'compileExpression': function (identifier, expr, fn) {
			if (typeof fn == 'function') {
				//Convert " and " to " && ", " not " to "!", " or " to " || ", " ~ " to concatanation
				expr = expr.replace(REG_AND, ' && ').replace(REG_OR, ' || ').replace(REG_NOT, '!').replace(REG_CAT, ' + "" + ');
				return fn(expr);
			}
			return '';
		},
		
		/**
		 * Generates variable name
		 * 
		 * @return Variable name
		 * @type {String}
		 */
		'generateVariable': function () {
			return '_' + ~~(Math.random() * 64000);
		},
		
		/**
		 * Output value
		 * Used in compilerExpressions
		 * 
		 * @param {String} expression Expression to output
		 */
		'output': function (str) {
			return 'p+=' + str + ';';
		},
		
		/**
		 * Debug value
		 * 
		 * @param {Object} object Object to debug
		 */
		'debug': function (obj) {
			if (window.console && console.log) {
				console.log(obj);
			}
		},
		
		/**
		 * Add filter function
		 * 
		 * @param {String} id Filter ID
		 * @param {Function} fn Filter function
		 */
		'registerFilter': function (id, fn) {
			C.filters[id] = fn;
		},
		
		/**
		 * Add function
		 * 
		 * @param {String} id Function ID
		 * @param {Function} fn Function
		 */
		'registerFunction': function (id, fn) {
			C.functions[id] = fn;
		},
		
		/**
		 * Filter functions
		 */
		'filters': {
			/**
			 * Replace substring in string
			 * 
			 * @param {String} str String
			 * @param {Object} replacements Replacements
			 * @return New string
			 * @type {String}
			 */
			'replace': function (str, replacements) {
				str = (''+str);
				for(var i in replacements) {
					str = str.split(i).join(replacements[i]);
				}
				return str;
			},
			
			/**
			 * Encode string into URL component
			 * 
			 * @param {String} str String
			 * @return Encoded string
			 * @type {String}
			 */
			'url_encode': function (str) {
				return encodeURIComponent((''+str));
			},
			
			/**
			 * Decode string
			 * 
			 * @param {String} str String
			 * @return Decoded string
			 * @type {String}
			 */
			'url_decode': function (str) {
				try {
					return QueryString.unescape((''+str));
				} catch (e) {
					return '' + str;
				}
			},
			
			/**
			 * Capitalizes all words
			 * 
			 * @param {String} str String
			 * @return Capitalized string
			 * @type {String}
			 */
			'title': function (str) {
				return (''+str).replace(REG_FILTER_TITLE, function (letter) {
			        return letter.toUpperCase();
			    });
			},
			
			/**
			 * Capitalizes first word in string
			 * 
			 * @param {String} str String
			 * @return Capitalized string
			 * @type {String}
			 */
			'capitalize': function (str) {
				str = (''+str);
				return str.length ? str[0].toUpperCase() + str.substr(1).toLowerCase() : '';
			},
			
			/**
			 * Changes all letters to upper case
			 * 
			 * @param {String} str String
			 * @return Upper cased string
			 * @type {String}
			 */
			'upper': function (str) {
				return (''+str).toUpperCase();
			},
			
			/**
			 * Changes all letters to lower case
			 * 
			 * @param {String} str String
			 * @return Lower cased string
			 * @type {String}
			 */
			'lower': function (str) {
				return (''+str).toLowerCase();
			},
			
			/**
			 * Strips tags and replaces adjacent whitespace by one space
			 * 
			 * @param {String} str String
			 * @return Stripped string
			 * @type {String}
			 */
			'striptags': function (str) {
				return (''+str).replace(REG_STRIP_TAGS, '').replace(REG_WHITESPACE, ' ');
			},
			
			/**
			 * Joins array or object values
			 * 
			 * @param {Object} arr Array or object
			 * @return Joined string
			 * @type {String}
			 */
			'join': function (arr, sep) {
				if (typeof arr == 'object' && !FN_IS_ARRAY(arr)) {
					arr = FN_TO_ARRAY(arr);
				}
				if (FN_IS_ARRAY(arr)) {
					return arr.join(sep || '');
				} else {
					return '';
				}
			},
			
			/**
			 * Reverse order of array or string
			 * 
			 * @param {Object} arr Array or string
			 * @return Reversed array or string
			 * @type {Object}
			 */
			'reverse': function (arr) {
				if (arr && arr.reverse) return arr.reverse();
				if (typeof arr == 'string') return arr.split('').reverse().join('');
				return arr;
			},
			
			/**
			 * Returns length of the array or object
			 * 
			 * @param {Object} arr Array or object
			 * @return Length
			 * @type {Number}
			 */
			'length': function (arr) {
				if (FN_IS_ARRAY(arr)) {
					return arr.length;
				} else if (typeof arr == 'object') {
					var len = 0;
					for(var i in arr) if (arr.hasOwnProperty(i)) len++;
					return len;
				} else {
					return 0;
				}
			},
			
			/**
			 * Sort array, if not an array then it's converted to one
			 * and then sorted
			 * 
			 * @param {Object} arr Array or object
			 * @return Sorted array
			 * @type {Array}
			 */
			'sort': function (arr) {
				if (typeof arr == 'object' && !FN_IS_ARRAY(arr)) {
					arr = FN_TO_ARRAY(arr);
				}
				return (arr && arr.sort ? [].concat(arr.sort()) : arr);
			},
			
			/**
			 * If string is null or empty return default value
			 * 
			 * @param {String} str String
			 * @param {String} val Default value
			 * @return String or default value if string is empty or null
			 * @type {String}
			 */
			'default': function (str, val) {
				return str || (val === undefined || val === null ? '' : val);
			},
			
			/**
			 * Returns array or object keys
			 * 
			 * @param {Object} obj Array or object
			 * @return Keys
			 * @type {Array}
			 */
			'keys': function (obj) {
				if (FN_IS_ARRAY(obj)) {
					var keys = new Array(obj.length);
					for(var i=0,ii=obj.length; i<ii; i++) keys[i] = i;
					return keys;
				} else if (typeof obj == 'object') {
					var keys = [], len = 0;
					for(var i in obj) keys[len++] = i;
					return keys;
				} else {
					return [];
				}
			},
			
			/**
			 * Converts <, >, &, ", ' symbols into HTML-safe sequences
			 * 
			 * @param {String}
			 * @return Escaped string
			 * @type {String} 
			 */
			'escape': function (str, type) {
				if (!type || type === 'html') {
					return (''+str).replace(/&/g, '&amp;')
								   .replace(/</g, '&lt;')
								   .replace(/>/g, '&gt;')
								   .replace(/"/g, '&quot;')
								   .replace(/'/g, '&#39;');
				} else if (type == 'html_attr') {
					return (''+str).replace(/[^a-zA-Z0-9,\.\-_]/g, escape_html_attr);
				} else if (type == 'js') {
					return (''+str).replace(/\\/g, '\\\\')
								   .replace(/"/g, '\\"')
								   .replace(/'/g, '\\\'')
								   .replace(/\r/g, '\\r')
								   .replace(/\n/g, '\\n')
								   .replace(/\t/g, '\\t')
				} else {
					return str;
				}
			},
			
			/**
			 * Merge arrays or objects
			 * 
			 * @param {Object} o1 Object
			 * @param {Object} o2 Object
			 * @return Merged object or array if o1 was array
			 * @type {Object}
			 */
			'merge': function (o1, o2) {
				var dest = {}, dest_is_array = false;
				if (typeof o1 == 'object') {
					if (FN_IS_ARRAY(o1)) {
						dest_is_array = true;
						dest = [].concat(o1);
					} else {
						for(var i in o1) dest[i] = o1[i];
					}
				}
				if (typeof o2 == 'object') {
					if (FN_IS_ARRAY(o2)) {
						if (dest_is_array) {
							dest.concat(o2);
						} else {
							for(var i=0,ii=o2.length; i<ii; i++) dest[i] = o2[i];
						}
					} else {
						if (dest_is_array) {
							for(var i in o2) dest.push(o2[i]);
						} else {
							for(var i in o2) dest[i] = o2[i];
						}
					}
				}
				
				return dest;
			},
			
			/**
			 * Raw value output
			 * Currently automatic escaping is not supported, so there is no need
			 * for this, we have it only for compatibility
			 * 
			 * @param {Object} obj Object
			 */
			'raw': function (obj) {
				return obj;
			},
			
			/**
			 * Supra.Intl filter
			 * Returns internationalized string
			 * 
			 * @param {String} ns Namespace
			 * @return Internationalized string
			 * @type {String}
			 */
			'intl': function (ns) {
				return Supra.Intl.get(ns.split('.'));
			},
			
			/**
			 * Y.DataType.Date.reformat
			 * Returns formated date
			 * 
			 * @param {String} date Date
			 * @return Formated date
			 * @type {String}
			 */
			'date': function (date) {
				return Y.DataType.Date.reformat(date, 'in_date', 'out_date');
			},
			'datetime': function (date) {
				return Y.DataType.Date.reformat(date, 'in_datetime', 'out_datetime');
			},
			'datetime_short': function (date) {
				return Y.DataType.Date.reformat(date, 'in_datetime_short', 'out_datetime_short');
			},
			'time': function (date) {
				return Y.DataType.Date.reformat(date, 'in_time', 'out_time');
			},
			'time_short': function (date) {
				return Y.DataType.Date.reformat(date, 'in_time_short', 'time_short');
			}
		},
		
		/**
		 * Functions
		 */
		'functions': {
			
			/**
			 * Cycle on an array of values
			 * 
			 * @param {Array} arr Array
			 * @param {Number} index Offset index
			 * @return Array value
			 * @type {Object}
			 */
			'cycle': function (arr, index) {
				var len = arr.length;
				index = parseInt(index, 10) || 0;
				return arr[index % len];
			},
			
			/**
			 * Returns a list containing an arithmetic progression of integers
			 * 
			 * @param {Number} from
			 * @param {Number} to
			 * @param {Number} step Optional. Default is 1
			 * @return Array of integers
			 * @type {Array}
			 */
			'range': function (from, to, step) {
				step = step || 1;
				from = parseInt(from, 10) || 0;
				to = parseInt(to, 10) || 0;
				step = parseInt(step, 10) || 0;
				
				//Prevent infinite loop
				if ((from < to && step < 0) || (from > to && step > 0)) return [];
				
				var arr = [];
				for(var i=from; i<=to; i+=step) {
					arr.push(i);
				}
				return arr;
			}
		},
		
		/**
		 * Expressions
		 */
		'compilerExpressions': {
			// {% set x = 10 %}
			'set': function (expression) {
				return C.compileVar(expression) + ';';
			},
			
			// {% debug x %}
			'debug': function (expression) {
				return '_c.debug(' + C.compileVar(expression) + ');';
			},
			
			// {% if x > 10 %}
			'if': function (expression) {
				if (Options.validate) {
					//Error validation
					Stack.unshift('if');
				}
				return 'if(' + C.compileVar(expression) + '){';
			},
			// {% elseif x < 10 %}
			'elseif': function (expression) {
				if (Options.validate) {
					//Error validation
					if (Stack[0] != 'if') throw new Error('Error_Syntax: missing opening "if" expression for "elseif"');
				}
				return '}else if(' + C.compileVar(expression) + '){';
			},
			// {% else %}
			'else': function (expression) {
				if (Options.validate) {
					//Error validation
					if (Stack[0] != 'if') throw new Error('Error_Syntax: missing opening "if" expression for "else"');
				}
				return '}else{';
			},
			// {% endif %}
			'endif': function (expression) {
				if (Options.validate) {
					//Error validation
					if (Stack[0] != 'if') throw new Error('Error_Syntax: missing opening "if" expression for "endif"');
					Stack.shift();
				}
				return '}';
			},
			
			// {% for key, value in variable %}
			'for': function (expression) {
				var var_name_tmp = C.generateVariable(),
					var_key_tmp = C.generateVariable(),
					var_key,
					var_val,
					var_name,
					out;
				
				//Find key, value and array variables
				expression.replace(REG_FOR, function (all, key, value_, val, name) {
					if (val) {
						var_key = C.compileVar(key);
						var_val = C.compileVar(val);
					} else {
						var_val = C.compileVar(key);
					}
					var_name = C.compileVar(name);
				});
				
				out = 'var ' + var_name_tmp + '=' + var_name + ';';
				out+= 't=_f.length(' + var_name_tmp + ');_d.loop={first:true,last:false,length:t,index:1,index0:0,revindex0:t-1,revindex:t};'
				out+= 'for(var ' + var_key_tmp + ' in ' + var_name_tmp + '){';
				out+= 'if(' + var_name_tmp + '.hasOwnProperty(' + var_key_tmp + ')){';
				out+= var_val + '=' + var_name_tmp + '[' + var_key_tmp + '];'
				
				if (var_key) {
					out+= var_key + '=' + var_key_tmp + ';';
				}
				
				//Error validation
				if (Options.validate) Stack.unshift('for');
				
				return out;
			},
			// {% endfor %}
			'endfor': function (expression) {
				if (Options.validate) {
					//Error validation
					if (Stack[0] != 'for') throw new Error('Error_Syntax: missing opening "for" expression for "endfor"');
					Stack.shift();
				}
				
				return '_d.loop.index++;_d.loop.index0++;_d.loop.revindex--;_d.loop.revindex0--;_d.loop.first=false;_d.loop.last=_d.loop.index==_d.loop.length;} }';
			},
			// {% include "TemplateId" %}
			'include': function (template) {
				return 'p+=Supra.Template(' + C.compileVar(template) + ', _d);';
			}
		}
	};
	
	var Options				= null,	//Compiler options
		Stack				= null,	//Validation stack
		
		TAG_VAR_OPEN 		= '{{',
		TAG_VAR_CLOSE 		= '}}',
		TAG_EXPR_OPEN 		= '{%',
		TAG_EXPR_CLOSE 		= '%}',
		TAG_COMMENT_OPEN	= '{#',
		TAG_COMMENT_CLOSE	= '#}',
		
		ESC_VAR_OPEN		= Y.Escape.regex(TAG_VAR_OPEN),
		ESC_VAR_CLOSE		= Y.Escape.regex(TAG_VAR_CLOSE),
		ESC_EXPR_OPEN 		= Y.Escape.regex(TAG_EXPR_OPEN),
		ESC_EXPR_CLOSE 		= Y.Escape.regex(TAG_EXPR_CLOSE),
		ESC_COMMENT_OPEN	= Y.Escape.regex(TAG_COMMENT_OPEN),
		ESC_COMMENT_CLOSE	= Y.Escape.regex(TAG_COMMENT_CLOSE),
		
		REG_CDATA_OPEN		= /(\/\/|\/\*)?\s*<\!\[CDATA\[\s*(\*\/)?/,
		REG_CDATA_CLOSE		= /(\/\/|\/\*)?\s*\]\]>\s*(\*\/)?/,
		REG_COMMENTS		= new RegExp(ESC_COMMENT_OPEN + '.*?' + ESC_COMMENT_CLOSE, 'g'),
		
		REG_ESCAPE			= new RegExp("[.*+?|()\\[\\]{}\\\\]", "g"), // .*+?|()[]{}\;
		REG_FILTER_TITLE	= /^([a-z])|\s+([a-z])/g,
		REG_WHITESPACE		= /[\r\n\t\s]+/g,
		REG_TEXT			= new RegExp('(^|' + ESC_VAR_CLOSE + '|' + ESC_EXPR_CLOSE + ')(.*?)($|' + ESC_VAR_OPEN + '|' + ESC_EXPR_OPEN + ')', 'g'),
		REG_TAG_WHITESPACE	= new RegExp('(' + ESC_VAR_OPEN + ')\\s+|\\s+(' + ESC_VAR_CLOSE + ')|(' + ESC_EXPR_OPEN + ')\\s+|\\s+(' + ESC_EXPR_CLOSE + ')', 'g'),
		REG_STRIP_TAGS		= /<[^>]+>/g,
		
		REG_VAR				= new RegExp(ESC_VAR_OPEN + '(.*?)' + ESC_VAR_CLOSE, 'g'),
		REG_VAR_STRING		= /("[^"]*"|'[^']*')/g,
		REG_VAR_TRIM		= /\s*(,|:|{|}|\(|\))\s*/g,
		REG_VAR_DATA		= /(^|\s|\[|\(|\!|\&|\-|\+|\*|\/|\%|,)([a-z])/gi,
		REG_VAR_FN			= /(^|\s|\[|\(|\!|\&)([a-z0-9_]+\()/gi,
		REG_VAR_MODIFIERS	= /([a-z0-9\$_'"\.\,\[\]\(\)\:\{\}]+)\|([a-z0-9_]+)(\(([^)]+)\))?/i,
		REG_EXPR			= new RegExp(ESC_EXPR_OPEN + '\\s*([a-z0-9\\\_]+)(\\s(.*?))?' + TAG_EXPR_CLOSE, 'g'),
		
		REG_CHECK_MODIFIERS	= /[a-z0-9\$_'"\.\,\[\]\(\)\:\{\}]+\|[a-z0-9_]/i,
		
		REG_CAT				= /\s*~\s*/g,
		REG_AND				= /\s+and\s+/g,
		REG_NOT				= /\s+not\s+/g,
		REG_OR				= /\s+or\s+/g,
		REG_FOR				= /\s*([a-z0-9_]+)(\s*,\s*([a-z0-9_]+))?\s+in\s+(.*)/i,
		
		FN_IS_ARRAY			= function (arr) { return arr && arr instanceof Array; },
		FN_TO_ARRAY			= function (obj) { var arr = []; for(var i in obj) if (obj.hasOwnProperty(i)) arr.push(obj[i]); return arr; },
		
		// Escape HTML attribute character
		escape_html_attr    = function (matches) {
			var chr = matches[0],
				ord = chr.charCodeAt(0),
				hex = '',
				entities = {34: 'quot', 38: 'amp', 60: 'lt', 62: 'gt'};
			
			if (entities[ord]) {
				return '&' + entities[ord] + ';';
			}
			
			// Characters undefined in HTML
			if ((ord <= 0x1f && chr != "\t" && chr != "\n" && chr != "\r") || (ord >= 0x7f && ord <= 0x9f)) {
				return '&#xFFFD;';
			}
		    
			hex = ('00' + ord.toString(16)).substr(-2).toUpperCase();
			return '&#x' + hex + ';';
		};
	
	C.filters.e = C.filters.escape;
	
	Supra.TemplateCompiler = C;
	
	/*
	 * @TODO Support for:
	 * 		{% for i in 1..10 %}
	 */
	
}, YUI.version);YUI.add('supra.template', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Returns template from ID or CSS selector
	 * If data argument is object then executes template and returns HTML
	 * 
	 * @param {String} id Template ID or css selector
	 * @param {Object} data 
	 * @return Template function or null if source was not found
	 * @type {Function}
	 */
	function Template (id, data) {
		if (!id && id !== '') return null;
		
		var source = null,
			template = id ? cache[id] : null;
		
		if (template) {
			return data ? template(data) : template;
		}

		if (id.isInstanceOf && id.isInstanceOf('Node')) {
			node = id;
			id = node.getAttribute('id');
		} else if (typeof id == 'string') {
			var node = Y.one('#' + id);
			if (!node) {
				node = Y.one(id);
				if (node) {
					id = node.getAttribute('id');
				}
			}
		}
		
		if (node) {
			var source = node.get('innerHTML');
			var template = Supra.TemplateCompiler.compile(source);
			
			cache[id] = template;
			return data ? template(data) : template;
		}
		
		return null;
	}
	
	/**
	 * Template cache
	 * @type {Object}
	 */
	var cache = Template.cache = {};
	
	/**
	 * Compile HTML into a template
	 * 
	 * @param {String} html Source HTML
	 * @param {String} id Optional template ID
	 * @return Template function
	 * @type {Function}
	 */
	Template.compile = function (html /* Source HTML */, id /* Template ID */) {
		if (id && cache[id]) return cache[id];
		
		var template = Supra.TemplateCompiler.compile(html, {
			'stripCDATA': true,
			'validate': false	//For performance reason disabled
		});
		
		if (id) cache[id] = template;
		
		return template;
	};
	
	/**
	 * Remove template from cache
	 * 
	 * @param {String} id Template ID
	 */
	Template.purgeCache = function (id) {
		if (id && cache[id]) delete(cache[id]);
	}
	
	
	Supra.Template = Template;
	
	
	//Since this object has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: [
	'supra.template-compiler'
]});YUI.add('supra.input-proto', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
		
		this._original_value = null;
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input';
	Input.ATTRS = {
		'inputNode': {
			value: null
		},
		'labelNode': {
			value: null
		},
		'descriptionNode': {
			value: null
		},
		'errorNode': {
			value: null
		},
		'value': {
			value: '',
			setter: '_setValue',
			getter: '_getValue'
		},
		'saveValue': {
			value: '',
			getter: '_getSaveValue'
		},
		'defaultValue': {
			value: null
		},
		'disabled': {
			value: null,
			setter: '_setDisabled'
		},
		'label': {
			value: null,
			setter: '_setLabel'
		},
		'description': {
			value: null,
			setter: '_setDescription'
		},
		'validationRules': {
			value: [],
			setter: '_processValidationRules'
		},
		'id': {
			value: null
		},
		'error': {
			value: false,
			setter: '_setError'
		},
		'style': {
			value: null,
			setter: '_setStyle'
		},
		
		// Parent widget, usually Supra.Form instance
		'parent': {
			value: null
		},
		// Root parent widget, usually Supra.Form instance
		'root': {
			value: null
		}
	};
	
	Input.HTML_PARSER = {
		'inputNode': function (srcNode) {
			var inp = srcNode;
			if (!srcNode.test('input,select,textarea')) {
				inp = srcNode.one('input') || srcNode.one('select') || srcNode.one('textarea');
			}
			
			this.set('inputNode', inp);
			return inp;
		},
		'labelNode': function (srcNode) {
			var label = this.get('labelNode');
			if (!label) {
				var label = srcNode.one('label');
				if (!label) {
					label = srcNode.previous();
					if (label && !label.test('label')) label = null;
				}
				this.set('labelNode', label);
			}
			return label;
		},
		'descriptionNode': function (srcNode) {
			var node = this.get('descriptionNode');
			if (!node) {
				node = srcNode.one('p');
				if (!node) {
					node = srcNode.next();
					if (node && !node.test('p')) node = null;
				}
			}
			if (node && node.test('p.label')) node = null;
			return node;
		},
		'disabled': function (srcNode) {
			var val = this.get('disabled');
			var inp = this.get('inputNode');
			
			if (inp) {
				if (val === null) {
					return inp.get('disabled');
				} else {
					this.set('disabled', val);
				}
			}
			
			return !!val;
		},
		'style': function (srcNode) {
			return srcNode.getAttribute('suStyle') || null;
		}
	};
	
	Y.extend(Input, Y.Widget, {
		INPUT_TEMPLATE: '<input type="text" value="" />',
		LABEL_TEMPLATE: '<label></label>',
		DESCRIPTION_TEMPLATE: '<p class="description"></p>',
		
		_original_value: null,
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var input = this.get('inputNode');
			if (!input) return;
			
			//On Input focus, focus input element
			this.on('focusedChange', function (event) {
				if (event.newVal != event.prevVal) {
					if (event.newVal) {
						this.get('inputNode').focus();
						this.fire('focus');
					} else {
						this.fire('blur');
					}
				}
			}, this);
			
			//On input change update value
			input.on('change', function (event) {
				if (!input.test('input[type="checkbox"],input[type="radio"]')) {
					this.set('value', input.get('value'));
				}
			}, this);
			
			//On input element blur, blur Input
			input.on('blur', this.blur, this);
		},
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			var inp = this.get('inputNode');
			var lbl = this.get('labelNode');
			var descr = this.get('descriptionNode');
			var cont = this.get('contentBox');
			var bound = this.get('boundingBox');
			
			if (!inp && this.INPUT_TEMPLATE) {
				inp = Y.Node.create(this.INPUT_TEMPLATE);
				cont.prepend(inp);
				this.set('inputNode', inp);
			}
			
			// Craete description element
			if (inp && !descr && this.DESCRIPTION_TEMPLATE) {
				var description = this.get('description');
				if (description) {
					descr = Y.Node.create(this.DESCRIPTION_TEMPLATE);
					this.set('descriptionNode', descr);
				}
			}
			if (descr && inp) {
				descr.addClass('description');
				inp.insert(descr, 'after');
			}
			
			// Create label element
			if (inp && !lbl && this.LABEL_TEMPLATE) {
				var id = inp.getAttribute('id');
				
				lbl = Y.Node.create(this.LABEL_TEMPLATE);
				lbl.setAttribute('for', id);
				lbl.set('text', this.get('label') || '');
				
				if (!this.get('label')) {
					lbl.addClass('hidden');
				}
				
				if (cont.compareTo(inp)) {
					inp.insert(lbl, 'before');
				} else {
					cont.prepend(lbl);
				}
				
				this.set('labelNode', lbl);
			}
			
			if (this.get('disabled')) {
				this.set('disabled', true);
			}
			
			//Move label inside bounding box
			if (lbl && inp && cont.compareTo(inp)) {
				bound.prepend(lbl);
			}
			
			//Add classnames
			bound.addClass(Y.ClassNameManager.getClassName('input'));
			bound.addClass(Y.ClassNameManager.getClassName(this.constructor.NAME));
			
			//Style
			this.set('style', this.get('style'));
			
			//Value
			this.set('value', this.get('value'));
		},
		
		getAttribute: function (key) {
			return this.get('inputNode').getAttribute(key);
		},
		
		addClass: function (c) {
			this.get('boundingBox').addClass(c);
			return this;
		},
		
		removeClass: function (c) {
			this.get('boundingBox').removeClass(c);
			return this;
		},
		
		hasClass: function (c) {
			return this.get('boundingBox').hasClass(c);
		},
		
		toggleClass: function (c, v) {
			this.get('boundingBox').toggleClass(c, v);
			return this;
		},
		
		/**
		 * Show error message
		 * 
		 * @param {String} message
		 */
		showError: function (message) {
			if (typeof message === 'string') {
				var node = this.get('errorNode');
				
				if (!node) {
					node = Y.Node.create('<div class="yui3-input-error-message"></div>');
					this.get('boundingBox').append(node);
					this.set('errorNode', node);
				} else {
					node.removeClass('hidden');
				}
				
				node.set('text', message);
			}
		},
		
		/**
		 * Hide error message
		 */
		hideError: function () {
			var node = this.get('errorNode');
			if (node) {
				node.addClass('hidden');
			}
		},
		
		/**
		 * Error setter
		 * Show error message if 'error' is string or just highlight if true
		 * If false, 0 or empty string, then hide error
		 *
		 * @param {String} error Error message
		 */
		_setError: function (error) {
			this.get('boundingBox').toggleClass('yui3-input-error', error);
			
			if (typeof error == 'string' && error) {
				this.showError(error);
			} else {
				this.hideError();
			}
			
			return error;
		},
		
		/**
		 * Disabled attribute setter
		 * Disable / enable HTMLEditor
		 * 
		 * @param {Boolean} value New state value
		 * @return New state value
		 * @type {Boolean}
		 * @private
		 */
		_setDisabled: function (value) {
			var node = this.get('inputNode');
			if (node) {
				node.set('disabled', !!value);
			}
			
			this.get('boundingBox').toggleClass('yui3-input-disabled', value);
			
			return !!value;
		},
		
		/**
		 * Value attribute getter
		 * 
		 * @param {String} value Previous value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_getValue: function () {
			return this.get('inputNode').get('value');
		},
		
		/**
		 * saveValue attribute getter
		 * Returns value for sending to server
		 * 
		 * @param {String} value Previous value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_getSaveValue: function () {
			return this.get('value');
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value New value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setValue: function (value) {
			value = (value === undefined || value === null ? '' : value);
			this.get('inputNode').set('value', value);
			
			this._original_value = value;
			return value;
		},
		
		/**
		 * Label attribute setter
		 * 
		 * @param {String} lbl Label text
		 * @return New label
		 * @type {String}
		 * @private
		 */
		_setLabel: function (lbl) {
			var node = this.get('labelNode');
			if (node) {
				lbl = Supra.Intl.replace(lbl);
				if (lbl) {
					node.set('text', lbl);
					node.removeClass('hidden');
				} else {
					node.addClass('hidden');
				}
			}
			
			return lbl;
		},
		
		/**
		 * Description attribute setter
		 * 
		 * @param {String} descr Description text
		 * @return New description
		 * @type {String}
		 * @private
		 */
		_setDescription: function (descr) {
			var node = this.get('descriptionNode'),
				inp = this.get('inputNode');
			
			if (!node && !inp) {
				//Can't do anything about it
				return descr;
			}
			if (!node && descr && this.DESCRIPTION_TEMPLATE) {
				node = Y.Node.create(this.DESCRIPTION_TEMPLATE);
				this.get('inputNode').insert(node, 'after');
				this.set('descriptionNode', node);
			}
			if (node) {
				var descr_text = Supra.Intl.replace(descr) || '';
				
				node.set('text', descr_text)
				    .toggleClass('hidden', !descr_text);
			}
			
			return descr;
		},
		
		/**
		 * Set input style
		 * 
		 * @param {String} style Style
		 * @private
		 */
		_setStyle: function (style) {
			var prev = this.get('style'),
				node = this.get('boundingBox');
			
			if (prev) {
				this.removeClass(Y.ClassNameManager.getClassName('input', prev));
			}
			if (style) {
				this.addClass(Y.ClassNameManager.getClassName('input', style));
			}
			
			return style;
		},
		
		/**
		 * Visible attribute setter
		 * 
		 * @private
		 */
		_uiSetVisible: function (visible) {
			Input.superclass._uiSetVisible.apply(this, arguments);
			this.get('boundingBox').toggleClass('hidden', !visible);
		},
		
		/**
		 * Set input value
		 * 
		 * @param {Object} value
		 */
		setValue: function (value) {
			this.set('value', value);
			return this;
		},
		
		/**
		 * Returns input value
		 * 
		 * @return Input value
		 * @type {Object}
		 */
		getValue: function () {
			return this.get('value');
		},
		
		/**
		 * Reset value to default
		 */
		resetValue: function () {
			this.set('value', this.get('defaultValue') || '');
			return this;
		},
		
		/**
		 * Set label
		 * 
		 * @param {String} label
		 */
		setLabel: function (label) {
			this.set('label', label);
			return this;
		},
		
		/**
		 * Returns label
		 * 
		 * @return Label
		 * @type {String}
		 */
		getLabel: function () {
			return this.get('label');
		},
		
		/**
		 * Disable/enable input
		 * 
		 * @param {Boolean} disabled
		 */
		setDisabled: function (disabled) {
			this.set('disabled', disabled);
			return this;
		},
		
		/**
		 * Returns true if input is disabled, otherwise false
		 * 
		 * @return True if input is disabled
		 * @type {Boolean}
		 */
		getDisabled: function () {
			return this.get('disabled');
		},
		
		/**
		 * Add validation rule
		 * 
		 * @param {Object} rule
		 */
		addValidationRule: function (rule) {
			//@TODO
			return this;
		},
		
		/**
		 * Add validation rules
		 * 
		 * @param {Array} rules
		 */
		addValidationRules: function (rules) {
			//@TODO
			return this;
		},
		
		/**
		 * Returns input validation rules
		 * 
		 * @return Array with validation rules
		 * @type {Array}
		 */
		getValidationRules: function () {
			//@TODO
		},
		
		/**
		 * Validate input value against validation rules
		 * 
		 * @return True on success, false on failure
		 * @type {Boolean}
		 */
		validate: function () {
			//@TODO
		},
		
		/**
		 * Start editing input
		 */
		startEditing: function () {
			if (!this.get('disabled')) {
				this.focus();
				return true;
			} else {
				return false;
			}
		},
		
		/**
		 * Stop editing input
		 */
		stopEditing: function () {
			this.blur();
		},
		
		/**
		 * Returns value as string
		 * 
		 * @return Value
		 * @type {String}
		 */
		toString: function () {
			return String(this.getValue() || '');
		},
		
		
		/* ------------------------------ SIDEBAR -------------------------------- */
		
		
		/**
		 * Returns parent widget by class name
		 * 
		 * @param {String} classname Parent widgets class name
		 * @return Widget instance or null if not found
		 * @private
		 */
		getParentWidget: function (classname) {
			var parent = this.get("parent");
			while (parent) {
				if (parent.isInstanceOf(classname)) return parent;
				parent = parent.get("parent");
			}
			return null;
		},
		
		/**
		 * Returns slideshow
		 * 
		 * @returns {Object} Slideshow instance if there is one
		 */
		getSlideshow: function () {
			var form = this.getParentWidget("form"),
				slideshow = form ? form.get("slideshow") : null;
			
			
			
			return slideshow;
		},
		
		/**
		 * Returns form
		 * 
		 * @returns {Object} Form instance to which this input belongs to
		 */
		getForm: function () {
			return this.getParentWidget("form");
		}
		
	});
	
	
	/**
	 * Generate "lipsum" value for input, optional
	 * 
	 * @returns {String} Lipsum value
	 */
	Input.lipsum = function () {
		return '';
	};
	
	
	Supra.Input = {
		'Proto': Input,
		
		/**
		 * Returns true if input is inline
		 * Input can be inline and contained at the same time, so this is not exclusive
		 * If IS_INLINE constant is not set on input, then by default returns false
		 * 
		 * @param {String} type Input type
		 * @param {Boolean} default_value Default return value if input doesn't exist, default is false
		 * @returns {Boolean} True if input is inline
		 */
		'isInline': function (type, default_value) {
			var type_str = String(type || ''),
				name = type_str.substr(0, 1).toUpperCase() + type_str.substr(1),
				inline = (default_value === true || default_value === false ? default_value : false);
			
			if (name in Supra.Input && Supra.Input[name].IS_INLINE === true) {
				inline = true;
			}
			
			return inline;
		},
		
		/**
		 * Returns true if input is contained inside form
		 * Input can be inline and contained at the same time, so this is not exclusive
		 * If IS_CONTAINED constant is not set on input, then by default returns true
		 * 
		 * @param {String} type Input type
		 * @param {Boolean} default_value Default return value if input doesn't exist, default is true
		 * @returns {Boolean} True if input is contained
		 */
		'isContained': function (type, default_value) {
			var type_str = String(type || ''),
				name = type_str.substr(0, 1).toUpperCase() + type_str.substr(1),
				contained = (default_value === true || default_value === false ? default_value : true);
			
			if (name in Supra.Input && Supra.Input[name].IS_CONTAINED === false) {
				contained = false;
			}
			
			return contained;
		}
	};
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['widget', 'supra.lipsum']});YUI.add("supra.input-hidden", function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-hidden";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		LABEL_TEMPLATE: '<label></label>',
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			//Handle value attribute change
			this.on('valueChange', this._afterValueChange, this);
		},
		
		_getValue: function (value) {
			return value;
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		}
	});
	
	Supra.Input.Hidden = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto"]});YUI.add('supra.input-string', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
		
		this._last_value = '';
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-string';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		'replacementNode': {
			value: null
		},
		'useReplacement': {
			value: false
		},
		'valueMask': {
			value: null,
			setter: '_setValueMask'
		},
		'valueSource': {
			value: null
		},
		'blurOnReturn': {
			value: false
		},
		'maxLength': {
			value: 0,
			setter: '_setMaxLength'
		}
	};
	
	Input.HTML_PARSER = {
		'maxLength': function (srcNode) {
			if (srcNode.hasAttribute('maxlength')) {
				return parseInt(srcNode.getAttribute('maxlength'), 10) || 0;
			}
		},
		'useReplacement': function (srcNode) {
			var use_replacement = srcNode.hasClass('input-label-replacement');
			this.set('useReplacement', use_replacement);
			return use_replacement;
		},
		'replacementNode': function (srcNode) {
			if (srcNode.hasClass('input-label-replacement')) {
				return srcNode.one('span');
			}
			return null;
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<input type="text" value="" />',
		LABEL_TEMPLATE: '<label></label>',
		
		/**
		 * Key code constants
		 */
		KEY_RETURN: 13,
		KEY_ESCAPE: 27,
		KEY_UP: 38,
		KEY_DOWN: 40,
		
		/**
		 * If keys are allowed, overwriten when String class
		 * is extended
		 */
		KEY_RETURN_ALLOW: true,
		KEY_ESCAPE_ALLOW: true,
		
		/**
		 * Character which is used instead of invalid characters
		 */
		MASK_REPLACEMENT_CHARACTER: '',
		
		/**
		 * Last known value, used to restore input value if new value doesn't
		 * pass mask validation
		 * @type {String}
		 * @private
		 */
		_last_value: null,
		
		/**
		 * Value source target input event listener
		 * @type {Object}
		 * @private
		 */
		_value_source_listener: null,
		
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var input = this.get('inputNode');
			
			input.on('focus', this._onFocus, this);
			input.on('blur', this._onBlur, this);
			
			//Max length
			var maxlength = this.get('maxLength');
			if (maxlength) {
				input.setAttribute('maxlength', maxlength);
			}
			
			//Clicking on replacement node triggers focuses
			var node = this.get('replacementNode');
			if (node) {
				node.on('click', this._onFocus, this);
			}
			
			//Handle keydown
			input.on('keydown', this._onKeyDown, this);
			
			//Handle input, with yui .on("input"...) event doesn't work
			var node = input.getDOMNode();
			if (node.addEventListener) {
				node.addEventListener('input', Y.bind(this._onInput, this), false);
			} else {
				input.on('keypress', this._onKeyPress, this);
			}
			
			//Handle value attribute change
			if (!this.get('srcNode').compareTo(input)) {
				this.on('valueChange', this._afterValueChange, this);
			}
			
			this.on('input', this._onWidgetInputEvent, this);
			
			// Value source
			this.after('valueSourceChange', this._afterValueSourceChange, this);
			
			if (this.get('valueSource')) {
				this._afterValueSourceChange({'prevVal': undefined, 'newVal': this.get('valueSource')});
			}
		},
		
		/**
		 * Handle keypress event:
		 * FF - charCode is for characters, keyCode is for non output keys
		 * Opera - which is for characters, keyCode is for all keys
		 * Chrome, Safari, IE9 - charCode and keyCode is for characters, but non output keys doesn't trigger keyPress
		 *
		 * @param {Event} e Event
		 * @private
		 */
		_onKeyPress: function (e) {
			var charCode = Y.UA.opera ? e._event.which : e._event.charCode,
				keyCode = e._event.keyCode || e._event.which || e._event.charCode,
				input = this.get('inputNode'),
				mask = this.get('valueMask');
			
			if (charCode >= 186 && charCode <= 222) {
				//Normalize to match fromCharCode with charCodeAt
				charCode = charCode - 144;
			}
			
			if (keyCode == this.KEY_RETURN && this.KEY_RETURN_ALLOW) {
				//Already handled by _onKeyDown
			} else if (keyCode == this.KEY_ESCAPE && this.KEY_ESCAPE_ALLOW) {
				//Already handled by _onKeyDown
			} else if (charCode) {
				//46 - 'Delete'
				//Validate against mask
				var str = String.fromCharCode(charCode),
					inputNode = Y.Node.getDOMNode(input),
					value = inputNode.value;
				
				value = value.substr(0, inputNode.selectionStart) + str + value.substr(inputNode.selectionEnd).replace(/^\s*|\s*$/, '');

				if (e.ctrlKey && charCode == 118) return;
				if (mask && !mask.test(value)) return e.preventDefault();
				
				//Trigger input event
				if (this._last_value != value) {
					this._last_value = value;
					this.fire('input', {'value': value});
				}
			}
		},
		
		/**
		 * Handle key down event
		 * Chrome doesn't trigger escape on keypress event
		 *
		 * @param {Event} e Event
		 * @private
		 */
		_onKeyDown: function (e) {
			var keyCode   = e._event.keyCode || e._event.which || e._event.charCode,
				input     = this.get('inputNode'),
				inputNode = input.getDOMNode(),
				value     = inputNode.value,
				isNumber  = (value == parseInt(value)),
				mask      = this.get('valueMask');
			
			if (keyCode == this.KEY_RETURN && this.KEY_RETURN_ALLOW) {
				if (this.get('replacementNode') || this.get('blurOnReturn')) {
					//If using replacement node then show it
					input.blur();
				}
			} else if ((keyCode == this.KEY_UP || keyCode == this.KEY_DOWN) && isNumber) {
				//On up or down arrow press if content is a number, then add or subtract 1
				//if shift/meta key is pressed then add or subtract 10
				value = parseInt(value) + (keyCode == this.KEY_UP ? 1 : -1) * (e.shiftKey || e.metaKey ? 10 : 1);
				if (mask && !mask.test(String(value))) return;
				
				//Trigger input event
				if (this._last_value != value) {
					inputNode.value = value;
					this._last_value = value;
					this.fire('input', {'value': value});
				}
			} else if (keyCode == this.KEY_ESCAPE && this.KEY_ESCAPE_ALLOW) {
				input.set('value', this._original_value);
				input.blur();
				this.fire('input', {'value': this._original_value});
				this.fire('reset');
			}
		},
		
		/**
		 * On data input validate value
		 * 
		 * @param {Object} e
		 */
		_onInput: function (e) {
			var value = this.get('value'),
				mask = this.get('valueMask');
			
			if (mask) {
				if (value && !mask.test(value)) {
					//It's not possible to prevent input event, so we set previous value
					this.set('value', this._last_value);
				} else {
					if (this._last_value != value) {
						this._last_value = value;
						this.fire('input', {'value': value});
					}
				}
			} else if (this._last_value != value) {
				this._last_value = value;
				this.fire('input', {'value': value});
			}
		},
		
		_onFocus: function () {
			if (this.get('disabled') || this.get('boundingBox').hasClass('yui3-input-focused')) return;
			
			this.get('boundingBox').addClass('yui3-input-focused');
			this.get('inputNode').focus();
		},
		_onBlur: function () {
			this.get('boundingBox').removeClass('yui3-input-focused');
			
			var node = this.get('replacementNode');
			if (node) {
				node.set('innerHTML', Y.Escape.html(this.get('value')) || '&nbsp;');
			}
			
			this._original_value = this.get('value');
		},
		
		_onWidgetInputEvent: function (e) {
			var value = e.value;
			
			if (value) {
				this.get('boundingBox').removeClass(this.getClassName('empty'));
			} else {
				this.get('boundingBox').addClass(this.getClassName('empty'));
			}
		},
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			if (!this.get('useReplacement') && this.get('srcNode').getAttribute('suUseReplacement') == 'true') {
				this.set('useReplacement', true);
				var labelNode = this.get('labelNode');
				if (labelNode) {
					labelNode.addClass('hidden');
				}
			}
			
			if (this.get('srcNode').getAttribute('suBlurOnReturn') == 'true') {
				this.set('blurOnReturn', true);
			}
			
			if (this.get('useReplacement')) {
				var node = this.get('replacementNode');
				var srcNode = this.get('srcNode');
				var srcNodeIsInput = srcNode.test('input,select,textarea');
				
				if (!srcNodeIsInput) {
					srcNode.addClass('input-label-replacement');
				} else {
					this.get('boundingBox').addClass('input-label-replacement');
				}
				
				if (!node) {
					node = Y.Node.create('<span class="replacement"></span>');
					
					if (srcNodeIsInput) {
						srcNode.insert(node, 'before');
					} else {
						srcNode.append(node);
						var input = this.get('inputNode');
						if (input) srcNode.append(input);
					}
					
					this.set('replacementNode', node);
				}
				
				node.set('innerHTML', Y.Escape.html(this.get('value')) || '&nbsp;');
				
				//If there is no label text then hide it
				var labelNode = this.get('labelNode');
				if (labelNode && !labelNode.get('text')) {
					labelNode.addClass('hidden');
				}
			}
			
			//Value mask
			if (!this.get('valueMask')) {
				var mask = this.get('inputNode').getAttribute('suValueMask');
				if (mask) {
					this.set('valueMask', new RegExp(mask));
				}
			}
			
			//Value source
			if (!this.get('valueSource')) {
				var mask = this.get('inputNode').getAttribute('suValueSource');
				if (mask) {
					this.set('valueSource');
				}
			}
		},
		
		_setValue: function (value) {
			value = (value === undefined || value === null ? '' : value);
			
			this.get('inputNode').set('value', value);
			var node = this.get('replacementNode');
			if (node) {
				node.set('innerHTML', Y.Escape.html(value) || '&nbsp;');
			}
			
			if (value) {
				this.get('boundingBox').removeClass(this.getClassName('empty'));
			} else {
				this.get('boundingBox').addClass(this.getClassName('empty'));
			}
			
			this._original_value = value;
			
			if (this._last_value != value) {
				this._last_value = value;
				this.fire('input', {'value': value});
			}
			
			return value;
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		/**
		 * Mask attribute setter
		 * 
		 * @param {String|RegExp} mask New value mask
		 * @returns {RegExp} New attribute value
		 * @private
		 */
		_setValueMask: function (mask) {
			if (typeof mask === 'string') {
				mask = new RegExp(mask);
			}
			return mask;
		},
		
		/**
		 * Max length attribute setter
		 * 
		 * @param {Number|String} maxlength New maxlength value
		 * @returns {Number} New attribute value
		 * @private
		 */
		_setMaxLength: function (maxlength) {
			maxlength = parseInt(maxlength, 10) || 0;
			
			var input = this.get('inputNode');
			if (input) {
				if (maxlength) {
					input.setAttribute('maxlength', maxlength);
				} else {
					input.removeAttribute('maxlength');
				}
			}
			
			return maxlength;
		},
		
		/**
		 * After value source change rebind listeners
		 * 
		 * @param {Object} evt valueSource attribute value change event object
		 * @private 
		 */
		_afterValueSourceChange: function (evt) {
			var form = this.getParentWidget("form"),
				input = null;
			
			if (!form || evt.prevVal == evt.newVal) return;
			
			if (this._value_source_listener) {
				this._value_source_listener.detach();
				this._value_source_listener = null;
			}
			
			if (evt.newVal) {
				input = form.getInput(evt.newVal);
				
				if (input) {
					this._value_source_listener = input.on('input', this._afterValueSourceInputChange, this);
				}
			}
		},
		
		/**
		 * After value source input value change update this input value
		 * 
		 * @param {Object} evt
		 * @private
		 */
		_afterValueSourceInputChange: function (evt) {
			var value = evt.value,
				mask  = this.get('valueMask'),
				out   = '',
				i     = 0,
				ii    = value.length,
				repl  = this.MASK_REPLACEMENT_CHARACTER;
			
			if (mask) {
				for (; i<ii; i++) {
					if (mask.test(value[i])) {
						out += value[i];
					} else {
						out += repl;
					}
				}
				
				value = out;
				/*if (repl) {
					out = out.replace(new RegExp('[' + Y.Escape.regex(repl) + ']{2,}', repl));
				}*/
			}
			
			this.set('value', value);
		}
		
	});
	
	Input.lipsum = function () {
		return Supra.Lipsum.sentence({'count': 4, 'variation': 1});
	};
	
	Supra.Input.String = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});
YUI.add('supra.input-text', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-text';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {};
	
	Y.extend(Input, Supra.Input.String, {
		INPUT_TEMPLATE: '<textarea spellcheck="false"></textarea>',
		KEY_RETURN_ALLOW: false
	});
	
	Input.lipsum = function () {
		return Supra.Lipsum.paragraph({'count': 4});
	};
	
	Supra.Input.Text = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-string']});//Invoke strict mode
"use strict";

YUI().add('supra.input-string-clear', function (Y) {
	
	/**
	 * Plugin for String input to clear content on icon click
	 */
	function InputStringClear () {
		InputStringClear.superclass.constructor.apply(this, arguments);
	};
	
	InputStringClear.NAME = 'InputStringClear';
	InputStringClear.NS = 'clear';
	
	Y.extend(InputStringClear, Y.Plugin.Base, {
		
		/**
		 * Clear icon/button
		 * 
		 * @type {Object}
		 * @private 
		 */
		nodeClear: null,
		
		/**
		 * Attach to event listeners, etc.
		 * 
		 * @constructor
		 * @private
		 */
		'initializer': function () {
			this.nodeClear = Y.Node.create('<a class="clear"></a>');
			this.nodeClear.on('click', this.clearInputValue, this);
			
			var host = this.get('host'),
				node = host.get('inputNode');
			
			if (node) {
				this.appendClearNode();
			} else {
				this.inputNodeEvt = host.after('inputNodeChange', this.appendClearNode, this);
			}
		},
		
		/**
		 * Add clear node to the input
		 * 
		 * @private
		 */
		'appendClearNode': function () {
			var host = this.get('host'),
				node = host.get('inputNode');
			
			if (node) {
				this.get('host').get('inputNode').insert(this.nodeClear, 'after');
			}
		},
		
		/**
		 * Clear input value
		 * 
		 * @private
		 */
		'clearInputValue': function () {
			this.get('host').set('value', '');
		}
	});
	
	Supra.Input.String.Clear = InputStringClear;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.form', 'plugin']});YUI().add('supra.google-fonts', function (Y) {
	//Invoke strict mode
	'use strict';
	
	//Map function to lowercase all array items
	var LOWERCASE_MAP = function (str) {
		return String(str || '').toLowerCase();
	};
	
	
	/**
	 * Iframe content widget
	 */
	function GoogleFonts (config) {
		GoogleFonts.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	GoogleFonts.NAME = 'google-fonts';
	
	// Google font API uri
	GoogleFonts.API_URI = document.location.protocol + '//fonts.googleapis.com/css?family=';
	
	// URI to load list of google fonts
	GoogleFonts.SUPRA_FONT_URI = /* dynamic url + */ '/content-manager/fonts/list.json';
	
	//List of fonts, which doesn't need to be loaded from Google Web Fonts
	GoogleFonts.SAFE_FONTS = [
		'Arial', 'Tahoma', 'Helvetica', 'sans-serif', 'Arial Black', 'Impact',
		'Trebuchet MS', 'MS Sans Serif', 'MS Serif', 'Geneva', 'Comic Sans MS' /* trololol.... */,
		'Palatino Linotype', 'Book Antiqua', 'Palatino', 'Monaco', 'Charcoal',
		'Courier New', 'Georgia', 'Times New Roman', 'Times',
		'Lucida Console', 'Lucida Sans Unicode', 'Lucida Grande', 'Gadget',
		'monospace'
	];
	
	// List of non-google fonts for fonts list
	GoogleFonts.STANDARD_FONTS = [
		{'title': 'Arial, Helvetica',							'family': 'Arial, Helvetica, sans-serif'},
		{'title': 'Times New Roman, Times, serif',				'family': '"Times New Roman", Times, serif'},
		{'title': 'Georgia', 									'family': 'Georgia, serif'},
		{'title': 'Palatino Linotype, Book Antiqua, Palatino',	'family': '"Palatino Linotype", "Book Antiqua", Palatino, serif'},
		{'title': 'Impact, Charcoal', 							'family': 'Impact, Charcoal, sans-serif'},
		{'title': 'Lucida Sans Unicode, Lucida Grande',			'family': '"Lucida Sans Unicode", "Lucida Grande", sans-serif'},
		{'title': 'Tahoma, Geneva',								'family': 'Tahoma, Geneva, sans-serif'},
		{'title': 'Trebuchet MS, Helvetica',					'family': '"Trebuchet MS", Helvetica, sans-serif'},
		{'title': 'Verdana, Geneva',							'family': 'Verdana, Geneva, sans-serif'}
	];
	
	// List of google font subsets
	GoogleFonts.SUBSETS = [
		'latin', 'cyrillic-ext', 'latin-ext', 'cyrillic'
	];
	
	GoogleFonts.ATTRS = {
		//Document element to which add fonts to
		'doc': {
			'value': document,
			'setter': '_setDoc'
		},
		
		//Google APIs font list
		'fonts': {
			'value': [],
			'setter': '_setFonts'
		}
	};
	
	Y.extend(GoogleFonts, Y.Base, {
		
		
		/**
		 * Initialization life cycle method
		 */
		initializer: function () {
			this.addFonts(this.get('fonts'));
		},
		
		/**
		 * Destruction life cycle method
		 */
		destructor: function () {
			// Nothing, leave LINK in document
		},
		
		
		/* ------------------------------------------- FONTS ------------------------------------------- */
		
		
		/**
		 * Load fonts from Google Fonts
		 * 
		 * @param {String} html HTML in which will be inserted <link />, if this is document then link is added to DOM <head />
		 * @private
		 */
		addFonts: function (fonts) {
			if (!fonts || !fonts.length) {
				return;
			}
			
			var new_uris = [],
				data = null,
				i = 0, ii = 0;
			
			data = this.getExistingLinkData();
			new_uris = GoogleFonts.getURI(fonts, {'exclude': data.fonts, 'split': true});
			
			if (new_uris.length) {
				for (i=0,ii=new_uris.length; i<ii; i++) {
					this.createLinkNode(new_uris[i]);
				}
			}
		},
		
		
		/*
		 * ---------------------------------- DOM ---------------------------------
		 */
		
		
		/**
		 * Returns link node
		 * 
		 * @param {Boolean} create Create link node if it doesn't exist
		 * @returns {Object} Google fonts link node
		 */
		getLinkNodes: function () {
			var doc = doc || this.get('doc'),
				head = null,
				links = null;
			
			if (!doc) return null;
			
			head = Y.Node(doc).one('head');
			if (!head) return null;
			
			links = head.all('link[href^="' + GoogleFonts.API_URI + '"]');
			return links ? links.getDOMNodes() : [];
		},
		
		/**
		 * Creates link node
		 */
		createLinkNode: function (uri) {
			var doc = doc || this.get('doc'),
				head = null,
				link = null;
			
			if (!doc) return null;
			
			head = Y.Node(doc).one('head');
			if (!head) return null;
			
			link = Y.Node.create('<link rel="stylesheet" type="text/css" href="' + (uri || '') + '" />');
			head.append(link);
			
			return link;
		},
		
		/**
		 * Returns existing data extracted from link
		 * Extracts fonts and subset from link
		 * 
		 * @returns {Object} Parsed link node
		 */
		getExistingLinkData: function () {
			var nodes = this.getLinkNodes(),
				uri  = '',
				subset = GoogleFonts.SUBSETS.join(','),
				fonts = [],
				i = 0,
				ii = nodes.length;
			
			for (; i<ii; i++) {
				uri = nodes[i].getAttribute('href');
				if (uri) {
					// Remove url, subset and styles
					uri = uri.replace(GoogleFonts.API_URI, '');
					uri = uri.replace(/&subset=([^&]+)/, '');
					//uri = uri.replace(/:[^|&?]*/g, '');
					
					// Fonts
					fonts = fonts.concat(uri.split('|'));
				}
			}
			
			return {'fonts': fonts, 'subset': subset};
		},
		
		
		/*
		 * ---------------------------------- ATTRIBUTES ---------------------------------
		 */
		
		
		/**
		 * Document object setter
		 * 
		 * @param {Object} doc Document object
		 * @returns {Object} New attribute value
		 * @private
		 */
		_setDoc: function (doc) {
			this._node = null;
			
			if (doc) {
				this.addFonts(this.get('fonts'));
			}
			
			return doc;
		},
		
		
		/**
		 * Load fonts from Google Fonts
		 * 
		 * @param {Array} fonts List of fonts
		 * @returns {Array} New attribute value
		 * @private
		 */
		_setFonts: function (fonts) {
			var fonts = (this.get('fonts') || []).concat(fonts),
				i = 0,
				ii = fonts.length,
				unique_arr = [],
				unique_hash = {},
				id = null;
			
			// Find unique
			for (; i<ii; i++) {
				id = fonts[i].apis || fonts[i].family;
				if (!(id in unique_hash)) {
					unique_hash[id] = true;
					unique_arr.push(fonts[i]);
				}
			}
			
			fonts = unique_arr;
			
			// Set
			this.addFonts(fonts);
			
			return fonts;
		}
	});
	
	Supra.GoogleFonts = GoogleFonts;
	
	
	/**
	 * Load list of all fonts
	 * 
	 * @returns {Object} Supra.Deferred object
	 * @private
	 */
	GoogleFonts.loadFonts = function () {
		if (GoogleFonts.loadFonts._deferred) {
			return GoogleFonts.loadFonts._promise;
		}
		
		var deferred = new Supra.Deferred(),
			promise  = deferred.promise(),
			uri      = Supra.Manager.Loader.getDynamicPath() + GoogleFonts.SUPRA_FONT_URI;
		
		Supra.io(uri).then(
			function (fonts) {
				// Success, return standard + google fonts
				var formatted = [],
					i = 0,
					ii = fonts.length,
					family = '';
				
				for (; i<ii; i++) {
					family = fonts[i];
					formatted.push({
						'title': family,
						'family': family, //amily.indexOf(' ') != -1 ? '"' + family + '"' : family,
						'apis': family.replace(/ /g, '+') + ':300,300italic,regular,italic,700,700italic'
					});
				}
				
				deferred.resolve([[
					{
						'title': 'Standard fonts',
						'fonts': GoogleFonts.STANDARD_FONTS,
					},
					{
						'title': 'Google fonts',
						'fonts': formatted
					}
				]]);
			}, function () {
				// Failure, return only standard fonts
				deferred.resolve([[
					{
						'title': 'Standard fonts',
						'fonts': GoogleFonts.STANDARD_FONTS,
					}
				]]);
			});
		
		GoogleFonts.loadFonts._promise = promise;
		return promise;
	};
	
	/**
	 * Returns URI with all fonts
	 * 
	 * @return URI for <link /> element which will load all fonts
	 * @private
	 */
	GoogleFonts.getURI = function (fonts, options) {
		
		var fonts = Y.Lang.isArray(fonts) ? fonts : [],
			i = 0,
			ii = fonts.length,
			
			exclude = options && options.exclude ? options.exclude : [],
			e = 0,
			ee = exclude.length,
			
			//Get all safe fonts in lowercase
			safe  = Y.Array(GoogleFonts.SAFE_FONTS).map(LOWERCASE_MAP),
			apis  = [],
			
			parts = [], k = 0, kk = 0,
			
			load  = [],
			temp  = '',
			uri   = GoogleFonts.API_URI,
			subset = '&subset=' + GoogleFonts.SUBSETS.join(','),
			
			index = 0,
			
			include = false;
		
		//Find which ones are not in the safe font list
		for (; i<ii; i++) {
			include = true;
			
			// API name instead of object?
			if (typeof fonts[i] === 'string') {
				for (e=0; e<ee; e++) {
					if (exclude[e] == fonts[i]) {
						include = false;
						break;
					}
				}
				if (include) {
					load.push(fonts[i]);
				}
				
				continue;
			}
			
			for (e=0; e<ee; e++) {
				if (exclude[e] == fonts[i].apis || exclude[e] == (fonts[i].family || fonts[i].title).replace(/["']/, '').replace(/\s+/g, '+')) {
					include = false;
					break;
				}
			}
			
			if (!include) {
				continue;
			}
			
			//Split "Arial, Verdana" into two items
			if (fonts[i].family || (fonts[i].title && !fonts[i].apis)) {
				parts = (fonts[i].family || fonts[i].title || '').replace(/\s*,\s*/g, ',').replace(/["']/, '').split(',');
			} else {
				parts = fonts[i].apis.replace(/:[^|]+/g, '').replace(/\+/g, ' ').split('|');
			}
			
			for (k=0,kk=parts.length; k<kk; k++) {
				//If any of the part is not in the safe list, then load from Google Fonts
				if (parts[k] && safe.indexOf(parts[k].toLowerCase()) == -1) {
					
					//Convert into format which is valid for uri
					if (fonts[i].apis) {
						temp = fonts[i].apis;
					} else {
						temp = (fonts[i].family || fonts[i].title || '').replace(/\s*,\s*/g, ',').replace(/["']/, '').replace(/\s+/g, '+').replace(/,/g, '|');
					}
					
					if (temp) {
						index = temp.indexOf('&subset=');
						if (index !== -1) {
							temp = temp.substr(0, index);
						}
						
						load.push(temp);
					}
					
					break;
				}
			}
		}
		
		// Font list
		load = Y.Array.unique(load).sort();
		
		if (options && options.split) {
			var split = [];
			
			for (i=0, ii=Math.ceil(load.length/10); i<ii; i++) {
				split.push(uri + load.slice(i*10, i*10+10).join('|') + subset);
			}
			
			return split;
		} else {
			return (load.length ? uri + load.join('|') + subset : '');
		}
	}
	
	GoogleFonts.addFontsToHTML = function (html, fonts) {
		var uri = GoogleFonts.getURI(fonts),
			replaced = false,
			regex = new RegExp('(<link[^>]+href=)["\'][^"\']*?' + Y.Escape.regex(GoogleFonts.API_URI) + '[^"\']*?["\']', 'i'),
			html = html.replace(regex, function (all, pre) {
				replaced = true;
				return pre + '"' + uri + '"';
			});
		
		if (!replaced) {
			//Insert
			html = html.replace(/<\/\s*head/i, '<link rel="stylesheet" href="' + uri + '" /></head');
		}
		
		return html;
	};
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['base']});YUI().add("supra.iframe-stylesheet-parser", function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Convert arrays to object, because object lookup is much faster
	var toObject = function (arr) { var o={},i=0,ii=arr.length; for(;i<ii;i++) o[arr[i]]=true; return o; };
	
	//Tag groups
	var tmp = null;
	var GROUPS = [
		{
			'id': 'text',
			'tags': (tmp = ['H1', 'H2', 'H3', 'H4', 'H5', 'P', 'B', 'EM', 'U', 'S', 'A']),
			'tagsObject': toObject(tmp)
		},
		{
			'id': 'list',
			'tags': (tmp = ['UL', 'OL', 'LI']),
			'tagsObject': toObject(tmp)
		},
		{
			'id': 'table',
			'tags': (tmp = ['TABLE', 'TR', 'TD', 'TH']),
			'tagsObject': toObject(tmp)
		},
		{
			'id': 'image',
			'tags': (tmp = ['IMG']),
			'tagsObject': toObject(tmp)
		}
	];
	
	
	/*
	 * Iframe stylesheet parser, extracts CSS definitions
	 */
	function StylesheetParser (config) {
		StylesheetParser.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	StylesheetParser.NAME = "StylesheetParser";
	
	StylesheetParser.ATTRS = {
		"selectorPrefix": {
			//CSS selector prefix which should be extracted
			"value": "#su-style-dropdown"
		},
		
		"iframe": {
			//Iframe object, required if win and doc attributes are ommited
			"value": null
		},
		"win": {
			//Window object, required if iframe attribute is ommited
			"value": null
		},
		"doc": {
			//Document object, required if iframe attribute is ommited
			"value": null
		}
	};
	
	Y.extend(StylesheetParser, Y.Base, {
		
		/**
		 * All found selectors
		 */
		selectors: null,
		
		
		
		/**
		 * Constructor
		 * @constructor
		 */
		initializer: function () {
			var iframe = this.get("iframe");
			if (iframe) {
				iframe.on("ready", this.reset, this)
			}
			this.reset();
		},
		
		/**
		 * Destructor, clean up
		 */
		destructor: function () {
			
		},
		
		/**
		 * Reset all info
		 */
		reset: function () {
			var iframe = this.get("iframe"),
				win = null,
				doc = null;
			
			if (iframe) {
				win = iframe.getDOMNode().contentWindow;
				doc = win.document;
				
				this.set("win", win);
				this.set("doc", doc);
			}
			
			this.selectors = null;
		},
		
		
		/* ------------------------------- API ----------------------------- */
		
		/**
		 * Returns all selectors
		 * 
		 * @return All selectors
		 * @type {Array}
		 */
		getSelectors: function () {
			return this.selectors || this.collectStyleSelectors();
		},
		
		/**
		 * Returns all selectors grouped by tag names
		 * 
		 * @return All selectors grouped by tag names
		 * @type {Object}
		 */
		getSelectorsGrouped: function () {
			var container = this.htmleditor.get('srcNode'),
				result = {},
				selectors = this.getSelectors(),
				selector = null,
				i = 0,
				imax = selectors.length;
			
			for(; i < imax; i++) {
				selector = selectors[i];
				if (!result[selector.tag]) result[selector.tag] = [];
				result[selector.tag].push(selector);
			}
			
			return result;
		},
		
		/**
		 * Returns all selectors by tag
		 * 
		 * @param {String} tag Tag name
		 * @param {Boolean} include_global If selectors doesn't have specific tag then include it also
		 * @return Selectors matching tag
		 * @type {Array}
		 */
		getSelectorsByTag: function (tag, include_global) {
			var result = [],
				selectors = this.getSelectors(),
				i = 0,
				imax = selectors.length,
				selector;
				
			for(; i < imax; i++) {
				selector = selectors[i];
				if (selector.tag == tag || (!selector.tag && include_global)) {
					result.push(selector);
				}
			}
			
			return result;
		},
		
		/**
		 * Returns all selectors which match given node or if node is ancestor of that element
		 * 
		 * @param {Object} container Container element
		 * @return List of all matching selectors grouped by tag name
		 * @type {Object}
		 */
		getSelectorsByNodeMatch: function (container) {
			var result = {},
				selectors = this.getSelectors(),
				selector = null,
				i = 0,
				imax = selectors.length;
				
			for(; i < imax; i++) {
				selector = selectors[i];
				if (!selector.path || container.test(selector.path) || container.test(selector.path + ' *')) {
					if (!result[selector.tag]) result[selector.tag] = [];
					result[selector.tag].push(selector);
				}
			}
			
			return result;
		},
		
		
		/* ------------------------------- PARSER ----------------------------- */
		
		
		/**
		 * Traverse stylesheets and extract definitions matching selectorPrefix
		 * 
		 * @return List of selectors
		 * @type {Object}
		 */
		collectStyleSelectors: function () {
			var result = [],
				rules,
				doc = new Y.Node(this.get('doc')),
				links = doc.all('link[rel="stylesheet"], style[type="text/css"]'),
				link = null,
				prefix = this.get("selectorPrefix");
			
			if (links) {
				for(var i=0,ii=links.size(); i<ii; i++) {
					link = links.item(i).getDOMNode();
					if (link.sheet) {
						try {
							rules = link.sheet.cssRules;
						} catch (err) {
							rules = null; //"Insecure operation" error
						}
						if(rules) {
							for(var k=0,kk=rules.length; k<kk; k++) {
								if (rules[k].selectorText && rules[k].cssText.indexOf(prefix) != -1) {
									result.push(rules[k].cssText);
								}
							}
						}
					}
				}
			}
			
			var style = doc.all('style[type="text/css"]'),
				regex = new RegExp(Y.Escape.regex(prefix) + " [^}]*}", "g"),
				css,
				match;
			
			if (style) {
				for(var i=0,ii=style.size(); i<ii; i++) {
					css = style.item(i).get('innerHTML');
					match = css.match(regex);
					
					if (match) {
						result = result.concat(match);
					}
				}
			}
			
			result = this.parseStyleSelectors(result);
			this.selectors = result;
			return result;
		},
		
		/**
		 * Parse collected style selectors and extract info
		 * 
		 * @param {Array} result List of selectors
		 * @return List of selector information
		 * @type {Object}
		 */
		parseStyleSelectors: function (result) {
			var i = 0,
				imax = result.length,
				prefix = this.get("selectorPrefix"),
				selector,
				match,
				list = [],
				tmp = null,
				//               PREFIX    TAG      .   CLASSNAME      [attrs][attr]       { styles }
				regex_normal = /(.+\s)?([a-z0-9]+)?\.([a-z0-9\-\_]+)\s?((\[[^\]]+\])+)?\s?\{([^\}]*)\}/i,
				//               PREFIX    TAG        [attr][attr]   .   CLASSNAME         { styles }
				regex_reverse = /(.+\s)?([a-z0-9]+)?((\[[^\]]+\])+)?\.([a-z0-9\-\_]+)\s?\{([^\}]*)\}/i;
			
			for(; i < imax; i++) {
				selector = result[i].replace(prefix + ' ', '');
				
				//Format is .selector tag.classname[attribute]{css}
				//match is: 0 - all selector, 1 - prefix, 2 - tag, 3 - classname, 4 - attributes, 5 - styles
				match = selector.match(regex_normal);
				
				//Need to support also: .selector tag[attribute].classname{css}
				if (match && !match[1] && !match[2] && !match[4] && !match[5]) {
					match = selector.match(regex_reverse);
					
					//Fix incorrect indexes
					tmp = match[4]; match[4] = match[5]; match[5] = tmp;
					tmp = match[3]; match[3] = match[4]; match[4] = tmp;
				}
				
				if (match) {
					tmp = match[2] ? match[2].toUpperCase() : '';
					list.push({
						'path': match[1] ? match[1].replace(/^\s+|\s+$/g, '') : null,
					    'tag': tmp,
					    'group': this.getGroupByTag(tmp),
					    'classname': match[3],
					    'attributes': this.parseSelectorAttributes(match),
					    'style': match[6]
					});
				}
			}
			
			return list;
		},
		
		/**
		 * Parse and return CSS selector attribute values
		 * 
		 * @param {Array} match Selector match
		 * @return Object with attribute names and values
		 * @type {Object}
		 */
		parseSelectorAttributes: function (match) {
			var attr = match[4],
				data,
				ret = {},
				trim = /^("|')|("|')$/g;
			
			if (attr) {
				//Convert [...][...] into ...,...
				attr = attr.replace(/\]\s*\[/g, ',').replace('[', '').replace(']', '');
				attr = attr.split(',');
				for(var i=0,ii=attr.length; i<ii; i++) {
					data = attr[i].split('=');
					ret[data[0]] = data.length > 1 ? data[1].replace(trim, '') : '';
				}
			}
			
			if (!ret.title) {
				ret.title = (match[2] ? match[2] : '') + match[3];
			}
			
			return ret;
		},
		
		/**
		 * Returns group ID by tag
		 * 
		 * @param {String} tag Tag name
		 * @return Group ID
		 * @type {String}
		 */
		getGroupByTag: function (tag) {
			var groups = GROUPS,
				i = 0,
				ii = groups.length;
			
			for(; i<ii; i++) {
				if (groups[i].tagsObject[tag]) return groups[i].id;
			}
			
			return null;
		}
		
	});
	
	Supra.IframeStylesheetParser = StylesheetParser;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {"requires": ["base"]});YUI().add('supra.htmleditor-base', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function HTMLEditor () {
		HTMLEditor.superclass.constructor.apply(this, arguments);
	}
	
	HTMLEditor.MODE_STRING	= 1;
	HTMLEditor.MODE_TEXT	= 4;
	HTMLEditor.MODE_SIMPLE	= 2;
	HTMLEditor.MODE_RICH	= 3;
	
	HTMLEditor.TYPE_STANDALONE = 1;
	HTMLEditor.TYPE_INLINE = 2;
	
	HTMLEditor.NAME = 'editor';
	HTMLEditor.CLASS_NAME = Y.ClassNameManager.getClassName(HTMLEditor.NAME);
	HTMLEditor.ATTRS = {
		'doc': {
			value: null
		},
		'win': {
			value: null
		},
		'srcNode': {
			value: null
		},
		'iframeNode': {
			value: null
		},
		'disabled': {
			value: false,
			setter: '_setDisabled'
		},
		'nativeSpellCheck': {
			value: true,
			setter: '_setNativeSpellCheck'
		},
		'toolbar': {
			value: null
		},
		/**
		 * Max content length in STRING or TEXT modes
		 */
		'maxLength': {
			value: 0
		},
		/**
		 * HTMLEditor mode: Supra.HTMLEditor.MODE_SIMPLE or Supra.HTMLEditor.MODE_RICH
		 */
		'mode': {
			value: HTMLEditor.MODE_RICH
		},
		/**
		 * Plugin configuration
		 */
		'plugins': {
			value: {}
		},
		/**
		 * HTMLEditor is in standalone mode
		 */
		'standalone': {
			value: false
		},
		/**
		 * Parent widget, usually input
		 */
		'parent': {
			value: null
		},
		/**
		 * Root parent input, could be form or block
		 */
		'root': {
			value: null
		},
		
		/**
		 * Stylesheet parser,
		 * Supra.IframeStylesheetParser instance
		 */
		'stylesheetParser': {
			value: null
		},
		
		/**
		 * Delayed initialization
		 * Used for performance reasons
		 */
		'delayedInitialization': {
			value: false
		}
	};
	
	Y.extend(HTMLEditor, Y.Base, {
		
		events: [],
		
		
		syncUI: function () {
			
		},
		
		bindUI: function () {
			var doc = new Y.Node(this.get('doc'));
			
			this.events.push(
				this.get('srcNode').on('keyup', this._handleKeyUp, this)
			);
			this.events.push(
				this.get('srcNode').on('keydown', this._handleKeyDown, this)
			);
			this.events.push(
				this.get('srcNode').on('keypress', this._handleKeyPress, this)
			);
			this.events.push(
				this.get('srcNode').on('mousedown', this._handleNodeMouseDown, this)
			);
			this.events.push(
				doc.on('mouseup', this._handleNodeChange, this)
			);
			
			this.events.push(
				doc.on('click', this._handleNodeChange, this)
			);
			
			var toolbar = this.get('toolbar');
			if (toolbar) {
				this.events.push(
					toolbar.on('command', function (event) {
						this.exec(event.command);
					}, this)
				);
			}
		},
		
		renderUI: function () {
			var srcNode = this.get('srcNode');
			
			this.set('disabled', this.get('disabled'));
			this.set('nativeSpellCheck', this.get('nativeSpellCheck'));
		},
		
		render: function () {
			this.events = [];
			this.data = {};
			this.commands = {};
			this.selection = null;
			
			// For performance reasons (if there is we must delay initialization
			if (this.get('delayedInitialization')) {
				Y.later(16, this, this.renderDelayed);
			} else {
				this.renderDelayed();
			}
		},
		
		/**
		 * Initialize everything
		 */
		renderDelayed: function () {
			if (!this.get("stylesheetParser")) {
				var root = this.get("root");
				if (root && root.getStylesheetParser) {
					//Root is block, we can take borrow from it
					this.set("stylesheetParser", root.getStylesheetParser());
				} else {
					//Create new parser
					this.set("stylesheetParser", new Supra.IframeStylesheetParser({
						"win": this.get("win"),
						"doc": this.get("doc")
					}));
				}
			}
			
			this.renderUI();
			this.bindUI();
			this.syncUI();
			
			this.initPlugins();
			
			this._changed = Supra.throttle(this._changed, 1000, this);
			
			this.setHTML(this.get('srcNode').get('innerHTML'));
		},
		
		/**
		 * Destroy editor
		 */
		destructor: function () {
			//Remove event listeners
			var events = this.events;
			for(var i=0,ii=events.length; i<ii; i++) events[i].detach();
			this.events = [];
			this.destroyPlugins();
		},
		
		/**
		 * Update selection, trigger necessary events
		 */
		refresh: function (force, delay) {
			if (delay) {
				//Delay is used after making modifications to the DOM
				Y.later(60, this, function () {
					this._handleNodeChange({}, force);
				});
			} else {
				return this._handleNodeChange({}, force) == 2;
			}
		},
		
		/**
		 * Set content HTML
		 * 
		 * @param {String} html
		 */
		setHTML: function (html) {
			//Make sure we have a string, not null or undefined
			var html = String(html || '');
			
			//editor:setHTML event
			var event = {html: this.uncleanHTML(html)};
			this.fire('setHTML', {}, event);
			
			//untagHTML
			html = event.html;
			
			var plugins = this.getAllPlugins(),
				data = this.getAllData(),
				id = null;
			
			for(id in plugins) {
				if (plugins[id].untagHTML) {
					html = plugins[id].untagHTML(html, data);
				}
			}
			
			//Replace with <p></p> if empty
			if (!Y.UA.ie && this.get('mode') == Supra.HTMLEditor.MODE_RICH) {
				if (!html) html = '<p></p>';
			}
			
			//Set HTML
			this.get('srcNode').set('innerHTML', html);
			this.restoreEditableStates();
			
			//Move cursor to the beginning of the content
			var srcNode = Y.Node.getDOMNode(this.get('srcNode')),
				selectionNode = srcNode.firstChild || srcNode;
			
			this.setSelection({'start': selectionNode, 'start_offset': 0, 'end': selectionNode, 'end_offset': 0});
			
			//Fire "nodeChange" event
			this.selection = null;
			this.refresh();
			
			//Fire event
			this.fire('afterSetHTML');
		},
		
		/**
		 * Returns cleaned up HTML
		 * 
		 * @return HTML
		 * @type {String}
		 */
		getHTML: function () {
			var html = this.get('srcNode').get('innerHTML');
				html = this.cleanHTML(html);
			
			var event = {'html': html};
			this.fire('getHTML', {}, event);
			
			return event.html || '';
		},
		
		/**
		 * Returns HTML with nodes converted into macros
		 * 
		 * @return HTML
		 * @type {String}
		 */
		getProcessedHTML: function () {
			var html = this.getHTML(),
				plugins = this.getAllPlugins();
			
			for(var id in plugins) {
				if (plugins[id].tagHTML) {
					html = plugins[id].tagHTML(html);
				}
			}
			
			return html;
		},
		
		/**
		 * Focus editor
		 */
		focus: function () {
			var srcNode = this.get('srcNode').getDOMNode(),
				node = srcNode.lastChild;
			
			// Find last text node
			while (node && node.nodeType == 1) {
				node = node.lastChild;
			}
			
			// Focus
			if (Y.UA.webkit) {
				this.get('win').focus();
				this.get('srcNode').focus();
			} else {
				this.get('srcNode').focus();
			}
			
			// Place cursor at the end
			Y.later(16, this, function () {
				if (node) {
					this.setSelection({
						start: node,
						start_offset: node.length,
						end: node,
						end_offset: node.length
					});
				} else {
					this.selectNode(srcNode);
				}
			});
		},
		
		/**
		 * Enable/disable editor
		 * 
		 * @param {Boolean} value
		 * @private
		 */
		_setDisabled: function (value) {
			if (value) {
				this.get('srcNode').setAttribute('contentEditable', false);
				this.editingAllowed = false;
				
				this.fire('editingAllowedChange', {'allowed': false});
				
				this.selection = null;
				this.selectedElement = null;
				this.path = null;
				
				this.fire('disable');
			} else {
				this.get('srcNode').setAttribute('contentEditable', true);
				
				// Focus
				this.focus();
				
				//Prevent object resizing
				this.disableObjectResizing();
				
				//Update selection, etc.
				this.refresh(true);
				
				this.fire('enable');
			}
			
			return !!value;
		},
		
		/**
		 * Enable/disable spell-checking in supported browsers
		 * 
		 * @param {Boolean} value
		 */
		_setNativeSpellCheck: function (value) {
			value = !!value;
			this.get('doc').body.spellcheck = value;
			if (value) {
				this.get('doc').body.removeAttribute('spellcheck');
			} else {
				this.get('doc').body.setAttribute('spellcheck', 'false');
			}
			
			return value;
		},
		
		/**
		 * Prevent key press if content is not editable
		 * 
		 * @param {Object} event
		 */
		_handleKeyPress: function (event) {
			var charCode = event.charCode || event.keyCode,
				navKey = this.navigationCharCode(charCode);
			
			/* 
			 * Cancel key press if node is not editable and key wasn't "navigation" key.
			 * If original event charCode is not empty, then this key definitely changes
			 * text and should be canceled
			 */
			if (!event.stopped && !this.editingAllowed && (event._event.charCode || !navKey)) {
				event.preventDefault();
				return;
			} else if (!navKey && !event.ctrlKey) {
				this._changed();
			}
		},
		
		/**
		 * Trigger node change when key is released
		 * 
		 * @param {Object} event
		 */
		_handleKeyUp: function (event) {
			var charCode = event.charCode,
				navKey = this.navigationCharCode(charCode);
			
			if (this.editingAllowed || navKey) {
				if (this.fire('keyUp', event, event) !== false) {
					Supra.immediate(this, function () {
						this._handleNodeChange(event);
					});
					
					if (!navKey && !event.ctrlKey) {
						this._changed();
					}
				}
			}
		},
		
		/**
		 * Trigger keydown event on editor
		 * 
		 * @param {Object} event
		 */
		_handleKeyDown: function (event) {
			var charCode = event.charCode,
				navKey = this.navigationCharCode(charCode);
			
			if (this.editingAllowed || navKey) {
				if (this.fire('keyDown', event, event) === false) {
					event.preventDefault();
				}
			}
		},
		
		/**
		 * Handle mouse down
		 * If user clicks on uneditable element, prevent text selection
		 * 
		 * @param {Object} event
		 */
		_handleNodeMouseDown: function (event) {
			if (this.get('disabled')) return;
			
			var target = Y.Node.getDOMNode(event.target);
			if (!this.isEditable(target)) {
				event.preventDefault();
				return false;
			}
		},
		
		/**
		 * If cursor position changed fires nodeChange event
		 * If cursor entered/left un-editable content fires editingAllowedChange
		 * 
		 * @param {Object} event
		 * @return Returns 2 if selection changed and 1 if selection didn't changed. True/false is not used to prevent event stopping
		 * @type {Number}
		 */
		_handleNodeChange: function (event, force) {
			if (this.get('disabled') && !force) return 1;
			
			var oldSel = this.selection,
				newSel = this.getSelection(),
				fireSelectionEvent = false,
				fireNodeEvent = false,
				node = null;
			
			//On mouse click / mouse down check if user clicked on image
			if (event && event.type && (event.type == 'mouseup' || event.type == 'click')) {
				if (event.target.test('img')) {
					node = event.target;
				} else {
					node = event.target.closest('svg');
				}
				if (node) {
					newSel = this._handleSelectableClick(node);
				}
			}
			
			if (oldSel) {
				if (oldSel.start !== newSel.start || oldSel.end !== newSel.end) {
					fireSelectionEvent = true;
					fireNodeEvent = true;
				} else if (oldSel.start_offset !== newSel.start_offset || oldSel.end_offset !== newSel.end_offset) {
					fireSelectionEvent = true;
				} else {
					//Nothing at all changed, skip
					return 1; 
				}
			} else {
				fireSelectionEvent = true;
				fireNodeEvent = true;
			}
			
			this.resetSelectionCache(newSel);
			
			if (fireSelectionEvent) {
				event.selection = newSel;
				this.fire('selectionChange', event);
				
				if (fireNodeEvent) {
					this.fire('nodeChange', event);
				}
				
				var allowed = true;
				if (!this.isSelectionEditable(newSel)) {
					allowed = false;
				}
				
				if (this.editingAllowed != allowed) {
					this.editingAllowed = allowed;
					this.fire('editingAllowedChange', {'allowed': allowed});
				}
				
				return 2;
			}
			
			
			return 1;
		},
		
		/**
		 * Handle click on image
		 * @private
		 */
		_handleSelectableClick: function (target) {
			var node = target.getDOMNode(),
				selection = {
					'start': node,
					'start_offset': 0,
					'end': node,
					'end_offset': 0,
					'collapsed': true
				};
			
			return selection;
		},
		
		/**
		 * Update 'changed' state if needed
		 */
		_changed: function () {
			this.fire('change');
			Supra.session.triggerActivity();
		}
		
	});
	
	//Plugins
	HTMLEditor.PLUGINS = {};
	
	
	Supra.HTMLEditor = HTMLEditor;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version);
YUI().add('supra.htmleditor-parser', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/* Tag white list, all other tags will be removed. <font> tag is added if "fonts" plugin is enabled */
	Supra.HTMLEditor.WHITE_LIST_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'p', 'b', 'em', 'small', 'sub', 'sup', 'a', 'img', 'br', 'strong', 's', 'strike', 'u', 'blockquote', 'q', 'big', 'table', 'tbody', 'tr', 'td', 'thead', 'th', 'ul', 'ol', 'li', 'div', 'dl', 'dt', 'dd', 'col', 'colgroup', 'caption', 'object', 'param', 'embed', 'article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section', '_span', 'svg', 'pre', 'code'];
	
	/* List of block elements */
	Supra.HTMLEditor.ELEMENTS_BLOCK = {'h1': 'h1', 'h2': 'h2', 'h3': 'h3', 'h4': 'h4', 'h5': 'h5', 'h6': 'h6', 'p': 'p', 'blockquote': 'blockquote', 'q': 'q', 'table': 'table', 'tbody': 'tbody', 'tr': 'tr', 'td': 'td', 'thead': 'thead', 'th': 'th', 'ul': 'ul', 'ol': 'ol', 'li': 'li', 'div': 'div', 'dl': 'dl', 'dt': 'dt', 'dd': 'dd', 'col': 'col', 'colgroup': 'colgroup', 'caption': 'caption', 'object': 'object', 'param': 'param', 'embed': 'embed', 'article': 'article', 'aside': 'aside', 'details': 'details', 'figcaption': 'figcaption', 'figure': 'figure', 'footer': 'footer', 'header': 'header', 'hgroup': 'hgroup', 'nav': 'nav', 'section': 'section', 'pre': 'pre', 'code': 'code'};
	Supra.HTMLEditor.ELEMENTS_BLOCK_ARR = Y.Lang.toArray(Supra.HTMLEditor.ELEMENTS_BLOCK);
	
	/* List of inline elements */
	Supra.HTMLEditor.ELEMENTS_INLINE = {'b': 'b', 'i': 'i', 'span': 'span', 'em': 'em', 'sub': 'sub', 'sup': 'sup', 'small': 'small', 'strong': 'strong', 's': 's', 'strike': 'strike', 'a': 'a', 'u': 'u', 'img': 'img', 'br': 'br', 'q': 'q', 'big': 'big', 'mark': 'mark', 'rp': 'rp', 'rt': 'rt', 'ruby': 'ruby', 'summary': 'summary', 'time': 'time', 'svg': 'svg', 'g': 'g', 'path': 'path'};
	Supra.HTMLEditor.ELEMENTS_INLINE_ARR = Y.Lang.toArray(Supra.HTMLEditor.ELEMENTS_INLINE);
	
	/* List of tags which doesn't need to be closed */
	Supra.HTMLEditor.NOT_CLOSED_TAGS = {'img': 'img', 'br': 'br', 'param': 'param', 'col': 'col', 'embed': 'embed', 'hr': 'hr'};
	
	/* Elements which should be checked for inline style */
	Supra.HTMLEditor.STYLED_INLINE   = {'span': 'span', 'b': 'b', 'i': 'i', 'em': 'em', 'sub': 'sub', 'sup': 'sup', 'small': 'small', 'strong':'strong', 's':'s', 'strike': 'strike', 'a': 'a', 'u': 'u', 'q': 'q', 'big': 'big'};
	
	/* Find all tags */
	var REGEXP_FIND_TAGS = /<\/?([a-z][a-z0-9\:]*)\b[^>]*>/gi;
	
	var REGEXP_FIND_CLASS = /class=(([a-z0-9\_\-]+)|"([^"]+)")/i;
	
	/* List of style properties which should be converted into tags */
	var STYLE_TO_TAG = [
		//[TAG, REGEX, KEEP STYLE ATTRIBUTE]
		['b', /font-weight:\s?bold/i],
		['em', /font-style:\s?italic/i],
		['u', /text-decoration:[^"']*underline/i],
		['s', /text-decoration:[^"']*line-through/i],
		['font', /background-color:[^;"']+/i, true] // we keep style, because we want to change only tag
	];
	
	/* List of tagNames and matching regular expressions to find correct tag name */
	var STYLE_TO_TAG_NAME = [
		['B', /font-weight:\s?bold/i],
		['EM', /font-style:\s?italic/i],
		['U', /text-decoration:[^"']*underline/i],
		['S', /text-decoration:[^"']*line-through/i]
	];
	
	/* */
	var REGEX_FIND_I = /<(\/?)i((\s[^>]+)?)>/ig,
		REGEX_FIND_B = /<(\/?)b((\s[^>]+)?)>/ig,
		REGEX_FIND_S = /<(\/?)s((\s[^>]+)?)>/ig,
		REGEX_FIND_STRONG = /<(\/?)strong([^>]*)>/g,
		
		REGEX_FIND_A_START = /(<a [^>]+>)\s/g,
		REGEX_FIND_A_END   = /\s(<\/a[^>]*>)/g,
		REGEX_A_BR         = /<br\s*\/?>\s*(<\/a[^>]*>)/gi,
		
		REGEX_SVG          = /<svg [^>]+>/g,
		REGEX_ATTR         = / ([a-zA-Z0-9\-\:]+)=("[^"]+")/g,
		
		REGEX_TAG_START    = /<(\/?)([a-z]+)/,
		REGEX_STRONG_START = /<(\/?)strong/ig,
		REGEX_STRIKE_START = /<(\/?)strike/ig,
		REGEX_NODE_ID_ATTR = /\s+id="yui_[^"]*"/gi,
		REGEX_NODE_UNEDITABLE = /su\-(un)?editable/gi,
		
		REGEX_FIND_STYLE  = /style=("[^"]*"|'[^']*')/,
		
		REGEX_EMPTY_UL_OL = /<(ul|ol)>[\s\r\n]*?<\/(ul|ol)>/gi,
		REGEX_ATTR_STYLE  = /\s+style=("[^"]*"|'[^']*')/gi,
		REGEX_STYLE_BG    = /(fill|background-color):[^;]+/,
		REGEX_EMPTY_CLASS = /class="\s*"/g,
		REGEX_YUI_CLASS   = /(yui3\-table\-selected|yui3\-cell\-selected)/g,
		
		REGEX_LT           = /<(\/?)_/g,
		
		REGEX_TAG_ATTRIBUTES = /([a-z0-9\-]+)=("[^"]*"|'[^']*'|[^\s]*)/ig,
		REGEX_STRIP_QUOTES   = /(^'|^"|"$|'$)/g,
		
		TAG_TO_SPAN = [
			['b',  'font-weight: bold', /<b(\s[^>]*)?(\sclass="[^"]+")?(\s[^>]*)?>/ig, /<\/b(\s[^>]*)?>/ig],
			['em', 'font-style: italic', /<em(\s[^>]*)?(\sclass="[^"]+")?(\s[^>]*)?>/ig, /<\/em(\s[^>]*)?>/ig],
			['u',  'text-decoration: underline', /<u(\s[^>]*)?(\sclass="[^"]+")?(\s[^>]*)?>/ig, /<\/u(\s[^>]*)?>/ig],
			['s',  'text-decoration: line-through', /<s(\s[^>]*)?(\sclass="[^"]+")?(\s[^>]*)?>/ig, /<\/s(\s[^>]*)?>/ig]
		];
	
	Y.mix(Supra.HTMLEditor.prototype, {
		/**
		 * Converts html into browser compatible format
		 * @param {Object} html
		 */
		uncleanHTML: function (html) {
			//Convert <i> into <em>
			html = html.replace(REGEX_FIND_I, '<$1em$2>');
			
			if (Y.UA.ie) {
				//IE uses STRONG, EM, U, STRIKE instead of SPAN
				html = html.replace(REGEX_FIND_I, '<$1strong$2>');
				html = html.replace(REGEX_FIND_S, '<$1strike$2>');
			} else {
				//Convert <strong> into <b>
				html = html.replace(REGEX_FIND_STRONG, '<$1b$2>');
				
				//Convert B, EM, U, S into SPAN
				var tagToSpan = TAG_TO_SPAN,
					tag,
					expression;
				
				for(var i=0,ii=tagToSpan.length; i<ii; i++) {
					tag = tagToSpan[i][0];
					
					html = html.replace(tagToSpan[i][2], '<span style="' + tagToSpan[i][1] + ';" $2>');
					html = html.replace(tagToSpan[i][3], '</span>');
				}
			}
			
			var event = {'html': html};
			this.fire('uncleanHTML', {}, event);
			
			return event.html;
		},
		
		/**
		 * Converts browser generated markup into valid html
		 * Handles cases like:
		 * 		Input:  <a style="font-weight: bold;">text</a>
		 * 		Output: <a><b>text</b></a>
		 * 
		 * 		Input:  <span style="font-weight: bold; font-style: italic;">text</span>
		 * 		Output: <b><i>text</i></b>
		 *
		 * 		Input:  <span style="text-decoration: underline line-through;">text</span>
		 * 		Output: <u><s>text</s></u>
		 *  
		 * @param {Object} html
		 */
		cleanHTML: function (html) {
			var mode = this.get('mode');
			
			if (mode == Supra.HTMLEditor.MODE_STRING || mode == Supra.HTMLEditor.MODE_TEXT) {
				//In string mode there is nothing to clean up
			} else {
				//IE creates STRONG, EM, U, STRIKE instead of SPAN
				if (Y.UA.ie) {
					html = html.replace(REGEX_STRONG_START, '<$1b');
					html = html.replace(REGEX_STRIKE_START, '<$1s');
				}
				
				//Remove YUI ids from nodes
				html = html.replace(REGEX_NODE_ID_ATTR, '');
				
				//Remove un-editable classnames
				html = html.replace(REGEX_NODE_UNEDITABLE, '');
				
				//Replace styles with tags
				var regexTag = REGEX_TAG_START,
					regexStyle = REGEX_FIND_STYLE,
					tagOpenIndex = html.indexOf('<'),
					tagCloseIndex = -1,
					tag = null,
					tagName = '',
					tagClosing = false,
					tagStack = [];
				
				while(tagOpenIndex != -1) {
					tagCloseIndex = html.indexOf('>', tagOpenIndex);
					if (tagCloseIndex != -1) {
						tag = this.cleanTag(html.substring(tagOpenIndex + 1, tagCloseIndex));
						if (tag) {
							if (typeof tag === 'string') {
								//Closing tag
								if (tagStack.length && tagStack[0][0] == tag) {
									//Get item from stack
									tag = tagStack.shift();
									
									if (tag[3]) {
										//Remove existing tag
										html = html.substr(0, tagOpenIndex) + tag[2] + html.substr(tagCloseIndex + 1);
										
										//Update index
										tagOpenIndex += tag[2].length - 1;
									} else {
										//Keep existing tag
										html = html.substr(0, tagOpenIndex) + tag[2] + html.substr(tagOpenIndex);
										
										//Update index
										tagOpenIndex = tagCloseIndex + tag[2].length - 1;
									}
								}
							} else {
								//Add item to stack
								tagStack.unshift(tag);
								
								if (tag[3]) {
									//Remove existing tag
									html = html.substr(0, tagOpenIndex) + tag[1] + html.substr(tagCloseIndex + 1);
									
									//Update index
									tagOpenIndex += tag[1].length - 1;
								} else {
									//Keep existing tag
									var tmp = html.substr(tagOpenIndex, tagCloseIndex + 1 - tagOpenIndex).replace(regexStyle, '');
									
									html =  html.substr(0, tagOpenIndex) +
											tmp +
											tag[1] +
											html.substr(tagCloseIndex + 1);
									
									//Update index
									tagOpenIndex += tmp.length + tag[1].length - 1;
								}
							}
						}
					}
					
					tagOpenIndex = html.indexOf('<', tagOpenIndex + 1);
				}
				
				//Convert <strong> into <b>
				html = html.replace(REGEX_FIND_STRONG, '<$1b$2>');
				
				//Convert <i> into <em>
				html = html.replace(REGEX_FIND_I, '<$1em$2>');
				
				//Moves whitespaces outside <A> tags
				html = html.replace(REGEX_FIND_A_START, ' $1');
				html = html.replace(REGEX_FIND_A_END, '$1 ');
				
				//Moves <BR> outside <A> tags
				html = html.replace(REGEX_A_BR, ' $1<br />');
				
				//Remove tags, which are not white-listed (SPAN is also removed)
				var white_list_tags = Supra.HTMLEditor.WHITE_LIST_TAGS;
				if (this.getPlugin("fonts")) {
					white_list_tags.push("font")
				}
				html = this.stripTags(html, white_list_tags);
				
				//Remove unneeded attributes from <SVG>
				var regex_attr = REGEX_ATTR;
				html = html.replace(REGEX_SVG, function (str) {
					return str.replace(regex_attr, function (m, property) {
						return property === 'id' ? m : '';
					});
				});
				
				//Convert <_ into <
				html = html.replace(REGEX_LT, '<$1');
				
				//Remove empty UL and OL tags
				html = html.replace(REGEX_EMPTY_UL_OL, '');
				
				//Remove style attribute, except background-color and fill
				var regex_style_bg = REGEX_STYLE_BG;
				html = html.replace(REGEX_ATTR_STYLE, function (all, styles) {
					styles = styles.replace(/(^['"]|['"]$)/g, ''); // trim
					styles = styles.match(regex_style_bg);
					if (styles && styles.length) {
						return ' style="' + styles[0] + '"';
					}
					return '';
				});
				
				//Remove empty class attributes
				html = html.replace(REGEX_EMPTY_CLASS, '');
				
				//Remove YUI classnames
				html = html.replace(REGEX_YUI_CLASS, '');
			}
			
			//Fire event to allow plugins to clean up after themselves
			var event = {'html': html};
			this.fire('cleanHTML', {}, event);
			
			return event.html || '';
		},
		
		/**
		 * Convert <span> and other tag style="" attributes into tags
		 * 
		 * @return Tag name, opening and closing HTML
		 * @private 
		 */
		cleanTag: function (html) {
			var tagName = html.match(/^(\/?)([a-z]+)/i);
			if (!tagName) return null;
			
			var styleToTag = STYLE_TO_TAG,
				k = 0,
				kk = styleToTag.length,
				
				styleTags = Supra.HTMLEditor.STYLED_INLINE,
				tagsAdd = [],
				classAdd = '',
				styleAdd = '',
				tagClosing = false,
				match = null,
				remove = false;
			
			tagClosing = !!tagName[1];
			tagName = tagName[2].toLowerCase();
			
			if (!(tagName in styleTags)) return null;
			if (tagClosing) return tagName;
			
			if (tagName == 'span') {
				//Remove existing tag
				remove = true;
			}
			
			for(k=0; k<kk; k++) {
				match = html.match(styleToTag[k][1]);
				if (match) {
					tagsAdd[tagsAdd.length] = styleToTag[k][0];
					
					//If keep style
					if (styleToTag[k][2]) {
						styleAdd = styleAdd + (styleAdd ? ' ': '') + match[0] + ';';
					}
				}
			}
			
			classAdd = html.match(REGEXP_FIND_CLASS);
			classAdd = classAdd ? ' class="' + (classAdd[2] || classAdd[3]) + '"' : '';
			
			styleAdd = styleAdd ? ' style="' + styleAdd + '"' : '';
			
			return [
				tagName,
				tagsAdd.length ? '<' + tagsAdd.join(classAdd + styleAdd + '><') + classAdd + styleAdd + '>' : '',
				tagsAdd.length ? '</' + tagsAdd.reverse().join('></') + '>' : '',
				remove
			];
		},
		
		/**
		 * Beautify HTML
		 * 
		 * @param {String} html HTML
		 * @return Beutified HTML code
		 * @type {String}
		 */
		beautifyHTML: function (html) {
			var i = 0,
				len = html.length,
				chr = '',
				indent = 0,
				out = '',
				tags = [],
				tag_name = '',
				tag_inline = false,
				regex_tagname = /\/?([a-z]+)/i,
				inline = Supra.HTMLEditor.ELEMENTS_INLINE,
				not_closed = Supra.HTMLEditor.NOT_CLOSED_TAGS,
				regex_pre = /<pre(.|\r|\n)*?<\/pre[^>]*>/i,
				pre_tag = '',
				pre_tags = [];
			
			// Extract PRE tags to preserve spacing, line breaks, etc.
			while(pre_tag = html.match(regex_pre)) {
				html = html.replace(pre_tag[0], '%{PRE_' + pre_tags.length + '}')
				pre_tags.push(pre_tag[0]);
			}
			
			function insertNewLine () {
				var str = '';
				for(var i=0; i<indent; i++) str += '    ';
				out += '\n' + str;
			}
			
			for(; i<len; i++) {
				chr = html.charAt(i);
				if (chr == '<') {
					tag_name = html.substr(i+1).match(regex_tagname);
					tag_name = tag_name ? tag_name[1] : '';
					tag_inline = !!inline[tag_name] || !!not_closed[tag_name];
					tags.push(tag_inline);
					
					if (!tag_inline) {
						if (html.charAt(i+1) == '/') {
							indent--;	//Closing tag </a>
							insertNewLine();
						} else {
							insertNewLine();
							indent++;	//Opening tag <a>
						}
					}
					
					out+= chr;
				} else if (chr == '>') {
					out+= chr;
					tag_inline = tags.pop();
					if (!tag_inline) {
						insertNewLine();
					}
				} else {
					out+= chr;
				}
			}
			
			out = out.replace(/\r/g, '');
			out = out.replace(/[ \n\t]*(\n[ \t]*)/g, '$1');
			
			// Restore PRE tags
			for (i=0,len=pre_tags.length; i<len; i++) {
				out = out.replace('%{PRE_' + i + '}', pre_tags[i]);
			}
			
			return out;
		},
		
		/**
		 * Strip tags from HTML leaving only whiteList tags
		 * 
		 * @param {String} html HTML from which tags should be striped
		 * @param {Array} whiteList List of allowed tags. Array or comma separated list
		 * @return Striped html
		 * @type {String}
		 */
		stripTags: function (html, whiteList) {
			whiteList = ',' + (Supra.Y.Lang.isArray(whiteList) ? whiteList.join(',') : typeof whiteList == 'string' ? whiteList : '') + ',';
			whiteList = whiteList.toLowerCase();
			
			return html.replace(REGEXP_FIND_TAGS, function(match, tagName) {
				return whiteList.indexOf(',' + tagName.toLowerCase() + ',') != -1 ? match : '';
			});
		},
		
		/**
		 * Parse tag attributes HTML and return object with key, value pairs
		 * 
		 * @param {String} html HTML which should be parsed
		 * @return Object with key,value pairs of attributes
		 * @type {Object}
		 */
		parseTagAttributes: function (html) {
			var parts = {},
				regexStripQuotes = REGEX_STRIP_QUOTES;
			
			html.replace(REGEX_TAG_ATTRIBUTES, function (all, key, val) {
				parts[key] = decodeURIComponent(val.replace(regexStripQuotes, ''));
				return '';
			});
			return parts;
		},
		
		/**
		 * Returns array with correct tag names (B, EM, U or S) for SPAN element, for all other
		 * elements returns array with single value, which is actual tagName
		 * 
		 * @param {Object} node HTML element
		 * @return Array of tag names
		 * @type {Array}
		 */
		getNodeTagName: function (node) {
			var tagName = (node instanceof Y.Node ? node.get('tagName') : node.tagName);
			if (tagName != 'SPAN') return [tagName];
			
			//Convert style attribute into B, EM, U, S
			var style = node.getAttribute('style'),
				tagNames = [],
				styleToTag = STYLE_TO_TAG_NAME;
			
			for(var i=0,ii=styleToTag.length; i<ii; i++) {
				if (styleToTag[i][1].test(style)) {
					tagNames.push(styleToTag[i][0]);
				}
			}
			
			return (tagNames.length ? tagNames : ['SPAN']);
		},
		
		/**
		 * Returns content character count
		 * 
		 * @returns {Number} Character count
		 */
		getContentCharacterCount: function (node) {
			var node = node || this.get('srcNode'),
				text = '',
				brs  = 0;
			
			if (!(node instanceof Y.Node)) node = Y.Node(node);
			 
			 brs = node.all('br').size();
			 text = node.get('text').replace(/[\r\n]/g, '');
			 
			 // Each BR is one character
			 return text.length + brs;
		},
	});
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-selection', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		
		/**
		 * Current selection
		 * @type {Object}
		 */
		selection: null,
		
		selectedElement: null,
		
		/**
		 * Path to currently selected element
		 * @type {Array}
		 */
		path: null,
		
		/**
		 * Returns path to currently selected element
		 * 
		 * @return Path to element
		 * @type {Array}
		 */
		getSelectionPath: function () {
			if (this.path) return this.path;
			if (!this.selection) return null;
			
			var path = [], node = this.selection.start, container = Y.Node.getDOMNode(this.get('srcNode'));
			
			while(node && node !== container) {
				if (node.nodeType == 1) path.push(node);
				node = node.parentNode;
			}
			
			this.path = path;
			return path;
		},
		
		/**
		 * Restore selection
		 * 
		 * @param {Object} selection
		 */
		setSelection: function (selection) {
			if (this.get('disabled')) return;
			
			var doc = this.get('doc');
			var win = this.get('win');
			
			if (win.getSelection) {
				//Standard compatible browsers
				var sel = win.getSelection();
				var range = sel.rangeCount ? sel.getRangeAt(0) : doc.createRange();
				
				try {
					//Preventing error when DOM node doesn't exist
					range.setStart(selection.start, selection.start_offset);
					range.setEnd(selection.end, selection.end_offset);
					
					sel.removeAllRanges();
					sel.addRange(range);
				} catch (err) {
				}
				
				this.resetSelectionCache(selection);
			}
		},
		
		/**
		 * Returns true if selection is collapsed
		 * 
		 * @return True if collapsed, otherwise false
		 * @type {Boolean}
		 */
		selectionIsCollapsed: function () {
			return !this.selection || this.selection.collapsed;
		},
		
		/**
		 * Returns element in which cursor is positioned
		 * Optionally searching for closest (parent) element matching selector or 
		 * if function is provided then uses it for testing element
		 * 
		 * @param {String} selector Optional. Will return first element matching selector
		 * @return HTMLElement or null
		 * @type {HTMLElement}
		 */
		getSelectedElement: function (selector) {
			if (this.selectedElement) {
				if (selector) {
					if (typeof selector === 'string') {
						if (selector == ':block') {
							selector = Supra.HTMLEditor.ELEMENTS_BLOCK_ARR.join(',');
						} else if (selector == ':inline') {
							selector = Supra.HTMLEditor.ELEMENTS_INLINE_ARR.join(',');
						}
						
						//Find closest element matching selector
						var node = new Y.Node(this.selectedElement),
							container = Y.Node.getDOMNode(this.get('srcNode'));
						
						//Don't traverse up more than container	
						while (node && !node.compareTo(container)) {
							if (node.test(selector)) return Y.Node.getDOMNode(node);
							node = node.get('parentNode');
						}
						
						return null;
					} else {
						//Find closest element which returns true for element
						var node = new Y.Node(this.selectedElement),
							container = Y.Node.getDOMNode(this.get('srcNode'));
						
						//Don't traverse up more than container	
						while (node && !node.compareTo(container)) {
							if (selector(node)) return Y.Node.getDOMNode(node);
							node = node.get('parentNode');
						}
						
						return null;
					}
				}
				
				return this.selectedElement;
			}
			
			var selection = this.selection,
				container = Y.Node.getDOMNode(this.get('srcNode'));
			
			if (!selection) return null;
			
			var node = selection.end || selection.start;
			if (selection.end_offset === 0 && (!selection.collapsed)) {
				node = selection.start || selection.end;
			}
			
			//Find HTMLElement
			while(node && node !== container) {
				if (node.nodeType != 1) {
					node = node.parentNode;
				} else {
					this.selectedElement = node;
					if (selector) {
						return this.getSelectedElement(selector);
					} else {
						return node;
					}
				}
			}
			
			this.selectedElement = (node === container ? container : null);
			if (selector && this.selectedElement) {
				return this.getSelectedElement(selector);
			} else {
				return this.selectedElement;
			}
		},
		
		/**
		 * Returns selection
		 * 
		 * @return Selection
		 * @type {Object}
		 */
		getSelection: function () {
			var doc = this.get('doc'),
				win = this.get('win');
			
			if (win.getSelection) {
				var sel = win.getSelection();
				var srcNode = Y.Node.getDOMNode(this.get('srcNode'));
				
				//If there is no selection, then report root node
				if (!sel.rangeCount) {
					sel = {
						start: srcNode,
						start_offset: 0,
						end: srcNode,
						end_offset: 0,
						collapsed: true
					};
					
					//Update also actual selection
					this.setSelection(sel);
					return sel;
				}
				
				var range = sel.getRangeAt(0);
				var start_container = range.startContainer, start_offset = range.startOffset,
					end_container = range.endContainer, end_offset = range.endOffset,
					start_el = start_container,
					end_el = end_container;
				
				//Check if selection is under root node
				while(start_el && start_el !== srcNode) start_el = start_el.parentNode;
				while(end_el && end_el !== srcNode) end_el = end_el.parentNode;
				
				//Selection is not under root node
				if (!start_el || !end_el) {
					sel = {
						start: srcNode,
						start_offset: 0,
						end: srcNode,
						end_offset: 0,
						collapsed: true
					};
					
					//Update also actual selection
					this.setSelection(sel);
					return sel;
				}
				
				//nodeType 3 is text
				//WebKit sometimes reports child node start_container (with offset same as length) or end_container
				//(with offset 0), which is incosistent with FF where parent node is reported
				//if (Y.UA.webkit) {
					/*
					if (this.getNodeLength(start_container) == start_offset) {
						if (start_container.nextSibling) {
							start_offset = this.getChildNodeIndex(start_container) + 1;
							start_container = start_container.parentNode;
						}
					}
					if (end_offset == 0) {
						if (end_container.previousSibling) {
							end_offset = this.getChildNodeIndex(end_container);
							end_container = end_container.parentNode;
						}
					}
					*/
				//}
				
				//If only one node is selected and there is no actual selection,
				//then change start_container and end_container to that node
				if (start_container == end_container && end_offset - start_offset == 1) {
					var node = start_container.childNodes[start_offset];
					if (node && node.nodeType == 1) {
						start_container = end_container = node;
						start_offset = end_offset = 0;
					}
				}
				
			}
			
			return this._normalizeSelection({
				start: start_container,
				start_offset: start_offset,
				end: end_container,
				end_offset: end_offset,
				collapsed: (start_container == end_container && start_offset == end_offset)
			});
		},
		
		/**
		 * Normalize selection value
		 * 
		 * @param {Object} selection Selection object
		 * @return Normalized selection value
		 * @private
		 */
		_normalizeSelection: function (selection) {
			var tmp_start = null,
				tmp_start_offset = null,
				tmp_end = null,
				tmp_end_offset = null;
			
			if (selection.start !== selection.end) {
				if (selection.start.nodeType == 3) {
					//Text node
					if (selection.start_offset == 0) {
						tmp_start = selection.start.parentNode;
						tmp_start_offset = this.getChildNodeIndex(selection.start);
					} else if (selection.start_offset == selection.start.length) {
						tmp_start = selection.start.nextSibling;
						tmp_start_offset = 0;
						if (!tmp_start) {
							tmp_start = selection.start.parentNode;
							tmp_start_offset = tmp_start.childNodes.length;
						}
					}
				}
				if (selection.end.nodeType == 3) {
					//Text node
					if (selection.end_offset == 0) {
						tmp_end = selection.end.previousSibling;
						tmp_end_offset = tmp_end ? this.getNodeLength(tmp_end) : 0;
						if (!tmp_end) {
							tmp_end = selection.end.parentNode;
							tmp_end_offset = tmp_end ? this.getNodeLength(tmp_end) : 0;
						}
					} else if (selection.end_offset == selection.end.length) {
						tmp_end = selection.end.parentNode;
						tmp_end_offset = this.getChildNodeIndex(selection.end) + 1;
					}
				}
				
				if (tmp_end && tmp_end === tmp_start) {
					selection.end = tmp_end;
					selection.end_offset = tmp_end_offset;
					selection.start = tmp_start;
					selection.start_offset = tmp_start_offset;
				} else if (tmp_end && tmp_end == selection.start) {
					selection.end = tmp_end;
					selection.end_offset = tmp_end_offset;
				} else if (tmp_start && tmp_start == selection.end) {
					selection.start = tmp_start;
					selection.start_offset = tmp_start_offset;
				}
			}
			
			return selection;
		},
		
		/**
		 * Select node
		 * 
		 * @param {HTMLElement} node
		 */
		selectNode: function (node) {
			var doc = this.get('doc');
			var win = this.get('win');
			
			if (win.getSelection) {
				var sel = win.getSelection();
				
				//WebKit may report empty selection
				var range = (sel.rangeCount ? sel.getRangeAt(0) : doc.createRange());
				
				if (node) {
					try {
						//Preventing error when DOM node doesn't exist
						range.selectNode(node);
					} catch (err) {
						return;
					}
				} else {
					var srcNode = Y.Node.getDOMNode(this.get('srcNode'));
					
					if(srcNode) {
						var c = srcNode.lastChild;
						if (c) {
							try {
								//Preventing error when DOM node doesn't exist
								range.setStartAfter(c);
							} catch (err) {
								return;
							}
						}
					}
				}
				
				sel.removeAllRanges();
				sel.addRange(range);
			} else if (doc.selection) {
				//IE < 9
				var range = doc.body.createTextRange();
				range.moveToElementText(node);
				range.select();
			}
			
			this.resetSelectionCache({
				"collapsed": !!(node.nodeType == 1 ? node.childNodes.length : node.length),
				"start": node,
				"start_offset": 0,
				"end": node,
				"end_offset": (node.nodeType == 1 ? node.childNodes.length : node.length)
			});
			
			if (node.nodeType == 1) {
				this.selectedElement = node;
			} else {
				this.selectedElement = null;
			}
		},
		
		/**
		 * Reset selection to nothing
		 */
		resetSelection: function () {
			var node = this.get('srcNode').getDOMNode();
			
			this.selectNode(node);
			this.refresh(true);
		},
		
		/**
		 * Replace selection or wrap selection in tag
		 * 
		 * @param {String} tagName
		 * @param {String} str
		 */
		replaceSelection: function (str, wrapTagName) {
			if (this.get('disabled')) return;
			
			var doc = this.get('doc');
			var win = this.get('win');
			
			if (win.getSelection) {
				//Standard compatible browsers
				var str = (str ? str : wrapTagName ? win.getSelection().toString() : '');
				var node, nodelist;
				
				if (wrapTagName) {
					node = doc.createElement(wrapTagName);
					node.innerHTML = str;
				} else {
					//Create TextNode with &nbsp; (non-breaking space) as content
					//Can't use createTextNode, because &amp; is automatically escaped
					var nodelist = doc.createElement('I');
						nodelist.innerHTML = str;
				}
				
				var sel = win.getSelection();
				var range = sel.getRangeAt(0);
				range.deleteContents();
				
				if (str) {
					// If we replaced with something, then select it
					if (node) {
						range.insertNode(node);
						range.setStartAfter(node);
					} else if (nodelist) {
						var first = null,
							block_elements = Supra.HTMLEditor.ELEMENTS_BLOCK,
							selected = this.getSelectedElement(Supra.HTMLEditor.ELEMENTS_BLOCK_ARR.join(',')),
							tag = selected ? selected.tagName : null;
						
						// @TODO FIX H1, H2, P, etc. being inserted into other H1, H2, P, etc. elements
						while(nodelist.lastChild) {
							first = nodelist.lastChild;
							if (first.nodeType) range.insertNode(first);
						}
						if (first) range.setStartAfter(first);
					}
					
					sel.removeAllRanges();
					sel.addRange(range);
				}
				
				this.resetSelectionCache();
				
				return node;
			}
		},
		
		/**
		 * Find nodes matching selector in selection or node in which cursor
		 * is positioned if it matches selector
		 * 
		 * @param {Object} selection Selection object
		 * @param {String} selector CSS selector
		 * @return Found nodes
		 * @type {Object}
		 */
		findNodesInSelection: function (selection, selector) {
			if (!this.selection) return new Y.NodeList(node || []);
			
			//@TODO Use correction selection
			
			var node = new Y.Node(this.getSelectedElement());
			
			while(node && !node.test(selector)) {
				node = node.get('parentNode');
			}
			
			var nodelist = new Y.NodeList(node || []);
			return nodelist;
		},
		
		/**
		 * Returns selected text
		 * 
		 * @return Selected text
		 * @type {String}
		 */
		getSelectionText: function () {
			var doc = this.get('doc'),
				win = this.get('win');
			
			if (win.getSelection) {
				return win.getSelection().toString();
			} else if (doc.selection) {
				//IE < 9
				return doc.selection.createRange().htmlText;
			}
		},
		
		/**
		 * Returns true if cursor is at the begining of given node
		 * 
		 * @param {HTMLElement} node Node to check
		 * @returns {Boolean} True if cursor is at the begining of node
		 */
		isCursorAtTheBeginingOf: function (node) {
			var selection = this.selection,
				start     = selection.start,
				length    = this.getNodeLength(start),
				tagname   = null,
				srcNode   = null,
				match     = null;
			
			if (selection.start_offset == 0) {
				return true;
			}
			
			if (start.nodeType == 3) {
				// Text node
				if (start.textContent.match(/^[\r\n\s]*/)[0].length < selection.start_offset) {
					// There is something before selection
					return false;
				}
			} else {
				// Element
				var children = start.childNodes,
					i = 0,
					ii = selection.start_offset;
				
				for (; i<ii; i++) {
					if (this.getNodeLength(children[i]) != 0) {
						// There is non-empty node before selection
						return false;
					}
				}
			}
			
			if (node) {
				// Traverse up the tree till we find the node
				srcNode = this.get('srcNode').getDOMNode();
				
				while (start && start !== srcNode) {
					if (start === node) return true;
					if (this.getFirstChild(start.parentNode) !== start) return false;
					start = start.parentNode;
				}
			} else {
				return true;
			}
			
			return false;
		},
		
		/**
		 * Returns true if cursor is at the end of given node
		 * 
		 * @param {HTMLElement} node Node to check
		 * @returns {Boolean} True if cursor is at the end of node
		 */
		isCursorAtTheEndOf: function (node) {
			var selection = this.selection,
				end       = selection.end,
				length    = this.getNodeLength(end),
				tagname   = null,
				srcNode   = null;
			
			if (selection.end_offset < length) {
				return false;
			}
				// Is at the end, but of what?
				
			if (node) {
				if (node.nodeType == 3) {
					// Text node
					return node === end;
				} else {
					// Element
					srcNode = this.get('srcNode').getDOMNode();
					
					if (node === srcNode) {
						// Selection always will be inside source node
						return true;
					}
					
					while (end && end !== srcNode) {
						if (end === node) return true;
						if (this.getLastChild(end.parentNode) !== end) return false;
						end = end.parentNode;
					}
				}
			} else {
				return true;
			}
			
			return false;
		},
		
		/**
		 * Returns true if all node content is selected, otherwise false
		 * 
		 * @param {HTMLElement} node Node to check
		 * @returns {Boolean} True if all node content is selected
		 */
		isAllNodeSelected: function (node) {
			return this.isCursorAtTheBeginingOf(node) &&
				   this.isCursorAtTheEndOf(node);
		},
		
		/**
		 * Reset selection variable cache
		 * 
		 * @param {Object} selection Optional. Selection object
		 */
		resetSelectionCache: function (selection) {
			this.selectedElement = null;
			this.selection = selection || this.getSelection();
			this.path = null;
		}
		
	});


	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-dom', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		
		/**
		 * Insert node before reference element
		 * 
		 * @param {HTMLElement|Text} node Node to insert
		 * @param {HTMLElement|Text} reference Reference node, before which to insert node
		 */
		insertBefore: function (node, reference) {
			var parent = reference.parentNode;
			parent.insertBefore(node, reference);
		},
		
		/**
		 * Insert node after reference element
		 * 
		 * @param {HTMLElement|Text} node Node to insert
		 * @param {HTMLElement|Text} reference Reference node, after which to insert node
		 */
		insertAfter: function (node, reference) {
			var parent = reference.parentNode,
				next = reference.nextSibling;
			
			if (next) {
				parent.insertBefore(node, next);
			} else {
				parent.appendChild(node);
			}
		},
		
		/**
		 * Insert node as first child of parent
		 * 
		 * @param {HTMLElement|Text} node Node to insert
		 * @param {HTMLElement} parent Parent element
		 */
		insertPrepend: function (node, parent) {
			if (parent && parent.nodeType == 1) {
				var reference = parent.firstChild;
				if (reference) {
					parent.insertBefore(node, reference);
				} else {
					parent.appendChild(node);
				}
			}
		},
		
		/**
		 * Returns node or closest ancestor matching selector
		 * Will not look further than editor srcNode
		 * 
		 * @param {String} selector CSS selector
		 * @return Y.Node matching selector
		 * @type {Object}
		 */
		closest: function (node, selector) {
			if (typeof selector == 'string') {
				var node = Y.Node(node),
					src  = this.get('srcNode');
				
				while(node && !node.compareTo(src)) {
					if (node.test(selector)) return node.getDOMNode();
					node = node.ancestor();
				}
				
				return null;
			} else {
				var node   = Y.Node(node),
					target = Y.Node(selector),
					src    = this.get('srcNode');
				
				if (!target) return null;
				
				while(node && !node.compareTo(src)) {
					if (node.compareTo(target)) return node.getDOMNode();
					node = node.ancestor();
				}
				
				return null;
			}
		},
		
		/**
		 * Returns all child elements of node
		 * 
		 * @param {HTMLElement} node Node to check
		 */
		getChildElements: function (node) {
			var children = node.childNodes,
				i = 0,
				ii = children.length,
				out = [];
			
			for (; i<ii; i++) {
				if (children[i].nodeType == 1) {
					out.push(children[i]);
				}
			}
			
			return out;
		},
		
		/**
		 * Returns last non-empty child of node
		 * 
		 * @param {HTMLElement} node Node to check
		 */
		getLastChild: function (node) {
			if (!node.lastChild) return null;
			
			var children = node.childNodes,
				i = 0,
				ii = children.length,
				tag = null;
			
			for (i = ii-1; i >= 0; i--) {
				if (children[i].nodeType == 1) {
					// Element
					if (children[i].tagName != 'BR') {
						return children[i];
					} else if (tag) {
						return tag;
					} else {
						tag = children[i];
					}
				} else if (children[i].nodeType == 3 && children[i].textContent.match(/[^\r\n\s]/)) {
					// Text
					return tag ? tag : children[i];
				}
			}
			
			return null;
		},
		
		/**
		 * Returns first non-empty child of node
		 * 
		 * @param {HTMLElement} node Node to check
		 */
		getFirstChild: function (node) {
			if (!node.firstChild) return null;
			
			var children = node.childNodes,
				i = 0,
				ii = children.length,
				tag = null;
			
			for (; i<ii; i++) {
				if (children[i].nodeType == 1) {
					// Element
					if (children[i].tagName != 'BR') {
						return children[i];
					} else if (tag) {
						return tag;
					} else {
						tag = children[i];
					}
				} else if (children[i].nodeType == 3 && children[i].textContent.match(/[^\r\n\s]/)) {
					// Text
					return tag ? tag : children[i];
				}
			}
			
			return null;
		},
		
		/**
		 * Returns true if node is empty, otherwise false
		 * 
		 * @param {HTMLElement} node Node to check
		 * @returns {Boolean} True if node is empty
		 */
		isNodeEmpty: function (node) {
			var length = this.getNodeLength(node),
				children = null,
				i = 0,
				ii = 0;
			
			if (length == 0) {
				return true;
			} else if (length <= 3) {
				children = node.childNodes;
				for (ii=children.length; i<ii; i++) {
					if (children[i].nodeType == 1) {
						// Text element
						if (children[i].textContent.replace(/[\r\n\s]+$/, '').length) {
							// Something else than new lines
							return false;
						}
					} else if (children[i].nodeType == 3) {
						// HTML element
						if (children[i].tagName != 'BR') {
							// Tag other than BR
							return false;
						}
					}
				}
				return true;
			}
			return false;
		},
		
		/**
		 * Returns text length without ending whitespaces if node is textNode, otherwise children count
		 * without last whitespace and <br />
		 * 
		 * @param {HTMLElement} node Node which length to return
		 * @returns {Number} Filtered node length
		 */
		getNodeLength: function (node) {
			if (node.nodeType == 1) {
				// HTML element, filter out begining and ending whitespace text nodes
				var children = node.childNodes,
					i = 0,
					ii = children.length,
					length = 0,
					lastTag = null;
				
				for (; i<ii; i++) {
					if (children[i].nodeType == 1) {
						length++;
						lastTag = children[i].tagName;
					} else if ((i == 0 || i == ii - 1) && !children[i].textContent.replace(/[\r\n\s]+$/, '').length) {
						// This is first or last text node and it's empty
					} else {
						length++;
						lastTag = null;
					}
				}
				
				// Last tag before ending was BR, remove it from length
				if (lastTag == 'BR') {
					length--;
				}
				return length;
			} else if (node.nodeType == 3) {
				// Text element
				var length = node.length,
					text   = null;
				
				if (length) {
					// Don't count new lines
					length = node.textContent.replace(/[\r\n\s]+$/, '').length;
				}
				
				return length;
			}
			
			return 0;
		},
		
		/**
		 * Returns index of child in childNodes 
		 * @param {Object} child
		 * @return Child index
		 * @type {Number}
		 */
		getChildNodeIndex: function (child) {
			var p = child.parentNode;
			if (p) {
				for(var i=0,ii=p.childNodes.length; i<ii; i++) {
					if (p.childNodes[i] === child) return i;
				}
			}
			return null;
		},
		
		/**
		 * Remove node from dom without removing its content
		 * 
		 * @param {Object} node Node to remove
		 */
		unwrapNode: function (node) {
			if (node && node.nodeType == 1 && node.parentNode) {
				while(node.firstChild) {
					node.parentNode.insertBefore(node.firstChild, node);
				}
				node.parentNode.removeChild(node);
			}
		},
		
		/**
		 * Split element into two elements at given position, returns second element
		 * 
		 * @returns {HTMLElement} Returns second element
		 */
		splitAt: function (node, offset) {
			var siblings = null,
				clone = null,
				tmp = null,
				i = 0,
				ii = 0,
				srcNode = this.get('srcNode').getDOMNode(),
				
				insertAfter = this.insertAfter,
				
				moveSiblings = function (node) {
					if (!node.parentNode) return null;
					
					var ref_parent = node.parentNode,
						
						parent = node.parentNode.cloneNode(),
						next = node.nextSibling,
						tmp = node;
					
					while (tmp) {
						parent.appendChild(tmp);
						tmp  = next;
						next = tmp ? tmp.nextSibling : null;
					}
					
					insertAfter(parent, ref_parent);
					
					return parent;
				};
			
			var SPLIT_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'blockquote', 'q', 'li', 'div', 'article', 'aside', 'details', 'figcaption', 'footer', 'header', 'hgroup', 'nav', 'section'];
			
			if (offset && node.nodeType == 3) {
				// Text node
				tmp = this.get('doc').createTextNode();
				tmp.textContent = node.textContent.substr(offset);
				node.textContent = node.textContent.substr(0, offset);
				
				insertAfter(tmp, node);
				node = tmp;
			} else if (node.nodeType == 1) {
				if (offset) {
					tmp = node.childNodes[offset];
					if (tmp) node = tmp.nextSibling;
				} else if (node.childNodes.length) {
					//tmp = node.childNodes[0];
				}
			}
			
			while (node) {
				if (node === srcNode || node.parentNode === srcNode) {
					return node;
				}
				
				node = moveSiblings(node);
				
				if (node.tagName && Y.Array.indexOf(SPLIT_TAGS, node.tagName.toLowerCase()) != -1) {
					// Element which can be split parent found, stop
					return node;
				}
				
			}
		}
		
	});


	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-traverse', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		
		/**
		 * Retrieves a nodeList based on the given CSS selector.
		 * 
		 * @param {String} selector The CSS selector to test against.
		 * @return A NodeList instance for the matching HTMLCollection/Array.
		 * @type {Object}
		 */
		all: function (selector) {
			return this.get('srcNode').all(selector);
		},
		
		/**
		 * Retrieves a Node instance of nodes based on the given CSS selector. 
		 * 
		 * @param {String} selector The CSS selector to test against.
		 * @return A Node instance for the matching HTMLElement.
		 * @type {Object}
		 */
		one: function (selector) {
			return this.get('srcNode').one(selector);
		}
		
	});


	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-editable', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		/**
		 * Current element editing is allowed
		 * @type {Boolean}
		 */
		editingAllowed: true,
		
		/**
		 * Disable content editing
		 * 
		 * @param {HTMLElement} node HTML element which shouldn't be editable
		 */
		disableNodeEditing: function (node) {
			node = Y.Node.getDOMNode(node);
			
			node.editable = false;
			Y.DOM.addClass(node, 'su-uneditable');
			Y.DOM.removeClass(node, 'su-editable');
		},
		
		/**
		 * Enable content editing
		 * 
		 * @param {HTMLElement} node HTML element which shouldn't be editable
		 */
		enableNodeEditing: function (node) {
			node = Y.Node.getDOMNode(node);
			
			node.editable = true;
			Y.DOM.removeClass(node, 'su-uneditable');
			Y.DOM.addClass(node, 'su-editable');
		},
		
		/**
		 * Return true if node is editable, otherwise false
		 * 
		 * @param {HTMLElement} node
		 * @return True if node is editable
		 * @type {Boolean}
		 */
		isEditable: function (node) {
			var rootNode = Y.Node.getDOMNode(this.get('srcNode'));
			node = Y.Node.getDOMNode(node);
			
			while(node && node !== rootNode && !('editable' in node)) {
				node = node.parentNode;
			}
			return node ? node.editable !== false : true;
		},
		
		/**
		 * Return true if selection is editable, otherwise false
		 * Checks all nodes between selection start and end node
		 * 
		 * @param {Object} selection Selection object
		 * @return True if selection is editable
		 * @type {Boolean}
		 */
		isSelectionEditable: function (selection) {
			//If only one node is selected, then 
			if (selection.start == selection.end) return this.isEditable(selection.start);
			
			var rootNode = Y.Node.getDOMNode(this.get('srcNode')),
				node = selection.start,
				endNode = selection.end,
				skipNextChildren = false;
			
			/*
			 * Returns next node which should be checked
			 */
			function getNextNode(node, rootNode) {
				//Previous getNextNode returned parent, so children were
				//already traversed
				var skipChildren = skipNextChildren;
					skipNextChildren = false;
				
				if (node === rootNode) return null;
				if (node.firstChild && !skipChildren) {
					return node.firstChild;
				}
				if (!node.parentNode) return null;
				if (node.nextSibling) return node.nextSibling;
				skipNextChildren = true;
				return node.parentNode;
			}
			
			//Traverse to end node and see if any node in the way is not editable
			while(true) {
				if ('editable' in node && !node.editable) return false;
				
				if (node === endNode) break;
				
				node = getNextNode(node);
				if (!node) break;
			}
			
			//Traverse up to root node and see if any node is/isn't editable
			node = selection.end;
			while(node && node !== rootNode) {
				if ('editable' in node) return node.editable;
				node = node.parentNode;
			}
			
			return true;
		},
		
		/**
		 * Restore editable states from classnames
		 * Used after setHTML call
		 */
		restoreEditableStates: function () {
			var srcNode = this.get('srcNode').getDOMNode(),
				nodes = null,
				i = 0,
				ii = 0;
			
			nodes = srcNode.querySelectorAll('.su-uneditable');
			for (i=0, ii=nodes.length; i<ii; i++) {
				nodes[i].editable = false;
			}
			
			nodes = srcNode.querySelectorAll('.su-editable');
			for (i=0, ii=nodes.length; i<ii; i++) {
				nodes[i].editable = true;
			}
		},
		
		/**
		 * Returns true if key pressed is navigation key and will not
		 * modify content
		 * 
		 * @param {Number} charCode
		 * @return If key will modify content
		 * @type {Boolean}
		 */
		navigationCharCode: function (charCode) {
			//32 - Space, 8 - backspace, 13 - return
			if (charCode == 32 || charCode == 8 || charCode == 13) return false;
			
			// before 40 are navigation keys
			// 91	- Left windows
			// 92	- Right windows
			// 93	- Context
			if (charCode <= 40 || charCode == 91 || charCode == 92 || charCode == 93) return true;
			
			return false;
		},
		
		/**
		 * Returns true if key pressed will insert new character and will modify
		 * content
		 * 
		 * @param {Number} charCode
		 * @return If key will modify content by adding something
		 * @type {Boolean}
		 */
		insertCharacterCharCode: function (charCode) {
			//32 - Space, 8 - backspace, 13 - return, 46 - delete
			if (charCode == 8 || charCode == 46) {
				return false;
			} else if (charCode == 32 || charCode == 13) {
				return true;
			}
			
			// before 40 are navigation keys
			// 91	- Left windows
			// 92	- Right windows
			// 93	- Context
			if (charCode <= 40 || charCode == 91 || charCode == 92 || charCode == 93) return false;
			
			return true;
		},
		
		/**
		 * Disable object resizing using handles
		 */
		disableObjectResizing: function () {
			try {
				this.get('doc').execCommand("enableInlineTableEditing", false, false);
				this.get("doc").execCommand("enableObjectResizing", false, false);
			} catch (err) {}
			
			if (Y.UA.ie) {
				//Prevent resizestart event
				this.get("srcNode").getDOMNode().onresizestart = function (e) {
					return false;
				};
			}
		}

	});


	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-commands', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		
		/**
		 * Plugin instances
		 */
		commands: {},
		
		/**
		 * Add command
		 * 
		 * @param {String} id
		 * @param {Function} callback
		 */
		addCommand: function (id, callback) {
			if (!(id in this.commands)) {
				this.commands[id] = [];
			}
			
			this.commands[id].push(callback);
		},
		
		/**
		 * Execute command
		 * 
		 * @param {String} action
		 */
		exec: function (command, data) {
			var disabled = this.get('disabled');
			if (disabled || !this.editingAllowed) return;
			
			if (command in this.commands) {
				var commands = this.commands[command],
					i=commands.length-1;
					
				for(; i >= 0; i--) {
					if (commands[i](data, command) === true) {
						//New node may have been added
						if (!this.refresh()) {
							//Or maybe only style changed
							this.fire('selectionChange');
							this.fire('nodeChange');
						};
						
						return true;
					}
				}
			}
			
			return false;
		}
	});

	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugins', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		
		/**
		 * Plugin instances
		 */
		plugins: {},
		
		/**
		 * Initialize all plugins
		 */
		initPlugins: function () {
			this.plugins = {};
			var plugins = Supra.HTMLEditor.PLUGINS,
				configuration = null,
				mode = this.get('mode'),
				default_modes = [],
				
				type = this.get('standalone') ? Supra.HTMLEditor.TYPE_STANDALONE : Supra.HTMLEditor.TYPE_INLINE,
				default_type = [Supra.HTMLEditor.TYPE_STANDALONE, Supra.HTMLEditor.TYPE_INLINE];
			
			for(var id in plugins) {
				configuration = this.getPluginConfiguration(id);
				
				if (configuration !== false) {
					
					//If plugin doesn't support this mode then skip it
					if (configuration) {
						if (Y.Array.indexOf(configuration.modes || default_modes, mode) == -1) {
							continue;
						}
						if (Y.Array.indexOf(configuration.types || default_type, type) == -1) {
							continue;
						}
					}
					
					this.plugins[id] = Supra.mix({
						'htmleditor': this,
						'id': id,
						'configuration': configuration,
						'NAME': id
					}, plugins[id].properties);
					
					if (this.plugins[id].init(this, configuration) === false) {
						//Initialization failed
						delete(this.plugins[id]);
					}
				}
			}
		},
		
		/**
		 * Add plugin only to this HTMLEditor instance
		 * 
		 * @param {Object} id
		 * @param {Object} configuration
		 * @param {Object} properties
		 */
		addPlugin: function (id, configuration, properties) {
			if (id in this.plugins) return;
			
			//Configuration is optional argument
			if (!properties && configuration) {
				properties = configuration;
				configuration = {};
			}
			
			configuration = this.getPluginConfiguration(id, configuration);
			if (configuration !== false) {
				this.plugins[id] = Supra.mix({
					'htmleditor': this,
					'id': id,
					'configuration': configuration,
					'NAME': id
				}, properties);
				
				if (this.plugins[id].init(this, configuration) === false) {
					//Initialization failed
					delete(this.plugins[id]);
				}
			}
		},
		
		/**
		 * Returns all plugin instances
		 * 
		 * @return All plugins
		 * @type {Object}
		 */
		getAllPlugins: function () {
			return this.plugins;
		},
		
		/**
		 * Returns plugin by ID
		 * 
		 * @param {String} pluginId
		 * @return Plugin instance
		 * @type {Object}
		 */
		getPlugin: function (pluginId) {
			var plugins = this.plugins;
			return pluginId in plugins ? plugins[pluginId] : null;
		},
		
		/**
		 * Destroy all plugins
		 */
		destroyPlugins: function () {
			var i,
				plugins = this.plugins;
				
			for(i in plugins) {
				if (plugins[i].destroy) plugins[i].destroy();
				delete(plugins[i]);
			}
			
			this.plugins = {};
		},
		
		/**
		 * Call plugin cleanUp method to remove everything plugin did to this node
		 * 
		 * @param {Object} node
		 */
		pluginsCleanUpNode: function (node, traverse) {
			var data = this.getData(node);
			if (data && data.type) {
				var plugin = this.getPlugin(data.type);
				if (plugin && 'cleanUp' in plugin) plugin.cleanUp(node, data);
				this.removeData(node);
			}
			if (traverse) {
				var nodes = node.all('[id^="su"]');
				for(var i=0,ii=nodes.size(); i<ii; i++) {
					this.pluginsCleanUpNode(nodes.item(i));
				}
			}
		},
		
		/**
		 * Returns plugins configuration
		 * 
		 * @return Default configuration mixed with user set configuration
		 * @type {Object}
		 */
		getPluginConfiguration: function (pluginId, defaultConfig) {
			if (!(pluginId in Supra.HTMLEditor.PLUGINS) && !defaultConfig) return false;
			
			var // Configuration from Supra.data
				configuration = Supra.data.get(['supra.htmleditor', 'plugins', pluginId]),
				// Configuration from plugin itself
				defaultConfig = defaultConfig || Supra.HTMLEditor.PLUGINS[pluginId].configuration,
				// Configuration from html editor configuration
				attrConfig    = this.get('plugins'),
				// Default modes
				defaultModes = [Supra.HTMLEditor.MODE_STRING, Supra.HTMLEditor.MODE_TEXT, Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH];
			
			if (attrConfig) {
				attrConfig = attrConfig[pluginId];
			} else {
				attrConfig = null;
			}
			
			if (attrConfig === false) {
				//If configuration is false then plugin is disabled
				return false;
			} else {
				var type = Y.Lang.type(attrConfig);
				if ((type === 'null' || type === 'undefined') && configuration === false) {
					//If configuration is false then plugin is disabled
					return false;
				} 
			} 
			
			if (!Y.Lang.isObject(attrConfig)) {
				attrConfig = {};
			}
			if (!Y.Lang.isObject(configuration)) {
				configuration = {};
			}
			
			return Supra.mix({'modes': defaultModes}, defaultConfig, configuration, attrConfig);
		}
		
	});

	//List of plugins
	Supra.HTMLEditor.PLUGINS = {};
	
	/**
	 * Add plugin
	 * 
	 * @param {String} id
	 * @param {Object} configuration
	 * @param {Object} properties
	 */
	Supra.HTMLEditor.addPlugin = function (id, configuration, properties) {
		//Configuration is optional argument
		if (!properties && configuration) {
			properties = configuration;
			configuration = {};
		}
		
		Supra.HTMLEditor.PLUGINS[id] = {'properties': properties, 'configuration': configuration || {}};
	};


	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-data', function (Y) {
	//Invoke strict mode
	"use strict";
	
	Y.mix(Supra.HTMLEditor.prototype, {
		
		/**
		 * Unique id generator
		 */
		dataNodeUID: 1,
		
		data: {},
		
		/**
		 * Returns all data
		 * 
		 * @return Data
		 * @type {Object}
		 */
		getAllData: function () {
			return this.data;
		},
		
		/**
		 * Returns list of all used Google API fonts
		 * 
		 * @return Fonts list
		 * @type {Array}
		 */
		getUsedFonts: function () {
			var plugin = this.getPlugin('fonts');
			if (plugin) {
				return plugin.getUsedFonts();
			} else {
				return [];
			}
		},
		
		/**
		 * Returns all data processed for saving
		 * 
		 * @return Data
		 * @type {Object}
		 */
		getProcessedData: function () {
			//Data has to be deep cloned to avoid overwriting values
			var data = Supra.mix({}, this.data, true),
				type = null,
				plugins = this.getAllPlugins(),
				plugin = null;
			
			for(var id in data) {
				type = data[id].type;
				if (type in plugins) {
					plugin = plugins[type];
					if (plugin.processData) {
						data[id] = plugin.processData(id, data[id]);
					}
				}
			}
			
			return data;
		},
		
		/**
		 * Returns all data encoded as JSON string
		 * 
		 * @return Data encoded as JSON string
		 * @type {String}
		 */
		getAllDataAsString: function () {
			return Y.JSON.stringify(this.data);
		},
		
		/**
		 * Set all content data
		 * 
		 * @param {Object} data
		 */
		setAllData: function (data) {
			if (typeof data == 'string') {
				try {
					data = Y.JSON.parse(data);
				} catch (e) {
					data = {};
				}
			}
			
			if (!Y.Lang.isObject(data)) {
				data = {};
			}
			
			this.data = data;
		},
		
		/**
		 * Associate data with node 
		 * 
		 * @param {Object} node
		 * @param {Object} data
		 * @param {Boolean} silent Doesn't trigger change if value is true, default is false
		 */
		setData: function (node, data, silent) {
			var id;
			if (typeof node == 'string') {
				id = node;
				node = Y.Node(this.get('doc')).one('#' + node);
			} else {
				node = new Y.Node(node);
				id = node.getAttribute('id');
			}
			
			if (id.indexOf('su') !== 0) {
				id = this.generateDataUID();
				node.setAttribute('id', id);
			}
			
			this.data[id] = data;
			
			//Data was changed, update state
			if (!silent) {
				this._changed();
			}
		},
		
		/**
		 * Returns data which is associated with node or id
		 * 
		 * @param {Object} node Node or ID
		 * @return Data
		 * @type {Object}
		 */
		getData: function (node) {
			if (typeof node == 'string' || typeof node == 'number') {
				var id = node;
			} else {
				node = new Y.Node(node);
				var id = node.getAttribute('id');	
			}
			
			if (!id || !(id in this.data)) return null;
			return this.data[id];
		},
		
		/**
		 * Removes data
		 * 
		 * @param {Object} node
		 * @return True if data was removed otherwise false
		 * @type {Boolean}
		 */
		removeData: function (node) {
			if (typeof node == 'string') {
				var id = node;
			} else {
				node = new Y.Node(node);
				var id = node.getAttribute('id');	
			}
			
			if (!id || !(id in this.data)) return false;
			delete(this.data[id]);
			return true;
		},
		
		/**
		 * Returns unique id, which is not used is page yet
		 * 
		 * @return Unique ID
		 * @type {String}
		 */
		generateDataUID: function () {
			var id = 'su' + this.dataNodeUID++,
				srcNode = this.get('srcNode');
			
			while(srcNode.one('#' + id)) {
				id = 'su' + this.dataNodeUID++;
			}
			
			return id;
		},
		
		/**
		 * Removes data which is associated with nodes, which are not
		 * in content anymore
		 */
		removeExpiredData: function () {
			var data = this.data,
				id,
				srcNode = this.get('srcNode');
			
			for(id in data) {
				if (!srcNode.one('#' + id)) {
					delete(data[id]);
				}
			}
		}
		
	});

	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-toolbar', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var BUTTONS_DEFAULT = {
		groups: [
			{
				"id": "main",
				"autoVisible": true, // always visible
				"animate": false, // never animate slide in/slide out
				"height": 48,
				"controls": [
					{"id": "source", "type": "button", "buttonType": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-source.png", "command": "source"},
					{"type": "separator"},
					//{"id": "fullscreen", "type": "button", "buttonType": "toggle", "icon": "/cms/lib/supra/img/htmleditor/icon-fullscreen.png", "command": "fullscreen"},
					//{"type": "separator"},
					{"id": "settings", "type": "button", "buttonType": "toggle", "icon": "/cms/lib/supra/img/htmleditor/icon-settings.png", "command": "settings"}
				]
			},
			{
				"id": "text",
				"autoVisible": true, // always visible
				"animate": true,
				"height": 42,
				"controls": [
						{"id": "style", "type": "button", "command": "style", "icon": "/cms/lib/supra/img/htmleditor/icon-style.png"},
					{"type": "separator"},
						{"id": "fonts", "type": "button", "command": "fonts", "icon": "/cms/lib/supra/img/htmleditor/icon-fonts.png", "visible": false},
					{"type": "separator"},
						{"id": "fontsize", "type": "dropdown", "command": "fontsize", "visible": false, "values": [
							{"id": 6, "title": "6"},
							{"id": 8, "title": "8"},
							{"id": 9, "title": "9"},
							{"id": 10, "title": "10"},
							{"id": 11, "title": "11"},
							{"id": 12, "title": "12"},
							{"id": 13, "title": "13"},
							{"id": 14, "title": "14"},
							{"id": 15, "title": "15"},
							{"id": 16, "title": "16"},
							{"id": 18, "title": "18"},
							{"id": 24, "title": "24"},
							{"id": 30, "title": "30"},
							{"id": 36, "title": "36"},
							{"id": 48, "title": "48"},
							{"id": 60, "title": "60"},
							{"id": 72, "title": "72"}
						]},
					{"type": "separator"},
						{"id": "forecolor", "type": "button", "command": "forecolor", "icon": "/cms/lib/supra/img/htmleditor/icon-forecolor.png", "visible": false},
						{"id": "backcolor", "type": "button", "command": "backcolor", "icon": "/cms/lib/supra/img/htmleditor/icon-backcolor.png", "visible": false},
					{"type": "separator"},
						{"id": "bold", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-bold.png", "command": "bold"},
						{"id": "italic", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-italic.png", "command": "italic"},
						{"id": "underline", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-underline.png", "command": "underline"},
						{"id": "strikethrough", "type": "button", "title": "Strike-through", "icon": "/cms/lib/supra/img/htmleditor/icon-strikethrough.png", "command": "strikethrough"},
					{"type": "separator"},
						{"id": "align", "type": "dropdown", "command": "align", "style": "icons-text", "values": [
							{"id": "left", "title": "Left", "icon": "/cms/lib/supra/img/htmleditor/align-left.png"},
							{"id": "center", "title": "Center", "icon": "/cms/lib/supra/img/htmleditor/align-center.png"},
							{"id": "right", "title": "Right", "icon": "/cms/lib/supra/img/htmleditor/align-right.png"},
							{"id": "justify", "title": "Justify", "icon": "/cms/lib/supra/img/htmleditor/align-justify.png"}
						]},
					{"type": "separator"},
						{"id": "ul", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-ul.png", "command": "ul"},
						{"id": "ol", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-ol.png", "command": "ol"},
					{"type": "separator"},
						{"id": "indent",  "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-indent-in.png",  "command": "indent",  "visible": false},
						{"id": "outdent", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-indent-out.png", "command": "outdent", "visible": false},
					{"type": "separator"},
						{"id": "insertlink", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-insertlink.png", "command": "insertlink", "visible": false},
					{"type": "separator"},
						{"id": "insert", "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-insert.png", "command": "insert"}
				]
			},
			{
				"id": "insert",
				"autoVisible": false, // visible only when needed
				"visible": false,
				"animate": true,
				"height": 42,
				"controls": [
						{"id": "insertimage", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-image.png", "command": "insertimage", "visible": false},
					{"type": "separator"},
						{"id": "inserticon", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-icon.png", "command": "inserticon", "visible": false},
					{"type": "separator"},
						{"id": "insertvideo", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-video.png", "command": "insertvideo", "visible": false},
					{"type": "separator"},
						{"id": "inserttable", "type": "button", "icon": "/cms/lib/supra/img/htmleditor/icon-table.png", "command": "inserttable"}
				]
			},
			{
				"id": "table",
				"autoVisible": false, // visible only when needed
				"visible": false,
				"animate": true,
				"height": 42,
				"controls": [
						{"id": "row-before",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-row-before.png",  "command": "row-before"},
						{"id": "row-delete",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-row-delete.png",  "command": "row-delete"},
						{"id": "row-after",   "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-row-after.png",  "command": "row-after"},
					{"type": "separator"},
						{"id": "merge",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-cell-merge.png",  "command": "merge-cells"},
					{"type": "separator"},
						{"id": "column-before",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-column-before.png",  "command": "column-before"},
						{"id": "column-delete",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-column-delete.png",  "command": "column-delete"},
						{"id": "column-after",   "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-column-after.png",  "command": "column-after"},
					{"type": "separator"},
						{"id": "table-settings",   "type": "button", "buttonType": "push", "command": "table-settings", "style": "small"}
				]
			},
			{
				"id": "itemlist",
				"autoVisible": false, // visible only when needed
				"visible": false,
				"animate": true,
				"height": 42,
				"controls": [
					{"id": "itemlist-row-before",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-row-before.png",  "command": "itemlist-before"},
					{"id": "itemlist-row-delete",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-row-delete.png",  "command": "itemlist-delete"},
					{"id": "itemlist-row-after",   "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-row-after.png",  "command": "itemlist-after"},
					{"id": "itemlist-column-before",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-column-before.png",  "command": "itemlist-before", "visible": false},
					{"id": "itemlist-column-delete",  "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-column-delete.png",  "command": "itemlist-delete", "visible": false},
					{"id": "itemlist-column-after",   "type": "button", "buttonType": "push", "icon": "/cms/lib/supra/img/htmleditor/icon-table-column-after.png",  "command": "itemlist-after", "visible": false}
				]
			}
		]
	};
	
	var TEMPLATE_GROUP = '<div class="yui3-editor-toolbar-{id} hidden">\
							<div class="yui3-editor-toolbar-{id}-content"></div>\
						  </div>';
	
	
	
	function HTMLEditorToolbar (config) {
		this.controls = {};
		this.groups = {};
		this.groupOrder = [];
		
		HTMLEditorToolbar.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	HTMLEditorToolbar.NAME = 'editor-toolbar';
	HTMLEditorToolbar.CLASS_NAME = Y.ClassNameManager.getClassName(HTMLEditorToolbar.NAME);
	HTMLEditorToolbar.ATTRS = {
		'editor': null,
		'disabled': {
			value: false,
			setter: '_setDisabled'
		}
	};
	
	Y.extend(HTMLEditorToolbar, Y.Widget, {
		
		/**
		 * List of groups
		 * @type {Object}
		 * @private
		 */
		groups: {},
		
		/**
		 * Visible group order
		 * @type {Object}
		 * @private
		 */
		groupOrder: [],
		
		/**
		 * List of all controls
		 * @type {Object}
		 * @private
		 */
		controls: {},
		
		/**
		 * List of controls and their disabled states
		 * before settings 'disabled' on toolbar
		 */
		previousControlStates: null,
		
		
		/* ---------------------------- Height ------------------------------ */
		
		
		/**
		 * Force leyout update
		 */
		syncLayout: function () {
			var action = Supra.Manager.getAction('LayoutTopContainer');
			if (action.get('executed')) action.syncLayout();
		},
		
		/**
		 * Calculate content height
		 * 
		 * @return Toolbar content height
		 * @type {Number}
		 * @private
		 */
		calculateContentHeight: function () {
			var groups = this.groups,
				height = 0,
				id = null;
			
			for (var id in groups) {
				if (groups[id].visible && id != 'main') { // "main" is outside content
					height += groups[id].height;
				}
			}
			
			return height;
		},
		
		/**
		 * Update content height
		 * 
		 * @private
		 */
		updateContentHeight: function () {
			var height = this.calculateContentHeight(),
				node = this.get('contentBox');
			
			node.setStyle('height', height + 'px');
			
			this.syncLayout();
			this.fire('contentResize');
		},
		
		/**
		 * Returns group node top position in which it should be
		 * 
		 * @param {String} group_id Group ID
		 * @return Group top position
		 * @type {Number}
		 */
		getGroupPosition: function (group_id) {
			var groups = this.groups,
				groupOrder = this.groupOrder,
				i = 0,
				ii = groupOrder.length,
				top = 0;
			
			for (; i<ii; i++) {
				if (groupOrder[i] == group_id) return top;
				if (groupOrder[i] != 'main') { // "main" is outside content
					top += groups[groupOrder[i]].height;
				}
			}
			
			return top;
		},
		
		
		/* ---------------------------- Controls ------------------------------ */
		
		
		/**
		 * Returns control
		 * 
		 * @param {String} id Control ID
		 * @return Control element or null if not found
		 * @type {Object}
		 */
		getControl: function (id) {
			return (id in this.controls ? this.controls[id] : null);
		},
		
		/**
		 * Returns all controls in group
		 * 
		 * @param {String} group_id Group ID
		 * @returns {Array} List of group controls
		 */
		getControlsInGroup: function (group_id) {
			var groups = BUTTONS_DEFAULT.groups,
				i = 0,
				ii = groups.length,
				controls = null,
				result = [];
				
			for (; i<ii; i++) {
				if (groups[i].id === group_id) {
					controls = groups[i].controls;
					
					if (controls) {
						for (i=0,ii=controls.length; i<ii; i++) {
							if (controls[i].type !== 'separator') {
								result.push(controls[i]);
							}
						}
					}
					
					break;
				}
			}
			
			return result;
		},
		
		/**
		 * Returns button, alias of getControl
		 */
		getButton: function (id) {
			return this.getControl(id);
		},
		
		/**
		 * Add control to toolbar
		 * 
		 * @param {String} group_id Tab ID
		 * @param {Object} data Control element data
		 * @return Y.Node or Supra.Button instance for created element 
		 * @type {Object}
		 */
		addControl: function (group_id, data, options) {
			if (!data || !group_id) return;
			if (typeof group_id == 'string' && !(group_id in this.groups)) return;
			
			var cont = typeof group_id == 'string' ? this.groups[group_id].node.one('div') : group_id,
				label,
				title,
				node,
				node_source,
				node_previous,
				first = options && 'first' in options ? options.first : true,
				last = options && 'last' in options ? options.last : true,
				visible = data.visible === false ? false : true;
			
			switch(data.type) {
				case 'separator':
					node = Y.Node.create('<div class="yui3-toolbar-separator"></div>');
					cont.append(node);
					break;
				case 'dropdown':
					node = Y.Node.create('<select></select>');
					cont.append(node);
					node = new Supra.Input.Select({
						'srcNode': node,
						'scrollable': false,
						'values': data.values,
						'textRenderer': data.style == 'icons-text' ? function (item) { return '<span class="icon-crop"><img src="' + item.icon + '" /></span>'; } : null,
						'visible': visible
					});
					node.render();
					break;
				case 'button':
				default:
					title = data.title || Y.Escape.html(Supra.Intl.get(['htmleditor', data.id]));
					node = new Supra.Button({"label": title, "icon": data.icon, "type": data.buttonType || "toggle", "style": data.style || "toolbar", "visible": visible});
					node.ICON_TEMPLATE = '<span class="img"><img src="" alt="" /></span>';
					node.render(cont);
					
					node.on('click', function (evt, data) {
						if (!node.get('disabled')) {
							this.fire('command', data);
						}
						
						evt.preventDefault();
						evt.stopPropagation();
						return false;
					}, this, data);
					
					if (!options || !('first' in options)) {
						//Check if this is first button
						node_previous = node.get('boundingBox').previous();
						if (node_previous) {
							if (node_previous.hasClass('su-button-last')) {
								node_previous.removeClass('su-button-last');
								first = false;
							}
						}
					}
					
					if (first) node.addClass('su-button-first');
					if (last) node.addClass('su-button-last');
					
					break;
			}
			
			if (node && data.id) {
				this.controls[data.id] = node;
			}
			
			return node;
		},
		
		/**
		 * Add control to toolbar, alias of addControl
		 */
		addButton: function (group_id, data, options) {
			return this.addControl(group_id, data, options);
		},
		
		/**
		 * Render all groups and controls
		 */
		renderUI: function () {
			HTMLEditorToolbar.superclass.renderUI.apply(this, arguments);
			
			var groups = BUTTONS_DEFAULT.groups,
				groupList = this.groups = {},
				id = null,
				index = 0;
			
			for(var i=0,ii=groups.length; i<ii; i++) {
				id = groups[i].id;
				
				groupList[id] = {
					'node': null,
					'visible': false,
					'height': groups[i].height,
					'animate': groups[i].animate,
					'autoVisible': groups[i].autoVisible,
					'index': null
				};
				
				//Create tab
				var template = Y.substitute(TEMPLATE_GROUP, {'id': id}),
					cont = groupList[id].node = Y.Node.create(template).appendTo(this.get('contentBox')),
					first = true,
					nextFirst = false,
					last = false;
				
				//Use content
				cont = cont.one('div');
				
				if (!('controls' in groups[i])) continue;
				
				//Create controls
				for(var k=0,kk=groups[i].controls.length; k<kk; k++) {
					var data = groups[i].controls[k];
					
					switch (data.type) {
						case 'separator':
							first = true;
							nextFirst = true;
							break;
						case 'dropdown':
							first = true;
							nextFirst = true;
							break;
						case 'button':
						default:
							last = k < kk-1 ? (groups[i].controls[k+1].type != 'button' ? true : false ) : true;
							nextFirst = false;
							break;
					}
					
					this.addControl(cont, data, {
						'first': first,
						'last': last
					});
					
					first = nextFirst;
				}
				
			}
		},
		
		/**
		 * Enable or disable all buttons
		 */
		_setDisabled: function (disabled) {
			var controls = this.controls,
				states = {};
			
			if (disabled) {
				for(var id in controls) {
					if (controls[id].get('disabled')) {
						states[id] = true;
					} else {
						controls[id].set('disabled', true);
						states[id] = false;
					}
				}
				
				this.previousControlStates = states;
			} else {
				states = this.previousControlStates;
				
				for(var id in states) {
					if (id in controls) {
						controls[id].set('disabled', states[id]);
					}
				}
				
				this.previousControlStates = {};
			}
		},
		
		
		/* ---------------------------- Visibility ------------------------------ */
		
		
		/**
		 * Returns true if group is visible, otherwise false
		 * 
		 * @param {String} group_id Group ID
		 * @returns {Boolean} True if group is visible, otherwise false
		 */
		isGroupVisible: function (group_id) {
			var group = this.groups[group_id];
			
			if (group) {
				return group.visible;
			} else {
				return false;
			}
		},
		
		/**
		 * Show group
		 * 
		 * @param {String} group_id Group ID
		 * @param {Boolean} silent In silent mode content height is not updated
		 */
		showGroup: function (group_id, silent) {
			var group = this.groups[group_id],
				groupOrder = this.groupOrder,
				position = null;
			
			if (group && !group.visible) {
				
				group.visible = true;
				group.node.removeClass('hidden');
				group.index = groupOrder.length;
				groupOrder.push(group_id);
				
				if (group.animate) {
					position = this.getGroupPosition(group_id);
					group.node.setStyle('top', position - 48 + 'px');
					group.node.transition({
						'top': position + 'px',
						'easing': 'ease-out',
						'duration': 0.5
					});
				} else if (group_id == 'main') {
					//Main slide has special animation
					group.node.one('div').transition({
						'duration': 0.5,
						'easing': 'ease-out',
						'marginTop': '0px'
					});
				}
				
				if (!silent) this.updateContentHeight();
			}
		},
		
		/**
		 * Hide group
		 * 
		 * @param {String} group_id Group name
		 * @param {Boolean} silent In silent mode content height is not updated
		 */
		hideGroup: function (group_id, silent, after) {
			var groups = this.groups,
				group = groups[group_id],
				groupOrder = this.groupOrder,
				position = null;
			
			if (group && group.visible) {
				groupOrder.splice(group.index, 1);
				
				group.index = null;
				group.visible = false;
				
				if (group.animate) {
					position = this.getGroupPosition(group_id);
					
					group.node.transition({
						'top': position - 48 + 'px',
						'easing': 'ease-out',
						'duration': 0.5
					}, Y.bind(function () {
						group.node.addClass('hidden');
						if (!silent) this.updateContentHeight();
						if (Y.Lang.isFunction(after)) after();
					}, this));
					
				} else if (group_id == 'main') {
					
					//Main slide has special animation
					group.node.one('div').transition({
						'duration': 0.5,
						'easing': 'ease-out',
						'marginTop': '50px'
					}, Y.bind(function () {
						group.node.addClass('hidden');
						if (!silent) this.updateContentHeight();
						if (Y.Lang.isFunction(after)) after();
					}, this));
					
				} else {
					
					if (!silent) this.updateContentHeight();
					if (Y.Lang.isFunction(after)) after();
					
				}
			}
		},
		
		/**
		 * Handle visibility change
		 * @param {Object} visible
		 */
		_uiSetVisible: function (visible) {
			if (visible) {
				this.get('boundingBox').removeClass(this.getClassName('hidden'));
				
				var group_proto = BUTTONS_DEFAULT.groups,
					groups = this.groups,
					id = null,
					i = 0,
					ii = group_proto.length,
					show = [];
				
				for (; i<ii; i++) {
					id = group_proto[i].id;
					if (groups[id].autoVisible) show.push(id);
				}
				
				for (i=0,ii=show.length; i<ii; i++) {
					this.showGroup(show[i], i != ii - 1);
				}
			} else {
				var groupOrder = this.groupOrder,
					i = groupOrder.length - 1,
					fn = Y.bind(function () { 
							this.get('boundingBox').addClass(this.getClassName('hidden'));
						 }, this);
				
				for (; i >= 0; i--) {
					this.hideGroup(groupOrder[i], i != 0, i == 0 ? fn : null);
				}
			}
		}
		
	});
	
	Supra.HTMLEditorToolbar = HTMLEditorToolbar;
	
	
}, YUI.version, {requires:['widget', 'supra.panel', 'supra.button', 'transition']});YUI.add('supra.slider', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Slider class 
	 * 
	 * @alias Supra.Slider
	 * @param {Object} config Configuration
	 */
	function Slider (config) {
		this.render_queue = [];
		this.history = [];
		this.slides = {};
		this.remove_on_hide = {};
		this.anim = null;
		
		Slider.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Slider.NAME = 'slider';
	Slider.CSS_PREFIX = 'su-' + Slider.NAME;
	
	Slider.ATTRS = {
		gutterSize: {
            value: 9,
            validator: Y.Lang.isNumber
        }
	};
	
	Y.extend(Slider, Y.Slider, {
		
		/**
	     * Rail template that will contain the end caps and the thumb.
	     * {placeholder}s are used for template substitution at render time.
	     *
	     * @property RAIL_TEMPLATE
	     * @type {String}
	     * @default &lt;span class="{railClass}">&lt;span class="{railMinCapClass}">&lt;/span>&lt;span class="{railMaxCapClass}">&lt;/span>&lt;/span>
	     */
	    RAIL_TEMPLATE     : '<span class="{railClass}">' +
	                            '<span class="{railLineMinClass}"></span>' +
	                            '<span class="{railLineMaxClass}"></span>' +
	                            '<span class="{railMinCapClass}"></span>' +
	                            '<span class="{railMaxCapClass}"></span>' +
	                        '</span>',
		
		/**
	     * Creates the Slider rail DOM subtree for insertion into the Slider's
	     * <code>contentBox</code>.  Override this method if you want to provide
	     * the rail element (presumably from existing markup).
	     *
	     * @method renderRail
	     * @return {Node} the rail node subtree
	     */
	    renderRail: function () {
	        var minCapClass = this.getClassName( 'rail', 'cap', this._key.minEdge ),
	            maxCapClass = this.getClassName( 'rail', 'cap', this._key.maxEdge ),
	            lineMinClass = this.getClassName( 'rail', 'line', this._key.minEdge ),
	            lineMaxClass = this.getClassName( 'rail', 'line', this._key.maxEdge );
	
	        return Y.Node.create(
	            Y.substitute( this.RAIL_TEMPLATE, {
	                railClass      : this.getClassName( 'rail' ),
	                railMinCapClass: minCapClass,
	                railMaxCapClass: maxCapClass,
	                railLineMinClass: lineMinClass,
	                railLineMaxClass: lineMaxClass
	            } ) );
	    },
	    
	    /**
	     * <p>Defaults the thumbURL attribute according to the current skin, or
	     * &quot;sam&quot; if none can be determined.  Horizontal Sliders will have
	     * their <code>thumbUrl</code> attribute set to</p>
	     * <p><code>&quot;/<em>configured</em>/<em>yu</em>i/<em>builddi</em>r/slider-base/assets/skins/sam/thumb-x.png&quot;</code></p>
	     * <p>And vertical thumbs will get</p>
	     * <p><code>&quot;/<em>configured</em>/<em>yui</em>/<em>builddir</em>/slider-base/assets/skins/sam/thumb-y.png&quot;</code></p>
	     *
	     * @method _initThumbUrl
	     * @protected
	     */
	    _initThumbUrl: function () {
	        if (!this.get('thumbUrl')) {
	            var skin = this.getSkinName() || 'supra',
	                base = Y.config.realBase || Y.config.base;
				
	            this.set('thumbUrl', '/cms/lib/supra/build/slider/assets/skins/' + skin + '/thumb-' + this.axis + '.png');
	        }
	    },
	    
	    /**
         * Positions the thumb in accordance with the translated value.
         *
         * @method _setPosition
         * @param value {Number} Value to translate to a pixel position
         * @param [options] {Object} Details object to pass to `_uiMoveThumb`
         * @protected
         */
        _setPosition: function ( value, options ) {
            var offset = this._valueToOffset( value ),
            	rail = this.rail,
            	node = null;
            
            this._uiMoveThumb( offset, options );
            
            if (rail) {
            	var gutter = this.get('gutterSize');
            	offset += 5;
            	
            	node = rail.one('.' + this.getClassName( 'rail', 'line', this._key.maxEdge ));
            	node.setStyle(this._key.minEdge, offset + 'px');
            	
            	node = rail.one('.' + this.getClassName( 'rail', 'line', this._key.minEdge ));
            	node.setStyle(this._key.dim, Math.max(0, offset - gutter) + 'px');
            }
        }
		
	});
	
	Supra.Slider = Slider;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};

}, YUI.version, {'requires': ['range-slider']});YUI().add('supra.imageresizer', function (Y) {
	
	// Resize handle size
	var RESIZE_HANDLE_SIZE = 16;
	
	/**
	 * Image resize class
	 * 
	 * @extends Y.Base
	 * @param {Object} config Attribute values
	 */
	function ImageResizer (config) {
		ImageResizer.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	ImageResizer.MODE_IMAGE = 0;
	ImageResizer.MODE_BACKGROUND = 1;
	ImageResizer.MODE_ICON = 2;
	
	ImageResizer.NAME = 'imageresizer';
	ImageResizer.CSS_PREFIX = 'su-' + ImageResizer.NAME;
	ImageResizer.CLASS_NAME = Y.ClassNameManager.getClassName(ImageResizer.NAME);
	
	ImageResizer.ATTRS = {
		// Image element
		'image': {
			value: null,
			setter: '_setImageAttr'
		},
		
		// Maximal image width (original image width)
		'maxImageWidth': {
			value: 0
		},
		// Maximal image height (original image height)
		'maxImageHeight': {
			value: 0
		},
		
		// Minimal width
		'minCropWidth': {
			value: 32
		},
		// Maximal width
		'maxCropWidth': {
			value: 0
		},
		// Minimal height
		'minCropHeight': {
			value: 32
		},
		// Maximal height
		'maxCropHeight': {
			value: 0
		},
		
		// Image document element
		'doc': {
			value: null
		},
		// Node used for resize handles
		'resizeHandleNode': {
			value: null
		},
		// Image container node
		'imageContainerNode': {
			value: null,
		},
		// Cursor:  0 - nw, 1 - ne, 2 - se, 3 - sw, 4 - move
		'cursor': {
			value: 4,
			setter: '_setCursorAttr'
		},
		
		// Stop editing when clicked outside
		'autoClose': {
			value: true
		},
		// Mode: 0 - image, 1 - background, 2 - icon
		'mode': {
			value: ImageResizer.MODE_IMAGE,
			setter: '_setMode'
		},
		
		// Resize crop region to smaller on image zoom change if needed
		'allowZoomResize': {
			value: false
		},
		// Change zoom on crop resize if needed
		'allowCropZooming': {
			value: false
		},
		
		// Width and height ratio is locked
		// when changing width or height input other one changes too
		'ratioLocked': {
			value: false,
			setter: '_setRatioLocked'
		}
	};
	
	Y.extend(ImageResizer, Y.Base, {
		
		/**
		 * Image width after zoom
		 * Crop left + crop width can't exceed this
		 * @type {Number}
		 * @private
		 */
		imageWidth: 0,
		
		/**
		 * Image height after zoom
		 * Crop top + crop height can't exceed this
		 * @type {Number}
		 * @private
		 */
		imageHeight: 0,
		
		/**
		 * Minimal image width, based on minCropWidth and image ratio
		 * @type {Number}
		 * @private
		 */
		minImageWidth: 0,
		
		/**
		 * Minimal image height, based on minCropHeight and image ratio
		 * @type {Number}
		 * @private
		 */
		minImageHeight: 0,
		
		
		/**
		 * Image crop width
		 * @type {Number}
		 * @private
		 */
		cropWidth: 0,
		
		/**
		 * Image crop width
		 * @type {Number}
		 * @private
		 */
		cropHeight: 0,
		
		/**
		 * Image left crop
		 * @type {Number}
		 * @private
		 */
		cropLeft: 0,
		
		/**
		 * Image top crop
		 * @type {Number}
		 * @private
		 */
		cropTop: 0,
		
		/**
		 * Image zoom level
		 * @type {Number}
		 * @private
		 */
		zoom: 1,
		
		
		
		/**
		 * Drag start mouse X position
		 * @type {Number}
		 * @private
		 */
		mouseStartX: null,
		
		/**
		 * Drag start mouse Y position
		 * @type {Number}
		 * @private
		 */
		mouseStartY: null,
		
		/**
		 * Drag start image width
		 * @type {Number}
		 * @private
		 */
		dragStartW: null,
		
		/**
		 * Drag start image height
		 * @type {Number}
		 * @private
		 */
		dragStartH: null,
		
		/**
		 * Drag image width
		 * @type {Number}
		 * @private
		 */
		dragW: null,
		
		/**
		 * Drag image height
		 * @type {Number}
		 * @private
		 */
		dragH: null,
		
		/**
		 * Drag image left offset
		 * @type {Number}
		 * @private
		 */
		dragCropLeft: null,
		
		/**
		 * Drag image top offset
		 * @type {Number}
		 * @private
		 */
		dragCropTop: null,
		
		
		/**
		 * Currently resizing crop
		 * @type {Boolean}
		 * @private
		 */
		resizeActive: false,
		
		/**
		 * Currently moving
		 * @type {Boolean}
		 * @private
		 */
		moveActive: false,
		
		/**
		 * Event listener object for mouse move event
		 * @type {Object}
		 * @private
		 */
		eventMove: null,
		
		/**
		 * Event listener object for mouse move event on main document
		 * @type {Object}
		 * @private
		 */
		eventMoveMain: null,
		
		/**
		 * Event listener object for mouse up event
		 * @type {Object}
		 * @private
		 */
		eventDrop: null,
		
		/**
		 * Event listener object for mouse up event on main document
		 * @type {Object}
		 * @private
		 */
		eventDropMain: null,
		
		/**
		 * Event listener object for document click event
		 * @type {Object}
		 * @private
		 */
		eventClick: null,
		
		/**
		 * Zoom and size panel
		 * Supra.Panel instance
		 * @type {Object}
		 * @private
		 */
		adjustmentPanel: null,
		
		/**
		 * Zoom slider
		 * Supra.Slider instance
		 * @type {Object}
		 * @private
		 */
		zoomSlider: null,
		
		/**
		 * Zoom in button
		 * Supra.Button instance
		 * @type {Object}
		 * @private
		 */
		buttonZoomIn: null,
		
		/**
		 * Zoom out button
		 * Supra.Button instance
		 * @type {Object}
		 * @private
		 */
		buttonZoomOut: null,
		
		/**
		 * Width input
		 * Supra.Input.String instance
		 * @type {Object}
		 * @private
		 */
		inputWidth: null,
		
		/**
		 * Height input
		 * Supra.Input.String instance
		 * @type {Object}
		 * @private
		 */
		inputHeight: null,
		
		/**
		 * Width/height ratio lock button
		 * Supra.Button instance
		 * @type {Object}
		 * @private
		 */
		buttonRatio: null,
		
		/**
		 * Size input values are changed by something other than
		 * direct input.
		 * @type {Boolean}
		 * @private
		 */
		sizeInputValuesChanging: false,
		
		
		/**
		 * On destruction revert changes to image, clean up
		 * 
		 * @private
		 */
		destructor: function () {
			if (this.get('image')) {
				this.set('image', null);
			}
			if (this.zoomSlider) {
				this.zoomSlider.destroy();
			}
			if (this.inputWidth) {
				this.inputWidth.destroy();
			}
			if (this.inputHeight) {
				this.inputHeight.destroy();
			}
			if (this.buttonRatio) {
				this.buttonRatio.destroy();
			}
			if (this.adjustmentPanel) {
				this.adjustmentPanel.destroy();
			}
			if (this.buttonZoomIn) {
				this.buttonZoomIn.destroy();
			}
			if (this.buttonZoomOut) {
				this.buttonZoomOut.destroy();
			}
			
			this.zoomSlider = null;
			this.inputWidth = null;
			this.inputHeight = null;
			this.buttonRatio = null;
			this.adjustmentPanel = null;
			this.buttonZoomIn = null;
			this.buttonZoomOut = null;
		},
		
		
		/* --------------------------------- Cursor --------------------------------- */
		
		
		/**
		 * Set mouse cursor 
		 */
		setMouseCursor: function (e) {
			//Resize is available only if resizing image
			//If currently resizing, then don't change cursor
			if (!this.resizeActive && !this.moveActive) {
				var xy = this.get('resizeHandleNode').getXY(),
					x = e.pageX - xy[0],
					y = e.pageY - xy[1],
					w = this.cropWidth + 6 * 2,
					h = this.cropHeight + 6 * 2,
					handleSize = RESIZE_HANDLE_SIZE,
					cursor = 4;
				
				if (x > w - handleSize) {
					if (y > h - handleSize) {
						cursor = 2;
					} else if (y < handleSize) {
						cursor = 1;
					}
				} else if (x < handleSize) {
					if (y > h - handleSize) {
						cursor = 3;
					} else if (y < handleSize) {
						cursor = 0;
					}
				}
				
				if (this.get('cursor') != cursor) {
					this.set('cursor', cursor);
				}
			}
		},
		
		/**
		 * Unset mouse cursor
		 */
		unsetMouseCursor: function (e) {
			if (!this.resizeActive && !this.moveActive && this.get('cursor') != 4) {
				this.set('cursor', 4);
			}
		},
		
		/**
		 * Returns cursor classname
		 * 
		 * @param {Number} cursor
		 * @return Classname for that cursor
		 * @type {String}
		 */
		getCursorClassName: function (cursor) {
			switch (cursor) {
				case 0:
					return 'supra-image-resize-nw';
				case 1:
					return 'supra-image-resize-ne';
				case 2:
					return 'supra-image-resize-se';
				case 3:
					return 'supra-image-resize-sw';
				default:
					var mode = this.get('mode');
					return mode == ImageResizer.MODE_IMAGE || mode == ImageResizer.MODE_ICON ? '' : 'supra-image-resize-move';
			}
		},
		
		
		/* --------------------------------- Zoom --------------------------------- */
		
		
		/**
		 * Create panel and slider
		 * 
		 * @private
		 */
		createPanel: function () {
			if (this.adjustmentPanel) return;
			
			var panel = this.adjustmentPanel = new Supra.Panel({
				'zIndex': 100,
				'plugins': [ Y.Plugin.Drag ],
				'style': 'dark'
				/*'alignPosition': 'T',
				'arrowVisible': true*/
			});
			panel.render();
			
			var boundingBox = panel.get('boundingBox'),
				contentBox = panel.get('contentBox'),
				sizeBox = Y.Node.create('<div class="clearfix su-imageresizer-sizebox"></div>'),
				slider = new Supra.Slider({
					'axis': 'x',
					'min': 0,
					'max': 100,
					'value': 100,
					'length': 250
				}),
				zoomIn = new Supra.Button({
					'label': '',
					'style': 'zoom-in'
				}),
				zoomOut = new Supra.Button({
					'label': '',
					'style': 'zoom-out'
				}),
				inputWidth = new Supra.Input.String({
					'label': Supra.Intl.get(['inputs', 'resize_width']),
					'style': 'size',
					'valueMask': /^[0-9]*$/,
					'value': this.imageWidth
				}),
				inputHeight = new Supra.Input.String({
					'label': Supra.Intl.get(['inputs', 'resize_height']),
					'style': 'size',
					'valueMask': /^[0-9]*$/,
					'value': this.imageHeight
				}),
				buttonRatio = new Supra.Button({
					'label': '',
					'style': 'small-gray'
				});
			
			this.zoomSlider = slider;
			this.buttonZoomIn = zoomIn;
			this.buttonZoomOut = zoomOut;
			this.inputWidth = inputWidth;
			this.inputHeight = inputHeight;
			this.buttonRatio = buttonRatio;
			
			slider.render(contentBox);
			slider.on('valueChange', this.zoomChange, this);
			
			// Zoom in, zoom out buttons
			zoomIn.render(contentBox);
			zoomOut.render(contentBox);
			
			zoomIn.on('click', function () {
				this.set('value', Math.min(100, this.get('value') + this.get('majorStep')));
			}, slider);
			zoomOut.on('click', function () {
				this.set('value', Math.max(0, this.get('value') - this.get('majorStep')));
			}, slider);
			
			// Width and height
			contentBox.append(sizeBox);
			
			sizeBox.append('<p class="label">' + Supra.Intl.get(['inputs', 'resize_frame_size']) + '</label>');
			
			inputWidth.render(sizeBox);
			
			buttonRatio.render(sizeBox);
			buttonRatio.addClass('su-button-ratio');
			
			if (this.get('mode') !== ImageResizer.MODE_IMAGE) {
				this.set('ratioLocked', true);
				buttonRatio.set('disabled', true);
			}
			if (this.get('ratioLocked')) {
				buttonRatio.addClass('su-button-locked');
			}
			
			inputHeight.render(sizeBox);
			
			inputWidth.on('input', Supra.throttle(function (e) {
				if (this.inputWidth.get('focused')) {
					this.widthChange(e, 'width');
				}
			}, 250, this, true), this);
			inputHeight.on('input', Supra.throttle(function (e) {
				if (this.inputHeight.get('focused')) {
					this.heightChange(e, 'height');
				}
			}, 250, this, true), this);
			
			// On blur change value
			inputWidth.on('blur', function () {
				var value = this.cropWidth;
				if (this.get('mode') == ImageResizer.MODE_BACKGROUND) {
					value = this.imageWidth;
				}
				if (this.inputWidth.get('value') != value) {
					this.inputWidth.set('value', value);
				}
			}, this);
			inputHeight.on('blur', function () {
				var value = this.cropHeight;
				if (this.get('mode') == ImageResizer.MODE_BACKGROUND) {
					value = this.imageHeight;
				}
				if (this.inputHeight.get('value') != value) {
					this.inputHeight.set('value', value);
				}
			}, this);
			
			inputWidth.on('valueChange', this.widthChange, this);
			inputHeight.on('valueChange', this.heightChange, this);
			
			buttonRatio.on('click', this.toggleRatioLock, this)
			buttonRatio.set('title', Supra.Intl.get(['inputs', 'resize_button_title']));
			
			// Panel style
			boundingBox.addClass('su-imageresizer');
			boundingBox.addClass('ui-dark');
		},
		
		/**
		 * Position panel, set current zoom value
		 */
		setUpPanel: function () {
			if (!this.adjustmentPanel) {
				this.createPanel();
			}
			
			this.adjustmentPanel.set('alignTarget', this.get('image'));
			this.adjustmentPanel.show();
			this.adjustmentPanel.centered();
			
			//Set zoom value
			var zoom = this.sizeToZoom(this.imageWidth, this.imageHeight);
			this.zoomSlider.set('value', zoom);
		},
		
		/**
		 * Handle zoom change
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		zoomChange: function (e) {
			if (e.silent || !this.get('image')) return;
			
			var image = this.get('image'),
				zoom = e.newVal,
				size = this.zoomToSize(zoom),
				ratio = null,
				containerNode = null,
				imageContainerNode = null;
			
			this.imageWidth = ~~size[0];
			this.imageHeight = ~~size[1];
			
			if (this.get('mode') == ImageResizer.MODE_IMAGE) {
				ratio = (this.get('maxImageWidth') / this.get('maxImageHeight'));
				
				if (this.get('allowZoomResize')) {
					//Resize crop if needed
					if (this.cropTop + this.cropHeight > this.imageHeight) {
						this.cropTop = this.imageHeight - this.cropHeight;
						if (this.cropTop < 0) {
							this.cropHeight = Math.max(this.cropHeight + this.cropTop, 0);
							this.cropTop = 0;
						}
					}
					if (this.cropLeft + this.cropWidth > this.imageWidth) {
						this.cropLeft = this.imageWidth - this.cropWidth;
						if (this.cropLeft < 0) {
							this.cropWidth = Math.max(this.cropWidth + this.cropLeft, 0);
							this.cropLeft = 0;
						}
					}
					
					imageContainerNode = this.get('imageContainerNode');
					containerNode = imageContainerNode.ancestor();
					
					imageContainerNode.setStyles({
						'width': this.cropWidth + 'px',
						'height': this.cropHeight + 'px'
					});
					containerNode.setStyles({
						'width': this.cropWidth + 'px',
						'height': this.cropHeight + 'px'
					});
				} else {
					//Crop resize not allowed, validate new size against crop
					if (this.cropTop + this.cropHeight > this.imageHeight) {
						this.cropTop = Math.max(0, this.imageHeight - this.cropHeight);
						this.imageHeight = this.cropTop + this.cropHeight;
						this.imageWidth = ~~(this.imageHeight * ratio);
					}
					if (this.cropLeft + this.cropWidth > this.imageWidth) {
						this.cropLeft = Math.max(0, this.imageWidth - this.cropWidth);
						this.imageWidth = this.cropLeft + this.cropWidth;
						this.imageHeight = ~~(this.imageWidth / ratio);
					}
				}
				
				image.setStyles({
					'margin': - this.cropTop + 'px 0 0 -' + this.cropLeft + 'px',
					'width': this.imageWidth + 'px',
					'height': this.imageHeight + 'px'
				});
				image.setAttribute('width', this.imageWidth);
				image.setAttribute('height', this.imageHeight);
				
				//Update size input values
				this._uiSetSizeInputValues(this.cropWidth, this.cropHeight);
			} else if (this.get('mode') == ImageResizer.MODE_ICON) {
				this.cropWidth = this.imageWidth;
				this.cropHeight = this.imageHeight;
				
				imageContainerNode = this.get('imageContainerNode');
				containerNode = imageContainerNode.ancestor();
				
				imageContainerNode.setStyles({
					'width': this.imageWidth + 'px',
					'height': this.imageHeight + 'px'
				});
				containerNode.setStyles({
					'width': this.imageWidth + 'px',
					'height': this.imageHeight + 'px'
				});
				image.setStyles({
					'width': this.imageWidth + 'px',
					'height': this.imageHeight + 'px'
				});
				
				image.setAttribute('width', this.imageWidth);
				image.setAttribute('height', this.imageHeight);
				
				//Update size input values
				this._uiSetSizeInputValues(this.imageWidth, this.imageHeight);
			} else {
				this.cropWidth = Math.max(0, this.imageWidth - this.cropLeft);
				this.cropHeight = Math.max(0, this.imageHeight - this.cropTop);
				
				image.setStyles({
					'backgroundSize': this.imageWidth + 'px ' + this.imageHeight + 'px'
				});
				
				//Update size input values
				this._uiSetSizeInputValues(this.imageWidth, this.imageHeight);
			}
		},
		
		/**
		 * Fix zoom when finished dragging slider
		 * 
		 * @private
		 */
		fixZoom: function () {
			this.zoomSlider.set('value', this.sizeToZoom(this.imageWidth, this.imageHeight), {silent: true});
		},
		
		/**
		 * Returns zoom by width and height
		 * 
		 * @param {Number} width Image width
		 * @param {Number} height Image height
		 * @return Image zoom
		 * @type {Number}
		 */
		sizeToZoom: function (width, height) {
			var minImageWidth = 0,
				minImageHeight = 0;
			
			if (this.get('allowZoomResize') || this.get('mode') == ImageResizer.MODE_BACKGROUND || this.get('mode') == ImageResizer.MODE_ICON) {
				minImageWidth = this.minImageWidth;
				minImageHeight = this.minImageHeight;
			} else {
				minImageWidth = this.cropWidth;
				minImageHeight = this.cropHeight;
			}
			
			if (this.get('maxImageWidth') - minImageWidth < this.get('maxImageHeight') - minImageHeight) {
				return Math.round((width - minImageWidth) / (this.get('maxImageWidth') - minImageWidth) * 100);
			} else {
				return Math.round((height - minImageHeight) / (this.get('maxImageHeight') - minImageHeight) * 100);
			}
		},
		
		/**
		 * Returns image width and height from zoom
		 * 
		 * @param {Number} zoom Image zoom
		 * @return Image width and height
		 * @type {Array}
		 */
		zoomToSize: function (zoom) {
			var width = 0,
				height = 0,
				ratio = 0,
				minImageWidth = 0,
				minImageHeight = 0;
			
			if (this.get('allowZoomResize') || this.get('mode') == ImageResizer.MODE_BACKGROUND || this.get('mode') == ImageResizer.MODE_ICON) {
				minImageWidth = this.minImageWidth;
				minImageHeight = this.minImageHeight;
			} else {
				minImageWidth = this.cropWidth;
				minImageHeight = this.cropHeight;
			}
			
			if (this.imageWidth > this.imageHeight) {
				ratio = (this.get('maxImageWidth') / this.get('maxImageHeight'));
				width = (this.get('maxImageWidth') - minImageWidth) * zoom / 100 + minImageWidth;
				height = width / ratio;
			} else {
				ratio = (this.get('maxImageHeight') / this.get('maxImageWidth'));
				height = (this.get('maxImageHeight') - minImageHeight) * zoom / 100 + minImageHeight;
				width = height / ratio;
			}
			
			return [Math.round(width), Math.round(height)];
		},
		
		
		/* ------------------------ Width & height change ------------------------- */
		
		
		/**
		 * Handle width change
		 * 
		 * @private
		 */
		widthChange: function (e, type) {
			if (this.sizeInputValuesChanging) return;
			
			var height = 0,
				width  = parseInt(e.newVal || e.value, 10),
				mode   = this.get('mode');
			
			if (mode == ImageResizer.MODE_IMAGE) {
				if (width == this.cropWidth) return;
				width = width || this.cropWidth;
				
				if (this.get('ratioLocked')) {
					height = Math.round(width * this.cropHeight / this.cropWidth);
				} else {
					height  = this.cropHeight;
				}
				
				this.sizeChangeImage(width, height, type);
			} else if (mode == ImageResizer.MODE_BACKGROUND) {
				if (width == this.imageWidth) return;
				width = width || this.imageWidth;
				this.sizeChangeBackground(width, null, type);
			} else {
				if (width == this.cropWidth) return;
				this.sizeChangeIcon(width || this.cropWidth, null, type);
			}
		},
		
		/**
		 * Handle height change
		 * 
		 * @private
		 */
		heightChange: function (e, type) {
			if (this.sizeInputValuesChanging) return;
			
			var height = parseInt(e.newVal || e.value, 10),
				width  = 0,
				mode   = this.get('mode');
			
			if (mode == ImageResizer.MODE_IMAGE) {
				if (height == this.cropHeight) return;
				height = height || this.cropHeight;
				
				if (this.get('ratioLocked')) {
					width = Math.round(height * this.cropWidth / this.cropHeight);
				} else {
					width  = this.cropWidth;
				}
				
				this.sizeChangeImage(width, height, type);
			} else if (mode == ImageResizer.MODE_BACKGROUND) {
				if (height == this.imageHeight) return;
				height = height || this.imageHeight;
				this.sizeChangeBackground(null, height, type);
			} else {
				if (height == this.cropHeight) return;
				this.sizeChangeIcon(null, height || this.cropHeight, type)
			}
		},
		
		/**
		 * Handle width and height change for image
		 * 
		 * @private
		 */
		sizeChangeImage: function (sizeX, sizeY, input_type) {
			if (!this.get('imageContainerNode')) return;
			this.sizeInputValuesChanging = true;
			
			var image = this.get('image'),
				node = this.get('imageContainerNode'),
				containerNode = node.ancestor(),
				
				imageWidth = this.imageWidth,
				imageHeight = this.imageHeight,
				
				cropTop = this.cropTop,
				cropLeft = this.cropLeft,
				
				cropWidth = this.cropWidth,
				cropHeight = this.cropHeight,
				
				minW = this.get('minCropWidth'),
				maxW = this.get('maxCropWidth'),
				minH = this.get('minCropHeight'),
				maxH = this.get('maxCropHeight'),
				
				locked = this.get('ratioLocked'),
				lock_ratio  = 0,
				changed_x = true,
				changed_y = true,
				itt = 2;
		
			// Image
			lock_ratio  = cropWidth / cropHeight;
		
			while ((changed_x || changed_y) && itt) {
				changed_x = false;
				changed_y = false;
				
				// Update X
				if (sizeX < minW) {
					sizeX = minW;
					changed_x = true;
				}
				if (maxW && sizeX > maxW) {
					sizeX = maxW;
					changed_x = true;
				}
				if (sizeX > imageWidth - cropLeft) {
					cropLeft = Math.max(0, imageWidth - sizeX);
					sizeX = imageWidth - cropLeft;
					changed_x = true;
				}
				
				if (changed_x && locked) {
					sizeY = Math.round(sizeX / lock_ratio);
				}
				
				// Update Y
				if (sizeY < minH) {
					sizeY = minH;
					changed_y = true;
				}
				if (maxH && sizeY > maxH) {
					sizeY = maxH;
					changed_y = true;
				}
				if (sizeY > imageHeight - cropTop) {
					cropTop = Math.max(0, imageHeight - sizeY);
					sizeY = imageHeight - cropTop;
					changed_y = true;
				}
				
				if (changed_y && locked) {
					sizeX = Math.round(sizeY * lock_ratio);
				}
				
				if (!locked) {
					changed_x = false;
					changed_y = false;
				}
				
				itt--;
			}
			
			if (this.cropTop != cropTop || this.cropLeft != cropLeft) {
				this.cropTop = cropTop;
				this.cropLeft = cropLeft;
				
				image.setStyle('margin', - cropTop + 'px 0 0 -' + cropLeft + 'px');
			}
			
			if (this.cropWidth != sizeX || this.cropHeight != sizeY) {
				this.cropWidth = sizeX;
				this.cropHeight = sizeY;
				
				node.setStyles({
					'width': sizeX,
					'height': sizeY
				});
				containerNode.setStyles({
					'width': sizeX,
					'height': sizeY
				});
				
				// Update size input values
				if (input_type !== 'width') {
					this.inputWidth.set('value', sizeX);
				}
				if (input_type !== 'height') {
					this.inputHeight.set('value', sizeY);
				}
				
				this.fixZoom();
			}
			
			this.sizeInputValuesChanging = false;
		},
		
		/**
		 * Handle width and height change for icon
		 * 
		 * @private
		 */
		sizeChangeIcon: function (sizeX, sizeY, input_type) {
			this.sizeInputValuesChanging = true;
			
			var node = this.get('imageContainerNode'),
				image = this.get('image'),
				minW = this.get('minCropWidth'),
				maxW = this.get('maxCropWidth'),
				minH = this.get('minCropHeight'),
				maxH = this.get('maxCropHeight'),
				imageHeight = this.imageHeight,
				imageWidth = this.imageWidth,
				ratio = (maxW && maxH ? maxW / maxH : (minW && minH ? minW / minH : imageWidth / imageHeight)),
				containerNode = node.ancestor();
			
			if (!sizeX) {
				sizeX = sizeY * ratio;
			} else if (!sizeY) {
				sizeY = sizeX / ratio;
			}
			
			if (!node) return;
			
			if (sizeX < minW) {
				sizeX = minW;
				sizeY = Math.round(sizeX / ratio);
			}
			if (sizeY < minH) {
				sizeY = minH;
				sizeX = Math.round(sizeY * ratio);
			}
			if (maxW && sizeX > maxW) {
				sizeX = maxW;
				sizeY = Math.round(sizeX / ratio);
			}
			if (maxH && sizeY > maxH) {
				sizeY = maxH;
				sizeX = Math.round(sizeY * ratio);
			}
			
			if (this.cropWidth != sizeX || this.cropHeight != sizeY) {
				this.cropWidth = this.imageWidth = sizeX;
				this.cropHeight = this.imageHeight = sizeY;
				
				// Update size input values
				this.inputWidth.set('value', sizeX);
				this.inputHeight.set('value', sizeY);
				
				node.setStyles({
					'width': sizeX,
					'height': sizeY
				});
				containerNode.setStyles({
					'width': sizeX,
					'height': sizeY
				});
				image.setStyles({
					'width': sizeX,
					'height': sizeY
				});
				
				image.setAttribute('width', sizeX + 'px');
				image.setAttribute('height', sizeY + 'px');
				
				// Update size input values
				if (input_type !== 'width') {
					this.inputWidth.set('value', sizeX);
				}
				if (input_type !== 'height') {
					this.inputHeight.set('value', sizeY);
				}
				
				this.fixZoom();
			}
			
			this.sizeInputValuesChanging = false;
		},
		
		/**
		 * Handle width and height change for background image
		 * 
		 * @private
		 */
		sizeChangeBackground: function (sizeX, sizeY, input_type) {
			var image  = this.get('image'),
				width  = sizeX,
				height = sizeY,
				maxImageWidth = this.get('maxImageWidth'),
				maxImageHeight = this.get('maxImageHeight'),
				minImageWidth = this.minImageWidth,
				minImageHeight = this.minImageHeight,
				ratio = (maxImageWidth / maxImageHeight);
			
			if (!width) {
				width = Math.round(height * ratio);
			} else if (!height) {
				height = Math.round(width / ratio);
			}
			
			if (width < minImageWidth) {
				width = minImageWidth;
				height = Math.round(width / ratio);
			}
			if (height < minImageHeight) {
				height = minImageHeight;
				width = Math.round(height * ratio);
			}
			if (width > maxImageWidth) {
				width = maxImageWidth;
				height = Math.round(width / ratio);
			}
			if (height > maxImageHeight) {
				height = maxImageHeight;
				width = Math.round(height * ratio);
			}
			
			if (width != this.imageWidth || height != this.imageHeight) {
				this.imageWidth = width;
				this.imageHeight = height;
				
				this.cropWidth = Math.max(0, width - this.cropLeft);
				this.cropHeight = Math.max(0, height - this.cropTop);
				
				image.setStyles({
					'backgroundSize': this.imageWidth + 'px ' + this.imageHeight + 'px'
				});
				
				// Update size input values
				if (input_type !== 'width') {
					this.inputWidth.set('value', width);
				}
				if (input_type !== 'height') {
					this.inputHeight.set('value', height);
				}
				
				this.fixZoom();
			}
		},
		
		/**
		 * Toggle ratio lock state
		 * 
		 * @private
		 */
		toggleRatioLock: function () {
			this.set('ratioLocked', !this.get('ratioLocked'));
		},
		
		
		/* --------------------------------- Drag --------------------------------- */
		
		
		/**
		 * Start dragging
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		dragStart: function (e) {
			this.resetPointerCache();
			
			var pointer = this.getPointerPosition(e),
				clientX = pointer[0],
				clientY = pointer[1],
				doc = this.get('doc');
			
			if (this.resizeActive || this.moveActive) {
				//If user released mouse outside browser
				this.dragEnd(e);
			}
			
			this.eventDrop = Y.Node(doc).on('mouseup', this.dragEnd, this);
			
			if (document !== doc) {
				this.eventDropMain = Y.Node(document).on('mouseup', this.dragEnd, this);
			}
			
			this.dragCropLeft = this.cropLeft;
			this.dragCropTop = this.cropTop;
			this.mouseStartX = clientX;
			this.mouseStartY = clientY;
			
			if (this.get('cursor') < 4) {
				//Resize
				this.resizeActive = true;
				
				if (this.get('mode') == ImageResizer.MODE_ICON) {
					this.eventMove = Y.Node(doc).on('mousemove', this.dragIconResize, this);
					
					if (document !== doc) {
						this.eventMoveMain = Y.Node(document).on('mousemove', this.dragIconResize, this);
					}
				} else {
					this.eventMove = Y.Node(doc).on('mousemove', this.dragResize, this);
					
					if (document !== doc) {
						this.eventMoveMain = Y.Node(document).on('mousemove', this.dragResize, this);
					}
				}
				
				this.dragStartW = this.dragW = this.cropWidth;
				this.dragStartH = this.dragH = this.cropHeight;
			} else if (this.get('mode') != ImageResizer.MODE_ICON) {
				//Move
				this.moveActive = true;
				this.eventMove = Y.Node(this.get('doc')).on('mousemove', this.dragMove, this);
				
				if (document !== doc) {
					this.eventMoveMain = Y.Node(document).on('mousemove', this.dragMove, this);
				}
				
				this.dragStartW = this.dragW = this.cropLeft;
				this.dragStartH = this.dragH = this.cropTop;
			}
			
			e.preventDefault();
		},
		
		/**
		 * Handle mouse move while dragging
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		dragMove: function (e) {
			var pointer = this.getPointerPosition(e),
				clientX = pointer[0],
				clientY = pointer[1],
				
				cursor = this.get('cursor'),
				deltaX = (clientX - this.mouseStartX) * (cursor == 0 || cursor == 3 || cursor == 4 ? -1 : 1),
				deltaY = (clientY - this.mouseStartY) * (cursor == 0 || cursor == 1 || cursor == 4 ? -1 : 1),
				sizeX  = this.dragStartW + deltaX,
				sizeY  = this.dragStartH + deltaY,
				mode   = this.get('mode');
			
			if (this.moveActive) {
				var node = this.get('image'),
					cropWidth = this.cropWidth,
					cropHeight = this.cropHeight,
					imageHeight = this.imageHeight,
					imageWidth = this.imageWidth;
				
				if (!node) return;
				
				if (sizeX < 0) sizeX = 0;
				if (sizeY < 0) sizeY = 0;
				
				if (mode == ImageResizer.MODE_IMAGE) {
					// Image
					if (sizeX + cropWidth > imageWidth) {
						sizeX = Math.max(0, imageWidth - cropWidth);
					}
					if (sizeY + cropHeight > imageHeight) {
						sizeY = Math.max(0, imageHeight - cropHeight);
					}
				} else {
					// Background
					if (sizeX > imageWidth) {
						sizeX = imageWidth;
					}
					if (sizeY > imageHeight) {
						sizeY = imageHeight;
					}
				}
				
				if (sizeX != this.dragCropLeft || sizeY != this.dragCropTop) {
					this.dragCropLeft = sizeX;
					this.dragCropTop  = sizeY;
					
					if (mode == ImageResizer.MODE_IMAGE) {
						node.setStyle('margin', - sizeY + 'px 0 0 -' + sizeX + 'px');
					} else {
						node.setStyle('backgroundPosition', - sizeX + 'px -' + sizeY + 'px');
					}
				}
			}
		},
		
		/**
		 * Handle mouse move while resizing
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		dragResize: function (e) {
			var pointer = this.getPointerPosition(e),
				clientX = pointer[0],
				clientY = pointer[1],
				
				cursor = this.get('cursor'),
				deltaX = (clientX - this.mouseStartX) * (cursor == 0 || cursor == 3 || cursor == 4 ? -1 : 1),
				deltaY = (clientY - this.mouseStartY) * (cursor == 0 || cursor == 1 || cursor == 4 ? -1 : 1),
				sizeX  = this.dragStartW + deltaX,
				sizeY  = this.dragStartH + deltaY,
				mode   = this.get('mode');
			
			if (this.resizeActive) {
				var image = this.get('image'),
					node = this.get('imageContainerNode'),
					minW = this.get('minCropWidth'),
					maxW = this.get('maxCropWidth'),
					minH = this.get('minCropHeight'),
					maxH = this.get('maxCropHeight'),
					cropTop = this.dragCropTop,
					cropLeft = this.dragCropLeft,
					imageHeight = this.imageHeight,
					imageWidth = this.imageWidth,
					allowCropZooming = this.get('allowCropZooming'),
					containerNode = node.ancestor();
				
				if (!node) return;
				
				if (sizeX < minW) sizeX = minW;
				if (maxW && sizeX > maxW) sizeX = maxW;
				if (sizeY < minH) sizeY = minH;
				if (maxH && sizeY > maxH) sizeY = maxH;
				
				if (allowCropZooming) {
					var maxImageWidth = this.get('maxImageWidth'),
						maxImageHeight = this.get('maxImageHeight'),
						ratio = maxImageWidth / maxImageHeight;
					
					if (sizeX > imageWidth) {
						sizeX = imageWidth = Math.min(sizeX, maxImageWidth);
						imageHeight = Math.min(Math.round(sizeX / ratio));
					}
					if (sizeY > imageHeight) {
						sizeY = imageHeight = Math.min(sizeY, maxImageHeight);
						imageWidth = Math.min(Math.round(sizeY * ratio));
					}
				}
				
				if (sizeY > imageHeight - cropTop) {
					cropTop = Math.max(0, imageHeight - sizeY);
					sizeY = imageHeight - cropTop;
				}
				if (sizeX > imageWidth - cropLeft) {
					cropLeft = Math.max(0, imageWidth - sizeX);
					sizeX = imageWidth - cropLeft;
				}
				
				if (this.dragW != sizeX || this.dragH != sizeY) {
					this.dragW = sizeX;
					this.dragH = sizeY;
					
					node.setStyles({
						'width': sizeX,
						'height': sizeY
					});
					containerNode.setStyles({
						'width': sizeX,
						'height': sizeY
					});
					
					//Update size input values
					this._uiSetSizeInputValues(sizeX, sizeY);
				}
				
				if (allowCropZooming && this.imageWidth != imageWidth && this.imageHeight != imageHeight) {
					this.imageWidth = imageWidth;
					this.imageHeight = imageHeight;
					
					image.setStyles({
						'width': imageWidth + 'px',
						'height': imageHeight + 'px'
					});
					image.setAttribute('width', imageWidth);
					image.setAttribute('height', imageHeight);
				}
				
				if (this.dragCropTop != cropTop || this.dragCropLeft != cropLeft) {
					this.dragCropTop = cropTop;
					this.dragCropLeft = cropLeft;
					
					image.setStyle('margin', - cropTop + 'px 0 0 -' + cropLeft + 'px');
				}
			}
		},
		
		/**
		 * Handle mouse move while resizing icon
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		dragIconResize: function (e) {
			var pointer = this.getPointerPosition(e),
				clientX = pointer[0],
				clientY = pointer[1],
				
				cursor = this.get('cursor'),
				deltaX = (clientX - this.mouseStartX) * (cursor == 0 || cursor == 3 || cursor == 4 ? -1 : 1),
				deltaY = (clientY - this.mouseStartY) * (cursor == 0 || cursor == 1 || cursor == 4 ? -1 : 1),
				delta  = Math.max(deltaX, deltaY),
				sizeX  = this.dragStartW + delta,
				sizeY  = this.dragStartH + delta;
			
			if (this.resizeActive) {
				var node = this.get('imageContainerNode'),
					image = this.get('image'),
					minW = this.get('minCropWidth'),
					maxW = this.get('maxCropWidth'),
					minH = this.get('minCropHeight'),
					maxH = this.get('maxCropHeight'),
					imageHeight = this.imageHeight,
					imageWidth = this.imageWidth,
					ratio = (maxW && maxH ? maxW / maxH : (minW && minH ? minW / minH : imageWidth / imageHeight)),
					containerNode = node.ancestor();
				
				if (!node) return;
				
				if (sizeX < minW) {
					sizeX = minW;
					sizeY = Math.round(sizeX / ratio);
				}
				if (sizeY < minH) {
					sizeY = minH;
					sizeX = Math.round(sizeY * ratio);
				}
				if (maxW && sizeX > maxW) {
					sizeX = maxW;
					sizeY = Math.round(sizeX / ratio);
				}
				if (maxH && sizeY > maxH) {
					sizeY = maxH;
					sizeX = Math.round(sizeY * ratio);
				}
				
				if (this.dragW != sizeX || this.dragH != sizeY) {
					this.dragW = sizeX;
					this.dragH = sizeY;
					
					node.setStyles({
						'width': sizeX,
						'height': sizeY
					});
					containerNode.setStyles({
						'width': sizeX,
						'height': sizeY
					});
					image.setStyles({
						'width': sizeX,
						'height': sizeY
					});
					
					image.setAttribute('width', sizeX + 'px');
					image.setAttribute('height', sizeY + 'px');
					
					//Update size input values
					this._uiSetSizeInputValues(sizeX, sizeY);
				}
			}
		},
		
		/**
		 * Stop drag
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		dragEnd: function (e) {
			if (this.resizeActive || this.moveActive) {
				this.eventDrop.detach();
				this.eventDrop = null;
				
				this.eventMove.detach();
				this.eventMove = null;
				
				if (this.eventDropMain) {
					this.eventDropMain.detach();
					this.eventDropMain = null;	
				}
				
				if (this.eventMoveMain) {
					this.eventMoveMain.detach();
					this.eventMoveMain = null;	
				}
				
				if (this.resizeActive) { // resize
					this.cropLeft = this.dragCropLeft;
					this.cropTop = this.dragCropTop;
					this.cropWidth = this.dragW;
					this.cropHeight = this.dragH;
					
					if (this.get('mode') == ImageResizer.MODE_ICON) {
						this.cropLeft = this.cropTop = 0;
						this.imageWidth = this.cropWidth;
						this.imageHeight = this.cropHeight;
					}
					
					//Update size input values
					this._uiSetSizeInputValues(this.cropWidth, this.cropHeight);
				} else { // move
					this.cropLeft = this.dragCropLeft;
					this.cropTop = this.dragCropTop;
				}
			
				e.preventDefault();
				
				//Reset cursor
				this.set('cursor', 4);
			}
			
			this.resizeActive = false;
			this.moveActive = false;
			this.fixZoom();
		},
		
		/**
		 * Handle document click outside of image
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		documentClick: function (e) {
			var image = this.get('image');
			if (this.get('autoClose') && image && e.target && !e.target.closest('span.supra-icon') && !e.target.closest('span.supra-image') && !e.target.closest('.supra-background-editing')) {
				this.set('image', null);
			}
		},
		
		/**
		 * Returns pointer position relative to the window of attribute doc 
		 * 
		 * @param {Event} e Event facade object
		 * @returns {Array} Array with x and y coordinates of pointer
		 * @private
		 */
		getPointerPosition: function (e) {
			var x          = 0,
				y          = 0,
				target     = e.target.getDOMNode(),
				doc_target = target.ownerDocument,
				doc        = this.get('doc'),
				offset     = this._iframeOffset,
				iframes    = null,
				iframe     = null,
				i          = 0,
				ii         = 0,
				tmp        = null;
			
			if (e.type.indexOf('touch') == -1) {
				// Mouse cursor
				x = e.clientX;
				y = e.clientY;
			} else {
				// Touch
				// @TODO In the future
				// x = e.touches[0].clientX;
				// y = e.touches[0].clientY;
			}
			
			if (doc !== doc_target) {
				// Adjust position by removing iframe position
				if (!offset) {
					// Find iframe
					iframes = Y.all('iframe');
					
					for (ii=iframes.size(); i<ii; i++) {
						tmp = iframes.item(i).getDOMNode();
						if ((tmp.contentDocument || tmp.contentWindow.document) === doc) {
							iframe = tmp; break;
						}
					}
					
					// Get offset
					offset = this._iframeOffset = (iframe ? Y.DOM.getXY(iframe) : [0, 0]);
				}
				
				x -= offset[0];
				y -= offset[1];
			}
			
			return [x, y];
		},
		
		/**
		 * Reset pointer cache
		 * 
		 * @private
		 */
		resetPointerCache: function () {
			this._iframeOffset = null;
		},
		
		
		/* --------------------------------- Image --------------------------------- */
		
		
		/**
		 * Set up needed elements for image resizing
		 * 
		 * @param {Y.Node} image Image node
		 * @private
		 */
		setUpImage: function (image) {
			var doc = this.get('doc'),
				resizeHandleNode = Y.Node(doc.createElement('SPAN')), // create in correct document
				imageContainerNode = Y.Node(doc.createElement('SPAN')),
				containerNode = image.ancestor(),
				width = containerNode.get('offsetWidth'),
				height = containerNode.get('offsetHeight');
			
			resizeHandleNode.addClass('supra-image-resize');
			containerNode.append(resizeHandleNode);
			resizeHandleNode.on('mousemove', this.setMouseCursor, this);
			resizeHandleNode.on('mouseleave', this.unsetMouseCursor, this);
			resizeHandleNode.on('mousedown', this.dragStart, this);
			this.set('resizeHandleNode', resizeHandleNode);
			
			imageContainerNode.addClass('supra-image-inner');
			containerNode.append(imageContainerNode);
			imageContainerNode.append(image);
			this.set('imageContainerNode', imageContainerNode);
			
			imageContainerNode.setStyles({
				'width': width,
				'height': height
			});
			containerNode.setStyles({
				'width': width,
				'height': height
			});
			
			image.setAttribute('unselectable', 'on');
			containerNode.setAttribute('contentEditable', 'false');
			containerNode.addClass('supra-image-editing');
			
			this.imageWidth = image.get('offsetWidth');
			this.imageHeight = image.get('offsetHeight');
			this.cropWidth = width;
			this.cropHeight = height;
			this.cropLeft = Math.max(0, - parseInt(image.getStyle('marginLeft'), 10) || 0);
			this.cropTop  = Math.max(0, - parseInt(image.getStyle('marginTop'), 10) || 0);
			
			//If image is not loaded, then width and height could be 0
			if (!this.imageWidth || !this.imageHeight) {
				image.on('load', function (event, image) {
					this.imageWidth = image.get('offsetWidth');
					this.imageHeight = image.get('offsetHeight');
				}, this, image);
			}
			
			//Update size input values
			this._uiSetSizeInputValues(this.cropWidth, this.cropHeight);
			
			//Calculate min image width and height for zoom
			var maxImageWidth = this.get('maxImageWidth'),
				maxImageHeight = this.get('maxImageHeight'),
				minImageWidth = this.get('minCropWidth'),
				minImageHeight = this.get('minCropHeight'),
				ratio = maxImageWidth / maxImageHeight;
			
			if (minImageWidth / ratio < minImageHeight) {
				minImageWidth = Math.ceil(minImageHeight * ratio);
			}
			if (minImageHeight * ratio < minImageWidth) {
				minImageHeight = Math.ceil(minImageWidth / ratio);
			}
			
			this.minImageWidth = minImageWidth;
			this.minImageHeight = minImageHeight;
			
			this.setUpPanel();
		},
		
		/**
		 * Remove all created elements and events
		 * 
		 * @param {Y.Node} image Image node
		 * @param {Boolean} silent Image is removed, but another will be set shortly
		 * @private
		 */
		tearDownImage: function (image, silent) {
			if (!image) return;
			
			if (!this.get('imageContainerNode')) {
				// Already teared down, 'resize' event triggered this again
				return;
			}
			
			var imageContainerNode = this.get('imageContainerNode'),
				resizeHandleNode = this.get('resizeHandleNode'),
				containerNode = imageContainerNode.ancestor();
			
			image.removeAttribute('unselectable');
			containerNode.append(image);
			containerNode.removeClass('supra-image-editing');
			containerNode.setStyles({
				'width': this.cropWidth,
				'height': this.cropHeight
			});
			
			resizeHandleNode.remove(true);
			this.set('resizeHandleNode', null);
			
			imageContainerNode.remove(true);
			this.set('imageContainerNode', null);
			
			if (this.adjustmentPanel) {
				this.adjustmentPanel.hide();
			}
			
			this.fire('resize', {
				'image': image,
				'cropLeft': this.cropLeft,
				'cropTop': this.cropTop,
				'cropWidth': this.cropWidth,
				'cropHeight': this.cropHeight,
				'imageWidth': this.imageWidth,
				'imageHeight': this.imageHeight,
				'silent': !!silent
			});
		},
		
		
		/* --------------------------------- Background --------------------------------- */
		
		
		/**
		 * Set up needed elements for background resizing
		 * 
		 * @param {Y.Node} image Node which background is resized
		 * @private
		 */
		setUpBackground: function (image) {
			var doc = this.get('doc'),
				resizeHandleNode = Y.Node(doc.createElement('SPAN')), // create in correct document
				containerNode = image;
			
			resizeHandleNode.addClass('supra-image-resize');
			resizeHandleNode.addClass('supra-image-resize-move');
			image.append(resizeHandleNode);
			resizeHandleNode.on('mousedown', this.dragStart, this);
			this.set('resizeHandleNode', resizeHandleNode);
			
			image.addClass('supra-background-editing');
			
			this.imageWidth = this.cropWidth = this.get('maxImageWidth');
			this.imageHeight = this.cropHeight = this.get('maxImageHeight');
			this.cropLeft = 0;
			this.cropTop = 0;
			
			var backgroundSize = image.getStyle('backgroundSize').match(/(\d+)px\s+(\d+)px/);
			if (backgroundSize) {
				this.cropWidth = this.imageWidth = parseInt(backgroundSize[1], 10) || this.cropWidth;
				this.cropHeight = this.imageHeight = parseInt(backgroundSize[2], 10) || this.cropHeight;
			}
			
			var backgroundPosition = image.getStyle('backgroundPosition').match(/(\-?\d+)px\s+(\-?\d+)px/);
			if (backgroundPosition) {
				this.cropLeft = Math.max(0, - parseInt(backgroundPosition[1], 10) || 0);
				this.cropTop = Math.max(0, - parseInt(backgroundPosition[2], 10) || 0);
				this.cropWidth -= this.cropLeft;
				this.cropHeight -= this.cropTop;
			}
			
			//Update size input values
			this._uiSetSizeInputValues(this.cropWidth, this.cropHeight);
			
			//Calculate min image width and height for zoom
			var maxImageWidth = this.get('maxImageWidth'),
				maxImageHeight = this.get('maxImageHeight'),
				minImageWidth = this.get('minCropWidth'),
				minImageHeight = this.get('minCropHeight'),
				ratio = maxImageWidth / maxImageHeight;
			
			if (minImageWidth / ratio < minImageHeight) {
				minImageWidth = Math.ceil(minImageHeight * ratio);
			}
			if (minImageHeight * ratio < minImageWidth) {
				minImageHeight = Math.ceil(minImageWidth / ratio);
			}
			
			this.minImageWidth = minImageWidth;
			this.minImageHeight = minImageHeight;
			
			this.setUpPanel();
		},
		
		/**
		 * Remove all created elements and events
		 * 
		 * @param {Y.Node} image Node which background was resized
		 * @param {Boolean} silent Image is removed, but another will be set shortly
		 * @private
		 */
		tearDownBackground: function (image, silent) {
			if (!image) return;
			
			var resizeHandleNode = this.get('resizeHandleNode');
			
			image.removeClass('supra-background-editing');
			
			resizeHandleNode.remove(true);
			this.set('resizeHandleNode', null);
			
			this.fire('resize', {
				'image': image,
				'cropLeft': this.cropLeft,
				'cropTop': this.cropTop,
				'cropWidth': this.cropWidth,
				'cropHeight': this.cropHeight,
				'imageWidth': this.imageWidth,
				'imageHeight': this.imageHeight,
				'silent': !!silent
			});
			
			if (this.adjustmentPanel) {
				this.adjustmentPanel.hide();
			}
		},
		
		
		/* --------------------------------- Icon --------------------------------- */
		
		
		/**
		 * Set up needed elements for background resizing
		 * 
		 * @param {Y.Node} image Node which background is resized
		 * @private
		 */
		setUpIcon: function (image) {
			var doc = this.get('doc'),
				resizeHandleNode = Y.Node(doc.createElement('SPAN')), // create in correct document
				imageContainerNode = Y.Node(doc.createElement('SPAN')),
				containerNode = image.ancestor(),
				width = containerNode.get('offsetWidth'),
				height = containerNode.get('offsetHeight');
			
			resizeHandleNode.addClass('supra-image-resize');
			containerNode.append(resizeHandleNode);
			resizeHandleNode.on('mousemove', this.setMouseCursor, this);
			resizeHandleNode.on('mouseleave', this.unsetMouseCursor, this);
			resizeHandleNode.on('mousedown', this.dragStart, this);
			this.set('resizeHandleNode', resizeHandleNode);
			
			imageContainerNode.addClass('supra-image-inner');
			containerNode.append(imageContainerNode);
			imageContainerNode.append(image);
			this.set('imageContainerNode', imageContainerNode);
			
			imageContainerNode.setStyles({
				'width': width,
				'height': height
			});
			containerNode.setStyles({
				'width': width,
				'height': height
			});
			
			image.setAttribute('unselectable', 'on');
			containerNode.setAttribute('contentEditable', 'false');
			containerNode.addClass('supra-icon-editing');
			
			this.cropWidth = this.imageWidth = image.get('offsetWidth');
			this.cropHeight = this.imageHeight = image.get('offsetHeight');
			this.cropLeft = this.cropTop = 0;
			
			//SVGAnimateLength object
			if (!this.cropWidth && !this.cropHeight) {
				this.cropWidth = this.imageWidth = Supra.getObjectValue(image.get('width'), ['baseVal', 'value']) || 0;
				this.cropHeight = this.imageHeight = Supra.getObjectValue(image.get('height'), ['baseVal', 'value']) || 0;
			}
			
			//Update size input values
			this._uiSetSizeInputValues(this.cropWidth, this.cropHeight);
			
			//Calculate min image width and height for zoom
			var maxImageWidth = this.get('maxImageWidth'),
				maxImageHeight = this.get('maxImageHeight'),
				minImageWidth = this.get('minCropWidth'),
				minImageHeight = this.get('minCropHeight'),
				ratio = maxImageWidth / maxImageHeight;
			
			if (minImageWidth / ratio < minImageHeight) {
				minImageWidth = Math.ceil(minImageHeight * ratio);
			}
			if (minImageHeight * ratio < minImageWidth) {
				minImageHeight = Math.ceil(minImageWidth / ratio);
			}
			
			this.minImageWidth = minImageWidth;
			this.minImageHeight = minImageHeight;
			
			this.setUpPanel();
		},
		
		/**
		 * Remove all created elements and events
		 * 
		 * @param {Y.Node} image Node which background was resized
		 * @param {Boolean} silent Image is removed, but another will be set shortly
		 * @private
		 */
		tearDownIcon: function (image, silent) {
			if (!image) return;
			
			if (!this.get('imageContainerNode')) {
				// Already teared down, 'resize' event triggered this again
				return;
			}
			
			var imageContainerNode = this.get('imageContainerNode'),
				resizeHandleNode = this.get('resizeHandleNode'),
				containerNode = imageContainerNode.ancestor();
			
			image.removeAttribute('unselectable');
			containerNode.append(image);
			containerNode.removeClass('supra-icon-editing');
			containerNode.setStyles({
				'width': this.imageWidth,
				'height': this.imageHeight
			});
			
			resizeHandleNode.remove(true);
			this.set('resizeHandleNode', null);
			
			imageContainerNode.remove(true);
			this.set('imageContainerNode', null);
			
			if (this.adjustmentPanel) {
				this.adjustmentPanel.hide();
			}
			
			this.fire('resize', {
				'image': image,
				'imageWidth': this.imageWidth,
				'imageHeight': this.imageHeight,
				'silent': !!silent
			});
		},
		
		
		/* --------------------------------- Attributes --------------------------------- */
		
		
		/**
		 * Image attribute setter
		 * 
		 * @param {Y.Node} image
		 * @return New attribute value
		 * @type {Y.Node}
		 */
		_setImageAttr: function (image) {
			var image = image ? (image.getDOMNode ? image : Y.Node(image)) : null,
				doc = image ? image.getDOMNode().ownerDocument : null,
				silent = !!image;
			
			if (this.get('image')) {
				
				if (this.get('mode') == ImageResizer.MODE_IMAGE) {
					this.tearDownImage(this.get('image'), silent);
				} else if (this.get('mode') == ImageResizer.MODE_ICON) {
					this.tearDownIcon(this.get('image'), silent);
				} else {
					this.tearDownBackground(this.get('image'), silent);
				}
			}
			
			if (this.eventClick) {
				this.eventClick.detach();
				this.eventClick = null;
			}
			
			if (image) {
				this.set('doc', doc);
				
				if (this.get('mode') == ImageResizer.MODE_IMAGE) {
					this.setUpImage(image);
				} else if (this.get('mode') == ImageResizer.MODE_ICON) {
					this.setUpIcon(image);
				} else {
					this.setUpBackground(image);
				}
				
				this.eventClick = Y.Node(doc).on('mousedown', this.documentClick, this);
			}
			
			return image;
		},
		
		/**
		 * Cursor attribute value setter
		 * Set classname to show which one is choosen
		 * 
		 * @param {Number} cursor
		 * @return New attribute value
		 * @type {Number}
		 */
		_setCursorAttr: function (cursor) {
			var node = this.get('resizeHandleNode');
			if (node) {
				node.replaceClass(
					this.getCursorClassName(this.get('cursor')),
					this.getCursorClassName(cursor)
				);
			}
			return cursor;
		},
		
		/**
		 * Mode attribute setter
		 * 
		 * @param {String} cursor
		 * @returns {String} New attribute value
		 */
		_setMode: function (mode) {
			var button = this.buttonRatio;
			
			// Width/height ratio should be locked
			if (button) {
				if (mode == ImageResizer.MODE_IMAGE) {
					button.set('disabled', false);
				} else {
					this.set('ratioLocked', true);
					button.set('disabled', true);
				}
			}
			
			return mode;
		},
		
		/**
		 * Ratio locked attribute setter
		 * 
		 * @param {Boolean} locked
		 * @returns {Boolean} New attribute value
		 */
		_setRatioLocked: function (locked) {
			locked = !!locked;
			
			var button = this.buttonRatio;
			if (button) {
				button.toggleClass('su-button-locked', locked);
			}
			
			return locked;
		},
		
		/**
		 * Set size input values
		 * 
		 * @param {Object} width
		 * @param {Object} height
		 */
		_uiSetSizeInputValues: function (width, height) {
			this.sizeInputValuesChanging = true;
			
			//Update size input values
			if (this.inputWidth) {
				this.inputWidth.set('value', width);
				this.inputHeight.set('value', height);
			}
			
			this.sizeInputValuesChanging = false;
		},
		
		
		
	});
	
	Supra.ImageResizer = ImageResizer;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.panel', 'supra.slider', 'dd-plugin']});YUI().add("supra.htmleditor-plugin-image", function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/* Default image size */
		size: "200x200",
		
		/* Allow none, border, lightbox styles */
		styles: true
	};
	
	var defaultProps = {
		"type": null,
		"title": "",
		"description": "",
		"align": "middle",
		"style": "",
		"image": {}
	};
	
	var Manager = Supra.Manager;
	
	Supra.HTMLEditor.addPlugin("image", defaultConfiguration, {
		
		settings_form: null,
		selected_image: null,
		selected_image_id: null,
		original_data: null,
		silent: false,
		
		/**
		 * DropTarget object for editor srcNode
		 * @type {Object}
		 * @private
		 */
		drop: null,
		
		/**
		 * List of image styles
		 * @type {Array}
		 * @private
		 */
		image_styles: null,
		
		/**
		 * Manage image
		 * @type {Object}
		 * @private
		 */
		resizer: null,
		
		/**
		 * Click event
		 * @type {Object}
		 * @private
		 */
		clickEvent: null,
		
		
		/**
		 * Generate settings form
		 */
		createSettingsForm: function () {
			//Get form placeholder
			var content = Manager.getAction("PageContentSettings").get("contentInnerNode");
			if (!content) return;
			
			//Properties form
			var form_config = {
				"inputs": [
					{"id": "title", "type": "String", "label": Supra.Intl.get(["htmleditor", "image_title"]), "value": ""},
					{"id": "description", "type": "String", "label": Supra.Intl.get(["htmleditor", "image_description"]), "value": ""},
					{"id": "align", "style": "minimal", "type": "SelectList", "label": Supra.Intl.get(["htmleditor", "image_alignment"]), "value": "right", "values": [
						{"id": "left", "title": Supra.Intl.get(["htmleditor", "alignment_left"]), "icon": "/cms/lib/supra/img/htmleditor/align-left-button.png"},
						{"id": "middle", "title": Supra.Intl.get(["htmleditor", "alignment_center"]), "icon": "/cms/lib/supra/img/htmleditor/align-center-button.png"},
						{"id": "right", "title": Supra.Intl.get(["htmleditor", "alignment_right"]), "icon": "/cms/lib/supra/img/htmleditor/align-right-button.png"}
					]},
					{"id": "style", "style": "minimal", "type": "SelectVisual", "label": Supra.Intl.get(["htmleditor", "image_style"]), "value": "default", "values": []}
				],
				"style": "vertical"
			};
			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			//On title, description, etc. change update image data
			for(var i=0,ii=form_config.inputs.length; i<ii; i++) {
				form.getInput(form_config.inputs[i].id).on("change", this.onPropertyChange, this);
			}
			
			//If in configuration styles are disabled, then hide buttons
			if (this.configuration.styles) {
				form.getInput("style").set("visible", true);
			} else {
				form.getInput("style").set("visible", false);
			}
			
			//Fill style list
			this.fillStylesList(form);
			
			//Add "Delete", "Edit" and "Replace buttons"
			//Replace button
			var btn = new Supra.Button({"label": Supra.Intl.get(["htmleditor", "image_replace"]), "style": "small-gray"});
				btn.render(form.get("contentBox"));
				btn.addClass("button-section");
				btn.on("click", this.replaceSelectedImage, this);
				
				//Move into correct place
				form.get("contentBox").prepend(btn.get("boundingBox"));
			
			//Delete button
			var btn = new Supra.Button({"label": Supra.Intl.get(["htmleditor", "image_delete"]), "style": "small-red"});
				btn.render(form.get("contentBox"));
				btn.addClass("su-button-delete");
				btn.on("click", this.removeSelectedImage, this);
			
			this.settings_form = form;
			return form;
		},
		
		/**
		 * Returns true if form is visible, otherwise false
		 */
		hideSettingsForm: function () {
			if (this.settings_form && this.settings_form.get("visible")) {
				Manager.PageContentSettings.hide();
			}
		},
		
		/**
		 * Apply settings changes
		 */
		settingsFormApply: function () {
			if (this.selected_image) {
				this.stopEditImage();
				
				var ancestor = this.getImageWrapperNode(this.selected_image);
				ancestor.removeClass("supra-image-selected");
				
				this.selected_image = null;
				this.selected_image_id = null;
				this.original_data = null;
				
				this.hideSettingsForm();
				this.hideMediaSidebar();
				
				//Property changed, update editor "changed" state
				this.htmleditor._changed();
			}
		},
		
		/**
		 * Fill styles list
		 */
		fillStylesList: function (form) {
			var container = this.htmleditor.get("srcNode"),
				styles = this.htmleditor.get("stylesheetParser").getSelectorsByNodeMatch(container)["IMG"],
				
				input  = form.getInput("style"),
				values = [{
							"id": "",
							"title": Supra.Intl.get(["htmleditor", "image_style_none"]),
							"icon": ""
						 }];
			
			if (styles && styles.length) {
				
				for (var i=0, ii=styles.length; i<ii; i++) {
					values.push({
						"id": styles[i].classname,
						"title": styles[i].attributes.title || styles[i].classname,
						"icon": styles[i].attributes.icon || ""
					});
				}
				
				input.set("values", values)
				input.show();
			} else {
				input.hide();
			}
			
			//Save to reuse when changing style
			this.image_styles = styles;
		},
		
		/**
		 * Replace selected image with another one from media library
		 * 
		 * @private
		 */
		replaceSelectedImage: function () {
			//Open Media library on "Replace"
			var image = this.selected_image,
				image_id = this.selected_image_id,
				data = this.original_data,
				path = null;
			
			if (image) {
				//Open settings form and open MediaSidebar
				this.stopEditImage();
				this.hideSettingsForm();
				
				//Restore selected image reference, which was removed in hideSettingsForm
				this.selected_image = image;
				this.selected_image_id = image_id;
				this.original_data = data;
				
				if (data && data.image && data.image.id) {
					path = [].concat(data.image.path || []).concat([data.image.id]);
				}
				
				Manager.getAction("MediaSidebar").execute({
					onselect: Y.bind(this.insertImage, this),
					item: path
				});
			}
		},
		
		/**
		 * Remove selected image
		 * 
		 * @private
		 */
		removeSelectedImage: function () {
			if (this.selected_image) {
				this.stopEditImage();
				
				var image = this.selected_image,
					container = image.ancestor();
				
				if (container.test(".supra-image")) {
					container.remove();
				} else {
					image.remove();
				}
				
				this.selected_image = null;
				this.selected_image_id = null;
				this.original_data = null;
				this.htmleditor.refresh(true);
				this.hideSettingsForm();
			}
		},
		
		/**
		 * Handle property input value change
		 * Save data and update UI
		 * 
		 * @param {Object} event Event
		 */
		onPropertyChange: function (event) {
			
			if (this.silent || !this.selected_image) return;
			
			var target = event.target,
				id = target.get("id"),
				imageId = this.selected_image_id,
				data = this.htmleditor.getData(imageId),
				value = (event.value !== undefined ? event.value : target.getValue());
			
			//Update image data
			if (imageId) {
				data[id] = value;
				this.htmleditor.setData(imageId, data);
			}
			
			this.setImageProperty(id, value);
		},
		
		/**
		 * Update image tag property
		 * 
		 * @param {String} id Property ID
		 * @param {String} value Property value
		 */
		setImageProperty: function (id, value, image) {
			if (!image) image = this.selected_image;
			
			var ancestor = this.getImageWrapperNode(image);
			
			if (id == "title") {
				image.setAttribute("title", value);
			} else if (id == "description") {
				image.setAttribute("alt", value);
			} else if (id == "align") {
				ancestor.removeClass("align-left").removeClass("align-right").removeClass("align-middle");
				image.removeClass("align-left").removeClass("align-right").removeClass("align-middle");
				
				if (value) {
					ancestor.addClass("align-" + value);
					image.addClass("align-" + value);
				}
			} else if (id == "size_width") {
				
				value = parseInt(value) || 0;
				var data = this.htmleditor.getData(this.selected_image_id),
					size = this.getImageDataBySize(data.image),
					ratio = size.width / size.height,
					height = value ? Math.round(value / ratio) : size.height,
					width = value || size.width;
				
				data.size_width = width;
				data.size_height = height;
				image.setAttribute("width", width);
				image.setAttribute("height", height);
				
			} else if (id == "size_height") {
				
				value = parseInt(value) || 0;
				var data = this.htmleditor.getData(this.selected_image_id),
					size = this.getImageDataBySize(data.image),
					ratio = size.width / size.height,
					width = value ? Math.round(value * ratio) : size.width,
					height = value || size.height;
				
				data.size_width = width;
				data.size_height = height;
				image.setAttribute("width", width);
				image.setAttribute("height", height);
				
			} else if (id == "style") {
				var styles = this.image_styles,
					s = 0,
					ss = styles.length;
				
				if (styles && styles.length) {
					for (; s<ss; s++) {
						if (styles[s].classname) {
							ancestor.removeClass(styles[s].classname);
							image.removeClass(styles[s].classname);
						}
					}
				}
				
				if (value) {
					ancestor.addClass(value);
					image.addClass(value);
				}
			} else if (id == "image") {
				image.setAttribute("src", this.getImageURLBySize(value));
				
				//If lightbox then also update link
				if (this.getImageProperty("style") == "lightbox") {
					this.setImageProperty("style", "lightbox", image);
				}
			} else if (id == "crop_width") {
				ancestor.setStyle("width", value + "px");
			} else if (id == "crop_height") {
				ancestor.setStyle("height", value + "px");
			} else if (id == "crop_left") {
				image.setStyle("marginLeft", - value + "px");
			} else if (id == "crop_top") {
				image.setStyle("marginTop", - value + "px");
			}
		},
		
		/**
		 * Returns image wrapper node
		 * If node doesn't exist then creates it
		 * 
		 * @param {HTMLElement} image Image element
		 * @return Image wrapper node
		 */
		getImageWrapperNode: function (image) {
			var ancestor = image.ancestor();
			
			if (ancestor) {
				if (!ancestor.test("span.supra-image")) {
					ancestor = ancestor.ancestor();
					if (ancestor && !ancestor.test("span.supra-image")) {
						ancestor = null;
					}
				}
			}
			
			if (!ancestor) {
				//Wrap image in <span class="supra-image">
				ancestor = Y.Node(this.htmleditor.get("doc").createElement("SPAN"));
				ancestor.addClass("supra-image");
				ancestor.setAttribute("contenteditable", false);
				ancestor.setAttribute("unselectable", "on");
				
				var data = this.getImageDataFromNode(image);
				if (!data) {
					// This image is not associated with any data,
					// there's nothing we can do about it
					return;
				}
				
				if (data.style) {
					ancestor.addClass(data.style);
				}
				if (data.align) {
					ancestor.addClass("align-" + data.align);
				}
				
				var crop_left   = data.crop_left   || image.getAttribute("data-crop-left")   || 0,
					crop_top    = data.crop_top    || image.getAttribute("data-crop-top")    || 0,
					crop_width  = data.crop_width  || image.getAttribute("data-crop-width")  || image.width,
					crop_height = data.crop_height || image.getAttribute("data-crop-height") || image.height,
					data_width  = data.size_width  || image.getAttribute("data-width")       || image.width,
					data_height = data.size_height || image.getAttribute("data-height")      || image.height;
				
				image.setAttribute("width", data_width);
				image.setAttribute("height", data_height);
				image.setStyles({
					"margin-left": crop_left ? -crop_left + "px" : "0px",
					"margin-top": crop_top ? -crop_top + "px" : "0px",
					"width": data_width ? data_width + "px" : "",
					"height": data_height ? data_height + "px" : ""
				});
				ancestor.setStyles({
					"width": crop_width ? crop_width + "px" : "auto",
					"height": crop_height ? crop_height + "px" : "auto"
				});
				
				//Set image to original
				var data = this.getImageDataFromNode(image),
					url  = this.getImageURLBySize(data.image, "original");
				
				image.setAttribute("src", url);
				image.removeAttribute("align");
				
				image.insert(ancestor, "before");
				ancestor.append(image);
			}
			
			return ancestor;
		},
		
		/**
		 * Returns image property value
		 * 
		 * @param {String} id
		 */
		getImageProperty: function (id) {
			if (this.selected_image) {
				var data = this.htmleditor.getData(this.selected_image_id);
				return id in data ? data[id] : null;
			}
			return null;
		},
		
		/**
		 * Returns image data from node
		 * 
		 * @param {HTMLElement} node Node
		 * @return Image data
		 * @type {Object}
		 */
		getImageDataFromNode: function (node) {
			var data = this.htmleditor.getData(node);
			if (!data && node.test("img")) {
				//Parse node and try to fill all properties
				/*
				data = Supra.mix({}, defaultProps, {
					"title": node.getAttribute("title") || "",
					"description": node.getAttribute("alt") || "",
					"align": node.getAttribute("align") || "left",
					"size_width": node.getAttribute("width") || node.offsetWidth || 0,
					"size_height": node.getAttribute("height") || node.offsetHeight || 0,
					"style": node.hasClass("lightbox") ? "lightbox" : (node.hasClass("border") ? "border" : ""),
					"image": "" //We don't know ID
				});
				this.htmleditor.setData(node, data);
				*/
			}
			return data;
		},
		
		/**
		 * Show image settings bar
		 */
		showImageSettings: function (target) {
			if (target.test(".gallery")) return false;
			
			var data = this.getImageDataFromNode(target),
				ancestor = this.getImageWrapperNode(target); // creates wrapper if it doesn't exist
			
			if (!data) {
				Y.log("Missing image data for image " + target.getAttribute("src"), "debug");
				return false;
			}
			
			//Make sure PageContentSettings is rendered
			var form = this.settings_form || this.createSettingsForm(),
				action = Manager.getAction("PageContentSettings");
			
			if (!form) {
				if (action.get("loaded")) {
					if (!action.get("created")) {
						action.renderAction();
						this.showImageSettings(target);
					}
				} else {
					action.once("loaded", function () {
						this.showImageSettings(target);
					}, this);
					action.load();
				}
				return false;
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			action.execute(form, {
				"hideCallback": Y.bind(this.settingsFormApply, this),
				"title": Supra.Intl.get(["htmleditor", "image_properties"]),
				"scrollable": true,
				"toolbarActionName": "htmleditor-plugin"
			});
			
			//
			this.selected_image = target;
			this.selected_image_id = this.selected_image.getAttribute("id");
			
			var ancestor = this.getImageWrapperNode(this.selected_image);
				ancestor.addClass("supra-image-selected");
			
			this.silent = true;			
			this.settings_form.resetValues()
							  .setValues(data, "id");
			this.silent = false;
			
			//Clone data because data properties will change and orginal properties should stay intact
			this.original_data = Supra.mix({}, data);
			
			//Start editing image immediatelly
			this.editImage();
			
			return true;
		},
		
		/**
		 * Show/hide media library bar
		 */
		toggleMediaSidebar: function () {
			var button = this.htmleditor.get("toolbar").getButton("insertimage");
			if (button.get("down")) {
				Manager.executeAction("MediaSidebar", {
					"onselect": Y.bind(this.insertImage, this),
					"hideToolbar": true
				});
			} else {
				this.hideMediaSidebar();
			}
		},
		
		/**
		 * Hide media library bar
		 */
		hideMediaSidebar: function () {
			Manager.getAction("MediaSidebar").hide();
		},
		
		
		/* ------------------------------- Manage image --------------------------- */
		
		
		/**
		 * Open image management
		 * 
		 * @private
		 */
		editImage: function () {
			var image = this.selected_image,
				ancestor = null,
				data  = this.original_data,
				size = null,
				resizer = this.resizer,
				max_crop_width = 0;
			
			if (image) {
				size = this.getImageDataBySize(data.image, "original");
				
				if (!resizer) {
					this.resizer = resizer = new Supra.ImageResizer({"autoClose": false});
					resizer.on("resize", this.onEditImageResize, this);
				}
				
				//Find content width
				ancestor = image.ancestor();
				if (ancestor.test(".supra-image")) ancestor = ancestor.ancestor();
				max_crop_width = Math.min(size.width, ancestor.get("offsetWidth"));
				
				resizer.set("maxCropWidth", max_crop_width);
				resizer.set("maxImageHeight", size.height);
				resizer.set("maxImageWidth", size.width);
				resizer.set("image", image);
			}
		},
		
		/**
		 * Handle image resize
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		onEditImageResize: function (event) {
			//Preserve image data
			var image = event.image,
				imageId = image.getAttribute("id"),
				data  = this.getImageDataFromNode(image);
			
			if (!data) {
				//Can't find image data, where this image appeared from?
				return;
			}
			
			data.crop_top = event.cropTop;
			data.crop_left = event.cropLeft;
			data.crop_width = event.cropWidth;
			data.crop_height = event.cropHeight;
			data.size_width = event.imageWidth;
			data.size_height = event.imageHeight;
			
			this.htmleditor.setData(imageId, data);
			
			//Property changed, update editor 'changed' state
			this.htmleditor._changed();
		},
		
		/**
		 * Stop image management
		 * 
		 * @private
		 */
		stopEditImage: function () {
			if (this.resizer && this.resizer.get("image")) {
				this.resizer.set("image", null);
			}
		},
		
		
		/* ------------------------------- Image insert/drop -------------------------- */
		
		
		/**
		 * Insert image into HTMLEditor content
		 * 
		 * @param {Object} event
		 */
		insertImage: function (event) {
			var htmleditor = this.htmleditor;
			
			var locale = Supra.data.get("locale");
			
			if (!htmleditor.get("disabled") && htmleditor.isSelectionEditable(htmleditor.getSelection())) {
				var image_data = event.image,
					size_data = this.getImageDataBySize(image_data, "original");
				
				if (this.selected_image) {
					//If image in content is already selected, then replace
					var imageId = this.selected_image_id,
						imageData = this.htmleditor.getData(imageId);
					
					var data = Supra.mix({}, defaultProps, {
						"type": this.NAME,
						"title": (image_data.title && image_data.title[locale]) ? image_data.title[locale] : "",
						"description": (image_data.description && image_data.description[locale]) ? image_data.description[locale] : "",
						"align": imageData.align,
						"style": imageData.style,
						"image": image_data,	//Original image data
						"size_width": size_data.width,
						"size_height": size_data.height,
						"crop_left": 0,
						"crop_top": 0,
						"crop_width": Math.min(size_data.width, imageData.crop_width || 9999),
						"crop_height": Math.min(size_data.height, imageData.crop_height || 9999)
					});
					
					//Preserve image data
					this.htmleditor.setData(imageId, data);
					
					//Update image attributes
					this.setImageProperty("image", data.image);
					this.setImageProperty("title", data.title);
					this.setImageProperty("description", data.description);
					this.setImageProperty("size_width", data.size_width);
					this.setImageProperty("size_height", data.size_height);
					this.setImageProperty("crop_left", data.crop_left);
					this.setImageProperty("crop_top", data.crop_top);
					this.setImageProperty("crop_width", data.crop_width);
					this.setImageProperty("crop_height", data.crop_height);
					
					//Update form input values
					this.settings_form.getInput("title").setValue(data.title);
					this.settings_form.getInput("description").setValue(data.description);
					
					this.original_data = data;
					this.editImage();
				} else {
					//Find image by size and set initial image properties
					var src = this.getImageURLBySize(image_data);
					
					//Calculate image size so that it fills container
					var container_width = htmleditor.get("srcNode").get("offsetWidth"),
						size_width = size_data.width,
						size_height = size_data.height;
					
					if (container_width < size_width) {
						size_height = Math.round(container_width / size_width * size_height);
						size_width = container_width;
					}
					
					//Image data
					var data = Supra.mix({}, defaultProps, {
						"type": this.NAME,
						"title": (image_data.title && image_data.title[locale]) ? image_data.title[locale] : "",
						"description": (image_data.description && image_data.description[locale]) ? image_data.description[locale] : "",
						"image": image_data,	//Original image data
						"size_width": size_width,
						"size_height": size_height,
						"crop_left": 0,
						"crop_top": 0,
						"crop_width": size_width,
						"crop_height": size_height
					});
					
					//Generate unique ID for image element, to which data will be attached
					var uid = htmleditor.generateDataUID();
					
					htmleditor.replaceSelection('<span class="supra-image align-' + data.align + '" unselectable="on" contenteditable="false" style="width: ' + data.crop_width + 'px; height: ' + data.crop_height + 'px;"><img draggable="false" id="' + uid + '" style="margin-left: -' + data.crop_left + 'px; margin-top: -' + data.crop_top + 'px;" width="' + data.size_width + '" src="' + src + '" title="' + Y.Escape.html(data.title) + '" alt="' + Y.Escape.html(data.description) + '" class="align-' + data.align + '" /></span>');
					htmleditor.setData(uid, data);
				}
				
				this.hideMediaSidebar();
			}
		},
		
		/**
		 * Update image after it was dropped using HTML5 drag & drop
		 * 
		 * @param {Object} event
		 */
		dropImage: function (target, image_id) {
			//If dropped on un-editable element
			if (!this.htmleditor.isEditable(target)) return true;
			if (!Manager.MediaSidebar) return true;
			
			var htmleditor = this.htmleditor,
				dataObject = Manager.MediaSidebar.dataObject(),
				image_data = dataObject.cache.one(image_id);
			
			if (image_data.type != Supra.MediaLibraryList.TYPE_IMAGE) {
				//Only handling images; folders should be handled by gallery plugin 
				return false;
			}
			
			if (dataObject.has(image_id) != 2) {
				// Load full data for image
				dataObject.one(image_id, true).done(function () {
					this.dropImage(target, image_id);
				}, this);
				return true;
			}
			
			var uid = htmleditor.generateDataUID(),
				size_data = this.getImageDataBySize(image_data, "original"),
				src = this.getImageURLBySize(image_data),
				img = null;
			
			var locale = Supra.data.get("locale");
			
			//Calculate image size so that it fills container
			var container_width = htmleditor.get("srcNode").get("offsetWidth"),
				size_width = size_data.width,
				size_height = size_data.height;
			
			if (container_width < size_width) {
				size_height = Math.round(container_width / size_width * size_height);
				size_width = container_width;
			}
			
			//Set additional image properties
			var data = Supra.mix({}, defaultProps, {
				"type": this.NAME,
				"title": (image_data.title && image_data.title[locale]) ? image_data.title[locale] : "",
				"description": (image_data.description && image_data.description[locale]) ? image_data.description[locale] : "",
				"image": image_data,	//Original image data
				"size_width": size_width,
				"size_height": size_height,
				"crop_left": 0,
				"crop_top": 0,
				"crop_width": size_width,
				"crop_height": size_height
			});
			
			img = Y.Node.create('<span class="supra-image align-' + data.align + '" unselectable="on" contenteditable="false" style="width: ' + data.crop_width + 'px; height: ' + data.crop_height + 'px;"><img draggable="false" id="' + uid + '" style="margin-left: -' + data.crop_left + 'px; margin-top: -' + data.crop_top + 'px;" width="' + data.size_width + '" src="' + src + '" title="' + Y.Escape.html(data.title) + '" alt="' + Y.Escape.html(data.description) + '" class="align-' + data.align + '" />');
			
			//If droping on inline element then insert image before it, otherwise append to element
			if (target.test("em,i,strong,b,s,strike,sub,sup,u,a,span,big,small,img")) {
				target.insert(img, "before");
			} else {
				target.prepend(img);
			}
			
			//Save into HTML editor data about image
			htmleditor.setData(uid, data);
			
			return true;
		},
		
		/**
		 * Returns image url matching size
		 * 
		 * @param {Object} data
		 * @param {String} size
		 */
		getImageURLBySize: function (data, size) {
			// Always return original if not specified size
			var size = size ? size : "original";
			
			if (data && data.sizes && size in data.sizes) {
				return data.sizes[size].external_path;
			}
			
			return null;
		},
		
		/**
		 * Returns image size data
		 * 
		 * @param {Object} data
		 * @param {String} size
		 */
		getImageDataBySize: function (data, size) {
			var size = size ? size : this.configuration.size;
			
			if (size in data.sizes) {
				return data.sizes[size];
			}
			
			return null;
		},
		
		/**
		 * On node change check if selected node is image and show settings
		 * 
		 * @private
		 */
		onNodeChange: function () {
			var element = this.htmleditor.getSelectedElement("img");
			if (element) {
				if (!this.showImageSettings(Y.Node(element))) {
					this.settingsFormApply();
				}
			}
		},
		
		/**
		 * If clicking outside image then hide settings form
		 * 
		 * @private
		 */
		documentClick: function (e) {
			if (e.target && !e.target.closest("span.supra-image")) {
				this.settingsFormApply();
			}
		},
			
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			var mediasidebar = Manager.getAction("MediaSidebar"),
				toolbar = htmleditor.get("toolbar"),
				button = toolbar ? toolbar.getButton("insertimage") : null;
			
			// When HTML changes make sure images has wrapper elements
			htmleditor.on("afterSetHTML", this.afterSetHTML, this);
			
			// Add command
			htmleditor.addCommand("insertimage", Y.bind(this.toggleMediaSidebar, this));
			
			// When clicking outside image hide image settings
			this.clickEvent = Y.Node(htmleditor.get("doc")).on("mousedown", this.documentClick, this)
			
			// When clicking on image show image settings
			htmleditor.on("nodeChange", this.onNodeChange, this);
			
			if (button) {
				button.show();
				
				//When media library is shown/hidden make button selected/unselected
				mediasidebar.after("visibleChange", function (evt) {
					button.set("down", evt.newVal);
				});
				
				//When un-editable node is selected disable mediasidebar toolbar button
				htmleditor.on("editingAllowedChange", function (event) {
					button.set("disabled", !event.allowed);
				});
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			//When media library is hidden show settings form if image is selected
			mediasidebar.on("hide", function () {
				if (this.selected_image) {
					Manager.executeAction("PageContentSettings", this.settings_form, {
						"doneCallback": Y.bind(this.settingsFormApply, this),
						
						"title": Supra.Intl.get(["htmleditor", "image_properties"]),
						"scrollable": true,
						"toolbarActionName": "htmleditor-plugin"
					});
				}
			}, this);
			
			//Hide media library when editor is closed
			htmleditor.on("disable", this.hideMediaSidebar, this);
			htmleditor.on("disable", this.settingsFormApply, this);
			htmleditor.on("disable", this.stopEditImage, this);
			
			//If image is rotated, croped or replaced in MediaLibrary update image source
			Manager.getAction("MediaLibrary").on(["rotate", "crop", "replace"], this.updateImageSource, this);
			
			this.bindUIDnD(htmleditor);
		},
		
		bindUIDnD: function (htmleditor) {
			var srcNode = htmleditor.get("srcNode"),
				doc = htmleditor.get("doc");
			
			//On drop insert image
			srcNode.on("dataDrop", this.onDrop, this);
			
			//Enable drag & drop
			if (Manager.PageContent) {
				this.drop = new Manager.PageContent.PluginDropTarget({
					"srcNode": srcNode,
					"doc": doc
				});
			}
		},
		
		/**
		 * Update image src attribute
		 * MediaLibrary must be initialized 
		 */
		updateImageSource: function (e) {
			var image_id = (typeof e == "object" ? e.file_id : e),
				all_data = this.htmleditor.getAllData(),
				item_data = null,
				item_id = null,
				data_object = null,
				image_data = null;
			
			for(var i in all_data) {
				if (all_data[i].type == this.NAME && all_data[i].image && all_data[i].image.id == image_id) {
					item_id = i;
					item_data = all_data[i];
					break;
				}
			}
			
			if (item_data) {
				data_object = Manager.getAction("MediaLibrary").medialist.get("dataObject");
				image_data = data_object.getData(image_id);
				
				if (image_data) {
					//Update image data
					image_data.path = data_object.getPath(image_id);
					item_data.image = image_data;
					
					//Change source
					var path = this.getImageURLBySize(image_data);
					var container = htmleditor.get("srcNode");
					var node = container.one("#" + item_id);
					
					if (node) {
						node.setAttribute("src", path);
					}
				}
			}
		},
		
		/**
		 * Handle drop
		 * 
		 * @param {Object} e Event
		 */
		onDrop: function (e) {
			//If image was from content, then prevent
			if (e.drag && e.drag.closest(this.htmleditor.get('srcNode'))) {
				if (e.halt) e.halt();
				return false;
			}
			
			var image_id = e.drag_id;
			if (!image_id) return;
			
			//Only if dropped from gallery
			if (image_id.match(/^\d[a-z0-9]+$/i) && e.drop) {
				if (this.dropImage(e.drop, image_id)) {
					//If image drop was successful then prevent other plugins
					//from doing anything
					if (e.halt) e.halt();
					return false;
				}
			}
		},
		
		/**
		 * Clean up node
		 * Remove all styles and data about node
		 */
		cleanUp: function (target, data) {
			if (target.test("img") && data && data.type == this.NAME) {
				this.htmleditor.removeData(target);
				this.setImageProperty("style", "", target);
				this.setImageProperty("align", "", target);
			}
		},
		
		/**
		 * Unclean HTML, add wrapper node around it
		 */
		afterSetHTML: function (event) {
			var htmleditor = this.htmleditor,
				node = htmleditor.get("srcNode"),
				images = node.all("img"),
				i = 0,
				ii = images.size(),
				data = null;
			
			for (; i<ii; i++) {
				data = htmleditor.getData(images.item(i));
				if (data && data.type == "image") {
					this.getImageWrapperNode(images.item(i));
				}
			}
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			if (this.clickEvent) this.clickEvent.detach();
			this.clickEvent = null;
		},
		
		/**
		 * Process HTML and replace all nodes with supra tags {supra.image id="..."}
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {String}
		 */
		tagHTML: function (html) {
			var htmleditor = this.htmleditor,
				NAME = this.NAME;
			
			html = html.replace(/(<a[^>]*>)?\s*(<span[^>]*>)?\s*<img [^>]*id="([^"]+)"[^>]*>\s*(<\/span[^>]*>)?\s*(<\/a[^>]*>)?/ig, function (html, link_open, wrap_open, id, wrap_close, link_close) {
				if (!id) return html;
				var data = htmleditor.getData(id);
				
				if (data && data.type == NAME) {
					if (data.style == "lightbox") {
						return "{supra." + NAME + " id=\"" + id + "\"}";
					} else {
						return (link_open || "") + "{supra." + NAME + " id=\"" + id + "\"}" + (link_close || "");
					}
				} else {
					return html;
				}
			});
			return html;
		},
		
		/**
		 * Process HTML and replace all supra tags with nodes
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			var NAME = this.NAME,
				self = this;
			
			html = html.replace(/{supra\.image id="([^"]+)"}/ig, function (tag, id) {
				if (!id || !data[id] || data[id].type != NAME) return "";
				
				var item = data[id],
					src = self.getImageURLBySize(item.image);
				
				if (src) {
					item.image.crop_left = item.image.crop_left || 0;
					item.image.crop_top = item.image.crop_top || 0;
					item.image.crop_width = item.image.crop_width || (item.image.size_width - item.image.crop_left);
					item.image.crop_height = item.image.crop_height || (item.image.size_height - item.image.crop_top);
					
					// Fix width/height if image proportions have been changed
					if (item.size_width && item.size_height) {
						var original = self.getImageDataBySize(item.image, 'original');

						if (original) {
							var original_height = original.height,
								original_width = original.width,
								min_ratio = Math.min(item.size_width / original_width, item.size_height / original_height),
								new_width = Math.round(min_ratio * original_width),
								new_height = Math.round(min_ratio * original_height);


							if (Math.abs(new_width - item.size_width) > 1) {
								item.size_width = new_width;
							}
							if (Math.abs(new_height - item.size_height) > 1) {
								item.size_height = new_height;
							}
						}
					}

					var style = ( ! item.image.exists ? '' : (item.size_width && item.size_height ? 'width="' + item.size_width + '" height="' + item.size_height + '"' : ''));
					var img_style = (item.size_width && item.size_height ? 'width: ' + item.size_width + 'px; height:' + item.size_height + ';' : '');					
					var classname = (item.align ? "align-" + item.align : "") + " " + item.style;
					var html = '<span class="supra-image ' + classname + '" unselectable="on" contenteditable="false" style="width: ' + item.crop_width + 'px; height: ' + item.crop_height + 'px;"><img ' + style + ' draggable="false" id="' + id + '" style="' + img_style + 'margin-left: -' + item.crop_left + 'px; margin-top: -' + item.crop_top + 'px;" class="' + classname + '" src="' + ( ! item.image.exists ? item.image.missing_path : src ) + '" title="' + Y.Escape.html(item.title) + '" alt="' + Y.Escape.html(item.description) + '" /></span>';
					
					if (item.type == 'lightbox') {
						//For lightbox add link around image
						return '<a class="lightbox" href="' + self.getImageURLBySize(item.image, "original") + '" rel="lightbox"></a>' + html + '</a>';
					}
					
					return html;
				}
				
				return "";
			});
			
			return html;
		},
		
		/**
		 * Process data and remove all unneeded before it's sent to server
		 * Called before save
		 * 
		 * @param {String} id Data ID
		 * @param {Object} data Data
		 * @return Processed data
		 * @type {Object}
		 */
		processData: function (id, data) {
			data.image = data.image.id;
			return data;
		}
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {"requires": ["supra.htmleditor-base", "supra.input-proto"]});
YUI().add("supra.htmleditor-plugin-icon", function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	var Manager = Supra.Manager;
	
	/**
	 * Icon plugin, PORTAL ONLY!!!
	 */
	Supra.HTMLEditor.addPlugin("icon", defaultConfiguration, {
		
		settings_form: null,
		selected_icon: null,
		selected_icon_id: null,
		original_data: null,
		silent: false,
		
		/**
		 * DropTarget object for editor srcNode
		 * @type {Object}
		 * @private
		 */
		drop: null,
		
		/**
		 * Manage image
		 * @type {Object}
		 * @private
		 */
		resizer: null,
		
		/**
		 * Click event
		 * @type {Object}
		 * @private
		 */
		clickEvent: null,
		
		
		/**
		 * Generate settings form
		 */
		createSettingsForm: function () {
			//Get form placeholder
			var content = Manager.getAction("PageContentSettings").get("contentInnerNode");
			if (!content) return;
			
			//Find color presets
			var presets = [],
				container = this.htmleditor.get("srcNode"),
				styles = this.htmleditor.get("stylesheetParser").getSelectorsByNodeMatch(container)["COLOR"],
				i = 0,
				ii = styles.length;
			
			for (; i<ii; i++) {
				if (styles[i].attributes.color) {
					presets.push(styles[i].attributes.color);
				}
			}
			
			//Properties form
			var form_config = {
				"inputs": [
					{"id": "align", "style": "minimal", "type": "SelectList", "label": Supra.Intl.get(["htmleditor", "image_alignment"]), "value": "right", "values": [
						{"id": "left", "title": Supra.Intl.get(["htmleditor", "alignment_left"]), "icon": "/cms/lib/supra/img/htmleditor/align-left-button.png"},
						{"id": "middle", "title": Supra.Intl.get(["htmleditor", "alignment_center"]), "icon": "/cms/lib/supra/img/htmleditor/align-center-button.png"},
						{"id": "right", "title": Supra.Intl.get(["htmleditor", "alignment_right"]), "icon": "/cms/lib/supra/img/htmleditor/align-right-button.png"}
					]},
					{"id": "color", "type": "Color", "label": Supra.Intl.get(["htmleditor", "icon_color"]), "value": "#000000", "presets": presets}
				],
				"style": "vertical"
			};
			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			//On title, description, etc. change update image data
			for(var i=0,ii=form_config.inputs.length; i<ii; i++) {
				form.getInput(form_config.inputs[i].id).on("change", this.onPropertyChange, this);
			}
			
			//Add "Delete", "Edit" and "Replace buttons"
			//Replace button
			var btn = new Supra.Button({"label": Supra.Intl.get(["htmleditor", "icon_replace"]), "style": "small-gray"});
				btn.render(form.get("contentBox"));
				btn.addClass("button-section");
				btn.on("click", this.replaceSelectedIcon, this);
				
				//Move into correct place
				form.get("contentBox").prepend(btn.get("boundingBox"));
			
			//Delete button
			var btn = new Supra.Button({"label": Supra.Intl.get(["htmleditor", "icon_delete"]), "style": "small-red"});
				btn.render(form.get("contentBox"));
				btn.addClass("su-button-delete");
				btn.on("click", this.removeSelectedIcon, this);
			
			this.settings_form = form;
			return form;
		},
		
		/**
		 * Returns true if form is visible, otherwise false
		 */
		hideSettingsForm: function () {
			if (this.settings_form && this.settings_form.get("visible")) {
				Manager.PageContentSettings.hide();
			}
		},
		
		/**
		 * Apply settings changes
		 */
		settingsFormApply: function () {
			if (this.selected_icon) {
				this.stopEditIcon();
				
				var ancestor = this.getIconWrapperNode(this.selected_icon);
				ancestor.removeClass("supra-icon-selected");
				
				this.selected_icon = null;
				this.selected_icon_id = null;
				this.original_data = null;
				
				this.hideSettingsForm();
				this.hideIconSidebar();
				
				//Property changed, update editor "changed" state
				this.htmleditor._changed();
			}
		},
		
		/**
		 * Replace selected image with another one from media library
		 * 
		 * @private
		 */
		replaceSelectedIcon: function () {
			//Open Media library on "Replace"
			if (this.selected_icon) {
				var icon = this.selected_icon,
					icon_id = this.selected_icon_id,
					data = this.original_data;
				
				//Open settings form and open IconSidebar
				this.stopEditIcon();
				this.hideSettingsForm();
				
				Manager.getAction("IconSidebar").execute({
					onselect: Y.bind(function (data) {
						// Restore selection
						this.selected_icon = icon;
						this.selected_icon_id = icon_id;
						this.original_data = data;
						
						this.insertIcon(data);
					}, this)
				});
			}
		},
		
		/**
		 * Remove selected i
		 * 
		 * @private
		 */
		removeSelectedIcon: function () {
			if (this.selected_icon_id) {
				this.removeIcon(this.selected_icon_id);
			}
		},
		
		/**
		 * Remove icon
		 * 
		 * @private
		 */
		removeIcon: function (id) {
			var current = this.selected_icon && this.selected_icon_id == id;
			if (current) {
				this.stopEditIcon();
			}
			
			var image = current ? this.selected_icon : this.htmleditor.one('#' + id),
				container = image ? image.ancestor() : null;
			
			if (container) {
				if (container.test(".supra-icon")) {
					container.remove();
				} else {
					image.remove();
				}
			}
			
			if (current) {
				this.selected_icon = null;
				this.selected_icon_id = null;
				this.original_data = null;
				this.htmleditor.refresh(true);
				this.hideSettingsForm();
			}
		},
		
		/**
		 * Handle property input value change
		 * Save data and update UI
		 * 
		 * @param {Object} event Event
		 */
		onPropertyChange: function (event) {
			if (this.silent || !this.selected_icon) return;
			
			var target = event.target,
				id = target.get("id"),
				icon_id = this.selected_icon_id,
				data = this.htmleditor.getData(icon_id),
				value = (event.value !== undefined ? event.value : target.getValue());
			
			//Update image data
			if (icon_id) {
				data[id] = value;
				this.htmleditor.setData(icon_id, data);
			}
			
			this.setIconProperty(id, value);
		},
		
		/**
		 * Update image tag property
		 * 
		 * @param {String} id Property ID
		 * @param {String} value Property value
		 */
		setIconProperty: function (id, value, node) {
			if (!node) node = this.selected_icon;
			var ancestor = this.getIconWrapperNode(node);
			
			if (id == "align") {
				ancestor.removeClass("align-left").removeClass("align-right").removeClass("align-middle");
				node.removeClass("align-left").removeClass("align-right").removeClass("align-middle");
				
				if (value) {
					ancestor.addClass("align-" + value);
					node.addClass("align-" + value);
				}
			} else if (id == "width") {
				
				value = parseInt(value) || 0;
				var data = this.htmleditor.getData(this.selected_icon_id),
					ratio = data.width / data.height,
					height = value ? Math.round(value / ratio) : data.height,
					width = value || data.width;
				
				data.width = width;
				data.height = height;
				
				node.setAttribute('width', width + 'px');
				node.setAttribute('height', height + 'px');
				
				node.setStyles({
					'width': width + 'px',
					'height': height + 'px'
				});
				
			} else if (id == "height") {
				
				value = parseInt(value) || 0;
				var data = this.htmleditor.getData(this.selected_icon_id),
					ratio = data.width / data.height,
					width = value ? Math.round(value * ratio) : data.width,
					height = value || data.height;
				
				data.width = width;
				data.height = height;
				
				node.setAttribute('width', width + 'px');
				node.setAttribute('height', height + 'px');
				
				node.setStyles({
					'width': width + 'px',
					'height': height + 'px'
				});
			} else if (id == "color") {
				
				var data = this.htmleditor.getData(this.selected_icon_id);
				data.color = value;
				node.setStyle("fill", value);
				
			} else if (id == "icon") {
				value.render(node);
			}
		},
		
		/**
		 * Returns icon wrapper node
		 * If node doesn't exist then creates it
		 * 
		 * @param {HTMLElement} image Image element
		 * @return Image wrapper node
		 */
		getIconWrapperNode: function (icon) {
			var ancestor = icon.ancestor();
			
			if (ancestor) {
				if (!ancestor.test("span.supra-icon")) {
					ancestor = ancestor.ancestor();
					if (ancestor && !ancestor.test("span.supra-icon")) {
						ancestor = null;
					}
				}
			}
			
			if (!ancestor) {
				//Wrap image in <span class="supra-icon">
				ancestor = Y.Node(this.htmleditor.get("doc").createElement("SPAN"));
				ancestor.addClass("supra-icon");
				ancestor.setAttribute("contenteditable", false);
				ancestor.setAttribute("unselectable", "on");
				
				var data = this.getIconDataFromNode(icon);
				if (!data) {
					// This icon is not associated with any data,
					// there's nothing we can do about it
					return;
				}
				
				if (data.align) {
					ancestor.addClass("align-" + data.align);
				}
				
				var width  = data.width || parseInt(Y.DOM.getStyle(icon, 'width') || 0, 10),
					height = data.height || parseInt(Y.DOM.getStyle(icon, 'height') || 0, 10);
				
				ancestor.setStyles({
					"width": width + "px",
					"height": height + "px"
				});
				
				icon.insert(ancestor, "before");
				ancestor.append(icon);
			}
			
			return ancestor;
		},
		
		/**
		 * Returns image data from node
		 * 
		 * @param {HTMLElement} node Node
		 * @return Image data
		 * @type {Object}
		 */
		getIconDataFromNode: function (node) {
			var data = this.htmleditor.getData(node);
			return data;
		},
		
		/**
		 * Show icon settings bar
		 */
		showIconSettings: function (target) {
			if (target.test(".gallery")) return false;
			
			var data = this.getIconDataFromNode(target),
				ancestor = this.getIconWrapperNode(target); // creates wrapper if it doesn't exist
			
			if (!data) {
				Y.log("Missing image data for icon " + target.getAttribute("src"), "debug");
				return false;
			}
			
			//Make sure PageContentSettings is rendered
			var form = this.settings_form || this.createSettingsForm(),
				action = Manager.getAction("PageContentSettings");
			
			if (!form) {
				if (action.get("loaded")) {
					if (!action.get("created")) {
						action.renderAction();
						this.showIconSettings(target);
					}
				} else {
					action.once("loaded", function () {
						this.showIconSettings(target);
					}, this);
					action.load();
				}
				return false;
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			action.execute(form, {
				"hideCallback": Y.bind(this.settingsFormApply, this),
				"title": Supra.Intl.get(["htmleditor", "icon_properties"]),
				"scrollable": true,
				"toolbarActionName": "htmleditor-plugin"
			});
			
			//
			this.selected_icon = target;
			this.selected_icon_id = this.selected_icon.getAttribute("id");
			
			var ancestor = this.getIconWrapperNode(this.selected_icon);
				ancestor.addClass("supra-icon-selected");
			
			this.silent = true;			
			this.settings_form.resetValues()
							  .setValues({"align": data.align, "color": data.color}, "id");
			this.silent = false;
			
			//Clone data because data properties will change and orginal properties should stay intact
			this.original_data = data;
			
			//Start editing image immediatelly
			this.editIcon();
			
			return true;
		},
		
		/**
		 * Show/hide media library bar
		 */
		toggleIconSidebar: function () {
			var button = this.htmleditor.get("toolbar").getButton("inserticon");
			if (button.get("down")) {
				Manager.executeAction("IconSidebar", {
					"onselect": Y.bind(this.insertIcon, this),
					"hideToolbar": true
				});
			} else {
				this.hideIconSidebar();
			}
		},
		
		/**
		 * Hide media library bar
		 */
		hideIconSidebar: function () {
			Manager.getAction("IconSidebar").hide();
		},
		
		
		/* ------------------------------- Manage image --------------------------- */
		
		
		/**
		 * Open image management
		 * 
		 * @private
		 */
		editIcon: function () {
			var node = this.selected_icon,
				ancestor = null,
				data  = this.original_data,
				size = null,
				resizer = this.resizer,
				max_size = 0,
				min_size = 16,
				ratio = 0;
			
			if (node) {
				if (!resizer) {
					this.resizer = resizer = new Supra.ImageResizer({
						"autoClose": false,
						"mode": Supra.ImageResizer.MODE_ICON,
						"allowZoomResize": true,
						"minCropWidth": min_size,
						"minCropHeight": min_size
					});
					resizer.on("resize", this.onEditIconResize, this);
				}
				
				//Find content width
				ancestor = node.ancestor();
				if (ancestor.test(".supra-icon")) ancestor = ancestor.ancestor();
				max_size = Math.max(min_size, ancestor.get("offsetWidth") || 220);
				ratio = data.width / data.height;
				
				resizer.set("maxCropWidth", max_size);
				resizer.set("maxCropHeight", Math.round(max_size / ratio));
				resizer.set("maxImageWidth", max_size);
				resizer.set("maxImageHeight", Math.round(max_size / ratio));
				resizer.set("minImageWidth", min_size);
				resizer.set("minImageHeight", Math.round(min_size / ratio));
				resizer.set("image", node);
			}
		},
		
		/**
		 * Handle image resize
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		onEditIconResize: function (event) {
			//Preserve image data
			var node = event.image,
				id = node.getAttribute("id"),
				data  = this.getIconDataFromNode(node);
			
			if (!data) {
				//Can't find image data, where this image appeared from?
				return;
			}
			
			data.width = event.imageWidth;
			data.height = event.imageHeight;
			
			this.htmleditor.setData(id, data);
			
			//Property changed, update editor 'changed' state
			this.htmleditor._changed();
		},
		
		/**
		 * Stop image management
		 * 
		 * @private
		 */
		stopEditIcon: function () {
			if (this.resizer && this.resizer.get("image")) {
				this.resizer.set("image", null);
			}
		},
		
		
		/* ------------------------------- Image insert/drop -------------------------- */
		
		
		/**
		 * Insert image into HTMLEditor content
		 * 
		 * @param {Object} event
		 */
		insertIcon: function (event) {
			var htmleditor = this.htmleditor;
			
			var locale = Supra.data.get("locale");
			
			if (!htmleditor.get("disabled") && htmleditor.isSelectionEditable(htmleditor.getSelection())) {
				var icon = event.icon;
				
				if (this.selected_icon) {
					//If icon in content is already selected, then replace
					var iconId = this.selected_icon_id,
						iconData = this.htmleditor.getData(iconId),
						data = icon;
					
					icon.width = iconData.width;
					icon.height = iconData.height;
					icon.align = iconData.align;
					icon.color = iconData.color;
					icon.type = this.NAME;
					
					//Preserve image data
					this.htmleditor.setData(iconId, data);
					
					//Update icon attributes
					this.setIconProperty("icon", data);
					this.setIconProperty("width", data.width);
					this.setIconProperty("height", data.height);
					
					this.editIcon();
				} else {
					//Calculate icon size so that it fills container
					var container_width = htmleditor.get("srcNode").get("offsetWidth");
					
					if (container_width < icon.width) {
						icon.height = Math.round(container_width / icon.width * icon.height);
						icon.width  = container_width;
					}
					
					//Icon data
					icon.type = this.NAME;
					
					//Generate unique ID for image element, to which data will be attached
					var uid = htmleditor.generateDataUID(),
						html = icon.toHTML({'id': uid}, true);
					
					htmleditor.replaceSelection('<span class="supra-icon' + (icon.align ? ' align-' + icon.align : '') + '" unselectable="on" contenteditable="false" style="width: ' + icon.width + 'px; height: ' + icon.height + 'px;">' + html + '</span>');
					htmleditor.setData(uid, icon);
					
					if (!icon.isDataComplete()) {
						// Load
						icon.load()
							.done(function () {
								var node = htmleditor.one('#' + uid);
								icon.render(node);
							}, this)
							.fail(function () {
								// Couldn't load icon SVG data, remove
								this.removeIcon(uid);
							}, this);
					}
				}
				
				this.hideIconSidebar();
			}
		},
		
		/**
		 * Update image after it was dropped using HTML5 drag & drop
		 * 
		 * @param {Object} event
		 */
		dropImage: function (target, image_id) {
			//@TODO
			
			//If dropped on un-editable element
			if (!this.htmleditor.isEditable(target)) return true;
			if (!Manager.MediaSidebar) return true;
			
			var htmleditor = this.htmleditor,
				dataObject = Manager.MediaSidebar.dataObject(),
				image_data = dataObject.cache.one(image_id);
			
			if (image_data.type != Supra.MediaLibraryList.TYPE_IMAGE) {
				//Only handling images; folders should be handled by gallery plugin 
				return false;
			}
			
			if (dataObject.has(image_id) != 2) {
				// Load full data for image
				dataObject.one(image_id, true).done(function () {
					this.dropImage(target, image_id);
				}, this);
				return true;
			}
			
			var uid = htmleditor.generateDataUID(),
				size_data = this.getImageDataBySize(image_data, "original"),
				src = this.getImageURLBySize(image_data),
				img = null;
			
			var locale = Supra.data.get("locale");
			
			//Calculate image size so that it fills container
			var container_width = htmleditor.get("srcNode").get("offsetWidth"),
				size_width = size_data.width,
				size_height = size_data.height;
			
			if (container_width < size_width) {
				size_height = Math.round(container_width / size_width * size_height);
				size_width = container_width;
			}
			
			//Set additional image properties
			var data = Supra.mix({}, {
				"type": this.NAME,
				"title": (image_data.title && image_data.title[locale]) ? image_data.title[locale] : "",
				"description": (image_data.description && image_data.description[locale]) ? image_data.description[locale] : "",
				"image": image_data,	//Original image data
				"size_width": size_width,
				"size_height": size_height,
				"crop_left": 0,
				"crop_top": 0,
				"crop_width": size_width,
				"crop_height": size_height
			});
			
			img = Y.Node.create('<span class="supra-icon align-' + data.align + '" unselectable="on" contenteditable="false" style="width: ' + data.crop_width + 'px; height: ' + data.crop_height + 'px;"><img id="' + uid + '" style="margin-left: -' + data.crop_left + 'px; margin-top: -' + data.crop_top + 'px;" width="' + data.size_width + '" src="' + src + '" title="' + Y.Escape.html(data.title) + '" alt="' + Y.Escape.html(data.description) + '" class="align-' + data.align + '" />');
			
			//If droping on inline element then insert image before it, otherwise append to element
			if (target.test("em,i,strong,b,s,strike,sub,sup,u,a,span,big,small,img")) {
				target.insert(img, "before");
			} else {
				target.prepend(img);
			}
			
			//Save into HTML editor data about image
			htmleditor.setData(uid, data);
			
			return true;
		},
		
		/**
		 * On node change check if selected node is image and show settings
		 * 
		 * @private
		 */
		onNodeChange: function () {
			var element = this.htmleditor.getSelectedElement("svg"),
				container = this.htmleditor.get('srcNode');
			
			if (element && Y.Node(element).closest(container)) {
				if (!this.showIconSettings(Y.Node(element))) {
					this.settingsFormApply();
				}
			}
		},
		
		/**
		 * If clicking outside image then hide settings form
		 * 
		 * @private
		 */
		documentClick: function (e) {
			if (e.target && !e.target.closest("span.supra-icon")) {
				this.settingsFormApply();
			}
		},
			
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			// If not portal, then don't do anything
			//if (!Supra.data.get(['site', 'portal'])) return;
			
			var iconsidebar = Manager.getAction("IconSidebar"),
				toolbar = htmleditor.get("toolbar"),
				button = toolbar ? toolbar.getButton("inserticon") : null;
			
			// When HTML changes make sure images has wrapper elements
			htmleditor.on("afterSetHTML", this.afterSetHTML, this);
			
			// Add command
			htmleditor.addCommand("inserticon", Y.bind(this.toggleIconSidebar, this));
			
			// When clicking outside icon hide icon settings
			this.clickEvent = Y.Node(htmleditor.get("doc")).on("mousedown", this.documentClick, this)
			
			// When clicking on icon show icon settings
			htmleditor.on("nodeChange", this.onNodeChange, this);
			
			if (button) {
				//Show button
				button.show();
				
				//When icon library is shown/hidden make button selected/unselected
				iconsidebar.after("visibleChange", function (evt) {
					button.set("down", evt.newVal);
				});
				
				//When un-editable node is selected disable iconsidebar toolbar button
				htmleditor.on("editingAllowedChange", function (event) {
					button.set("disabled", !event.allowed);
				});
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			//When media library is hidden show settings form if image is selected
			iconsidebar.on("hide", function () {
				if (this.selected_icon) {
					Manager.executeAction("PageContentSettings", this.settings_form, {
						"doneCallback": Y.bind(this.settingsFormApply, this),
						
						"title": Supra.Intl.get(["htmleditor", "icon_properties"]),
						"scrollable": true,
						"toolbarActionName": "htmleditor-plugin"
					});
				}
			}, this);
			
			//Hide media library when editor is closed
			htmleditor.on("disable", this.hideIconSidebar, this);
			htmleditor.on("disable", this.settingsFormApply, this);
			htmleditor.on("disable", this.stopEditIcon, this);
			
			//this.bindUIDnD(htmleditor);
		},
		
		bindUIDnD: function (htmleditor) {
			//@TODO
			var srcNode = htmleditor.get("srcNode"),
				doc = htmleditor.get("doc");
			
			//On drop insert image
			srcNode.on("dataDrop", this.onDrop, this);
			
			//Enable drag & drop
			if (Manager.PageContent) {
				this.drop = new Manager.PageContent.PluginDropTarget({
					"srcNode": srcNode,
					"doc": doc
				});
			}
		},
		
		/**
		 * Handle drop
		 * 
		 * @param {Object} e Event
		 */
		onDrop: function (e) {
			//@TODO			
			var image_id = e.drag_id;
			if (!image_id) return;
			
			//Only if dropped from gallery
			if (image_id.match(/^\d[a-z0-9]+$/i) && e.drop) {
				if (this.dropImage(e.drop, image_id)) {
					//If image drop was successful then prevent other plugins
					//from doing anything
					if (e.halt) e.halt();
					return false;
				}
			}
		},
		
		/**
		 * Clean up node
		 * Remove all styles and data about node
		 */
		cleanUp: function (target, data) {
			if (target.test("svg") && data && data.type == this.NAME) {
				this.htmleditor.removeData(target);
				this.setIconProperty("align", "", target);
			}
		},
		
		/**
		 * Unclean HTML, add wrapper node around it
		 */
		afterSetHTML: function (event) {
			var htmleditor = this.htmleditor,
				node = htmleditor.get("srcNode"),
				icons = node.all("svg"),
				i = 0,
				ii = icons.size(),
				data = null,
				data_icon = null;
			
			for (; i<ii; i++) {
				data = htmleditor.getData(icons.item(i));
				if (data && data.type == "icon") {
					data_icon = new Y.DataType.Icon(data);
					data_icon.render(icons.item(i));
					
					this.getIconWrapperNode(icons.item(i));
				}
			}
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			if (this.clickEvent) this.clickEvent.detach();
			this.clickEvent = null;
		},
		
		/**
		 * Process HTML and replace all nodes with supra tags {supra.icon id="..."}
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {String}
		 */
		tagHTML: function (html) {
			var htmleditor = this.htmleditor,
				NAME = this.NAME;
			
			html = html.replace(/<svg [^>]*id="([^"]+)"[\s\S]*?<\/svg>/ig, function (html, id) {
				if (!id) return html;
				var data = htmleditor.getData(id);
				
				if (data && data.type == NAME) {
					return "{supra." + NAME + " id=\"" + id + "\"}";
				} else {
					return html;
				}
			});
			return html;
		},
		
		/**
		 * Process HTML and replace all supra tags with nodes
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			var NAME = this.NAME,
				self = this;
			
			html = html.replace(/{supra\.icon id="([^"]+)"}/ig, function (tag, id) {
				if (!id || !data[id] || data[id].type != NAME) return "";
				
				var item = data[id],
					icon = new Y.DataType.Icon(item);
				
				if (icon.isDataComplete()) {
					var classname = (icon.align ? "align-" + icon.align : "");
					var svg = icon.toHTML({'id': id});
					var html = '<span class="supra-icon ' + classname + '" unselectable="on" contenteditable="false" style="width: ' + icon.width + 'px; height: ' + icon.height + 'px;">' + svg + '</span>';
					
					return html;
				}
				
				return "";
			});
			
			return html;
		},
		
		/**
		 * Process data and remove all unneeded before it's sent to server
		 * Called before save
		 * 
		 * @param {String} id Data ID
		 * @param {Object} data Data
		 * @return Processed data
		 * @type {Object}
		 */
		processData: function (id, data) {
			return data;
		}
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {"requires": ["supra.htmleditor-base", "supra.input-proto"]});
/**
 * 
 */
YUI().add('supra.htmleditor-plugin-gallery', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/* Supported HTML editor use types */
		types: [Supra.HTMLEditor.TYPE_INLINE],
		
		/* Default image size */
		size: '200x200',
		
		/* Gallery block id */
		galleryBlockId: null
	};
	
	var Manager = Supra.Manager;
	
	Supra.HTMLEditor.addPlugin('gallery', defaultConfiguration, {
		
		/**
		 * Add gallery if folder was dropped using HTML5 drag & drop
		 */
		dropFolder: function (e) {
			var gallery_id = e.drag_id,
				target = e.drop;
			
			//If there is no folder or trying to drop on un-editable element
			if (!gallery_id || !this.htmleditor.isEditable(target)) return;
			if (!Manager.MediaSidebar) return true;
			
			var htmleditor = this.htmleditor,
				dataObject = Manager.MediaSidebar.dataObject(),
				folder_data = dataObject.cache.one(gallery_id);
			
			if (!folder_data || folder_data.type != Supra.MediaLibraryList.TYPE_FOLDER) {
				//Only handling folders; images should be handled by image plugin 
				return;
			}
			
			//Prevent default (which is insert folder thumbnail image) 
			if (e.halt) e.halt();
			
			var image_data = [],
				loaded = 0,
				count  = 0;
			
			var checkComplete = Y.bind(function () {
				if (count && loaded == count) {
					if (Manager.PageContent) {
						this.insertGalleryBlock(image_data);
					}
				}
			}, this);
			
			//Load all image data
			dataObject.all(gallery_id).done(function (images) {
				
				var loadDone = function (image) {
					image_data.push(image);
					loaded++;
					checkComplete();
				};
				var loadFail = function () {
					count--;
					checkComplete();
				};
				
				for(var i=0, ii=images.length; i<ii; i++) {
					if (images[i].type == Supra.MediaLibraryList.TYPE_IMAGE) {
						count++;
						dataObject.one(images[i].id, true).done(loadDone).fail(loadFail);
					}
				}
				
				checkComplete();
				
			}, this);
			
			return false;
		},
		
		insertGalleryBlock: function (images) {
			var content = Manager.PageContent.getContent().get('activeChild'),
				list = content.get('parent'),
				gallery_block_id = this.configuration.galleryBlockId;
			
			//If list is closed or gallery is not a valid child type then cancel
			if (list.isClosed() || !list.isChildTypeAllowed(gallery_block_id)) return;
			
			//Save and close current block
			content.fire('editing-end');
			
			//Insert block
			list.get('super').getBlockInsertData({
				'type': gallery_block_id,
				'placeholder_id': list.getId()
			}, function (data) {
				Manager.PageToolbar.setActiveAction("Page");
				this.createChildFromData(data);
					
				//Add images to gallery block
				var block = this.get('super').get('activeChild');
				if (Y.Lang.isFunction(block.addImage)) {
					for(var i=0,ii=images.length; i<ii; i++) {
						block.addImage(images[i]);
					}
					
					if (Y.Lang.isFunction(block.reloadContent())) {
						block.reloadContent();
					}
				} else {
					Y.log('Block "' + gallery_block_id + '" doesn\'t have required method "addImage"');
				}
			}, list);
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @param {Object} configuration Plugin configuration
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			var block_data = Manager.Blocks.getBlock(configuration.galleryBlockId);
			if (configuration.galleryBlockId && block_data.classname) {
				//On image folder drop add gallery
				htmleditor.get('srcNode').on('dataDrop', this.dropFolder, this);
			}
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-link', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/* Search for plain text email addresses and replace them with links */
		parseEmails: true,
		
		/* Classname to use for button style */
		buttonClassName: 'button',
		
		/* String replacements */
		replacements: [
			[
				/[a-z]+:\/\/[a-z0-9\-\.@:]+[a-z0-9](\/[a-z0-9\?#&%\-\_=\(\)\\\/\$\!:,]*)?/ig,
				function (url) { return '<a href="' + url + '" target="_blank">' + url + '</a>'; }
			],
			[
				/([a-z0-9]([a-z0-9\.\-\_]*[a-z0-9])?@[a-z0-9][a-z0-9\-\_]*([\.]([a-z0-9][a-z0-9\-\_]?)?[a-z0-9])*)/ig,
				function (email) { return '<a href="mailto:' + email + '">' + email + '</a>'; }
			]
		]
	};
	
	Supra.HTMLEditor.addPlugin('link', defaultConfiguration, {
		
		/**
		 * Link editor is visible
		 * @type {Boolean}
		 */
		visible: false,
		
		
		/**
		 * Insert link around current selection
		 */
		insertLink: function () {
			if (!this.htmleditor.editingAllowed) return;
			
			var htmleditor = this.htmleditor,
				selection = htmleditor.getSelection();
			
			//If in current selection is a link then edit it instead of creating new
			var nodes = htmleditor.findNodesInSelection(selection, 'a');
			
			if (nodes && nodes.size())
			{
				//Edit selected link
				this.editLink({
					'currentTarget': nodes.item(0)
				});
				
				//Prevent default 
				return false;
			}
			else if (selection.collapsed)
			{
				//Cancel if no text is selected
				return false;
			}
			else if (htmleditor.isSelectionEditable(selection))
			{
				//Show link manager
				this.showLinkManager(null, function (data) {
					this.insertLinkConfirmed(data, selection);
				}, this);
				
				//Prevent default
				return false;
			}
			
			//Nothing was done
			return true;
		},
		
		/**
		 * After user entered value in prompt insert link
		 * 
		 * @param {Object} event
		 */
		insertLinkConfirmed: function (data, selection) {
			if (data && data.href) {
				var htmleditor = this.htmleditor,
					classname = data.classname || '';
				
				//Restore selection
				htmleditor.setSelection(selection);
				
				//Button class
				if (data.button) {
					if (classname.indexOf(this.configuration.buttonClassName) == -1) {
						classname = (classname ? ' ' : '') + this.configuration.buttonClassName;
					}
				}
				
				//Insert link
				var uid = htmleditor.generateDataUID(),
					text = this.htmleditor.getSelectionText(),
					html = '<a id="' + uid + '"' + (classname ? ' class="' + classname + '"' : '') + (data.target ? ' target="' + data.target + '"' : '') + ' title="' + Y.Escape.html(data.title || '') + '">' + text + '</a>';
				
				data.type = this.NAME;
				htmleditor.setData(uid, data)
				htmleditor.replaceSelection(html, null);
			}
			
			//Trigger selection change event
			this.htmleditor._changed();
			this.visible = false;
			this.htmleditor.refresh(true);
			
			var button = this.htmleditor.get('toolbar').getButton('insertlink');
			if (button) button.set('down', false).set('disabled', true);
		},
		
		/**
		 * Double clicking link must open prompt to enter new link url
		 * 
		 * @param {Object} event Event
		 */
		editLink: function (event) {
			var target = event.currentTarget;
			if (!this.htmleditor.editingAllowed || !this.htmleditor.isEditable(target)) return;
			
			//Get current value
			var data = this.htmleditor.getData(target);
			if (!data) {
				data = {
					'type': this.NAME,
					'title': target.getAttribute('title'),
					'target': target.getAttribute('target'),
					'href': this.normalizeHref(target.getAttribute('href')),
					'resource': 'link',
					'classname': target.getAttribute('class')
				}
			}
			
			this.showLinkManager(data, function (data) {
				this.editLinkConfirmed(data, target);
			}, this);
		},
		
		/**
		 * After user changed link save data into htmleditor and update html
		 * 
		 * @param {Object} event
		 */
		editLinkConfirmed: function (data, target) {
			if (data && data.href) {
				data.type = this.NAME;
				
				//Silently update data, we will trigger change manually
				this.htmleditor.setData(target, data, true);
				
				//Title attribute
				target.setAttribute('title', data.title || '');
				
				//Target attribute
				if (data.target) {
					target.setAttribute('target', data.target);
				} else {
					target.removeAttribute('target');
				}
				
				//Button
				if (data.button) {
					target.addClass(this.configuration.buttonClassName);
				} else {
					target.removeClass(this.configuration.buttonClassName);
				}
			} else {
				//Insert all link children nodes before link and remove <A>
				target.insert(target.get('childNodes'), 'before').remove();
			}
			
			//Trigger selection change event
			this.htmleditor._changed();
			this.visible = false;
			this.htmleditor.refresh(true);
			
			var button = this.htmleditor.get('toolbar').getButton('insertlink');
			if (button) button.set('down', false).set('disabled', true);
		},
		
		/**
		 * Normalize link by removing domain
		 * 
		 * @param {String} href
		 * @return Normalized domain
		 * @type {String}
		 */
		normalizeHref: function (href) {
			var domain = document.location.protocol + '//' + document.location.host;
			return String(href || '').replace(domain, '') || '/';
		},
		
		/**
		 * Show link manager
		 * 
		 * @param {String} href
		 * @param {Object} target
		 * @param {Function} callback
		 */
		showLinkManager: function (data, callback, context) {
			if (!callback) return;
			
			Supra.Manager.getAction('LinkManager').once('execute', function () {
				this.visible = true;
			}, this);
			
			Supra.Manager.getAction('LinkManager').execute(data, {
				'mode': 'link',
				'hideToolbar': true
			}, callback, context || this);
		},
		
		/**
		 * Hide link manager
		 */
		hideLinkManager: function () {
			if (this.visible) {
				Supra.Manager.getAction('LinkManager').hide();
				this.visible = false;
				this.htmleditor.refresh();
			}
		},
		
		/**
		 * Show or hide link manager based on toolbar button state
		 */
		toggleLinkManager: function () {
			if (!this.visible) {
				this.insertLink();
			} else {
				this.hideLinkManager();
			}
			
			//return true;
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			// Add command
			htmleditor.addCommand('insertlink', Y.bind(this.toggleLinkManager, this));
			
			// When double clicking on link show popup
			var container = htmleditor.get('srcNode');
			container.delegate('click', Y.bind(this.editLink, this), 'a');
			
			var self = this;
			var toolbar = htmleditor.get('toolbar');
			var button = toolbar ? toolbar.getButton('insertlink') : null;
			if (button) {
				button.show();
				
				//When un-editable node is selected disable toolbar button
				htmleditor.on('editingAllowedChange', function (event) {
					button.set('disabled', !event.allowed);
				});
				
				//If there is no text selection disable toolbar button
				htmleditor.on('selectionChange', function (event) {
					var allowEditing = false,
						down = false;
					
					//Check if cursor is inside link
					var node = this.getSelectedElement();
					if (node && node.tagName == 'A') {
						if (this.editingAllowed) {
							allowEditing = true;
							down = self.visible;
						}
					} else if (this.editingAllowed) {
						//Check if there is text selection
						if (!this.selection.collapsed) {
							allowEditing = true;
							down = self.visible;
						}
					}
					
					button.set('disabled', !allowEditing);
					button.set('down', down);
				});
			}
			
			this.visible = false;
			
			//After paste replace links with tags
			htmleditor.on('pasteHTML', this.tagPastedHTML, this);
			
			//When selection changes hide link manager
			htmleditor.on('selectionChange', this.hideLinkManager, this);
			
			//Hide link manager when editor is closed
			htmleditor.on('disable', this.hideLinkManager, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {},
		
		
		/**
		 * Parse HTML and replace all email addresses with links
		 */
		parseStrings: function (html) {
			if (!this.configuration.parseEmails) return html;
			
			var replacements = this.configuration.replacements,
				k = 0,
				kk = replacements.length,
			
				regex = null,
				replacement = null,
				
				addresses = [],
				match = null,
				pos_match = 0,
				pos_tag_end = 0,
				pos_tag_start = 0,
				tag = null,
				ok = false,
				search = true,
				
				i = 0;
			
			for (; k<kk; k++) {
				regex = replacements[k][0];
				replacement = replacements[k][1];
				
				addresses = [];
				
				while(match = regex.exec(html)) {
					ok = true;
					search = true;
					pos_match = (match.index || regex.lastIndex);
					pos_tag_start = pos_match + 1;
					
					while (search && pos_tag_start > 0) {
						pos_tag_end = html.lastIndexOf('>', pos_tag_start - 1);
						pos_tag_start = html.lastIndexOf('<', pos_tag_start - 1);
						
						if (pos_tag_start != -1) {
							if (pos_tag_end == -1 || pos_tag_end < pos_tag_start) {
								// email address is an attribute
								ok = false;
								search = false;
							} else {
								// check if it is inside <a> tag
								tag = html.substr(pos_tag_start + 1, 2);
								if (tag == '/a') {
									// Found closing a tag, there is no open link tag before email address
									search = false;
								} else if (tag == 'a ') {
									// There is open a before email address, skip
									ok = false;
									search = false;
								} else {
									// continue searching
								}
							}
						} else {
							// No opening tags found
							search = false;
						}
					}
					
					if (ok) {
						addresses.push([pos_match, pos_match + match[0].length, match[0]]);
					}
				}
				
				// Reset, is this even needed?
				regex.lastIndex = 0;
				
				// Replace with <a> tags
				for (i = addresses.length - 1; i >= 0; i--) {
					html = html.substr(0, addresses[i][0]) +
						   replacement(addresses[i][2]) +
						   html.substr(addresses[i][1]);
				}
			}
			
			return html;
		},
		
		/**
		 * Process HTML and replace all nodes with supra tags {supra.link id="..."}
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {HTML}
		 */
		tagHTML: function (html) {
			var htmleditor = this.htmleditor,
				NAME = this.NAME,
				self = this;
			
			//Add links to email addresses
			html = this.parseStrings(html);
			
			//Opening tag
			html = html.replace(/<a([^>]*)>/gi, function (html, attrs_html) {
				var attrs = htmleditor.parseTagAttributes(attrs_html),
					id = attrs.id || htmleditor.generateDataUID(),
					data = htmleditor.getData(id);
				
				if (!id || !data) {
					// Only if there isn't data
					
					if (attrs.href.indexOf('mailto:') == 0) {
						data = {
							'href': attrs.href || '',
							'resource': 'email',
							'target': attrs.target || '',
							'title': attrs.title || attrs.href.replace('mailto:', ''),
							'classname': attrs['class'] || '',
							'button': (attrs['class'] || '').indexOf(self.configuration.buttonClassName) != -1,
							'type': NAME
						};
					} else {
						data = {
							'href': attrs.href || '',
							'resource': 'link',
							'target': attrs.target || '',
							'title': attrs.title || '',
							'classname': attrs['class'] || '',
							'button': (attrs['class'] || '').indexOf(self.configuration.buttonClassName) != -1,
							'type': NAME
						};
					}
					
					htmleditor.setData(id, data, true);
					return '{supra.' + NAME + ' id="' + id + '"}';
				} else {
					data = htmleditor.getData(id);
				
					if (data && data.type == NAME) {
						//Extract classname
						data.classname = attrs['class'] || '';
						
						//Does link has button style
						data.button = data.classname.indexOf(self.configuration.buttonClassName) != -1;
						
						return '{supra.' + NAME + ' id="' + id + '"}';
					} else {
						return html;
					}
				}
			});
			
			//Closing tag
			html = html.replace(/<\/a[^>]*>/g, '{/supra.' + NAME + '}');
			
			return html;
		},
		
		/**
		 * Process pasted HTML and add links to data object
		 * Called after paste plugin cleanPastedHTML
		 * 
		 * @param {Object} event Event
		 */
		tagPastedHTML: function (event, data) {
			var htmleditor = this.htmleditor,
				NAME = this.NAME,
				self = this;
			
			//Extract email addresses
			if (event) {
				data.html = this.parseStrings(data.html);
			}
			
			//Opening tag
			data.html = data.html.replace(/<a([^>]*)>/gi, function (html, attrs_html) {
				var attrs = htmleditor.parseTagAttributes(attrs_html),
					id = attrs.id || htmleditor.generateDataUID(),
					data = null;
				
				if (!id || !htmleditor.getData(id)) {
					// Only if there isn't already data
					
					if (attrs.href.indexOf('mailto:') == 0) {
						data = {
							'href': attrs.href || '',
							'resource': 'email',
							'target': attrs.target || '',
							'title': attrs.title || attrs.href.replace('mailto:', ''),
							'classname': attrs['class'] || '',
							'button': (attrs['class'] || '').indexOf(self.configuration.buttonClassName) != -1,
							'type': NAME
						};
					} else {
						data = {
							'href': attrs.href || '',
							'resource': 'link',
							'target': attrs.target || '',
							'title': attrs.title || '',
							'classname': attrs['class'] || '',
							'button': (attrs['class'] || '').indexOf(self.configuration.buttonClassName) != -1,
							'type': NAME
						};
					}
					
					htmleditor.setData(id, data, true);
				}
				
				// Remove 'href' because it prevents entering another symbol after last/before first in Chrome
				if ('href' in attrs) {
					attrs_html = attrs_html.replace(/href="?'?[^\s"'>]+'?"?/i, '');
				}
				
				if (attrs.id) {
					return '<a' + attrs_html.replace(/id="?'?[a-z0-9\_]+'?"?/i, 'id="' + id + '"') + '>';
				} else {
					return '<a' + attrs_html + ' id="' + id + '">';
				}
			});
		},
		
		/**
		 * Process HTML and replace all supra tags with nodes
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			var htmleditor = this.htmleditor,
				NAME = this.NAME,
				self = this,
				tmp  = {'html': html};
			
			//Save data and process normal <a> tags
			this.tagPastedHTML(null, tmp);
			html = tmp.html;
			
			//Opening tags
			html = html.replace(/{supra\.link id="([^"]+)"}/ig, function (tag, id) {
				if (!id || !data[id] || data[id].type != NAME) return '';
				
				var href = self.normalizeHref(data[id].href),
					classname = data[id].classname || '';
				
				if (data[id].button) {
					if (classname.indexOf(self.configuration.buttonClassName) == -1) {
						classname = (classname ? ' ' : '') + self.configuration.buttonClassName;
					}
				}
				
				return '<a id="' + id + '"' + (classname ? ' class="' + classname + '"' : '') + (data[id].target ? ' target="' + data[id].target + '"' : '') + ' title="' + Y.Escape.html(data[id].title || '') + '">';
			});
			
			//Closing tags
			html = html.replace(/{\/supra\.link}/g, '</a>');
			
			//Process email addresses
			html = this.parseStrings(html);
			
			return html;
		},
		
		/**
		 * Process data and remove all unneeded before it's sent to server
		 * Called before save
		 * 
		 * @param {String} id Data ID
		 * @param {Object} data Data
		 * @return Processed data
		 * @type {Object}
		 */
		processData: function (id, data) {
			//Remove unneeded data
			delete(data.file_path);
			
			//HREF is needed for external links and email (optional)
			if (data.resource != 'link' && data.resource != 'email') delete(data.href);
			
			return data;
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-video', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	var Manager = Supra.Manager;
	
	var DEFAULT_ALIGN = 'middle';
	
	Supra.HTMLEditor.addPlugin('video', defaultConfiguration, {
		
		/**
		 * Link editor is visible
		 * @type {Boolean}
		 */
		visible: false,
		
		
		/* --------------------------- INSERT/EDIT VIDEO --------------------------- */
		
		
		/**
		 * Returns empty data object
		 * 
		 * @private
		 */
		getBlankData: function () {
			return {
				'type': this.NAME,
				'resource': 'source',
				'source': '',
				'width': 0,
				'height': 0,
				'align': DEFAULT_ALIGN
			};
		},
		
		/**
		 * Insert link around current selection
		 */
		insertVideo: function () {
			if (!this.htmleditor.editingAllowed) return;
			
			var htmleditor = this.htmleditor,
				selection = htmleditor.getSelection(),
				node = null;
			
			// If in current selection is a video then edit it instead of creating new
			var nodes = htmleditor.findNodesInSelection(selection, '.supra-video');
			
			if (nodes && nodes.size()) {
				// Edit selected video
				
				node = nodes.item(0);
				
				if ( this.editVideo(node) ) {
					//Prevent default 
					return false;
				}
				
			} else if (htmleditor.isSelectionEditable(selection)) {
				// Insert video element
				var uid = htmleditor.generateDataUID(),
					html = '<div id="' + uid + '" class="supra-video su-uneditable" tabindex="0"></div>',
					data = this.getBlankData();
				
				htmleditor.setData(uid, data);
				htmleditor.replaceSelection(html, null);
				
				node = htmleditor.one('#' + uid);
				node.addClass('align-' + data.align);
				htmleditor.disableNodeEditing(node.getDOMNode());
				
				// Trigger selection change event
				this.htmleditor.refresh(true);
				
				// Start editing video
				if ( this.editVideo(node, data) ) {
					//Prevent default
					return false;
				}
				
			}
			
			return true;
		},
		
		/**
		 * Edit video
		 * 
		 * @param {Object} target Event or target element
		 * @param {Object} data Target element data, optional
		 * @private
		 */
		editVideo: function (target, data) {
			// Target may be actually event object
			var target = target.currentTarget ? target.currentTarget : target;
			
			if (!this.htmleditor.editingAllowed) return;
			
			//Get current value
			var data = data || this.htmleditor.getData(target);
			
			if (!data) {
				// Missing data
				return false;
			}
			
			this.showVideoSettings(target, data, function () {
				this.onVideoEditingDone(target);
			}, this);
			
			return true;
		},
		
		/**
		 * After user changed video save data into htmleditor
		 * 
		 * @param {Object} event
		 * @private
		 */
		onVideoEditingDone: function () {
			if (!this.selected_video) return;
			
			var data  = this.settings_form.getValues('id'),
				id    = this.selected_video_id,
				video = null;
			
			if (data && data.video) {
				video = data.video;
				
				if (!video.width) {
					video.width = parseInt(this.selected_video.get('offsetWidth'), 10);
					video.height = ~~(video.width / Supra.Input.Video.getVideoSizeRatio(video));
				}
				
				// Update data
				this.htmleditor.setData(id, Supra.mix({'type': this.NAME}, video));
				
				// Update preview
				this.updateVideoPreview(this.selected_video, video);
				this.selected_video.removeClass('align-left').removeClass('align-right').removeClass('align-middle').addClass('align-' + video.align);
			}
			
			//
			this.selected_video = null;
			this.selected_video_id = null;
			
			this.hideVideoSettings();
			
			//Trigger selection change event
			this.visible = false;
			this.htmleditor.refresh(true);
			
			//Button is not down anymore
			var button = this.htmleditor.get('toolbar').getButton('insertvideo');
			if (button) button.set('down', false);
		},
		
		/**
		 * On video input change update UI
		 */
		updatePreview: function (e) {
			// Triggered because we are setting form values
			if (this._setValueTrigger || !e.value) return;
			

			var input = this.settings_form.getInput('video'),
				value = e.value,
				node  = this.selected_video;
			
			node.removeClass('align-left').removeClass('align-right').removeClass('align-middle').addClass('align-' + value.align);
			this.updateVideoPreview(node, value);
			
		},
		
		/**
		 * Update video preview size
		 * 
		 * @param {Object} node Video element
		 * @param {Object} data Video data
		 * @private
		 */
		updateVideoSize: function (node, data) {
			var Input = Supra.Input.Video,
				width = parseInt(data.width, 10) || node.get('offsetWidth'),
				height = ~~(width / Input.getVideoSizeRatio(data));
			
			if (data.width != width) {
				data.width = width;
				data.height = height;
			}
			
			node.setStyles({
				'width': data.width + 'px',
				'height': data.height + 'px'
			});
		},
		
		/**
		 * Update video preview image
		 * 
		 * @param {Object} node Video element
		 * @param {Object} data Video data
		 * @private
		 */
		updateVideoPreview: function (node, data) {
			var Input = Supra.Input.Video;
			Input.getVideoPreviewUrl(data).always(function (url) {
				if (url) {
					// Using setAttribute because it's not possible to use !important in styles
					node.setAttribute('style', 'background: #000000 url("' + url + '") no-repeat scroll center center !important; background-size: 100% !important;')
				} else {
					node.removeAttribute('style');
				}
				
				this.updateVideoSize(node, data);
			}, this);
		},
		
		
		/* --------------------------- DELETE VIDEO --------------------------- */
		
		
		/**
		 * Remove selected video
		 * 
		 * @private
		 */
		removeSelectedVideo: function () {
			var node = this.selected_video,
				id = this.selected_video_id;
			
			if (node) {
				node.remove();
				this.selected_video = null;
				this.selected_video_id = null;
				this.htmleditor.removeData(id);
				this.htmleditor.refresh(true);
				
				this.hideVideoSettings();
			}
		},
		
		
		/* --------------------------- SETTINGS FORM --------------------------- */
		
		
		/**
		 * Settings form
		 * @type {Object}
		 * @private
		 */
		settings_form: null,
		
		/**
		 * Selected video ID
		 * @type {String}
		 * @private
		 */
		selected_video_id: null,
		
		/**
		 * Selected video element
		 * @type {Object}
		 * @private
		 */
		selected_video: null,
		
		
		/**
		 * Create settings form
		 * 
		 * @returns {Object} Settings form
		 * @private
		 */
		createSettingsForm: function () {
			//Get form placeholder
			var content = Manager.getAction("PageContentSettings").get("contentInnerNode");
			if (!content) return;
			
			//Properties form
			var form_config = {
				"inputs": [
					{
						"id": "video",
						"type": "Video",
						"label": Supra.Intl.get(["htmleditor", "video_source"]),
						"description": Supra.Intl.get(["htmleditor", "video_description"]),
						"value": "",
						"allowAlign": true
					}
				],
				"style": "vertical"
			};
			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			form.getInput('video').on('change', this.updatePreview, this);
			
			//Delete button
			var btn = new Supra.Button({"label": Supra.Intl.get(["htmleditor", "video_delete"]), "style": "small-red"});
				btn.render(form.get("contentBox"));
				btn.addClass("su-button-delete");
				btn.on("click", this.removeSelectedVideo, this);
			
			this.settings_form = form;
			return form;
		},
		
		/**
		 * Show video settings
		 * 
		 * @param {Object} target Target element
		 * @param {Object} data Video object data
		 */
		showVideoSettings: function (target, data, callback) {
			if (!data) {
				Y.log("Missing data to edit video", "debug");
				return false;
			}
			
			//Make sure PageContentSettings is rendered
			var form = this.settings_form || this.createSettingsForm(),
				action = Manager.getAction("PageContentSettings"),
				width = 0,
				max_width = 0;
			
			if (!form) {
				if (action.get("loaded")) {
					if (!action.get("created")) {
						action.renderAction();
						this.showVideoSettings(target, data, callback);
					}
				} else {
					action.once("loaded", function () {
						this.showVideoSettings(target, data, callback);
					}, this);
					action.load();
				}
				return false;
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			action.execute(form, {
				"hideCallback": Y.bind(callback, this),
				"title": Supra.Intl.get(["htmleditor", "video_properties"]),
				"scrollable": true,
				"toolbarActionName": "htmleditor-plugin"
			});
			
			//
			this.selected_video = target;
			this.selected_video_id = this.selected_video.getAttribute("id");
			
			// Initial width
			max_width = parseInt(this.selected_video.ancestor().get('offsetWidth'), 10);
			width = parseInt(data.width || this.selected_video.get('offsetWidth'), 10);
			
			if (!data.width || data.width != width) {
				data.width = width;
				data.height = ~~(width / Supra.Input.Video.getVideoSizeRatio(data));
			}
			
			this._setValueTrigger = true;
			
			form.getInput('video').set('maxWidth', max_width);
			
			form.resetValues()
				.setValues({'video': data}, 'id', true);
			
			this._setValueTrigger = false;
			
			
			return true;
		},
		
		/**
		 * Hide link manager
		 */
		hideVideoSettings: function () {
			if (this.settings_form && this.settings_form.get("visible")) {
				Manager.PageContentSettings.hide();
			}
		},
		
		/**
		 * Show or hide link manager based on toolbar button state
		 */
		toggleVideoSettings: function () {
			if (this.selected_video) {
				this.onVideoEditingDone();
				
				// Prevent default
				return false;
			} else {
				return this.insertVideo();
			}
		},
		
		/* --------------------------- INITIALIZE --------------------------- */
		
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			// Add command
			htmleditor.addCommand('insertvideo', Y.bind(this.toggleVideoSettings, this));
			
			// When clicking on video show editor
			var container = htmleditor.get('srcNode');
			container.delegate('click', Y.bind(this.editVideo, this), '.supra-video');
			
			// Button
			var toolbar = htmleditor.get('toolbar');
			var button = toolbar ? toolbar.getButton('insertvideo') : null;
			if (button) {
				button.show();
				
				//When un-editable node is selected disable toolbar button
				htmleditor.on('editingAllowedChange', function (event) {
					button.set('disabled', !event.allowed);
				});
			}
			
			this.visible = false;
			
			//After paste replace links with tags
			htmleditor.on('pasteHTML', this.tagPastedHTML, this);
			
			//When selection changes hide link manager
			htmleditor.on('selectionChange', this.hideVideoSettings, this);
			
			//Hide link manager when editor is closed
			htmleditor.on('disable', this.hideVideoSettings, this);
			
			// When HTML changes make sure video previews are set
			htmleditor.on("afterSetHTML", this.afterSetHTML, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {},
		
		
		/* --------------------------- PARSER --------------------------- */
		
		
		/**
		 * Update video previews
		 * 
		 * @private
		 */
		afterSetHTML: function () {
			var htmleditor = this.htmleditor,
				data = htmleditor.getAllData(),
				id,
				srcNode = htmleditor.get('srcNode'),
				node = null;
			
			for(id in data) {
				if (data[id].type == this.NAME) {
					node = srcNode.one('#' + id);
					if (node) {
						this.updateVideoPreview(node, data[id]);
					}
				}
			}
		},
		
		/**
		 * Process HTML and replace all nodes with supra tags {supra.video id="..."}
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {HTML}
		 */
		tagHTML: function (html) {
			var htmleditor = this.htmleditor,
				NAME = this.NAME;
			
			//Opening tag
			html = html.replace(/<div [^>]*id="([^"]+)"[^>]*>[^<]*<\/div[^>]*>/gi, function (html, id) {
				if (!id) return html;
				var data = htmleditor.getData(id);
				
				if (data && data.type == NAME) {
					return '{supra.' + NAME + ' id="' + id + '"}';
				} else {
					return html;
				}
			});
			
			return html;
		},
		
		/**
		 * Process HTML and replace all supra tags with nodes
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			var NAME = this.NAME;
			
			html = html.replace(/{supra\.video id="([^"]+)"}/ig, function (tag, id) {
				if (!id || !data[id] || data[id].type != NAME) return '';
				return '<div id="' + id + '" class="supra-video su-uneditable align-' + (data[id].align || DEFAULT_ALIGN) + '" tabindex="0"></div>';
			});
			
			return html;
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-table', function (Y) {
	
	//Constants
	var HTMLEDITOR_COMMAND = 'inserttable',
		HTMLEDITOR_SETTINGS_COMMAND = 'table-settings',
		HTMLEDITOR_BUTTON  = 'inserttable';
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	
	Supra.HTMLEditor.addPlugin('table', defaultConfiguration, {
		
		settings_form: null,
		selected_cell: null,
		selected_table: null,
		original_data: null,
		data: null,
		silent: false,
		
		/**
		 * Generate settings form
		 */
		createSettingsForm: function () {
			//Get form placeholder
			var content = Manager.getAction('PageContentSettings').get('contentInnerNode');
			if (!content) return;
			
			
			//Remove table from "style" plugin list, because this plugin will manage TABLE classnames
			var plugin = this.htmleditor.getPlugin('style');
			if (plugin) {
				plugin.excludeTags(['table', 'tr', 'td', 'th']);
			}
			
			//Form
			var form_config = {
				'style': 'vertical',
				'inputs': [
					{'id': 'rows', 'label': 'Rows', 'type': 'Select', 'value': '3', 'values': [
							{'title': '1', 'id': '1'}, {'title': '2', 'id': '2'}, {'title': '3', 'id': '3'}, {'title': '4', 'id': '4'}, {'title': '5', 'id': '5'}, {'title': '6', 'id': '6'}, {'title': '7', 'id': '7'}, {'title': '8', 'id': '8'}, {'title': '9', 'id': '9'}
						]},
					{'id': 'columns', 'label': 'Columns', 'type': 'Select', 'value': '3', 'values': [
							{'title': '1', 'id': '1'}, {'title': '2', 'id': '2'}, {'title': '3', 'id': '3'}, {'title': '4', 'id': '4'}, {'title': '5', 'id': '5'}, {'title': '6', 'id': '6'}, {'title': '7', 'id': '7'}, {'title': '8', 'id': '8'}, {'title': '9', 'id': '9'}
						]},
				]
			};

			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			//On style change update table
			for(var i=0,ii=form_config.inputs.length; i<ii; i++) {
				form.getInput(form_config.inputs[i].id).after('valueChange', this.onPropertyChange, this);
			}
			
			//Delete button
			var btn = new Supra.Button({'label': Supra.Intl.get(['buttons', 'delete']), 'style': 'small-red'});
				btn.render(form.get('contentBox'));
				btn.addClass('su-button-delete');
				btn.on('click', this.removeSelectedTable, this);
			
			this.settings_form = form;
			return form;
		},
		
		cmdRowBefore: function () {
			this.cmdRow('before');
		},
		cmdRowAfter: function () {
			this.cmdRow('after');
		},
		cmdRow: function (where) {
			var sel_td = this.selected_cell,
				sel_tr = sel_td.ancestor(),
				all_td = sel_tr.get('children'),
				new_tr = '',
				colspan = 1,
				cell_html = '<br />';
			
			if (Y.UA.ie) {
				cell_html = '';
			}
			
			for(var i=0,ii=all_td.size(); i<ii; i++) {
				colspan = parseInt(all_td.item(i).getAttribute('colspan'), 10) || 1;
				new_tr += '<td' + (colspan > 1 ? ' colspan="' + colspan +'"' : '') + '>' + cell_html + '</td>';
			}
			
			sel_tr.insert('<tr>' + new_tr + '</tr>', where);
		},
		cmdRowDelete: function () {
			this.selected_cell.ancestor().remove();
			
			if (this.selected_table.all('tr').size() == 0) {
				//Table last row was removed
				return this.removeSelectedTable();
			}
			
			this.selected_cell = this.selected_table.one('th,td');
			this.selected_cell.addClass('yui3-cell-selected');
		},
		
		cmdColBefore: function () {
			var sel_td = Y.Node.getDOMNode(this.selected_cell),
				index = this.getCellIndex(sel_td),
				table = this.selected_table,
				trs = Y.Node.getDOMNode(table).getElementsByTagName('TR');
			
			if (index > 0) {
				var cell = null,
					prevCell = null;
				
				for(var i=0,ii=trs.length; i<ii; i++) {
					//Find current and previous cell (by index) in given TR
					cell = this.getCellAtIndex(trs[i], index);
					prevCell = this.getCellAtIndex(trs[i], index - 1);
					
					if (prevCell === cell) {
						//If they match, then update colspan
						cell.setAttribute('colspan', this.getCellSpan(cell) + 1);
					} else {
						this.insertCell(trs[i], index);
					}
				}
			} else {
				//If inserting first cell then ignore colspan
				for(var i=0,ii=trs.length; i<ii; i++) {
					this.insertCell(trs[i], index);
				}
			}
		},
		cmdColAfter: function () {
			var sel_td = Y.Node.getDOMNode(this.selected_cell),
				index = this.getCellIndex(sel_td),
				table = this.selected_table,
				trs = Y.Node.getDOMNode(table).getElementsByTagName('TR'),
				length = this.getRowLength(trs[0]),
				targetcell = null;
			
			if (index + 1 < length) {
				var cell = null,
					prevCell = null;
				
				for(var i=0,ii=trs.length; i<ii; i++) {
					//Find current and next cell (by index) in given TR
					cell = this.getCellAtIndex(trs[i], index + 1);
					prevCell = this.getCellAtIndex(trs[i], index);
					if (prevCell === cell) {
						//If they match, then update colspan
						cell.setAttribute('colspan', this.getCellSpan(cell) + 1);
					} else {
						this.insertCell(trs[i], index + 1);
					}
				}
			} else {
				//If inserting last cell then ignore colspan
				for(var i=0,ii=trs.length; i<ii; i++) {
					this.insertCell(trs[i], index + 1);
				}
			}
		},
		
		cmdColDelete: function () {
			var sel_td = Y.Node.getDOMNode(this.selected_cell),
				index = this.getCellIndex(sel_td),
				table = this.selected_table,
				trs = Y.Node.getDOMNode(table).getElementsByTagName('TR'),
				td = null,
				colspan = 0;
			
			for(var i=0,ii=trs.length; i<ii; i++) {
				td = this.getCellAtIndex(trs[i], index);
				colspan = this.getCellSpan(td);
				if (colspan > 1) {
					td.setAttribute('colspan', colspan - 1);
				} else {
					td.parentNode.removeChild(td);
				}
			}
			
			if (table.all('td').size() == 0 && table.all('th').size() == 0) {
				//Table last column was removed
				this.removeSelectedTable();
			}
		},
		
		fixRangeContainer: function (container, offset) {
			if (container.nodeType != 1) container = container.parentNode;
			if (container.tagName != 'TD' && container.tagName != 'TH' && container.tagName != 'TR') {
				var node = new Y.Node(container);
					node = node.closest('TD,TH');
				
				container = node ? Y.Node.getDOMNode(node) : null;
				if (!container) return null;
			}
			
			if (container.tagName == 'TR') {
				container = container.childNodes[offset];
			}
			
			return container;
		},
		
		cmdMergeCells: function () {
			var win = this.htmleditor.get('win'), tr = null;
			if (win.getSelection) {
				var sel = win.getSelection(),
					tds = [],
					colspansum = 0,
					range = null,
					td = null,
					start_container = null,
					end_container = null;
				
				for(var i=0,ii=sel.rangeCount; i<ii; i++) {
					range = sel.getRangeAt(i);
					start_container = range.startContainer;
					end_container = range.endContainer;
					
					start_container = this.fixRangeContainer(start_container, range.startOffset);
					
					if (range.startContainer !== range.endContainer) {
						end_container = this.fixRangeContainer(end_container, range.endOffset);
					} else {
						end_container = start_container;
					}
					
					if (!tr) {
						tr = start_container.parentNode;
					}
					
					if (start_container.parentNode === tr && end_container.parentNode === tr) {
						while(start_container) {
							if (start_container.nodeType == 1) {
								tds.push(start_container);
								colspansum += this.getCellSpan(start_container);
							}
							if (start_container === end_container) break;
							start_container = start_container.nextSibling;
						}
					}
				}
				
				for(var i=0,ii=tds.length; i<ii; i++) {
					if (i == 0) {
						tds[i].setAttribute('colspan', colspansum);
					} else {
						tds[i].parentNode.removeChild(tds[i]);
					}
				}
			}
		},
		
		/**
		 * Insert cell at specific index
		 * If row consists of THs then insert TH instead of TD
		 * 
		 * @param {Object} tr
		 * @param {Object} index
		 */
		insertCell: function (tr, index) {
			//Insert new cell
			var cell_html = '<br />';
			if (Y.UA.ie) {
				cell_html = '';
			}
			
			//Find tag name
			var children = Y.Node(tr).get('children'),
				tag = children.size() ? children.item(0).get('tagName') : 'TD';
			
			//Create new cell
			var td = document.createElement(tag);
				td.innerHTML = cell_html;
			
			var cell = this.getCellAtIndex(tr, index);
			if (cell) {
				tr.insertBefore(td, cell);
			} else {
				tr.appendChild(td);
			}
		},
		
		/**
		 * Returns number of columns in the table
		 * 
		 * @return Column count
		 * @type {Number}
		 */
		getColCount: function () {
			if (!this.selected_table) return 0;
			
			var trs = this.selected_table.all('tr'),
				i = 0,
				ii = trs.size(),
				max = 0;
			
			for (; i<ii; i++) {
				max = Math.max(max, this.getRowLength(trs.item(i).getDOMNode()));
			}
			
			return max;
		},
		
		/**
		 * Returns number of rows in the table
		 * 
		 * @return Row count
		 * @type {Number}
		 */
		getRowCount: function () {
			return this.selected_table ? this.selected_table.all('tr').size() : 0;
		},
		
		/**
		 * Returns cell index (all previous cell colspan summ)
		 * 
		 * @param {HTMLElement} cell
		 * @return Cell index
		 * @type {Number}
		 */
		getCellIndex: function (cell) {
			var index = 0;
			
			cell = cell.previousSibling;
			while(cell) {
				if (cell.nodeType == 1) {
					index += this.getCellSpan(cell);
				}
				cell = cell.previousSibling;
			}
			
			return index;
		},
		
		/**
		 * Returns number of cells in a row
		 * 
		 * @param {HTMLElement} tr Row element
		 * @return Number of cells in a row
		 * @type {Number}
		 */
		getRowLength: function (tr) {
			var tds = tr.childNodes,
				length = 0;
			
			for(var i=0,ii=tds.length; i<ii; i++) {
				if (tds[i].nodeType == 1) length++;
			}
			
			return length;
		},
		
		/**
		 * Returns cell at index
		 * 
		 * @param {HTMLElement} tr
		 * @param {Number} index
		 * @return Cell
		 * @type {HTMLElement}
		 */
		getCellAtIndex: function (tr, index) {
			var tds = tr.childNodes,
				curindex = 0;
			
			for(var i=0,ii=tds.length; i<ii; i++) {
				if (tds[i].nodeType == 1) {
					curindex += this.getCellSpan(tds[i]);
					if (curindex > index) return tds[i];
				}
			}
			
			return null;
		},
		
		/**
		 * Returns cells colspan
		 * 
		 * @param {HTMLElement} cell
		 * @return Cell colspan
		 * @type {Number}
		 */
		getCellSpan: function (cell) {
			return parseInt(cell.getAttribute('colspan'), 10) || 1;
		},
		
		/**
		 * Returns TD index
		 * 
		 * @param {HTMLElement} cell
		 * @return TD index
		 * @type {Number}
		 */
		getTDIndex: function (cell) {
			var index = 0;
			
			cell = cell.previousSibling;
			while(cell) {
				if (cell.nodeType == 1) {
					index++;
				}
				cell = cell.previousSibling;
			}
			
			return index;
		},
		
		/**
		 * Handle property input value change, update UI
		 * 
		 * @param {Object} event Event
		 */
		onPropertyChange: function (event) {
			if (this.silent || !this.selected_table) return;
			
			var target = event.target,
				id = target.get('id'),
				value = this.settings_form.getInput(id).get('value');
			
			this.setProperty(id, value);
		},
		
		/**
		 * Set property value, update UI
		 * 
		 * @param {String} id
		 * @param {String} value
		 */
		setProperty: function (id, value) {
			if (id == 'rows') {
				var old_value = this.getRowCount(),
					i = 0, ii = 0,
					trs = this.selected_table.all('tr');
				
				//Remove selection classname
				if (this.selected_cell) {
					this.selected_cell.removeClass('yui3-cell-selected');
				}
				
				value = parseInt(value, 10);
				this.selected_cell = trs.item(trs.size() - 1).one('th, td');
				
				if (value > old_value) {
					//Increase column count
					for (i=old_value+1, ii=value+1; i<ii; i++) {
						this.cmdRowAfter();
						
						trs = this.selected_table.all('tr');
						this.selected_cell = trs.item(trs.size() - 1).one('th, td');
					}
				} else if (value < old_value) {
					//Remove columns
					for (i=old_value, ii=value; i>ii; i--) {
						this.cmdRowDelete();
						
						trs = this.selected_table.all('tr');
						this.selected_cell = trs.item(trs.size() - 1).one('th, td');
					}
				}
				
				//Set selection and add classname
				trs = this.selected_table.all('tr');
				this.selected_cell = trs.item(trs.size() - 1).one('th, td');
				this.selected_cell.addClass('yui3-cell-selected');
				
				//Property changed, update editor 'changed' state
				this.htmleditor._changed();
				
			} else if (id == 'columns') {
				var old_value = this.getColCount(),
					i = 0, ii = 0,
					tds = this.selected_table.one('tr').all('th, td');
				
				//Remove selection classname
				if (this.selected_cell) {
					this.selected_cell.removeClass('yui3-cell-selected');
				}
				
				value = parseInt(value, 10);
				this.selected_cell = tds.item(tds.size() - 1);
				
				if (value > old_value) {
					//Increase column count
					for (i=old_value+1, ii=value+1; i<ii; i++) {
						this.cmdColAfter();
						
						tds = this.selected_table.one('tr').all('th, td');
						this.selected_cell = tds.item(tds.size() - 1);
					}
				} else if (value < old_value) {
					//Remove columns
					for (i=old_value, ii=value; i>ii; i--) {
						this.cmdColDelete();
						
						tds = this.selected_table.one('tr').all('th, td');
						this.selected_cell = tds.item(tds.size() - 1);
					}
				}
				
				//Set selection and add classname
				tds = this.selected_table.one('tr').all('th, td');
				this.selected_cell = tds.item(tds.size() - 1);
				this.selected_cell.addClass('yui3-cell-selected');
				
				//Property changed, update editor 'changed' state
				this.htmleditor._changed();
				
			}
		},
		
		/**
		 * Returns true if form is visible, otherwise false
		 */
		hideSettingsForm: function () {
			if (this.settings_form && this.settings_form.get('visible')) {
				Manager.PageContentSettings.hide();
			}
			
			//Button style
			this.getButton(HTMLEDITOR_SETTINGS_COMMAND).set('down', false);
		},
		
		/**
		 * Remove selected image
		 */
		removeSelectedTable: function () {
			if (this.selected_table) {
				this.selected_table.remove();
				this.selected_table = null;
				this.selected_cell = null;
				this.original_data = null;
				this.data = null;
				this.htmleditor.refresh(true);
				this.hideToolbar();
				this.hideSettingsForm();
			}
		},
		
		/**
		 * Returns all table styles
		 */
		getTableStyles: function () {
			var style_plugin = this.htmleditor.getPlugin('style'),
				list = [{'id': '', 'title': ''}];
			
			if (style_plugin) {
				var styles = style_plugin.getSelectors('table', true, true);	//Get all table styles
				
				for(var i=0,ii=styles.length; i<ii; i++) {
					list.push({
						'id': styles[i].classname,
						'title': styles[i].attributes.title
					});
				}
			}
			
			return list.length == 1 ? [] : list;
		},
		
		showToolbar: function () {
			var toolbar = this.htmleditor.get('toolbar');
			toolbar.getButton(HTMLEDITOR_BUTTON).set('down', true);
			toolbar.showGroup('table');
		},
		
		hideToolbar: function () {
			var toolbar = this.htmleditor.get('toolbar');
			toolbar.getButton(HTMLEDITOR_BUTTON).set('down', false);
			toolbar.hideGroup('table');
		},
		
		/**
		 * Show table settings bar
		 */
		showTableSettings: function () {
			if (!this.selected_table) return;
			
			//Make sure PageContentSettings is rendered
			var form = this.settings_form || this.createSettingsForm(),
				action = Manager.getAction('PageContentSettings');
			
			if (!form) {
				if (action.get('loaded')) {
					if (!action.get('created')) {
						action.renderAction();
						this.showTableSettings();
					}
				} else {
					action.once('loaded', function () {
						this.showTableSettings();
					}, this);
					action.load();
				}
				return false;
			}
			
			//Button style
			this.getButton(HTMLEDITOR_SETTINGS_COMMAND).set('down', true);
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			action.execute(form, {
				'doneCallback': Y.bind(this.hideSettingsForm, this),
				'title': Supra.Intl.get(['htmleditor', 'table_properties']),
				'scrollable': true,
				'toolbarActionName': 'htmleditor-plugin'
			});
			
			this.silent = true;
			form.getInput('rows').set('value', this.getRowCount());
			form.getInput('columns').set('value', this.getColCount());
			this.silent = false;
		},
		
		/**
		 * Focus table
		 */
		focusTable: function (element) {
			var table = element ? element.closest('table') : null,
				cell = element ? element.closest('td,th') : null;
			
			if (this.selected_table && (!table || !table.compareTo(this.selected_table))) {
				this.selected_table.removeClass('yui3-table-selected');
			}
			if (table) {
				table.addClass('yui3-table-selected');
			}
			
			if (this.selected_cell && (!cell || !cell.compareTo(this.selected_cell))) {
				this.selected_cell.removeClass('yui3-cell-selected');
			}
			if (cell) {
				cell.addClass('yui3-cell-selected');
			}
			
			this.selected_table = table;
			this.selected_cell = cell;
		},
		
		/**
		 * Insert table
		 */
		insertTable: function (values) {
			var htmleditor = this.htmleditor;
			
			if (this.selected_table) {
				//Focus already on table, don't allow creating table inside another table
				return;
			}
			
			if (!htmleditor.get('disabled') && htmleditor.isSelectionEditable(htmleditor.getSelection())) {
				var cell_html = '<br />';
				if (Y.UA.ie) {
					cell_html = '';
				}
				
				var html_row = '<tr><td>' + cell_html + '</td><td>' + cell_html + '</td><td>' + cell_html + '</td></tr>',
					html_table = '<table class="desktop"><tbody><tr><th>' + cell_html + '</th><th>' + cell_html + '</th><th>' + cell_html + '</th></tr>' + html_row + html_row + '</tbody></table>';
				
				//Replace selection with table
				var node = htmleditor.replaceSelection(html_table);
				
				if (node) {
					node = (new Y.Node(node)).one('th,th');
					
					this.showToolbar();
					this.focusTable(node);
				}
				
				//Set changed event
				htmleditor._changed();
			}
		},
		
		/**
		 * On node change check if settings form needs to be hidden
		 */
		onNodeChange: function () {
			var element = this.htmleditor.getSelectedElement('img,td,th,table');
			
			if (element && !Y.Node(element).test('img')) {
				var element = new Y.Node(element),
					table = element.closest('table');
				
				if (this.selected_table && !table.compareTo(this.selected_table)) {
					this.hideSettingsForm();
				}
				
				if (!this.selected_table) {
					this.showToolbar();
				}
				
				this.focusTable(element);
			} else if (this.selected_table) {
				this.focusTable(null);
				this.hideSettingsForm();
				this.hideToolbar();
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			
			// Add command
			htmleditor.addCommand(HTMLEDITOR_COMMAND, Y.bind(this.insertTable, this));
			htmleditor.addCommand(HTMLEDITOR_SETTINGS_COMMAND, Y.bind(this.showTableSettings, this));
			
			htmleditor.addCommand('row-before', Y.bind(this.cmdRowBefore, this));
			htmleditor.addCommand('row-after', Y.bind(this.cmdRowAfter, this));
			htmleditor.addCommand('row-delete', Y.bind(this.cmdRowDelete, this));
			htmleditor.addCommand('merge-cells', Y.bind(this.cmdMergeCells, this));
			htmleditor.addCommand('column-before', Y.bind(this.cmdColBefore, this));
			htmleditor.addCommand('column-after', Y.bind(this.cmdColAfter, this));
			htmleditor.addCommand('column-delete', Y.bind(this.cmdColDelete, this));
			
			var button = this.getButton();
			if (button) {
				//When un-editable node is selected disable toolbar button
				htmleditor.on('editingAllowedChange', function (event) {
					if (!event.allowed) {
						this.hideToolbar();
					}
					button.set('disabled', !event.allowed);
				}, this);
			}
			
			//When image looses focus hide settings form
			htmleditor.on('nodeChange', this.onNodeChange, this);
		},
		
		getButton: function (id) {
			var toolbar = this.htmleditor.get('toolbar');
			return toolbar ? toolbar.getButton(id || HTMLEDITOR_BUTTON) : null;
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {},
		
		/**
		 * Process HTML
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {HTML}
		 */
		tagHTML: function (html) {
			return html;
		},
		
		/**
		 * Process HTML
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			return html;
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-table-mobile', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	//Regular expressions
	var REGEX_TABLE = /<table[^>]*>(.|\n|\r)*?<\/table>/ig,
		REGEX_MOBILE_TABLE = /<table[^>]+class=("[^"]*"|'[^']*'|[^\s>]*)(.|\n|\r)*?<\/table>/ig,
		REGEX_TABLE_START = /<table[^>]*>/i,
		REGEX_HEADINGS = /<th[^>]*>((.|\r|\n)*?)<\/th[^>]*>/ig,
		REGEX_ROWS = /<tr[^>]*>((.|\r|\n)*?)<\/tr[^>]*>/ig,
		REGEX_CELLS = /<td[^>]*>((.|\r|\n)*?)<\/td[^>]*>/ig,
		REGEX_COLSPAN = /\s+colspan="?'?(\d+)'?"?/i,
		
		CLASSNAME_EVEN = 'even',
		CLASSNAME_ODD = 'odd';
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	
	Supra.HTMLEditor.addPlugin('table-mobile', defaultConfiguration, {
		
		/**
		 * On table insert add 'desktop' class to the table
		 * 
		 * @private
		 */
		onTableInsert: function () {
			var plugin = this.htmleditor.getPlugin('table'),
				table;
			
			if (plugin) {
				table = plugin.selected_table;
				if (table) {
					table.addClass('desktop');
				}
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			htmleditor.addCommand('inserttable', Y.bind(this.onTableInsert, this));
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {},
		
		/**
		 * Process HTML and insert mobile friendly version of table
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {HTML}
		 */
		tagHTML: function (html) {
			var regex_table = REGEX_TABLE,
				regex_table_start = REGEX_TABLE_START,
				regex_rows = REGEX_ROWS,
				regex_cells = REGEX_CELLS,
				regex_colspan = REGEX_COLSPAN,
				
				classname_even = CLASSNAME_EVEN,
				classname_odd = CLASSNAME_ODD,
				
				extractHeadings = this.tagHTMLExtractHeadings;
			
			//Regex are dirty, but quick and does the job done
			html = html.replace(regex_table, function (match) {
				var html = '<table class="mobile mobile-portrait">',
					headings = extractHeadings(match),
					rows = match.match(regex_rows),
					cells = null,
					colspan = null,
					i = 0,
					ii = rows ? rows.length : 0,
					k = 0,
					kk = 0,
					index = 0,
					transform = true;
				
				for (; i<ii; i++) {
					cells = rows[i].match(regex_cells) || [];
					index = 0;
					
					if (i == 0 && cells.length < 3 && headings.length == 0) {
						// Don't transform table
						transform = false;
						break;
					}
					
					for (k=0, kk=cells.length; k<kk; k++) {
						colspan = cells[k].match(regex_colspan);
						if (colspan) {
							cells[k] = cells[k].replace(colspan[0], '');
							colspan = parseInt(colspan[1], 10) || 1;
						} else {
							colspan = 1;
						}
						
						html += '<tr class="' + (i % 2 ? classname_even : classname_odd) + '">';
						html += headings[index] || '';
						html += cells[k] || '';
						html += '</tr>';
						
						index += colspan;
					}
				}
				
				if (transform) {
					return match.replace(/<table[^>]*(class="?'?[^"']*"?'?)?/i, '<table class="desktop tablet"') + html + '</table>';
				} else {
					return match.replace(/<table[^>]*(class="?'?[^"']*"?'?)?/i, '<table');
				}
			});
			
			return html;
		},
		
		/**
		 * Extract all headings from HTML
		 * 
		 * @param {String} html
		 * @return Array with all heading HTML
		 * @type {Array}
		 */
		tagHTMLExtractHeadings: function (html) {
			var regex_headings = REGEX_HEADINGS,
				regex_colspan = REGEX_COLSPAN,
				headings = [],
				heading = '',
				colspan = 1,
				matches = html.match(regex_headings),
				i = 0,
				ii = matches ? matches.length : 0;
			
			for (; i<ii; i++) {
				heading = matches[i] || '';
				colspan = heading.match(regex_colspan);
				
				if (colspan) {
					heading = heading.replace(colspan[0], '');
					colspan = parseInt(colspan[1], 10) || 1;
				} else {
					colspan = 1;
				}
				
				headings.push(heading);
				
				if (colspan > 1) {
					for (var i=1; i<=colspan; i++) {
						headings.push('<th></th>');
					}
				}
			}
			
			return headings;
		},
		
		/**
		 * Process HTML and remove all mobile version tables
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			html = html.replace(REGEX_MOBILE_TABLE, function (html, classname) {
				if (classname.indexOf('mobile') != -1) {
					if (classname.indexOf('desktop') == -1 && classname.indexOf('tablet') == -1) {
						// classname is "mobile"
						return '';
					} else {
						// clasname is "mobile mobile-portrait desktop tablet"
						return html.replace(classname, '""');
					}
				}
				
				return html;
			});
			return html;
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-itemlist', function (Y) {
	
	//Constants
	var HTMLEDITOR_TOOLBAR = 'itemlist';
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_STRING, Supra.HTMLEditor.MODE_TEXT, Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	
	Supra.HTMLEditor.addPlugin('itemlist', defaultConfiguration, {
		
		
		/* --------------------------- TOOLBAR --------------------------- */
		
		
		/**
		 * Show itemlist toolbar
		 */
		showToolbar: function () {
			var toolbar = this.htmleditor.get('toolbar'),
				orientation = this.getOptions().orientation;
			
			if (!toolbar.isGroupVisible(HTMLEDITOR_TOOLBAR)) {
				toolbar.showGroup(HTMLEDITOR_TOOLBAR);
				
				if (orientation == 'horizontal') {
					toolbar.getButton('itemlist-row-before').hide();
					toolbar.getButton('itemlist-row-delete').hide();
					toolbar.getButton('itemlist-row-after').hide();
					toolbar.getButton('itemlist-column-before').show();
					toolbar.getButton('itemlist-column-delete').show();
					toolbar.getButton('itemlist-column-after').show();
				} else {
					toolbar.getButton('itemlist-row-before').show();
					toolbar.getButton('itemlist-row-delete').show();
					toolbar.getButton('itemlist-row-after').show();
					toolbar.getButton('itemlist-column-before').hide();
					toolbar.getButton('itemlist-column-delete').hide();
					toolbar.getButton('itemlist-column-after').hide();
				}
			}
		},
		
		/**
		 * Hide itemlist toolbar
		 */
		hideToolbar: function () {
			var toolbar = this.htmleditor.get('toolbar');
			
			if (toolbar.isGroupVisible(HTMLEDITOR_TOOLBAR)) {
				toolbar.hideGroup(HTMLEDITOR_TOOLBAR);
			}
		},
		
		
		/* --------------------------- Options --------------------------- */
		
		
		/**
		 * Configuration options, how to handle DOM, etc.
		 * @type {Object}
		 * @private
		 */
		_options: null,
		
		/**
		 * Returns options from embeded script tag in page HTML
		 */
		getOptions: function () {
			if (this._options !== null) return this._options;
			
			var container = this.getBlockContainer();
				node = container ? container.one('[type="text/supra-instructions"]') : null,
				options = {
					'orientation': 'horizontal',
					'properties': []
				};
			
			if (node) {
				try {
					options = Supra.mix(options, Y.JSON.parse(node.get('innerHTML')) || {});
				} catch (err) {
					options = false;
				}
			}
			
			if (!options || !options.properties || !options.properties.length) {
				options = false; 
			}
			
			this._options = options;
			
			return options;
		},
		
		/**
		 * Returns property options
		 */
		getPropertyOptions: function (property) {
			var properties = this.getOptions().properties,
				i = 0,
				ii = properties.length;
			
			property = property.replace(/\d+/, '%d');
			
			for (; i<ii; i++) {
				if (properties[i].name === property) return properties[i];
			}
			
			return null;
		},
		
		
		/* --------------------------- ITEMS --------------------------- */
		
		/**
		 * Number of items used
		 * @type {Number}
		 * @private
		 */
		_count: 0,
		
		/**
		 * Total number of items
		 * @type {Number}
		 * @private
		 */
		_total: 0,
		
		/**
		 * List of nodes grouped by property name
		 * @type {Object}
		 * @private
		 */
		_nodes: null,
		
		
		/**
		 * Remove cache
		 */
		purgeCache: function () {
			this._nodes = null;
		},
		
		/**
		 * Collect cache
		 */
		collectCache: function () {
			this.getItemNodes();
		},
		
		/**
		 * Returns list of all nodes grouped by property name
		 * 
		 * @returns {Object}
		 */
		getItemNodes: function () {
			if (this._nodes) return this._nodes;
			
			var node = this.getBlockContainer(),
				properties = this.getOptions().properties,
				i = 0,
				ii = properties.length,
				nodes = {},
				
				tmp = null,
				count = 0,
				total = 0;
			
			if (node) {
				for (; i<ii; i++) {
					tmp = node.all(properties[i]['item-selector']);
					nodes[properties[i]['name']] = tmp;
					
					if (i == 0) {
						total = tmp.size();
						count = total - tmp.filter('.supra-hidden').size();
					}
				}
			}
			
			this._total = total;
			this._count = count;
			
			return nodes; 
		},
		
		/**
		 * Returns block container node
		 * 
		 * @returns {Object} Block container node
		 */
		getBlockContainer: function () {
			var root = this.htmleditor.get('root');
			if (root && root.getNode) return root.getNode();
			return null;
		},
		
		/**
		 * Returns active index
		 * 
		 * @returns {Number} Active item index
		 */
		getActiveIndex: function () {
			var properties = this.getOptions().properties,
				i = 0,
				ii = properties.length,
				classname = '',
				
				nodes = this.getItemNodes(),
				tmp = null,
				k = 0,
				kk = 0;
			
			for (; i<ii; i++) {
				classname = properties[i]['classname-active'];
				if (classname) {
					tmp = nodes[properties[i].name];
					k = 0;
					kk = tmp.size();
					
					for (; k<kk; k++) {
						if (tmp.item(k).hasClass(classname)) return k;
					}
				}
			}
			
			// Fail...
			return 0;
		},
		
		/**
		 * Returns nodes by index
		 */
		getItemNodesByIndex: function (index) {
			var nodes = this.getItemNodes(),
				properties = this.getOptions().properties,
				i = 0,
				ii = properties.length,
				output = [],
				node = null;
			
			for (; i<ii; i++) {
				node = nodes[properties[i].name].item(index);
				if (node) {
					output.push(node);
				}
			}
			
			return output;
		},
		
		/**
		 * Hide item by index
		 * 
		 * @param {Number} index Item index
		 */
		hideItemByIndex: function (index) {
			var nodes = this.getItemNodesByIndex(index),
				i = 0,
				ii = nodes.length;
			
			for (; i<ii; i++) {
				nodes[i].addClass('supra-hidden');
			}
		},
		
		/**
		 * Show item by index
		 * 
		 * @param {Number} index Item index
		 */
		showItemByIndex: function (index) {
			var nodes = this.getItemNodesByIndex(index),
				i = 0,
				ii = nodes.length;
			
			for (; i<ii; i++) {
				nodes[i].removeClass('supra-hidden');
			}
		},
		
		/**
		 * Set active item by index
		 * 
		 * @param {Number} index Item index
		 */
		setActiveItemByIndex: function (index) {
			if (index >= 0 && index < this._count) {
				
				var properties = this.getOptions().properties,
					i = 0,
					ii = properties.length,
					nodes = this.getItemNodes(),
					tmp = null,
					k = 0,
					kk = 0,
					classname = '';
				
				for (; i<ii; i++) {
					classname = properties[i]['classname-active'];
					
					if (classname) {
						tmp = nodes[properties[i].name];
						k = 0;
						kk = tmp.size();
						
						for (; k<kk; k++) {
							if (k === index) {
								tmp.item(k).addClass(classname);
							} else {
								tmp.item(k).removeClass(classname);
							}
						}
					}
				}
				
			}
		},
		
		/**
		 * Copy property values from index a to index b
		 */
		copyItemPropertiesByIndex: function (a, b) {
			var properties = this.getOptions().properties,
				i = 0,
				ii = properties.length,
				name_a = null,
				name_b = null,
				root = this.htmleditor.get('root'), // root is either a block or form
				inputs = root.getInputs ? root.getInputs() : root.properties.get('form').getInputs(),
				input_a = null,
				input_b = null;
			
			for (; i<ii; i++) {
				name_a = properties[i].name.replace('%d', (a + 1)); // +1 because property names starts from 1
				name_b = properties[i].name.replace('%d', (b + 1)); // +1 because property names starts from 1
				
				input_a = inputs[name_a];
				input_b = inputs[name_b];
				
				if (input_a && input_b) {
					input_b.setValue(input_a.getValue());
				}
			}
		},
		
		/**
		 * Reset item property values
		 */
		resetItemPropertiesByIndex: function (index) {
			var properties = this.getOptions().properties,
				i = 0,
				ii = properties.length,
				name = null,
				root = this.htmleditor.get('root'), // root is either a block or form
				inputs = root.getInputs ? root.getInputs() : root.properties.get('form').getInputs(),
				input = null;
			
			for (; i<ii; i++) {
				name = properties[i].name.replace('%d', (index + 1)); // +1 because property names starts from 1
				input = inputs[name];
				
				if (input) {
					input.setValue('');
				}
			}
		},
		
		
		/* --------------------------- COMMANDS --------------------------- */
		
		
		cmdInsertBefore: function () {
			this.collectCache();
			
			// Maximum number of items reached
			if (this._count >= this._total) return;
			
			this.showItemByIndex(this._count);
			this._count++;
			
			var active = this.getActiveIndex(),
				i = this._count,
				ii = active + 1; 
			
			for (; i>ii; i--) {
				this.copyItemPropertiesByIndex(i-2, i-1);
			}
			
			this.resetItemPropertiesByIndex(active);
			this.htmleditor._changed();
		},
		
		cmdInsertAfter: function () {
			this.collectCache();
			
			// Maximum number of items reached
			if (this._count >= this._total) return;
			
			this.showItemByIndex(this._count);
			this._count++;
			
			var active = this.getActiveIndex(),
				i = this._count,
				ii = active + 2; 
			
			for (; i>ii; i--) {
				this.copyItemPropertiesByIndex(i-2, i-1);
			}
			
			this.resetItemPropertiesByIndex(active + 1);
			this.setActiveItemByIndex(active + 1);
			this.htmleditor._changed();
		},
		
		cmdDelete: function () {
			this.collectCache();
			
			// At least one item must remain
			if (this._count <= 1) return;
			
			this.hideItemByIndex(this._count - 1);
			this._count--;
			
			var active = this.getActiveIndex(),
				i = active,
				ii = this._count; 
			
			for (; i<ii; i++) {
				this.copyItemPropertiesByIndex(i+1, i);
			}
			
			if (active >= this._count) { 
				this.setActiveItemByIndex(active - 1);
			}
			
			this.resetItemPropertiesByIndex(this._count);
			this.htmleditor._changed();
		},
		
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			// Find options
			var options = this.getOptions();
			
			if (options) {
				// Add commands
				htmleditor.addCommand('itemlist-before', Y.bind(this.cmdInsertBefore, this));
				htmleditor.addCommand('itemlist-after', Y.bind(this.cmdInsertAfter, this));
				htmleditor.addCommand('itemlist-delete', Y.bind(this.cmdDelete, this));
			}
			
			htmleditor.on('disabledChange', this.purgeCache, this);
			htmleditor.on('editingAllowedChange', this.purgeCache, this);
			
			//When un-editable node is selected hide toolbar
			htmleditor.on('disabledChange', function (event) {
				if (event.newVal !== event.prevVal) {
					if (event.newVal || !options) {
						this.hideToolbar();
					} else {
						this.showToolbar();
					}
				}
			}, this);
			htmleditor.on('editingAllowedChange', function (event) {
				if (!event.allowed || !options) {
					this.hideToolbar();
				} else {
					this.showToolbar();
				}
			}, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			this.purgeCache();
		},
		
		/**
		 * Process HTML
		 * Called before HTML is saved
		 * 
		 * @param {String} html
		 * @return Processed HTML
		 * @type {HTML}
		 */
		tagHTML: function (html) {
			return html;
		},
		
		/**
		 * Process HTML
		 * Called before HTML is set
		 * 
		 * @param {String} html HTML
		 * @param {Object} data Data
		 * @return Processed HTML
		 * @type {String}
		 */
		untagHTML: function (html, data) {
			return html;
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};

}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add("supra.htmleditor-plugin-insert", function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	/*
	 * Plugin to control insert panel
	 */
	Supra.HTMLEditor.addPlugin("insert", defaultConfiguration, {
		
		/**
		 * Insert toolbar is visible
		 */
		visible: false,
		
		/**
		 * Toggle insert toolbar
		 */
		toggleInsertToolbar: function () {
			var toolbar = this.htmleditor.get("toolbar"),
				button = toolbar.getButton("insert");
			
			if (button) {
				if (!this.visible) {
					this.visible = true;
					toolbar.showGroup("insert");
					button.set("down", true);
				} else {
					this.visible = false;
					toolbar.hideGroup("insert");
					button.set("down", false);
				}
			}
		},
		
		/**
		 * Hide insert toolbar
		 */
		hideInsertToolbar: function () {
			if (this.visible) {
				var toolbar = this.htmleditor.get("toolbar"),
					button = toolbar.getButton("insert");
				
				toolbar.hideGroup("insert");
				button.set("down", false);
				
				this.visible = false;
			}
		},
		
		/**
		 * When editable/uneditable content is selected enable/disable button and hide toolbar
		 * 
		 * @private
		 */
		onEditingAllowedChange: function (event) {
			this.htmleditor.get("toolbar").getButton("insert").set("disabled", !event.allowed);
			
			if (!event.allowed) {
				this.hideInsertToolbar();
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			var toolbar = htmleditor.get("toolbar"),
				button = toolbar ? toolbar.getButton("insert") : null;
			
			// Add command
			htmleditor.addCommand("insert", Y.bind(this.toggleInsertToolbar, this));
			
			// When one of the insert controls is clicked hide toolbar
			var controls = toolbar.getControlsInGroup("insert"),
				i = 0,
				ii = controls.length;
			
			for (; i<ii; i++) {
				if (controls[i].command) {
					htmleditor.addCommand(controls[i].command, Y.bind(this.hideInsertToolbar, this));
				}
			}
			
			if (button) {
				//When un-editable node is selected disable toolbar button and hide toolbar
				htmleditor.on("editingAllowedChange", this.onEditingAllowedChange, this);
			}
			
			//Hide media library when editor is closed
			htmleditor.on("disable", this.hideInsertToolbar, this);
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {"requires": ["supra.htmleditor-base"]});YUI().add('supra.htmleditor-plugin-maxlength', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_STRING, Supra.HTMLEditor.MODE_TEXT]
	};
	
	Supra.HTMLEditor.addPlugin('paragraph-maxlength', defaultConfiguration, {
		
		/**
		 * Prevent keys if new content will be added and maxlength has been reached
		 * 
		 * @private
		 */
		_onKey: function (event) {
			var keyCode = event.keyCode,
				charCode = event.charCode || event.keyCode,
				editor = this.htmleditor,
				maxLength = editor.get('maxLength');
			
			if (maxLength && !event.stopped && !event.alyKey && !event.ctrlKey && !event.metaKey) {
				if (editor.insertCharacterCharCode(charCode)) {
              		if (editor.getContentCharacterCount() >= maxLength) {
              			event.halt();
              		}
              	} 
			}
		},
		
		/**
		 * Check content length after paste
		 * and remove characters if content length exceeds maxLength 
		 * 
		 * @private 
		 */
		_afterPaste: function (event) {
			var editor    = this.htmleditor,
				maxlength = editor.get('maxLength'),
				srcNode   = null,
				nodes     = null,
				count     = 0,
				remove    = 0,
				text      = '';
			
			if (maxlength) {
				srcNode = editor.get('srcNode');
				count = editor.getContentCharacterCount();
				
				if (count >= maxlength) {
					remove = count - maxlength;
					nodes = srcNode.get('childNodes').getDOMNodes();
					
					for (var i=nodes.length-1; i>=0; i--) {
						if (nodes[i].nodeType == 1) {
							// BR tag, remove it
							nodes[i].parentNode.removeChild(nodes[i]);
							remove--;
						} else if (nodes[i].nodeType == 3) {
							// Text node
							text = nodes[i].textContent;
							if (text.length) {
								if (text.length > remove) {
									// Truncate text
									nodes[i].textContent = text.substr(0, text.length - remove);
									remove = 0;
								} else {
									// Remove node
									remove -= text.length;
									nodes[i].parentNode.removeChild(nodes[i]);
								}
							}
						}
						
						if (remove == 0) {
							// We have removed needed amount of characters
							return;
						}
					}
				}
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			htmleditor.on('keyDown', this._onKey, this);
			htmleditor.on('afterPaste', this._afterPaste, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI.add('supra.manager-base', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Class for managing Actions, loading and executing them
	 *
	 * @class ManagerHost
	 */
	function ManagerHost () {
		ManagerHost.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	ManagerHost.NAME = 'ManagerHost';

        /**
         * Manage Supra Action loading, execution
         */
        Supra.Manager = {

		/**
		 * List of all actions which are loaded
		 * @type {Object}
                 * @private
		 */
		actions: {},

		/**
		 * List of all actions which are not loaded and
		 * have temporary objects
		 * @type {Object}
                 * @private
		 */
		temporaries: {},

		/**
		 * Queued actions
		 * @type {Array}
                 * @private
		 */
		executionQueue: [],

		/**
		 * Manager container node
		 * @type {Object}
                 * @private
		 */
		containerNode: null,

		/**
		 * Returns action object by name
		 * If action isn't loaded yet, then returns temporary
		 * action object
		 *
		 * @alias Supra.action
		 * @param {String} action_name
		 * @return Action object
		 * @type {ActionBase Object}
		 */
		getAction: function (action_name) {
			if (typeof action_name === 'object' && action_name.isInstanceOf) {
				return action_name;
			} else if (action_name in this.actions) {
				return this.actions[action_name];
			} else if (!(action_name in this.temporaries)) {
				this.temporaries[action_name] = new Supra.Manager.Action.Base(action_name);
			}

			return this.temporaries[action_name];
		},

		/**
		 * Load action
		 *
		 * @param {String} action_name
		 * @return True if action started loading, false if it is already loading or loaded
		 * @type {Boolean}
		 */
		loadAction: function (action_name) {
			return Supra.Manager.Loader.loadAction(action_name);
		},
		
		/**
		 * Load list of actions
		 *
		 * @param {Array} action_names
		 * @type {Boolean}
		 */
		loadActions: function (action_names) {
			return Supra.Manager.Loader.loadActions(action_names);
		},

		/**
		 * Add action to execution queue
		 *
		 * @param {String} action_name
		 * @param {Array} args
		 * @private
		 */
		addActionToQueue: function (action_name, args) {
			var args = args || [];
			
			this.executionQueue.push({
				"action_name": action_name,
				"args": args
			});
		},

		/**
		 * Run queued actions which are ready now
		 */
		runExecutionQueue: function ()  {
			var queue = this.executionQueue;
			var index = 0;
			
			while(index < queue.length) {
				var exec_info = queue[index];
				var action_name = exec_info.action_name;

				if (action_name in this.actions) {
					var action = this.actions[action_name];
					
					//Only if loaded
					if (action.get('loaded')) {
						//Remove item from queue
						this.executionQueue = queue = queue.slice(0,index).concat(queue.slice(index+1));
						
						//Execute
						if (Supra.data.get('catchNativeErrors')) {
							try {
								action.execute.apply(action, exec_info.args);
							} catch (e) {
								Y.error(e);
							}
						} else {
							action.execute.apply(action, exec_info.args);
						}
						
						//Executing an action could change executionQueue array, reset it
						index = 0;
						queue = this.executionQueue;
					} else {
						index++;
					}
				} else {
					return;
				}
			}
		},

		/**
		 * Execute action
		 *
		 * @alias Supra.exec
		 * @param {String} action_name
		 */
		executeAction: function (action_name) {
			var args = [].slice.call(arguments, 1);
			var Loader = Supra.Manager.Loader;
			
			if (action_name in this.actions) {
				if (this.actions[action_name].isLoaded()) {
					
					//Execute
					if (Supra.data.get('catchNativeErrors')) {
						try {
							var action = this.actions[action_name];
							action.execute.apply(action, args);
						} catch (e) {
							Y.error(e);
						}
					} else {
						var action = this.actions[action_name];
						action.execute.apply(action, args);
					}
					
				} else {
					//If not loaded then add to queue
					this.addActionToQueue(action_name, args);
				}
				return true;
			} else if (!Loader.isLoaded(action_name)) {
				this.addActionToQueue(action_name, args);

				if (!Loader.isLoading(action_name)) {
					Loader.loadAction(action_name);
				}

				return false;

			} else {
				this.addActionToQueue(action_name, args);
				
				//Action is loaded, but object wasn't created
				Y.log('Action ' + action_name + ' was loaded, but action object wasn\'t found', 'error');
			}
		},
		
		/**
		 * Destroy action
		 * 
		 * @param {String} action_name
		 */
		destroyAction: function (action_name) {
			if (action_name in this) {
				this[action_name].destroy();
				delete(this[action_name]);
				delete(this.actions[action_name]);
				Supra.Manager.Loader.destroyAction(action_name);
			}
		},

		/**
		 * Returns root container node for actions
		 *
		 * @return Container node
		 * @type {Object}
		 */
		getContainerNode: function () {
			if (!this.containerNode) this.containerNode = Y.one('#cmsContent');
			return this.containerNode;
		}

	};

	Y.extend(ManagerHost, Y.Base, Supra.Manager);
	
	Supra.Manager = new ManagerHost();
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-base']});YUI.add('supra.manager-loader', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Manager = Supra.Manager;
	
	/*
	 * Manager loader loads action JS / HTML / CSS
	 */
	Manager.Loader = {
		
		//Extensions
		EXTENSION_SCRIPT: '.js',
		EXTENSION_TEMPLATE: '.html',
		EXTENSION_STYLE: '.css',
		EXTENSION_DATA: '.json',
		
		/**
		 * Path to static files
		 * @type {String}
		 */
		static_path: null,
		
		/**
		 * Path to dynamic files
		 * @type {String}
		 */
		dynamic_path: null,
		
		/**
		 * Path to current manager
		 * @type {String}
		 */
		base: null,
		
		/**
		 * Paths to external managers
		 * @type {Object}
		 */
		paths: {},
		
		/**
		 * List of loaded actions
		 * @type {Object}
		 */
		loaded: {},
		
		/**
		 * List of actions which are currently loading
		 * @type {Object}
		 */
		loading: {},
		
		/**
		 * Action info cache
		 * @type {Object}
		 */
		action_info_cache: {},
		
		/**
		 * Action template cache
		 * @type {Object}
		 */
		template_cache: {},
		
		/**
		 * List of templates which are loading
		 * @type {Object}
		 */
		template_loading: {},
		
		/**
		 * Action dependancies
		 * @type Object}
		 */
		dependancies: {},
		
		/**
		 * Set manager base path
		 * 
		 * @param {Object} path
		 */
		setBasePath: function (path) {
			//Remove trailing slash from folder
			this.base = String(path).replace(/\/+$/, '');
		},
		
		/**
		 * Get manager base path
		 * 
		 * @return Path
		 * @type {String}
		 */
		getBasePath: function () {
			return this.base;
		},
		
		/**
		 * Set manager static file path
		 * 
		 * @param {String} path
		 */
		setStaticPath: function (path) {
			//Remove trailing slash from folder
			this.static_path = String(path).replace(/\/+$/, '');
		},
		
		/**
		 * Returns static file path
		 * 
		 * @return Path
		 * @type {String}
		 */
		getStaticPath: function () {
			return this.static_path;
		},
		
		/**
		 * Set manager dynamic file path
		 * 
		 * @param {String} path
		 */
		setDynamicPath: function (path) {
			//Remove trailing slash from folder
			this.dynamic_path = String(path).replace(/\/+$/, '');
		},
		
		/**
		 * Returns dynamic file path
		 * 
		 * @return Path
		 * @type {String}
		 */
		getDynamicPath: function () {
			return this.dynamic_path;
		},
		
		/**
		 * Returns if action is loaded
		 * 
		 * @param {String} action_name Action name
		 * @return True if action is in loaded action list or in manager
		 * @type {Boolean}
		 */
		isLoaded: function (action_name) {
			return action_name in this.loaded ||
				   action_name in Manager;
		},
		
		/**
		 * Returns if action is loading
		 * 
		 * @param {String} action_name Action name
		 * @return True if action is in loading action list
		 * @type {Boolean}
		 */
		isLoading: function (action_name) {
			return action_name in this.loading;
		},
		
		/**
		 * Remove all information about action
		 * 
		 * @param {String} action_name
		 */
		destroyAction: function (action_name) {
			var info = this.getActionInfo(action_name);
			
			delete(this.loading[action_name]);
			delete(this.loaded[action_name]);
			delete(this.template_cache[info.path_template]);
			delete(this.template_loading[info.path_template]);
			delete(this.action_info_cache[action_name]);
			
		},
		
		/**
		 * Load actions
		 *
		 * @param {Array} action_names Array of action names
		 * @return True if any action stated loading, false if all actions already loading or loading
		 * @type {Boolean}
		 */
		loadActions: function (action_names) {
			var load_list = [],
				paths = [],
				info = null;
			
			for(var i=0,ii=action_names.length; i<ii; i++) {
				if (!this.isLoaded(action_names[i]) && !this.isLoading(action_names[i])) {
					load_list.push(action_names[i]);
				}
			}
			
			//All action already loaded or loading?
			if (!load_list.length) return false;
			
			//If internationalized data not loaded, wait till it is
			var base = this.static_path + (this.paths[load_list[0]] || this.getBasePath());
			if (!Supra.Intl.isLoaded(base)) {
				Supra.Intl.loadAppData(base, function () {
					//Call loadAction again
					this.loadActions(action_names);
				}, this);
				return;
			}
			
			//
			for(i=0,ii=load_list.length; i<ii; i++) {
				//
				info = this.getActionInfo(load_list[i]);
				paths.push(info.path_script);
				
				this.loading[load_list[i]] = {
					'script': true,
					'style': false,
					'template': false,
					'dependancies': false
				};
			}
			
			var path = Supra.YUI_BASE.groups.website.comboBase + paths.join('&');
			
			//Get SCRIPT
			Y.Get.js(path, {
				onSuccess: function (o) {
					//Script is loaded, but template and stylesheet is not
					//rest is handled by Supra.Managet.Action
				},
				async: true,
				context: this,
				data: load_list
			});
			
			return true;
		},
		
		/**
		 * Load action
		 * 
		 * @param {String} action_name
		 * @return True if action started loading, false if it is already loading or loaded
		 * @type {Boolean}
		 */
		loadAction: function (action_name) {
			if (this.isLoaded(action_name) || this.isLoading(action_name)) return false;
			return this.loadActions([action_name]);
		},
		
		/**
		 * Load stylesheet and template
		 * 
		 * @private
		 */
		loadExtras: function (action_name) {
			var self = this,
				action = Manager.getAction(action_name);
			
			//Script finished loading
			if (action_name in this.loading) {
				this.loading[action_name].script = false;
				
				this.loadTemplate(action_name, function (template) {
					
					//Locale strings were already replaced by Supra.IO
					action.template = template || action.template;
					
					if (!(action_name in self.dependancies)) {
						//There are no depedancies, fire loaded
						action._fireLoaded();
						Manager.runExecutionQueue();
					}
					
				});
			} else {
				//Action was created, but is was not loaded using Supra.Manager.Loader.loadAction()
				//so there is no this.loading[action_name] for given action
				action._fireLoaded();
				Manager.runExecutionQueue();
			}
		},
		
		/**
		 * Check if dependancies are resolved
		 * 
		 * @param {String} action_name Action name
		 */
		checkDependancies: function (action_name) {
			var dependancies = this.dependancies,
				list = [],
				index = 0,
				is_loaded = false;
			
			for(var id in this.dependancies) {
				list = this.dependancies[id];
				
				index = Y.Array.indexOf(list, action_name);
				if (index !== -1) {
					list.splice(index, 1);
				}
				
				//No more dependancies
				if (!list.length) {
					delete(this.dependancies[id]);
					
					this.loading[id].dependancies = false;
					
					if (!this.loading[id].style && !this.loading[id].template) {
						//Only if style and template is loaded
						Manager.getAction(id)._fireLoaded();
						is_loaded = true;
					}
				}
			}
			
			if (is_loaded) {
				Manager.runExecutionQueue();
			}
		},
		
		/**
		 * Loads action template
		 * @param {Object} path
		 * @param {Object} callback
		 */
		loadTemplate: function (action_name, callback) {
			
			var action = Manager.getAction(action_name);
			
			var templatePath = action.getTemplatePath();
			var hasTemplate = action.getHasTemplate();
			
			//Prevent multiple requests for same action
			if (templatePath && hasTemplate && this.template_loading[templatePath]) {
				return;
			}
			
			var stylesheetPath = action.getStylesheetPath();
			var hasStylesheet = action.getHasStylesheet();
			var stylesheetLoaded = true;
			var templateLoaded = !templatePath || !hasTemplate || (templatePath in this.template_cache) ? true : false;
			var template = '';
			
			//Load stylesheet if needed
			if (stylesheetPath && hasStylesheet) {
				
				Manager.Loader.loading[action_name].style = true;
				stylesheetLoaded = false;
				
				//CSS are loaded synchronously
				Supra.io.css(stylesheetPath, {
					'onSuccess': function () {
						stylesheetLoaded = true;
						Manager.Loader.loading[action_name].style = false;
						
						//If template request already completed, call callback
						if (templateLoaded) callback(template);
					}
				});
				
				//If there is no need to load template then return
				if (templateLoaded) {
					return;
				}
			}
			
			//Load template if needed
			if (templatePath && hasTemplate) {
				var cache = this.template_cache;
				var loading = this.template_loading;
				
				if (!(templatePath in cache)) {

					Manager.Loader.loading[action_name].template = true;
					loading[templatePath] = true;
					templateLoaded = false;
					
					Supra.io(templatePath, {
						'type': 'html',
						'on': {
							'success': function (html, status) {
								templateLoaded = true;
								Manager.Loader.loading[action_name].template = false;
								
								delete(loading[templatePath]);
								cache[templatePath] = html;
								template = html;
								
								//If stylesheet request already completed, call callback
								if (stylesheetLoaded) callback(html);
							},
							'failure': function () {
								//@TODO Handle failure
								templateLoaded = true;
								Manager.Loader.loading[action_name].template = false;
								
								delete(loading[templatePath]);
								cache[templatePath] = template;
								
								//If stylesheet request already completed, call callback
								if (stylesheetLoaded) callback(template);
							}
						}
					}, this);
				} else {
					template = cache[templatePath];
				}
			}
			
			//Set loaded states
			this.loading[action_name].template = !templateLoaded;
			this.loading[action_name].style = !stylesheetLoaded;
			
			if (templateLoaded && stylesheetLoaded) {
				//Action doesn't have stylesheet and template
				callback(template);
			}
		},
		
		/**
		 * Returns information about action
		 * 
		 * @param {String} action_name Action name
		 * @return Info about where action files can be found 
		 * @type {Object}
		 */
		getActionInfo: function (action_name /* Action name */) {
			if (action_name in this.action_info_cache) return this.action_info_cache[action_name];
			
			var file = this.getActionFileFromName(action_name);
			var folder_static = this.getActionFolder(action_name, false);
			var folder_dynamic = this.getActionFolder(action_name, true);
			var info = {
				'folder': folder_static,
				'folder_data': folder_dynamic,
				'path_data': folder_dynamic + file + this.EXTENSION_DATA,
				'path_script': folder_static + file + this.EXTENSION_SCRIPT,
				'path_template': folder_static + file + this.EXTENSION_TEMPLATE,
				'path_stylesheet': folder_static + file + this.EXTENSION_STYLE
			};
			
			this.action_info_cache[action_name] = info;
			return info;
		},
		
		/**
		 * Returns action folder path
		 * 
		 * @param {String} action_name Action name
		 * @param {String} dynamic Return dynamic folder path instead of static
		 * @return URL where action files can be found
		 * @type {String}
		 * @private
		 */
		getActionFolder: function (action_name /* Action name */, dynamic /* Return dynamic folder path */) {
			if (!action_name) return null;
			var base = '';
			
			//Is action from another manager?
			if (action_name in this.paths) {
				base = this.paths[action_name];
			}
			
			base = base || this.getBasePath() || '';
			
			var action_file = this.getActionFileFromName(action_name);
			if (!action_file) return null;
			
			var prefix = dynamic ? this.getDynamicPath() : this.getStaticPath();
			return prefix + base + '/' + action_file + '/';
		},
		
		/**
		 * Returns file name from action name
		 * 
		 * @param {String} action_name Action name
		 * @return Action file name
		 * @type {String}
		 * @private
		 */
		getActionFileFromName: function (action_name /* Action name */) {
			return String(action_name).replace(/[^a-z0-9\-\_]*/ig, '').toLowerCase();
		},
		
		/**
		 * Set external action base path
		 * 
		 * @param {String} id Action name 
		 * @param {String} path Path to action manager
		 */
		setActionBasePath: function (action_name  /* Action name */, path /* Path */) {
			//Remove trailing slash
			var path = path.replace(/[\/\\]*$/g, '');
			this.paths[action_name] = path;
			return this;
		},
		
		/**
		 * Returns external action base path
		 *
		 * @param {String} id Action name
		 * @return Action base path
		 * @type {String}
		 */
		getActionBasePath: function (action_name /* Action name */) {
			return this.paths[action_name] || this.base;
		},
		
		/**
		 * Set multiple action base paths 
		 * 
		 * @param {Object} actions
		 */
		setActionBasePaths: function (actions) {
			if (Y.Lang.isObject(actions)) {
				for(var action_name in actions) {
					this.setActionBasePath(action_name, actions[action_name]);
				}
			}
			return this;
		}
		
	};
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-base']});YUI.add('supra.manager-loader-actions', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Set common action base paths
	 * 
	 * Define here all actions which are reusable between 'managers' to allow them loading
	 * without specifying path each time
	 */
	Supra.Manager.Loader.setActionBasePaths({
		'Header': '/content-manager',
		'SiteMap': '/content-manager',
		'SiteMapRecycle': '/content-manager',
		'PageToolbar': '/content-manager',
		'PageButtons': '/content-manager',
		'EditorToolbar': '/content-manager',
		'Page': '/content-manager',
		'PageSettings': '/content-manager',
		'PageContentSettings': '/content-manager',
		'PageSourceEditor': '/content-manager',
		'LayoutContainers': '/content-manager',
		'Confirmation': '/content-manager',
		'LinkManager': '/content-manager',
		
		'MediaLibrary': '/media-library',
		'MediaSidebar': '/media-library',
		'IconSidebar': '/media-library',
		
		'Login': '/login',
		'MyPassword': '/login',
		
		'UserAvatar': '/internal-user-manager',
		
		'Applications': '/dashboard',
		'BrowserSupport': '/dashboard',
		
		'Sites': '-local/site-list-manager', // This is rather hacky.
		'DesignCustomize': '-local/design-manager', // This is rather hacky.
		'DesignSidebar': '-local/design-manager', // This is rather hacky.
		
		'Blog': '/blog-manager',
		
		'Tips': '/help'
	});

	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-loader']});YUI.add('supra.manager-action', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Manager = Supra.Manager,
		Loader = Manager.Loader;
	
	/**
	 * Create new action
	 * Last argument is action object
	 * 
	 */
	function ManagerAction () {
		var args = [].slice.call(arguments, 0);
		var object = args.pop();
		var plugins = args;
		
		/*
		 * If not an object or NAME property is missing, then throw error
		 */
			if (!Y.Lang.isObject(object)) {
				Y.log('Action() last parameter must be an object (action body)', 'error');
				return;
			}
			if (!('NAME' in object)) {
				Y.log('Action is missing NAME property', 'error');
				return;
			}
		
		/*
		 * Get action info
		 */
			var name = object.NAME;
			var action = Manager.getAction(name);
			var action_info = Loader.getActionInfo(name);
		
		/*
		 * Change placeholder if it's defined in Action
		 */
			if ('PLACE_HOLDER' in object && object.PLACE_HOLDER) {
				action.set('placeHolderNode', object.PLACE_HOLDER);
			}
		
		/*
		 * Set stylesheet/template
		 */
			if ('HAS_STYLESHEET' in object && object.HAS_STYLESHEET !== null) {
				action.set('hasStylesheet', !!object.HAS_STYLESHEET);
			}
			if ('HAS_TEMPLATE' in object && object.HAS_TEMPLATE !== null) {
				action.set('hasTemplate', !!object.HAS_TEMPLATE);
			}
		
		/*
		 * Extend with properties, etc.
		 */
			action = Supra.mix(action, object, {
				'plugins': new Manager.Action.PluginManager(action, plugins)
			});
			
			if (action.get('templatePath') === null) {
				action.set('templatePath', 'templatePath' in object ? object.templatePath : action_info.path_template);
			}
			if (action.get('stylesheetPath') === null) {
				action.set('stylesheetPath', 'stylesheetPath' in object ? object.stylesheetPath : action_info.path_stylesheet);
			}
			if (action.get('dataFolder') === null) {
				action.set('dataFolder', 'dataFolder' in object ? object.dataFolder : action_info.folder_data);
			}
			if (action.get('dataPath') === null) {
				action.set('dataPath', 'dataPath' in object ? object.dataPath : action_info.path_data);
			}
			
			action.set('actionPath', action_info.folder);
		
		/*
		 * When everything is loaded overwrite execute function
		 */
			function onLoadReady () {
				//Remove reference
				delete(action._beforeLoaded);
				
				//
				if (action.execute !== Supra.Manager.Action.Base.prototype.execute) {
					action._originalExecute = action.execute;
				} else {
					action._originalExecute = function () {};
				}
				action.execute = action._execute;
				
				delete(Manager.temporaries[name]);
				Manager.actions[name] = action;
				Manager[name] = action;
				
				//On first 'execute' make sure Action is initialized
				action.once('execute', action._preExecute, action);
				
				//Before execute do call plugins
				action.on('execute', action._postExecute, action);
				
				//On execute call original execute method
				action.on('execute', function (event) {
					return this._originalExecute.apply(this, event.details[0]);
				}, action);
				
				//Set loaded state
				delete(Loader.loading[name]);
				Loader.loaded[name] = true;
				
				//Run queued execute requests
				Manager.runExecutionQueue();
			}
			
			action._beforeLoaded = onLoadReady;
			
		/*
		 * Set dependancies
		 */
		if (object.DEPENDANCIES && object.DEPENDANCIES.length) {
			var dependancies = object.DEPENDANCIES,
				load_list = [];
			
			for(var i=0,ii=dependancies.length; i<ii; i++) {
				if (!Loader.isLoaded(dependancies[i])) {
					load_list.push(dependancies[i]);
				}
			}
			
			if (load_list.length) {
				if (!(name in Loader.dependancies)) Loader.dependancies[name] = [];
				Loader.dependancies[name] = load_list;
				Loader.loading[name].dependancies = true;
				
				Manager.loadActions(load_list);
			}
		}
		
		/*
		 * Action script is loaded,
		 * load template and stylesheet if needed
		 */
		Loader.loadExtras(name);
		
		return action;
	};
	
	Manager.Action = ManagerAction;
    
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-base']});YUI.add('supra.manager-action-base', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Manager = Supra.Manager,
		empty = function () {};
		
	function updateAttributeOnEvent (event, attr_name) {
		this.set(attr_name, event.newVal);
	}
	
	function bubbleEvent (event, event_name) {
		this.fire(event_name, event);
	}
	
	/**
     * Supra Action temporary class
     *
     * @namespace Supra.Manager.Action.Base
     */
	function ActionBase (name) {
		ActionBase.superclass.constructor.apply(this, []);
		
		this.init.apply(this, []);
		
		this.set('NAME', name);
		this.NAME = name;
		this.PLACE_HOLDER = null;
		this.HAS_STYLESHEET = null;
		this.HAS_TEMPLATE = null;
		this.template = '';
		this.plugins = null;
		this.children = {};
	};
	
	ActionBase.NAME = 'ActionBase';
	
	/*
	 * Action attributes 
	 */
	ActionBase.ATTRS = {
		/**
		 * Action state
		 * Action has been loaded and created
		 */
		'created': {
			'value': false
		},
		/**
		 * Action state
		 */
		'loaded': {
			'value': false
		},
		
		/**
		 * Manager has been executed at least once
		 */
		'executed': {
			'value': false
		},
		
		/**
		 * Action has stylesheet or not
		 */
		'hasStylesheet': {
			'value': false
		},
		/**
		 * Action has template or not
		 */
		'hasTemplate': {
			'value': false
		},
		
		/**
		 * Path to action
		 */
		'actionPath': {
			'value': null
		},
		/**
		 * Action template path
		 */
		'templatePath': {
			'value': null
		},
		/**
		 * Action stylesheet path
		 */
		'stylesheetPath': {
			'value': null
		},
		/**
		 * Action data path
		 */
		'dataPath': {
			'value': null
		},
		/**
		 * Action data folder
		 */
		'dataFolder': {
			'value': null
		},
		
		/**
		 * Action srcNode
		 */
		'srcNode': {
			'value': null
		},
		/**
		 * Action place holder; node in which action template was inserted
		 */
		'placeHolderNode': {
			'value': null,
			'getter': '_getPlaceHolderNode'
		},
		
		/**
		 * Action visibility state
		 */
		'visible': {
			'value': false
		}
	};
	
	Y.extend(ActionBase, Y.Base, {
		/**
		 * Action name
		 * @type {String}
		 */
		NAME: null,
		
		/**
		 * Content placeholder
		 * @type {HTMLElement}
		 */
		PLACE_HOLDER: null,
		
		/**
		 * Action has stylesheet
		 * @type {Boolean}
		 */
		HAS_STYLESHEET: null,
		
		/**
		 * Action has template
		 * @type {Boolean}
		 */
		HAS_TEMPLATE: null,
		
		/**
		 * Action dependancies on other actions
		 * @type {Array}
		 */
		DEPENDANCIES: null,
		
		/**
		 * Template
		 * @type {String}
		 */
		template: '',
		
		/**
		 * Plugin manager
		 * @type {Object}
		 */
		plugins: null,
		
		/**
		 * Children actions
		 * @type {Object}
		 */
		children: {},
		
		
		
		/**
		 * Add children action
		 * 
		 * @param {String} action_id
		 */
		addChildAction: function (action_id) {
			this.children[action_id] = Supra.Manager.getAction(action_id);
			return this;
		},
		
		/**
		 * Remove children action
		 * 
		 * @param {String} action_id
		 */
		removeChildAction: function (action_id) {
			if (action_id in this.children) {
				delete(this.children[action_id]);
			}
			return this;
		},
		
		/**
		 * Returns children actions
		 * 
		 * @return Object with child actions
		 * @type {Object}
		 */
		getChildActions: function () {
			return this.children;
		},
		
		/**
		 * Returns children actions which state is 'created'
		 */
		getActiveChildActions: function () {
			var ret = {}, children = this.children;
			for(var id in children) {
				if (children[id].get('created')) {
					ret[id] = children[id];
				}
			}
			return ret;
		},
		
		/**
		 * Returns action name
		 * 
		 * @return Action name
		 * @type {String}
		 */
		getName: function () {
			return this.NAME;
		},
		
		/**
		 * Returns true if action has template
		 * 
		 * @return True if action has template
		 * @type {Boolean}
		 */
		getHasTemplate: function () {
			return this.get('hasTemplate');
		},
		
		/**
		 * Set if action has template
		 * 
		 * @param {Boolean} has_template
		 */
		setHasTemplate: function (has_template) {
			this.set('hasTemplate', !!has_template);
			return this;
		},
		
		/**
		 * Returns true if action has stylesheet
		 * 
		 * @return True if action has stylesheet
		 * @type {Boolean}
		 */
		getHasStylesheet: function () {
			return this.get('hasStylesheet');
		},
		
		/**
		 * Set if action has stylesheet
		 * 
		 * @param {Boolean} has_stylesheet
		 */
		setHasStylesheet: function (has_stylesheet) {
			this.set('hasStylesheet', !!has_stylesheet);
			return this;
		},
		
		/**
		 * Returns template path
		 * 
		 * @return URI path to template
		 * @type {String}
		 */
		getTemplatePath: function () {
			return this.get('templatePath') || Manager.Loader.getActionInfo(this.NAME).path_template;
		},
		
		/**
		 * Change template path
		 * 
		 * @param {String} path
		 */
		setTemplatePath: function (path) {
			this.set('templatePath', path || '');
			return this;
		},
		
		/**
		 * Returns data path
		 * 
		 * @param {String} filename Optional. Filename inside action
		 * @param {Object} parameters Optional. Parameters
		 * @return URI path to template
		 * @type {String}
		 */
		getDataPath: function (filename, parameters) {
			var out = '', path = null;
			
			if (filename) {
				path = this.get('dataFolder') || Manager.Loader.getActionInfo(this.NAME).folder_data;
				out = path + filename + Manager.Loader.EXTENSION_DATA;
			} else {
				out = this.get('dataPath') || Manager.Loader.getActionInfo(this.NAME).path_data;
			}
			
			if (typeof parameters == 'object') {
				parameters = Supra.io.serializeIntoString(parameters);
				if (parameters) {
					out += (out.indexOf('?') == -1 ? '?' : '&') + parameters;
				}
			}
			
			return out;
		},
		
		/**
		 * Change data path
		 * 
		 * @param {String} path
		 */
		setDataPath: function (path) {
			this.set('dataPath', path || '');
			return this;
		},
		
		/**
		 * Returns stylesheet path
		 * 
		 * @return URI path to stylesheet
		 * @type {String}
		 */
		getStylesheetPath: function () {
			return this.get('stylesheetPath') || Manager.Loader.getActionInfo(this.NAME).path_stylesheet;
		},
		
		/**
		 * Change stylesheet path
		 * 
		 * @param {String} path
		 */
		setStylesheetPath: function (path) {
			this.set('templatePath', path || '');
			return this;
		},
		
		/**
		 * Returns action path
         *
         * @return URI path to action
         * @type {String}
		 */
		getActionPath: function () {
			var path = this.get('actionPath');
			if (!path) {
				path = Supra.Manager.Loader.getActionInfo(this.NAME).folder;
			}
			return path;
		},
		
		/**
		 * Returns action container nodes
		 * 
		 * @return Container node list, Y.NodeList
		 * @type {Object}
		 */
		getContainers: function () {
			return this.get('srcNode');
		},
		
		/**
		 * Returns action container node matching css selector or first container node
		 * 
		 * @param {String} selector Optional. CSS selector
		 * @return Container node element matching css selector or first container element, Y.Node
		 * @type {Object}
		 */
		getContainer: function (selector) {
			//Y.NodeList
			var srcNode = this.get('srcNode');
			if (!srcNode) return null;
			
			if (selector) {
				//Check if one of the nodes matches selector
				var matches = srcNode.filter(selector);
				var node = matches.item(0);
				
				if (!node) {
					for(var i=0,ii=srcNode.size(); i<ii; i++) {
						node = srcNode.item(i).one(selector);
						if (node) break;
					}
				}
				
				return node;
			} else {
				return srcNode.item(0);
			}
		},
		
		/**
		 * Alias for getContainer
		 * 
		 * @param {String} selector Optional. CSS selector
		 * @return Container node element matching css selector or first container element, Y.Node
		 * @type {Object}
		 */
		one: function (selector) {
			return this.getContainer(selector);
		},
		
		/**
		 * Returns all nodes matching selector
		 * 
		 * @param {String} selector Optional. CSS selector
		 * @return All nodes matching css selector, Y.NodeList
		 * @type {Object}
		 */
		all: function (selector) {
			//Y.NodeList
			var srcNode = this.get('srcNode');
			if (!srcNode) return null;
			
			var matches = srcNode.filter(selector) || new Y.NodeList(selector);
			
			srcNode.each(function () {
				var sub = this.all(selector);
				if (sub) matches = matches.concat(sub);
			});
			
			return matches;
		},
		
		/**
		 * Returns place holder node
		 * Place holder is node where content will be inserted
		 * 
		 * @return Place holder node, Y.Node
		 * @type {Y.Node}
		 */
		getPlaceHolder: function () {
			return this.get('placeHolderNode');
		},
		
		/**
		 * Set place holder node where action content will be inserted
		 * 
		 * @param {Object} node
		 */
		setPlaceHolder: function (node) {
			this.set('placeHolderNode', node);
			return this;
		},
		
		/**
		 * Returns place holder node
		 * 
		 * @param {Object} value
		 * @return Place holder node
		 * @type {Y.Node}
		 * @private
		 */
		_getPlaceHolderNode: function (value) {
			return value || Manager.getContainerNode();
		},
		
		/**
		 * Returns all widgets for given plugin
		 * 
		 * @param {String} plugin_name
		 * @return All widgets for given plugin
		 * @type {Object}
		 */
		getPluginWidgets: function (plugin_name, as_array) {
			var plugin = this.plugins.getPlugin(plugin_name);
			var widgets = {};
			
			if (plugin) {
				widgets = plugin.getWidgets();
			} else {
				return (as_array ? [] : {});
			}
			
			if (as_array) {
				var dest = [];
				for(var i in widgets) {
					dest[dest.length] = widgets[i];
				}
				widgets = dest;
			}
			
			return widgets;
		},
		
		/**
		 * Bind widget attribute to Action attribute,
		 * when ones attribute changes others attribute is changed also
		 * 
		 * @param {Object} widget Widget instance
		 * @param {Object} attributes List of attributes, which should be linked
		 */
		bindAttributes: function (widget, attributes) {
			if (Y.Lang.isArray(attributes)) {
				for(var i=0,ii=attributes.length; i<ii; i++) {
					if (Y.Lang.isString(attributes[i])) {
						widget.after(attributes[i] + 'Change', updateAttributeOnEvent, this, attributes[i]);
						this.after(attributes[i] + 'Change', updateAttributeOnEvent, widget, attributes[i]);
					}
				}
			} else if (Y.Lang.isObject(attributes)) {
				for(var i in attributes) {
					if (Y.Lang.isString(attributes[i])) {
						var action_attr = attributes[i];
						var widget_attr = i;
						
						widget.after(widget_attr + 'Change', updateAttributeOnEvent, this, action_attr);
						this.after(action_attr + 'Change', updateAttributeOnEvent, widget, widget_attr);
					}
				}
			}
			return this;
		},
		
		/**
		 * Bubble widgets events to Action
		 * 
		 * @param {Object} widget Widget instance
		 * @param {Object} events List of events, which should be propagated
		 */
		bubbleEvents: function (widget, events) {
			if (Y.Lang.isArray(events)) {
				for(var i=0,ii=events.length; i<ii; i++) {
					if (Y.Lang.isString(events[i])) {
						widget.on(events[i], bubbleEvent, this, events[i]);
					}
				}
			} else if (Y.Lang.isObject(events)) {
				for(var i in events) {
					if (Y.Lang.isString(events[i])) {
						widget.on(i, bubbleEvent, this, events[i]);
					}
				}
			}
			return this;
		},
		
		/**
		 * Bind widget methods to Action
		 * Creates method for action, which will call widget method when called
		 * 
		 * @param {Object} widget Widget instance
		 * @param {Object} methods List of methods
		 */
		importMethods: function (widget, methods) {
			if (Y.Lang.isArray(methods)) {
				for(var i=0,ii=methods.length; i<ii; i++) {
					if (Y.Lang.isString(methods[i])) {
						var fn = widget[methods[i]];
						if (Y.Lang.isFunction(fn)) {
							this[methods[i]] = Y.bind(widget[methods[i]], widget);
						}
					}
				}
			} else if (Y.Lang.isObject(methods)) {
				for(var i in methods) {
					if (Y.Lang.isString(methods[i])) {
						this[methods[i]] = Y.bind(widget[i], widget);
					}
				}
			}
			return this;
		},
		
		/**
		 * Returns a function that will execute the supplied function in the Action context
		 * 
		 * @param {Function} fn
		 * @return Function which will execute in Action context
		 * @type {Function}
		 */
		bind: function (fn) {
			return Y.bind(fn, this);
		},
		
		/**
		 * Returns true if action is loaded, otherwise false
		 * 
		 * @return Action loaded state
		 * @type {Boolean}
		 */
		isLoaded: function () {
			return this.get('loaded');
		},
		
		/**
		 * Returns true if action is initialized, otherwise false
		 * 
		 * @return Action intialized state
		 * @type {Boolean}
		 */
		isInitialized: function () {
			return this.get('created');
		},
		
        /**
         * Fires 'loaded' event
         *
         * @private
         */
		_fireLoaded: function () {
			//Final changes to action object
			if (this._beforeLoaded) {
				this._beforeLoaded();
			}
			
			this.set('loaded', true);
			this.fire('loaded');
			Manager.fire(this.NAME + ':loaded');
			
			//Action is loaded, execute all other actions which depend on this
			Manager.Loader.checkDependancies(this.NAME);
		},
		
		/**
		 * Called before initialize()
         *
         * @private
		 */
		_preInitialize: function () {
			//Initialize plugins
			this.plugins.create();
			
			//Insert template into DOM
			if (this.template) {
				var container = this.getPlaceHolder();
				
				//Create node from HTML
				var nodes = Y.Node.create(this.template);
				
				//If template was several nodes, then 'node' is document fragment,
				//but we need Y.NodeList 
				if (nodes._node.nodeType == 11) {	//11 - DocumentFragment
					nodes = nodes.get('children');
				} else {
					//Convert Y.Node into Y.NodeList
					nodes = new Y.NodeList(nodes);
				}
				
				//Append all nodes to container
				nodes.each(function () {
				    container.append(this);
				});
				
				this.set('srcNode', nodes);
			}
			
			//On visibility change, update children actions
			this.on('visibleChange', function (event) {
				if (!event.newVal) {
					var children = this.getActiveChildActions();
					for(var id in children) {
						children[id].hide();
					}
				}
			}, this);
			
			//Initialize plugins
			this.plugins.initialize();
			
			//Bind destroy
			this.on('destroy', this._destroy, this);
		},
		
		/**
		 * Called before render()
         *
         * @private
		 */
		_preRender: function () {
			//Fire 'initialized' callback
			this.set('created', true);
			this.fire('initialize');
			Manager.fire(this.NAME + ':initialize');
			
			//Render all plugins
			this.plugins.render();
		},
		
		/**
		 * Called after render()
         *
         * @private
		 */
		_postRender: function () {
			this.fire('render');
		},
		
		/**
		 * Called before 'execute' event.
		 * Initializes Action if not done already
         *
         * @private
		 */
		_preExecute: function (event) {
			//Initialization phase
			if (!this.get('created')) {
				this.create();
				this._preInitialize();
				this.initialize();
				this._preRender();
				this.render();
				this._postRender();
			}
		},
		
		
		
		/**
		 * Called after execute()
         *
         * @private
		 */
		_postExecute: function (event) {
			//Execute plugins (show panel, reload data, etc.)
			this.plugins.execute.apply(this.plugins, event.details[0]);
		},
		
		/**
		 * Execute action, overwrite .execute()
         *
         * @private
		 */
		_execute: function () {
			var args = [].slice.call(arguments, 0);
			
			if (!this.get('loaded') || !this.get('initialized')) {
				args = [this.NAME].concat(args);
				Manager.executeAction.apply(Manager, args);
			} else {
				this.fire('execute', args);
				this.set('executed', true);
				this.fire('executed', args);
			}
		},
		
		/**
		 * Call manager to load action and execute it
		 * Overwritten by _execute
		 */
		execute: function () {
			if (!this.get('loaded')) {
				var args = [].slice.call(arguments, 0);
					args = [this.NAME].concat(args);
				
				Manager.executeAction.apply(Manager, args);
			}
			
			return this;
		},
		
		/**
		 * Call manager to load action
		 */
		load: function () {
			if (!this.get('loaded')) {
				Manager.loadAction(this.NAME);
			}
			
			return this;
		},
		
		/**
		 * Show action, Action plugins are responsible for showing
		 * needed elements
		 */
		show: function () {
			this.set('visible', true);
			return this;
		},
		
		/**
		 * Hide action, Action plugins are responsible for hiding
		 * needed elements
		 */
		hide: function () {
			this.set('visible', false);
			return this;
		},
		
		/**
		 * Render action
		 */
		renderAction: function () {
			this._preExecute();
		},
		
		/**
         * On action create it's possible to change placeholder
         *
         * @private
         */
		create: function () {},
		
		/**
         * Initialize action
         *
         * @private
         */
		initialize: function () {},

        /**
         * Render action widgets
         *
         * @private
         */
		render: function () {},
		
		/**
		 * Destroy action and all children actions
		 * 
		 * @private
		 */
		_destroy: function () {
			//Remove listener to prevent being called again and creating a loop
			this.detach('destroy', this._destroy, this);
			
			//Destroy children
			for(var id in this.children) {
				this.children[id].destroy();
			}
			
			delete(this.children);
			
			//Plugins
			if (this.plugins) {
				this.plugins.destroy();
				delete(this.plugins);
			}
			
			//Other data
			delete(this.template);
			
			//Remove node
			if (this.get('srcNode')) {
				this.get('srcNode').detach().remove();
			}
			
			//Remove from Supra.Manager
			Manager.destroyAction(this.NAME);
		},
		
        /**
         * Original 'execute' function
         * 
         * @private
         */
		_originalExecute: function () {}
		
	});
	
	Supra.Manager.Action.Base = ActionBase;
	
	
	
	//Set browser UA classname
	var html = Y.one('html');
	
	for(var browser in Y.UA) {
		if (Y.UA[browser] && browser != 'os') {
			html.addClass(browser);
		}
	}
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-base']});YUI.add('supra.manager-action-plugin-manager', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/*
	 * Shortcuts
	 */
	var Manager = Supra.Manager;
	
	/**
	 * Plugin manager for action
	 * 
	 * @param {Object} host
	 * @param {Array} plugins
	 */
	var PluginManager = function (host, plugins) {
		this.host = host;
		this.plugins = plugins || [];
		this.instances = {};
		this.initialized = false;
		this.created = false;
	};
	
	PluginManager.prototype = {
		/**
		 * Initialization state
		 * @type {Boolean}
		 */
		initialized: false,
		
		/**
		 * Created state
		 * @type {Boolean}
		 */
		created: false,
		
		/**
		 * Action object
		 * @type {Object}
		 */
		host: null,
		
		/**
		 * Plugin classes
		 * @type {Array}
		 */
		plugins: [],
		
		/**
		 * Plugin instances
		 * @type {Object}
		 */
		instances: {},
		
		/**
		 * Returns plugin by name
		 * 
		 * @param {String} plugin_name
		 * @return Plugin instance
		 * @type {Object}
		 */
		getPlugin: function (plugin_name) {
			var instances = this.instances;
			if (plugin_name in instances) {
				return instances[plugin_name];
			} else {
				return null;
			}
		},
		
		/**
		 * Call create on plugins for compatibility with action
		 */
		create: function () {
			if (this.created) return;
			this.created = true;
			
			var host = this.host,
				plugins = this.plugins,
				base = Manager.Action.PluginBase;
				
			for(var i=0,ii=plugins.length; i<ii; i++) {
				//If plugin doesn't exist, throw error
				if (!plugins[i]) {
					//Debug info
					var trace_path = Supra.Manager.Loader.getActionInfo(host.NAME).path_script;
					Y.log('Action plugin doesn\'t exist, used in ' + host.NAME + ' (' + trace_path + ')', 'error');
					continue;
				}
				
				//Create plugin
				var plugin = new plugins[i](host);
				
				if (plugin instanceof base) {
					//Get NAME
					var plugin_id = plugins[i].NAME;
					
					//Create instance
					this.instances[plugin_id] = plugin;
					
					//Initialize
					plugin.create();
				} else {
					//Debug info
					var trace_path = Supra.Manager.Loader.getActionInfo(host.NAME).path_script;
					Y.log('Plugin ' + plugins[i].NAME || '"unnamed"' + ' is not subclass of PluginBase. Used in action ' + host.NAME + ' (' + trace_path + ')', 'error');
				}
			}
			
			host.fire('plugins:create');
		},
		
		/**
		 * Render plugins
		 */
		render: function () {
			var host = this.host,
				instances = this.instances;
			
			for(var i in instances) {
				instances[i].render();
			}
			
			host.fire('plugins:render');
		},
		
		/**
		 * @constructor
		 */
		initialize: function () {
			if (this.initialized) return;
			this.initialized = true;
			
			var host = this.host,
				instances = this.instances;
			
			for(var i in instances) {
				instances[i].initializeBase();
				instances[i].initialize();
			}
			
			host.fire('plugins:initialize');
		},
		
		/**
		 * Execute plugin
		 */
		execute: function () {
			var host = this.host,
				instances = this.instances;
			
			for(var i in instances) {
				instances[i].execute.apply(instances[i], arguments);
			}
			
			host.fire('plugins:execute');
		},
		
		/**
		 * Destroy all plugins
		 */
		destroy: function () {
			var plugins = this.plugins;
			for(var i=0,ii=plugins.length; i<ii; i++) {
				plugins[i].destroy();
			}
			this.host.unplug();
			
			delete(this.instances);
			delete(this.plugins);
			delete(this.host);
			this.initialized = false;
		}
	};
	
	Manager.Action.PluginManager = PluginManager;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-base']});YUI.add('supra.manager-action-plugin-base', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Action = Supra.Manager.Action;
	var uid = 1;
	
	function PluginBase (host) {
		this.host = host;
		this.instances = {};
	};
	
	PluginBase.NAME = 'PluginBase';
	
	PluginBase.prototype = {
		/**
		 * Host action
		 * @type {Object}
		 */
		host: null,
		
		/**
		 * List of widget instances
		 * @type {Object}
		 */
		instances: {},
		
		/**
		 * Default placeholder nodes
		 * @type {Object}
		 */
		placeholders: null,
		
		/**
		 * Returns widget container ID attribute value
		 * @private
		 * @param {Object} widget
		 */
		_getWidgetContainerId: function (widget) {
			var node = widget.get('srcNode');
			if (node) {
				var id = node.getAttribute('id');
				if (id && id.indexOf('yui_') != 0) {
					return id;
				}
			}
			return null;
		},
		
		/**
		 * Add widget to instance list
		 * 
		 * @param {Object} widget
		 * @param {Object} id
		 * @param {Boolean} multiple Support multiple instances
		 * @return Widget which was added
		 * @type {Object}
		 */
		addWidget: function (widget, prefix) {
			//Use container ID
			var id = prefix;
			
			if (!prefix && !id) id = this._getWidgetContainerId(widget);
			if (!id && !prefix) id = widget.name;
			
			if (this.instances[id] || this.host[id]) id += uid++;
			
			this.instances[id] = widget;
			this.host[id] = widget;
			
			return widget;
		},
		
		/**
		 * Returns widget by ID
		 * 
		 * @param {String} id
		 * @return Widget instance
		 * @type {Object}
		 */
		getWidget: function (id) {
			return id in this.instances ? this.instances[id] : null;
		},
		
		/**
		 * Returns all widget instances generated by plugin
		 * 
		 * @return List of widget instances
		 * @type {Object}
		 */
		getWidgets: function () {
			return this.instances;
		},
		
		/**
		 * Actions create phase
		 */
		create: function () {
		},
		
		/**
		 * Set placeholders, this shouldn't be overwritten
		 * @private
		 */
		initializeBase: function () {
			//Set placeholders
			this.placeholders = this.host.getContainers();
		},
		
		/**
		 * Create all widgets
		 * @constructor
		 */
		initialize: function () {},
		
		/**
		 * Render widgets
		 */
		render: function () {
			var instances = this.instances;
			for(var i in instances) {
				var instance = instances[i];
				if ('render' in instance) {
					//If widget srcNode is in DOM, then no need to supply
					//place holder node
					if (instance.get('srcNode').ancestor()) {
						instance.render();
					} else {
						instance.render(this.placeholders.item(0));
					}
				}
			}
		},
		
		/**
		 * Execute
		 */
		execute: function () {}
	};
	
	Action.PluginBase = PluginBase;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-base']});YUI.add('supra.manager-action-plugin-panel', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Action = Supra.Manager.Action;
	
	function PluginPanel () {
		PluginPanel.superclass.constructor.apply(this, arguments);
		this.children = {};
	};
	
	PluginPanel.NAME = 'PluginPanel';
	
	Y.extend(PluginPanel, Action.PluginBase, {
		
		initialize: function () {
			if (!this.placeholders) {
				Y.log('Can\'t find container to create Panel for Action ' + this.host.NAME + '. Please make sure there is a template', 'error');
				return;
			}
			
			//Panel
			var node = this.host.one('DIV');
			if (node) {
				
				var config = {
					'srcNode': node,
					'xy': [20, 65],
					'visible': false
				};
				
				this.addWidget(new Supra.Panel(config));
			}
			
			//Propagate events to Action
			//When panel is hidden/shown do the same for action and vice versa
			var instances = this.instances;
			for(var i in instances) {
				this.host.bindAttributes(instances[i], {'visible': 'visible'});
			}
		},
		
		/**
		 * Render UI
		 */
		render: function () {
			PluginPanel.superclass.render.apply(this, arguments);
			
			//Initially all panels should be are hidden
			var instances = this.instances;
			for(var i in instances) instances[i].hide();
		},
		
		execute: function () {
			PluginPanel.superclass.execute.apply(this, arguments);
			
			//Hide panels
			var instances = this.instances;
			for(var i in instances) if (!instances[i].get('visible')) instances[i].show();
		}
		
	});
	
	Action.PluginPanel = PluginPanel;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-action-plugin-base', 'supra.panel']});YUI.add("supra.footer", function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Button configuration defaults
	var BUTTON_DEFINITION = {
		"id": null,
		"srcNode": null,
		"type": "push",
		"label": "",
		"icon": null,
		"style": "small",
		"disabled": false
	};
	
	var BUTTON_STYLES = {
		"create": "small-blue",
		"save": "small-blue",
		"ok": "small-blue",
		"cancel": "small",
		"yes": "small-blue",
		"no": "small",
		"apply": "small-blue",
		"done": "small",
		"delete": "small-red",
		"reset": "small",
		"error": "small-red"
	};
	
	function bubbleEvent (event, event_name) {
		this.fire(event_name, event);
	}
	
	/**
	 * Class for handling buttons lists 
	 * 
	 * @alias Supra.Footer
	 * @param {Object} config Configuration
	 */
	function Footer (config) {
		Footer.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
		
		this.buttons = {};
		this.buttons_definition = {};
	}
	
	Footer.NAME = "footer";
	Footer.ATTRS = {
		"buttons": {
			value: null
		},
		"autoDiscoverButtons": {
			value: true
		},
		"style": {
			value: "default"
		}
	};
	
	Y.extend(Footer, Y.Widget, {
		
		/**
		 * Buttons
		 * @type Object
		 * @private
		 */
		buttons: {},
		
		/**
		 * Button definition
		 * @type {Object}
		 * @private
		 */
		buttons_definition: {},
		
		/**
		 * Index used to create ID if one is not set
		 * @type {Number}
		 * @private 
		 */
		button_index: 0,
		
		/**
		 * Render buttons
		 * @private
		 */
		renderUI: function () {
			Footer.superclass.renderUI.apply(this, arguments);
			
			var button_count = 0;
			var definitions = Supra.mix(this.buttons_definition || {}, this.get("buttons") || {}, true);
			
			//Find all buttons
			if (this.get("autoDiscoverButtons")) {
				definitions = Supra.mix(this.discoverButtons(), definitions, true);
			}
			
			//Create Inputs
			for(var i in definitions) {
				this._renderButton(definitions[i]);
				button_count++;
			}
			
			//Style
			this.get("srcNode").addClass(Y.ClassNameManager.getClassName(Footer.NAME, this.get("style")));
			
			//If there are no buttons to show, then hide panel
			if (button_count == 0) this.hide();
		},
		
		/**
		 * Bind to button events
		 * @private
		 */
		bindUI: function () {
			Footer.superclass.bindUI.apply(this, arguments);
			
			//When user will click on button, then event BUTTON_ID will be triggered on Footer
			var buttons = this.buttons;
			for(var i in buttons) {
				buttons[i].on("click", bubbleEvent, this, buttons[i].get("id"));
			}
		},
		
		/**
		 * Search for buttons in DOM
		 * 
		 * @private
		 * @return Object with button definitions
		 * @type {Object}
		 */
		discoverButtons: function () {
			var buttons = this.get("srcNode").all("input[type='button'],input[type='submit'],button");
			var config = {};
			var styles = BUTTON_STYLES;
			
			for(var i=0,ii=buttons.size(); i<ii; i++) {
				var button = buttons.item(i);
				
				var id = button.getAttribute("id");
				if (!id) {
					for(var style in styles) {
						if (button.hasClass(style)) {
							id = style;
							break;
						}
					}
				}
				
				if (!id) continue;
				
				var disabled = button.getAttribute("disabled") ? true : false;
				var label = button.test("input") ? button.get("value") : button.get("innerHTML");
				
				config[id] = {
					"id": id,
					"label": label,
					"srcNode": button,
					"disabled": disabled
				};
			}
			
			return config;
		},
		
		/**
		 * Normalize button config
		 * 
		 * @private
		 * @param {Object} config
		 * @return Normalized button configuration
		 * @type {Object}
		 */
		normalizeButtonConfig: function (config) {
			var style_definition = {
				"style": "small",
				"label": ""
			};
			
			if (config.id && config.id in BUTTON_STYLES) {
				style_definition.style = BUTTON_STYLES[config.id];
			}
			
			if (config.id && !config.label) {
				var label = Supra.Intl.get(["buttons", config.id]);
				if (label) style_definition.label = label;
			}
			
			//Convert arguments into
			//[{}, INPUT_DEFINITION, argument1, argument2, ...]
			var args = [].slice.call(arguments,0);
				args = [{}, BUTTON_DEFINITION, style_definition].concat(args);
			
			//Mix them together
			return Supra.mix.apply(Supra, args);
		},
		
		/**
		 * Add button
		 * 
		 * @param {Object} config Button configuration, see Supra.Button 
		 * @see Supra.Button
		 */
		addButton: function (config) {
			if (this.get("rendered")) {
				this._renderButton(config);
				this.show();
			} else {
				var index = this.button_index++;
				var id = ("id" in config && config.id ? config.id : "button" + index);
				var conf = (id in this.buttons_definition ? this.buttons_definition[id] : {});
				this.buttons_definition[id] = Supra.mix(conf, config);
			}
			
			return this;
		},
		
		/**
		 * Render button
		 * @param {Object} definition
		 */
		_renderButton: function (definition) {
			var srcNode = this.get("srcNode"),
				contentBox = this.get("contentBox"),
				definition = this.normalizeButtonConfig(definition),
				id = definition.id,
				buttons = this.buttons = (this.buttons || {}),
				node = null;
			
			//Try finding input
			if (!definition.srcNode) {
				node = srcNode.one("#" + id);
				if (!node) {
					node = srcNode.one("input." + id + ", button." + id);
				}
				
				definition.srcNode = node;
			}
			
			//Remove old button if it already exist
			if (id in buttons) {
				this.removeButton(id);
			}
			
			//Create button, but without ID to prevent ID attribute collision
			var config = Supra.mix({}, definition);
			
			delete(config.id);
			buttons[id] = new Supra.Button(config);
			
			if (definition.srcNode) {
				buttons[id].render();
			} else {
				//If input doesn't exist, then create it
				buttons[id].render(contentBox);
			}
			
			return this;
		},
		
		/**
		 * Remove button
		 * Chainable
		 * 
		 * @param {String} id Button ID
		 */
		removeButton: function (id) {
			if (id in this.buttons) {
				var node = this.buttons[id].get("srcNode");
				this.buttons[id].destroy();
				delete(this.buttons[id]);
				node.destroy();
			}
			
			return this;
		},
		
		/**
		 * Returns button instance by ID. If button doesn't exist returns null
		 * 
		 * @return Button instance (Supra.Button)
		 * @type {Object}
		 */
		getButton: function (id) {
			if (id in this.buttons) {
				return this.buttons[id];
			} else {
				return null;
			}
		},
		
		/**
		 * Returns all buttons in object, where keys are button IDs 
		 * 
		 * @return Object with buttons
		 * @type {Object}
		 */
		getButtons: function () {
			return this.buttons;
		},
		
		/**
		 * Disable / enable button
		 * Chainable
		 * 
		 * @param {String} id Button ID
		 * @param {Boolean} disabled
		 */
		setButtonDisabled: function (id, disabled) {
			var button = this.getButton(id);
			if (button) {
				button.set("disabled", !!disabled);
			}
			return this;
		},
		
		/**
		 * Returns true if button is disabled, otherwise false
		 * 
		 * @param {String} id Button ID
		 * @return True if button is disabled
		 * @type {Boolean}
		 */
		getButtonDisabled: function (id) {
			var button = this.getButton(id);
			if (button) {
				return button.get("disabled");
			} else {
				return false;
			}
		},
		
		/**
		 * Show / hide button
		 * 
		 * @param {String} id Button ID
		 * @param {Boolean} visible Button visibility
		 */
		setButtonVisible: function (id, visible) {
			var button = this.getButton(id);
			if (button) {
				button.set("visible", !!visible);
			}
			return this;
		},
		
		/**
		 * Returns true if button is visible, otherwise false.
		 * If button is not found then returns false
		 * 
		 * @param {String} id
		 * @return True if button is visible
		 * @type {Boolean}
		 */
		getButtonVisible: function (id) {
			var button = this.getButton(id);
			if (button) {
				return button.get("visible");
			} else {
				return false;
			}
		},
		
		/**
		 * Enable/disable auto discover feature.
		 * If enabled, then will try to find buttons
		 */
		setAutoDiscoverButtons: function () {
			this.set("autoDiscoverButtons", true);
			return this;
		}
	});
	
	Supra.Footer = Footer;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version);YUI.add('supra.manager-action-plugin-footer', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Action = Supra.Manager.Action;
	
	function PluginFooter () {
		PluginFooter.superclass.constructor.apply(this, arguments);
	};
	
	PluginFooter.NAME = 'PluginFooter';
	
	Y.extend(PluginFooter, Action.PluginBase, {
		
		initialize: function () {
			
			if (!this.placeholders) {
				Y.log('Can\'t find container to create Form for Action ' + this.host.NAME + '. Please make sure there is a template', 'error');
				return;
			}
			
			//Find container
			var node = this.host.one('div.footer');
			
			//Add widget
			if (node) {
				var config = {
					'srcNode': node
				};
				this.addWidget(new Supra.Footer(config));
			}
		},
		
		render: function () {
			PluginFooter.superclass.render.apply(this, arguments);
			
			//Find panel
			var panel = this.host.getPluginWidgets('PluginPanel', true);
			panel = panel.length ? panel[0] : null;
			
			//Find form
			var form = this.host.getPluginWidgets('PluginForm', true);
			form = form.length ? form[0] : null;
			
			//Close button should close form
			var cancel = this.instances.footer.getButton('cancel');
			if (cancel && panel) {
				cancel.on('click', panel.hide, panel);
			}
		},
		
		execute: function () {
			PluginFooter.superclass.execute.apply(this, arguments);
			
			// @TODO reset form values
		}
		
	});
	
	Action.PluginFooter = PluginFooter;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-action-plugin-base', 'supra.footer']});/**
 * Manager Action plugin to automatically hide container when
 * action 'visible' attribute changes
 */
YUI.add('supra.manager-action-plugin-container', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Action = Supra.Manager.Action;
	
	function PluginContainer () {
		PluginContainer.superclass.constructor.apply(this, arguments);
		this.children = {};
	};
	
	PluginContainer.NAME = 'PluginContainer';
	
	Y.extend(PluginContainer, Action.PluginBase, {
		
		initialize: function () {
			//On visibility change show/hide container
			this.host.on('visibleChange', function (evt) {
				var node = this.one();
				if (node && evt.newVal != evt.prevVal) {
					node.toggleClass('hidden', !evt.newVal);
					
					if (evt.newVal) {
						this.fire('show');
					} else {
						this.fire('hide');
					}
				}
			});
		}
		
	});
	
	Action.PluginContainer = PluginContainer;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-action-plugin-base']});/**
 * Manager Action plugin to automatically set container as main
 * content and resize if left, right or top (Header) containers changes
 */
YUI.add('supra.manager-action-plugin-maincontent', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Action = Supra.Manager.Action;
	
	function PluginMainContent () {
		PluginMainContent.superclass.constructor.apply(this, arguments);
		this.children = {};
	};
	
	PluginMainContent.NAME = 'PluginMainContent';
	
	Y.extend(PluginMainContent, Action.PluginBase, {
		
		initialize: function () {
			var layoutTopContainer = Supra.Manager.getAction('LayoutTopContainer'),
				layoutLeftContainer = Supra.Manager.getAction('LayoutLeftContainer'),
				layoutRightContainer = Supra.Manager.getAction('LayoutRightContainer');
			
			//Attribute
			if (this.host.addAttr) {
				this.host.addAttr('layoutDisabled', {
					'value': false
				});
			}
			
			//Position
			this.host.one().addClass('center-container');
			
			//Container position sync with other actions
			this.host.plug(Supra.PluginLayout, {
				'offset': [0, 0, 0, 0]	//Default offset from page viewport
			});
			
			//Offsets from other containers 
			this.host.layout.addOffset(layoutTopContainer, layoutTopContainer.one(), 'top', 0);
			this.host.layout.addOffset(layoutLeftContainer, layoutLeftContainer.one(), 'left', 0);
			this.host.layout.addOffset(layoutRightContainer, layoutRightContainer.one(), 'right', 0);
			
			//On visible change and execute reposition container
			this.host.after('execute', function (e) {
				//Update position
				this.host.layout.syncUI();
			}, this);
			
			this.host.on('visibleChange', function (e) {
				if (e.newVal) {
					//Update position
					this.host.layout.syncUI();
				}
			}, this);
			
			this.host.layout.syncUI();
		}
		
	});
	
	Action.PluginMainContent = PluginMainContent;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-action-plugin-base']});YUI.add('supra.manager-action-plugin-layout-sidebar', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Manager = Supra.Manager,
		Action = Manager.Action;
	
	function PluginSidebar () {
		PluginSidebar.superclass.constructor.apply(this, arguments);
	};
	
	PluginSidebar.NAME = 'PluginSidebar';
	
	Y.extend(PluginSidebar, Action.PluginBase, {
		
		/**
		 * Content scroller, Supra.Scrollable instance
		 * @type {Object}
		 */
		scrollable: null,
		
		
		/**
		 * Set as sidebar child
		 */
		create: function () {
			//Add as right bar child
			if (this.host.LAYOUT_CONTAINER) {
				Manager.getAction(this.host.LAYOUT_CONTAINER).addChildAction(this.host.NAME);
			}
		},
		
		/**
		 * Initialize plugin
		 */
		initialize: function () {
			var header = null,
				node = null;
			
			//Header
			header = this.host.one('.sidebar-header');
			this.host.addAttr('headerNode', {
				'value': header
			});
			this.host.addAttr('headerVisible', {
				'value': header && !header.hasClass('hidden'),
				'setter': Y.bind(this.setHeaderVisible, this)
			});
			
			//Buttons
			node = header.one('.button-back');
			this.host.addAttr('backButton', {
				'value': node ? new Supra.Button({
									'srcNode': node,
									'style': 'small-gray',
									'visible': !node.hasClass('hidden')
								}) : null
			});
			
			node = header.one('.button-control');
			this.host.addAttr('controlButton', {
				'value': node ? new Supra.Button({
									'srcNode': node,
									'style': 'small-blue',
									'visible': !node.hasClass('hidden')
								}) : null
			});
			
			//Icon
			node = header.one('img');
			this.host.addAttr('iconNode', {
				'value': node
			});
			this.host.addAttr('icon', {
				'value': node.getAttribute('src'),
				'setter': Y.bind(this.setIcon, this)
			});
			
			//Title
			node = header.one('h2');
			this.host.addAttr('titleNode', {
				'value': node
			});
			this.host.addAttr('title', {
				'value': node.get('text'),
				'setter': Y.bind(this.setTitle, this)
			});
			
			//Content
			node = this.host.one('.sidebar-content');
			this.host.addAttr('contentNode', {
				'value': node
			});
			
			this.host.addAttr('contentInnerNode', {
				'value': null,
				'getter': Y.bind(this.getContentInnerNode, this)
			});
			
			//Scrollable
			this.host.addAttr('scrollable', {
				'value': node.hasClass('scrollable'),
				'setter': Y.bind(this.setScrollable, this)
			});
			
			if (this.host.get('scrollable')) {
				this.setScrollable(true);
			}
			
			//Slideshow
			this.host.addAttr('slideshow', {
				'value': false,
				'setter': Y.bind(this.setSlideshow, this)
			});
			
			// Back button event listener
			var back = this.host.get('backButton');
			if (back) {
				back.hide();
				back.after('click', this.onBackButtonClick, this);
			}
			
			/*
			 * In frozen state if sidebar is hidden then toolbar buttons
			 * will not be removed and "hide" function is not called,
			 * on action execute "execute" function will not be called either
			 */
			this.host.addAttr('frozen', {
				'value': this.host.get('frozen') || false
			});
			
			this.host._frozenExecute = this.host.execute;
			this.host._frozenHide = this.host.hide;
			
			this.host.execute = this.executeHost;
			this.host.hide = this.hideHost;
			this.host.showFrozen = this.showFrozenHost;
			
			this.host.after('visibleChange', this.afterVisibleChange, this);
		},
		
		
		/* ------------------------------ Slideshow ------------------------------ */
		
		
		/**
		 * Slideshow attribute setter
		 * 
		 * @param {Object} slideshow Slideshow object or null
		 * @returns {Object} New attribute value
		 * @private
		 */
		setSlideshow: function (slideshow) {
			var backButton = this.host.get('backButton'),
				old_slideshow = this.host.get('slideshow');
			
			if (old_slideshow !== slideshow) {
				if (old_slideshow) {
					old_slideshow.detach('slideChange', this.onSlideshowSlideChange, this);
				}
				if (slideshow) {
					slideshow.on('slideChange', this.onSlideshowSlideChange, this);
				}
				
				if (backButton) {
					if (!slideshow || slideshow.isRootSlide()) {
						backButton.hide();
					} else {
						backButton.show();
					}
				}
			}
			
			return slideshow;
		},
		
		/**
		 * Handle back button click
		 */
		onBackButtonClick: function (event) {
			var slideshow = this.host.get('slideshow');
			if (slideshow && !event.stoped && !event.prevented) {
				slideshow.scrollBack();
			}
		},
		
		/**
		 * On slideshow slide change show or hide back button
		 */
		onSlideshowSlideChange: function (evt) {
			var slideshow = this.host.get('slideshow'),
				history = slideshow.getHistory();
			
			if (!slideshow.isRootSlide(evt.newVal)) {
				// Root slide
				var button = this.host.get('backButton');
				if (button) button.show();
			} else {
				// Not a root slide
				var button = this.host.get('backButton');
				if (button) button.hide();
			}
		},
		
		/* ------------------------------ Attributes ------------------------------ */
		
		
		/**
		 * Set header visibility
		 * 
		 * @param {Boolean} value Visibility state
		 * @return New visibility state
		 * @type {Boolean}
		 */
		setHeaderVisible: function (value) {
			var node = this.host.one('headerNode'),
				cont = this.host.get('contentNode');
			
			if (value && node) {
				node.removeClass('hidden');
				if (cont) cont.addClass('has-header');
			} else {
				if (node) node.addClass('hidden');
				if (cont) cont.removeClass('has-header');
				value = false;
			}
			
			return !!value;
		},
		
		/**
		 * Set header icon
		 * 
		 * @param {String} path Path to icon
		 * @return New icon path
		 * @type {String}
		 */
		setIcon: function (path) {
			var node = this.host.get('iconNode');
			
			if (node) {
				if (path) {
					node.setAttribute('src', path);
					node.removeClass('hidden');
				} else {
					node.addClass('hidden');
				}
				
				return path;
			}
			
			return null;
		},
		
		/**
		 * Set sidebar title
		 * 
		 * @param {String} title Title
		 * @return New title
		 * @type {String}
		 */
		setTitle: function (title) {
			var node = this.host.get('titleNode');
			
			if (node) {
				node.set('text', title);
			}
			
			return title;
		},
		
		/**
		 * Set if content node is scrollable
		 * 
		 * @param {Boolean} scrollable
		 * @return True if content is scrollable, otherwise false
		 * @type {Boolean}
		 */
		setScrollable: function (scrollable) {
			var node = this.host.get('contentNode');
			
			if (scrollable) {
				node.addClass('scrollable');
				if (!this.scrollable) {
					var children = node.get('children');
					this.scrollable = new Supra.Scrollable();
					this.scrollable.render(node);
					this.scrollable.get('contentBox').append(children);
				} else {
					this.scrollable.set('disabled', false);
				}
			} else {
				node.removeClass('scrollable');
				
				if (this.scrollable) {
					this.scrollable.set('disabled', true);
				}
			}
			
			return !!scrollable;
		},
		
		/**
		 * Returns inner content node inside which content should be added
		 * 
		 * @return Content inner node
		 * @type {Boolean}
		 */
		getContentInnerNode: function () {
			if (this.scrollable) {
				return this.scrollable.get('contentBox');
			} else {
				return this.host.get('contentNode');
			}
		},
		
		/**
		 * On visibility change show/hide toolbar buttons
		 */
		afterVisibleChange: function (evt) {
			if (evt.newVal != evt.prevVal) {
				var toolbar = Manager.getAction('PageToolbar'),
					buttons = Manager.getAction('PageButtons'),
					container = this.host.one();
				
				if (evt.newVal) {
					//Show container
					if (container) container.removeClass('hidden');
					
					//Show action
					if (this.host.LAYOUT_CONTAINER) {
						Manager.getAction(this.host.LAYOUT_CONTAINER).setActiveAction(this.host.NAME);
					}
					
					//Show buttons
					if (toolbar.hasActionButtons(this.host.NAME)) {
						if (this.host.PLUGIN_LAYOUT_SIDEBAR_MANAGE_BUTTONS !== false) {
							toolbar.setActiveAction(this.host.NAME);
							buttons.setActiveAction(this.host.NAME);
						}
					}
					
					//Event
					this.host.fire('show');
				} else {
					if (!this.host.get('frozen')) {
						//Hide buttons
						if (toolbar.hasActionButtons(this.host.NAME)) {
							if (this.host.PLUGIN_LAYOUT_SIDEBAR_MANAGE_BUTTONS !== false) {
								toolbar.unsetActiveAction(this.host.NAME);
								buttons.unsetActiveAction(this.host.NAME);
							}
						}
					}
					
					//Hide action
					if (this.host.LAYOUT_CONTAINER) {
						Manager.getAction(this.host.LAYOUT_CONTAINER).unsetActiveAction(this.host.NAME);
					}
					
					//Hide container
					if (container) container.addClass('hidden');
					
					//Event
					this.host.fire('hide');				
				}
				
			}
		},
		
		/**
		 * Render
		 */
		render: function () {
			PluginSidebar.superclass.render.apply(this, arguments);
			
			//Render buttons
			var button = this.host.get('backButton');
			if (button) button.render();
			
			button = this.host.get('controlButton');
			if (button) button.render();
		},
		
		/**
		 * Execute
		 */
		execute: function () {
			PluginSidebar.superclass.execute.apply(this, arguments);
			this.host.show();
		},
		
		
		/**
		 * Function which overwrites hosts "execute" to prevent
		 * calling it in frozen state
		 */
		executeHost: function () {
			if (!this.get('frozen')) {
				this._frozenExecute.apply(this, arguments);
			}
		},
		
		/**
		 * Function which overwrites hosts "hide" to prevent
		 * calling it in frozen state
		 */
		hideHost: function () {
			if (!this.get('frozen')) {
				this._frozenHide.apply(this, arguments);
			}
		},
		
		/**
		 * Force showing content even in frozen mode
		 */
		showFrozenHost: function () {
			if (this.get('visible')) {
				this.plugins.getPlugin('PluginSidebar').afterVisibleChange({'newVal': true, 'prevVal': false});
			} else {
				this.show();
			}
		}
		
	});
	
	Action.PluginLayoutSidebar = PluginSidebar;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-action-plugin-base', 'supra.input', 'supra.scrollable']});/**
 * Block level element formatting (H1, H2, H3, H4, H5, H6, P)
 */
YUI().add('supra.htmleditor-plugin-formats', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/* Available formats */
		formats: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p']
	};
	
	Supra.HTMLEditor.addPlugin('formats', defaultConfiguration, {
		
		/**
		 * List of formats (from configuration)
		 * @type {Object}
		 */
		formats: null,
		
		/**
		 * List of buttons
		 * @type {Object}
		 */
		buttons: null,
		
		/**
		 * Execute command
		 * 
		 * @param {Object} data
		 * @param {String} command Command
		 * @private
		 */
		exec: function (data, command) {
			var htmleditor = this.htmleditor,
				doc = this.htmleditor.get('doc'),
				selection = null;
			
			if (Y.UA.ie) {
				//If selection length is 0 then IE fails to change node
				selection = htmleditor.selection;
				
				if (selection.start == selection.end && selection.start_offset == selection.end_offset) {
					if (selection.end_offset == selection.end.length) {
						selection.start_offset--;
					} else {
						selection.end_offset++;
					}
				}
				
				htmleditor.setSelection(selection);
			}
			
			//Change to P, H1, H2, ...
			doc.execCommand('formatblock', false, '<' + command + '>');
			
			//Trigger "change" event on editor
			htmleditor._changed();
			
			return true;
		},
		
		/**
		 * Returns current format
		 * 
		 * @return Current format
		 * @type {String}
		 */
		getCurrentFormat: function () {
			var htmleditor = this.htmleditor,
				selectedElement = null,
				//currentFormat is empty string (false in Safari) or "H1", "P", ...
				//in IE currentFormat is "Normal" even for elements without tag or "Heading 1", ...
				currentFormat = null;
				
			try {
				currentFormat = htmleditor.get('doc').queryCommandValue('formatblock');
				
				//Normalize IE value
				if (Y.UA.ie) {
					currentFormat = currentFormat.replace('Heading ', 'H');
					
					//Check for P tag
					if (currentFormat == 'Normal') {
						selectedElement = htmleditor.getSelectedElement('P');
						if (selectedElement) {
							currentFormat = 'P';
						}
					}
				}
			} catch (err) {
				//If selected text is not 'contenteditable' then error is thrown
				currentFormat = '';
			}
			
			if (currentFormat) currentFormat = currentFormat.toUpperCase();
			return currentFormat;
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			// Formats
			if (configuration && Y.Lang.isArray(configuration.formats)) {
				var formats = this.formats = configuration.formats;
			} else {
				//If there are no formats, then plugin is useless
				return false;
			}
			
			// Add command
			var i = 0,
				imax = formats.length,
				execCallback = Y.bind(this.exec, this);
				
			for(; i < imax; i++) {
				this.htmleditor.addCommand(formats[i], execCallback);
			}
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			delete(this.buttons);
			delete(this.formats);
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});/**
 * Block level element formatting (UL, OL)
 */
YUI().add('supra.htmleditor-plugin-lists', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/* List types */
		lists: ['ul', 'ol']
	};
	
	Supra.HTMLEditor.addPlugin('lists', defaultConfiguration, {
		
		lists:  null,
		commands: {'ul': 'insertunorderedlist', 'ol': 'insertorderedlist'},
		
		buttons: {},
		
		/**
		 * Execute command
		 * 
		 * @param {Object} data
		 * @param {String} command
		 */
		exec: function (data, command) {
			if (command in this.commands) {
				var res = this.htmleditor.get('doc').execCommand(this.commands[command], false, null);
				this.htmleditor._changed();
				return res;
			} else if (command == 'indent') {
				var res = this.htmleditor.get('doc').execCommand('indent', false, null);
				this.htmleditor._changed();
				return res;
			} else if (command == 'outdent') {
				var res = this.htmleditor.get('doc').execCommand('outdent', false, null);
				this.htmleditor._changed();
				return res;
			} else {
				return false;
			}
		},
		
		bindButton: function (format) {
			var htmleditor = this.htmleditor;
			var toolbar = htmleditor.get('toolbar');
			var button = toolbar ? toolbar.getButton(format) : null;
			if (button) {
				this.buttons[format.toUpperCase()] = button;
			}
		},
		
		/**
		 * When node changes update button states
		 * @param {Object} event
		 */
		handleNodeChange: function (event) {
			var allowEditing = this.htmleditor.editingAllowed;
			
			var node = this.htmleditor.getSelectedElement(),
				rootNode = this.htmleditor.get('srcNode').getDOMNode(),
				down = false,
				buttons = this.buttons,
				selected = null,
				i = null;
			
			while (node) {
				if (node.tagName in buttons) {
					selected = node.tagName;
					break;
				}
				if (node === rootNode) break;
				node = node.parentNode;
			}
			
			for(i in buttons) {
				buttons[i].set('down', i == selected);
				buttons[i].set('disabled', !allowEditing);
			}
			
			buttons.INDENT.set('visible', !!selected);
			buttons.OUTDENT.set('visible', !!selected);
		},
		
		/**
		 * When editing allowed changes update button states 
		 * @param {Object} event
		 */
		handleEditingAllowChange: function (event) {
			var i,
				disabled = !event.allowed,
				buttons = this.buttons;
			
			for(i in buttons) {
				buttons[i].set('disabled', disabled);
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			if (!configuration) return;
			
			this.lists = (Y.Lang.isArray(configuration.lists) ? configuration.lists : []);
			this.buttons = {};
			
			// Add command
			var lists = ['indent', 'outdent'].concat(this.lists),
				i = 0,
				imax = lists.length,
				execCallback = Y.bind(this.exec, this);
				
			for(; i < imax; i++) {
				this.htmleditor.addCommand(lists[i], execCallback);
				this.bindButton(lists[i]);
			}
			
			//When un-editable node is selected disable toolbar button
			this.htmleditor.on('editingAllowedChange', this.handleEditingAllowChange, this);
			this.htmleditor.on('nodeChange', this.handleNodeChange, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-textstyle', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/* List of document commands */
		commands: ['bold', 'italic', 'underline', 'strikethrough']
	};
	
	/*
	 * Handle BOLD, ITALIC, UNDERLINE and STRIKETHROUGH commands
	 */
	Supra.HTMLEditor.addPlugin('textstyle', defaultConfiguration, {
		
		/**
		 * List of commands
		 * @type {Array}
		 */
		commands: null,
		
		/**
		 * Execute command
		 * 
		 * @param {Object} data
		 * @param {String} command
		 * @return True on success, false on failure
		 * @type {Boolean}
		 */
		exec: function (data, command) {
			var res = this.htmleditor.get('doc').execCommand(command, null, false);
			this.htmleditor._changed();
			this.htmleditor.refresh(true);
			return res;
		},
		
		/**
		 * Bind command to a button
		 * 
		 * @param {String} command
		 */
		bindButton: function (command) {
			var htmleditor = this.htmleditor,
				doc = htmleditor.get('doc'),
				toolbar = htmleditor.get('toolbar'),
				button = toolbar ? toolbar.getButton(command) : null;
			
			if (button) {
				this.buttons[command] = button;
			}
		},
		
		/**
		 * When selection changes update button states
		 * @param {Object} event
		 */
		handleSelectionChange: function (event) {
			var htmleditor = this.htmleditor,
				allowEditing = htmleditor.editingAllowed && !htmleditor.selection.collapsed,
				down,
				buttons = this.buttons,
				id;
			
			for(id in buttons) {
				try {
					down = htmleditor.get('doc').queryCommandState(id);
				} catch (err) {
					//If selected content is not 'contenteditable' error is thrown
					down = false;
				}
				
				buttons[id].set('disabled', !allowEditing);
				buttons[id].set('down', down);
			}
		},
		
		/**
		 * When editing allowed changes update button states 
		 * @param {Object} event
		 */
		handleEditingAllowChange: function (event) {
			var id,
				disabled = !event.allowed,
				buttons = this.buttons;
			
			for(id in buttons) {
				buttons[id].set('disabled', disabled);
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			this.buttons = {};
			
			// Commands
			if (configuration && Y.Lang.isArray(configuration.commands)) {
				var commands = this.commands = configuration.commands;
			} else {
				//If there are no commands, then plugin is useless
				return false;
			}
			
			// Bind commands to buttons
			var i = 0,
				imax = commands.length,
				execCallback = Y.bind(this.exec, this);
			
			for(; i < imax; i++) {
				htmleditor.addCommand(commands[i], execCallback);
				this.bindButton(commands[i]);
			}
			
			//When un-editable node is selected disable toolbar button
			htmleditor.on('editingAllowedChange', this.handleEditingAllowChange, this);
			
			//When selection changes update buttons
			htmleditor.on('selectionChange', this.handleSelectionChange, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-shortcuts', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	Supra.HTMLEditor.addPlugin('shortcuts', defaultConfiguration, {
		
		/**
		 * Execute command
		 * 
		 * @param {Object} data
		 * @param {String} command
		 * @return True on success, false on failure
		 * @type {Boolean}
		 */
		exec: function (data, command) {
			var res = this.htmleditor.get('doc').execCommand(command, null, false);
			this.htmleditor._changed();
			this.htmleditor.refresh(true);
			return res;
		},
		
		/**
		 * Enable ctrl+b, ctrl+i, etc. shortcuts
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		handleShortcut: function (_, evt) {
			var htmleditor = this.htmleditor,
				allowEditing = htmleditor.editingAllowed && !htmleditor.selection.collapsed,
				res = false;
			
			if (allowEditing && !evt.altKey && (evt.ctrlKey || evt.metaKey)) {
				
				if (evt.keyCode == 66) {
					res = htmleditor.exec('bold');			// CTRL + B
				} else if (evt.keyCode == 73) {
					res = htmleditor.exec('italic');		// CTRL + I
				} else if (evt.keyCode == 85) {
					res = htmleditor.exec('underline');		// CTRL + U
				}/* else if (evt.keyCode == 76) {
					res = htmleditor.exec('insertlink');	// CTRL + L
				}*/
				
				if (res) {
					evt.preventDefault();
				}
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			//Handle key shortcuts
			htmleditor.on('keyDown', this.handleShortcut, this);
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});/**
 * Style sidebar
 */
YUI().add('supra.htmleditor-plugin-styles', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	//Convert arrays to object, because object lookup is much faster
	var toObject = function (arr) { var o={},i=0,ii=arr.length; for(;i<ii;i++) o[arr[i]]=true; return o; };
	
	//Style groups
	var tmp = null;
	var GROUPS = [
		{
			'id': 'text',
			'title': '{# htmleditor.group_text #}',
			'tags': (tmp = ['H1', 'H2', 'H3', 'H4', 'H5', 'P', 'B', 'EM', 'U', 'S', 'A']),
			'tagsObject': toObject(tmp)
		},
		{
			'id': 'list',
			'title': '{# htmleditor.group_list #}',
			'tags': (tmp = ['UL', 'OL', 'LI']),
			'tagsObject': toObject(tmp)
		}
		/*{
			'id': 'table',
			'title': '{# htmleditor.group_table #}',
			'tags': (tmp = ['TABLE', 'TR', 'TD', 'TH']),
			'tagsObject': toObject(tmp)
		},
		{
			'id': 'image',
			'title': '{# htmleditor.group_image #}',
			'tags': (tmp = ['IMG']),
			'tagsObject': toObject(tmp)
		}*/
	];
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	var TEMPLATE_STYLES = Supra.Template.compile('\
			<div class="style-item {% if main %}current{% endif %} style-main {{ tag }}" data-tag="{{ tag }}" data-id="">\
				{% set title = "htmleditor.tags." + tag %}\
				{{ title|intl }}\
			</div>\
			{% for key, match in matches %}\
				<div class="style-item {% if classname == match.classname %}current{% endif %} style-class" data-tag="{{ tag }}" data-id="{{ match.classname }}" style="{{ match.style }}">\
					{{ match.attributes.title }}\
				</div>\
			{% endfor %}\
		');
	
	
	/*
	 * Style plugin handles P, H1-H5 tag change and tag styling using
	 * dropdown menus
	 */
	Supra.HTMLEditor.addPlugin('styles', defaultConfiguration, {
		
		/**
		 * Formats plugin instance
		 * @type {Object}
		 */
		pluginFormats: null,
		
		/**
		 * Selectors grouped by tags
		 * @type {Object}
		 */
		selectors: {},
		
		/**
		 * Sidebar styles element
		 * @type {Object}
		 */
		sidebarElement: null,
		
		/**
		 * Nodes which styles are being changed
		 * @type {Array}
		 */
		targetNodes: [],
		
		/**
		 * List of tags, which can't be styled
		 * @type {Object}
		 */
		excludeList: {},
		
		/**
		 * Event listeners
		 * @type {Array}
		 */
		listeners: [],
		
		/**
		 * Node which is used for highlighting
		 * @type {Object}
		 */
		highlightNode: null,
		
		
		/**
		 * Add tag names to list of tags which will not be in the list
		 * 
		 * @param {Array} tagNames Tag names
		 */
		excludeTags: function (tagNames) {
			if (!Y.Lang.isArray(tagNames)) tagNames = [tagNames];
			for(var i=0,ii=tagNames.length; i<ii; i++) {
				this.excludeList[tagNames[i].toUpperCase()] = true;
			}
		},
		
		
		/* -------------------------------------- CSS parsing ------------------------------------------ */
		
		
		/**
		 * Filter out selectors, which doesn't match current container
		 */
		getSelectors: function () {
			var container = this.htmleditor.get('srcNode'),
				result = this.htmleditor.get("stylesheetParser").getSelectorsByNodeMatch(container);
			
			//Text noeds can changed be changed between P, H1, H2, H3 and H4
			//add these to the selector list to allow them changing even if there are
			//no styles in the list
			if (!result['P'])  result['P'] = [];
			if (!result['H1']) result['H1'] = [];
			if (!result['H2']) result['H2'] = [];
			if (!result['H3']) result['H3'] = [];
			if (!result['H4']) result['H4'] = [];
			
			return result;
		},
		
		
		
		
		/**
		 * Update style dropdown values
		 */
		updateStylesList: function () {
			var group = "text", //this.dropdownTypes.get('value'),
				groups = GROUPS,
				tags = null,
				tagsArr = null,
				i = 0,
				ii = groups.length;
			
			//Find tags
			for(var i=0,ii=groups.length; i<ii; i++) {
				if (groups[i].id == group) {
					tags = groups[i].tagsObject;
					tagsArr = groups[i].tags;
					break;
				}
			}
			
			//Check nodes
			var targetNodes = this.targetNodes,
				node = null,
				selectors = this.selectors,
				tag = null,
				matchesObject = {},
				matches = [],
				classnames = [],
				classname = '',
				c = 0,
				cc = 0;
			
			for(i=0,ii=targetNodes.length; i<ii; i++) {
				node = new Y.Node(targetNodes[i].node);
				tag = targetNodes[i].tag;
				
				//Check if tag is in this group
				if (tags[tag] && selectors[tag]) {
					//Find matching classname
					classname = '';
					classnames = selectors[tag];
					c = 0;
					cc = classnames.length;
					
					for(; c<cc; c++) {
						if (node.hasClass(classnames[c].classname)) {
							classname = classnames[c].classname;
							break;
						}
					}
					
					matchesObject[tag] = true;
					matches.push({'tag': tag, 'main': !classname, 'classname': classname, 'matches': selectors[tag]});
				}
			}
			
			//Add styles for P, H1-H4
			if (group == 'text') {
				if (!matchesObject['P'])  matches.push({'tag': 'P',  'main': false, 'classname': '', 'matches': selectors['P']  || []});
				if (!matchesObject['H1']) matches.push({'tag': 'H1', 'main': false, 'classname': '', 'matches': selectors['H1'] || []});
				if (!matchesObject['H2']) matches.push({'tag': 'H2', 'main': false, 'classname': '', 'matches': selectors['H2'] || []});
				if (!matchesObject['H3']) matches.push({'tag': 'H3', 'main': false, 'classname': '', 'matches': selectors['H3'] || []});
				if (!matchesObject['H4']) matches.push({'tag': 'H4', 'main': false, 'classname': '', 'matches': selectors['H4'] || []});
			}
			
			//Sort array
			matches.sort(function (a, b) {
				var a_i = Y.Array.indexOf(tagsArr, a.tag),
					b_i = Y.Array.indexOf(tagsArr, b.tag);
				
				return (a_i == b_i ? 0 : (a_i > b_i ? 1 : -1));
			});
			
			this.renderStylesList(matches);
		},
		
		/**
		 * Render style list
		 * 
		 * @param {Array} matches Tags and matching selectors
		 */
		renderStylesList: function (matches) {
			var tag = null,
				i = 0,
				ii = matches.length,
				html = '',
				node = this.sidebarElement;
			
			if (!node) return;
			
			for(; i<ii; i++) {
				html += TEMPLATE_STYLES(matches[i]);
			}
			
			node.set('innerHTML', html);
		},
		
		
		/* -------------------------------------- HTML editor ---------------------------------------- */
		
		
		/**
		 * When node changes update type dropdown values
		 * @param {Object} event
		 */
		handleNodeChange: function (event) {
			var allowEditing = this.htmleditor.editingAllowed;
			
			var selectedNode = this.htmleditor.getSelectedElement(),
				node = selectedNode,
				srcNode = this.htmleditor.get('srcNode'),
				selectors = this.selectors,
				tagNames = null,
				targetNodes = this.targetNodes = [],
				i = 0,
				ii = 0,
				groups = {'text': true},	/* Text group is always available */
				includedTags = {};			/* List of tags already included in the list */
			
			//Traverse up the tree and find tags which has selectors
			while(node && !srcNode.compareTo(node)) {
				//All tagnames for this node, SPAN may have more than 1 tag name
				//because its style may match B, U, I, S
				tagNames = this.htmleditor.getNodeTagName(node);
				
				for(i=0,ii=tagNames.length; i<ii; i++) {
					//If such tag is not in the list already and there are
					//selectors for this tag
					if (!includedTags[tagNames[i]] && selectors[tagNames[i]]) {
						
						if (selectors[tagNames[i]].length) {
							groups[selectors[tagNames[i]][0].group] = true;
						}
						
						targetNodes.push({'node': node, 'tag': tagNames[i]});
						includedTags[tagNames[i]] = true;
						
						break;
					}
				}
				node = node.parentNode;
			}
			
			/*
			//If there are no selectors for this or parent elements then show selectors which are for all tags
			if ('' in selectors && !srcNode.compareTo(selectedNode)) {
				tagNames = this.htmleditor.getNodeTagName(selectedNode);
				this.targetNode = selectedNode;
				this.fillOptions(selectedNode, tagNames[0]);
				
				return;
			}
			*/
			
			// Show / hide groups
			/*
			var nodes = this.dropdownTypesNodes,
				prevValue = this.dropdownTypes.get('value'),
				value = null;
			
			for(i in nodes) {
				if (groups[i]) {
					nodes[i].removeClass('hidden');
					if (value === null || prevValue == i) {
						value = i;
					}
				} else {
					nodes[i].addClass('hidden');
				}
			}
			
			this.dropdownTypes.set('value', value);
			*/
			
			this.updateStylesList();
		},
		
		/**
		 * When editing allowed changes update sidebar visibility 
		 * @param {Object} event
		 */
		handleEditingAllowChange: function (event) {
			if (!event.allowed) {
				this.hideStylesSidebar();
			}
			
			this.htmleditor.get('toolbar').getButton('style').set('disabled', !event.allowed);
		},
		
		/**
		 * Highlight content element
		 * 
		 * @param {Object} element Element which needs to be highlighted
		 */
		highlightElement: function (element) {
			var node = element ? Y.Node(element) : null;
			if (node) {
				if (!this.highlightNode) {
					this.highlightNode = Y.Node.create('<div class="su-element-overlay"></div>');
					
					var doc = Y.Node(this.htmleditor.get('doc'));
					doc.one('body').append(this.highlightNode);
				}
				
				var offset = node.get('region');
				this.highlightNode.setStyles({
					'left': offset.left - 2,		//2px border
					'top': offset.top - 2,			//2px border
					'width': offset.width,
					'height': offset.height,
					'display': 'block'
				});
			} else {
				if (this.highlightNode) {
					this.highlightNode.setStyle('display', 'none');
				}
			}
		},
		
		/**
		 * Highlight element closest to selection which matches tag
		 * 
		 * @param {String} tag Tag name
		 */
		highlightElementByTag: function (tag) {
			if (tag) {
				var match = this.getMatchingTarget(tag);
				if (match) {
					this.highlightElement(match.target.node);
				}
			} else {
				this.highlightElement(null);
			}
		},
		
		highlightElementByEvent: function (e) {
			var item		= e.target.closest('.style-item'),
				tag			= item.getAttribute('data-tag');
			
			//While dropdown is closing it's possible to hover one of the items
			//but in this case we don't want to highlight anything
			if (e.type == 'mouseenter' && this.settings_form && this.settings_form.get('visible')) {
				this.highlightElementByTag(tag);
			} else if (e.type == 'mouseleave') {
				this.highlightElementByTag(null);
			}
		},
		
		
		/* -------------------------------------- Style change ---------------------------------------- */
		
		/**
		 * Returns object with 'target' and 'exact' values
		 * Exact is true if exact match was found or false if similar type node is returned
		 * Searching for P, H1 - H5 any of P, H1 - H5 can be returned
		 * 
		 * @param {String} tag Tag name
		 * @return Object with 'target' and 'exact'
		 * @type {Object}
		 */
		getMatchingTarget: function (tag) {
			var targets = this.targetNodes,
				target = null,
				t = 0,
				tt = targets.length,
				exact = true;
			
			//Find item in target list which classname needs to be changed
			for(; t<tt; t++) {
				if (targets[t].tag == tag) {
					target = targets[t];
					break;
				}
			}
			
			//Element with exact tag not found
			//Find similar element
			if (!target) {
				for(t = 0; t<tt; t++) {
					if (targets[t].tag == 'P' || targets[t].tag == 'H1' || targets[t].tag == 'H2' || targets[t].tag == 'H3' || targets[t].tag == 'H4' || targets[t].tag == 'H5') {
						target = targets[t];
						break;
					}
				}
				
				if (!target) {
					return null;
				} else {
					exact = false;
				}
			}
			
			return {
				'target': target,
				'exact': exact
			};
		},
		
		/**
		 * Update element style
		 * 
		 * @param {Event} e Event facade object
		 */
		updateStyle: function (e) {
			if (this.htmleditor.get('disabled')) return;
			
			var item		= e.target.closest('.style-item'),
				tag			= item.getAttribute('data-tag'),
				classname	= item.getAttribute('data-id'),
				
				match		= this.getMatchingTarget(tag),
				target 		= match ? match.target : null,
				changeTag	= match ? !match.exact : true;
			
			//Remove highlight
			this.highlightElement(null);
			
			if (!target) {
				target = this.htmleditor.getSelectedElement();
				target = target ? this.htmleditor.closest(target, 'H1, H2, H3, H4, H5, P, LI') : null;
				
				if (target && target.tagName == 'LI') {
					//List item is selected, wrap all inner nodes
					this.wrapContents(Y.Lang.toArray(target.childNodes), tag, classname);
					this.htmleditor.refresh(true);
				} else {
					//No matching elements were found, user has selected simple text
					//Create P element
					this.htmleditor.exec((tag || 'p').toLowerCase());
					this.htmleditor.refresh(true);
					
					//Style newly created element
					if (classname) {
						var node = this.htmleditor.getSelectedElement();
						if (node) {
							node = Y.Node(node).closest('H1, H2, H3, H4, H5, P');
							
							//Set new class
							if (node) {
								node.addClass(classname);
							}
						}
					}
				}
			} else {
				
				var node = Y.Node(target.node),
					classnames = this.selectors[target.tag],
					c = 0,
					cc = classnames.length;
				
				//Remove previous class
				for(; c<cc; c++) {
					node.removeClass(classnames[c].classname);
				}
				
				//Change tag
				if (changeTag) {
					//Commands are case-sensitive and are lower case
					this.htmleditor.exec(tag.toLowerCase());
					this.htmleditor.refresh(true);
					
					//Find newly created element
					node = this.htmleditor.getSelectedElement();
					if (node) {
						node = Y.Node(node).closest('H1, H2, H3, H4, H5, P');
					}
				}
				
				//Set new class
				if (node && classname) {
					node.addClass(classname);
				}
			}
		},
		
		/**
		 * Wrap 'node' inside a node
		 * Block level elements are traversed and their inline children and text are wrapped
		 * Heading and paragraph tags are replaced with 'tag'
		 * 
		 * @param {HTMLElement|Text} node Node to wrap
		 * @param {String} tag Tag name to wrap content inside
		 * @param {String} className Optional class to add to wrapped tag
		 * @private
		 */
		wrapContents: function (node, tag, className) {
			var replace    = {'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'p': true},
				inline     = Supra.HTMLEditor.ELEMENTS_INLINE,
				htmleditor = this.htmleditor,
				selected   = null,
				
				createNode = function (content, replace) {
					var node = document.createElement(tag),
						old_node = null;
					
					if (className) {
						node.className = className;
					}
					if (content) {
						if (replace) {
							htmleditor.insertBefore(node, content);
							old_node = content;
							content = content.childNodes ? Y.Lang.toArray(content.childNodes) : [content];
						}
						if (Y.Lang.isArray(content)) {
							if (content.length) {
								if (!replace) {
									htmleditor.insertBefore(node, content[0]);
								}
								for (var i=0,ii=content.length; i<ii; i++) {
									node.appendChild(content[i]);
								}
							}
						} else {
							htmleditor.insertBefore(node, content);
							node.appendChild(content);
						}
						if (replace) {
							old_node.parentNode.removeChild(old_node);
						}
					}
					
					return node;
				},
				
				traverse = function (nodes) {
					var i = 0,
						ii = nodes.length,
						first = null,
						node = null,
						tagName = null;
					
					for (; i<ii; i++) {
						if (nodes[i].nodeType == 1) {
							tagName = nodes[i].tagName.toLowerCase();
							if (tagName in replace) {
								// Replace tag
								node = createNode(nodes[i], true);
								first = first || node;
							} else if (!(tagName in inline)) {
								// Traverse children, if tag is not inline
								traverse(Y.Lang.toArray(nodes[i].childNodes));
								// Reset node, so that it's created for next matching item
								// to preserve correct tag order
								node = null;
							} else {
								// Inline node, wrap inside a tag
								if (node) {
									// We already have a tag, append content to it
									node.appendChild(nodes[i]);
								} else {
									// Create a tag
									node = createNode(nodes[i]);
									first = first || node;
								}
							}
						} else if (nodes[i].nodeType == 3 && htmleditor.getNodeLength(nodes[i])){
							// Non empty text node
							if (node) {
								// We already have a tag, append content to it
								node.appendChild(nodes[i]);
							} else {
								// Create a tag
								node = createNode(nodes[i]);
								first = first || node;
							}
						}
					}
					
					return node;
				};
			
			if (Y.Lang.isArray(node)) {
				selected = traverse(node);
			} else {
				selected = traverse([node]);
			}
			
			if (selected) {
				htmleditor.selectNode(selected);
			}
		},
		
		
		/* -------------------------------------- Sidebar ---------------------------------------- */
		
		
		/**
		 * Create styles sidebar
		 */
		createStylesSidebar: function () {
			//Get form placeholder
			var content = Manager.getAction('PageContentSettings').get('contentInnerNode');
			if (!content) return;
			
			//Properties form
			var form_config = {
				'inputs': [],
				'style': 'vertical'
			};
			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			var node = this.sidebarElement = Y.Node.create('<div class="style-list"></div>');
			form.get('contentBox').append(node);
			
			//When user selects a value, update content
			this.listeners.push(
				node.delegate('click', this.updateStyle, '.style-item', this)
			);
			this.listeners.push(
				node.delegate('mouseenter', this.highlightElementByEvent, '.style-item', this)
			);
			this.listeners.push(
				node.delegate('mouseleave', this.highlightElementByEvent, '.style-item', this)
			);
			
			this.settings_form = form;
			return form;
		},
		
		/**
		 * Show styles sidebar
		 */
		showStylesSidebar: function () {
			//Make sure PageContentSettings is rendered
			var form = this.settings_form || this.createStylesSidebar(),
				action = Manager.getAction('PageContentSettings');
			
			if (!form) {
				if (action.get('loaded')) {
					if (!action.get('created')) {
						action.renderAction();
						this.showStylesSidebar();
					}
				} else {
					action.once('loaded', function () {
						this.showStylesSidebar();
					}, this);
					action.load();
				}
				return false;
			}
			
			var node = this.node = Y.Node.create('<div></div>');
			form.get('contentBox').append(node);
			
			if (!Manager.getAction('PageToolbar').hasActionButtons("htmleditor-plugin")) {
				Manager.getAction('PageToolbar').addActionButtons("htmleditor-plugin", []);
				Manager.getAction('PageButtons').addActionButtons("htmleditor-plugin", []);
			}
			
			action.execute(form, {
				'doneCallback': Y.bind(this.hideStylesSidebar, this),
				'hideCallback': Y.bind(this.onStyleSidebarHide, this),
				
				'title': Supra.Intl.get(['htmleditor', 'styles']),
				'scrollable': true,
				'toolbarActionName': 'htmleditor-plugin'
			});
			
			//Render list
			this.updateStylesList();
			
			//Style toolbar button
			this.htmleditor.get('toolbar').getButton('style').set('down', true);
		},
		
		/**
		 * Hide styles sidebar
		 */
		hideStylesSidebar: function () {
			if (this.settings_form && this.settings_form.get('visible')) {
				Manager.PageContentSettings.hide();
			}
		},
		
		/**
		 * When styles sidebar is hidden update toolbar button to reflect that
		 * 
		 * @private
		 */
		onStyleSidebarHide: function () {
			//Unstyle toolbar button
			this.htmleditor.get('toolbar').getButton('style').set('down', false);
		},
		
		
		/* -------------------------------------- Plugin ---------------------------------------- */
		
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			var toolbar = htmleditor.get('toolbar');
			
			this.pluginFormats = htmleditor.getPlugin('formats');
			this.excludeList = {};
			this.targetNodes = [];
			this.selectors = this.getSelectors();
			this.listeners = [];
			
			htmleditor.addCommand('style', Y.bind(this.showStylesSidebar, this));
			
			//When un-editable node is selected disable toolbar button
			this.listeners.push(
				htmleditor.on('editingAllowedChange', this.handleEditingAllowChange, this)
			);
			this.listeners.push(
				htmleditor.on('nodeChange', this.handleNodeChange, this)
			);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			this.pluginFormats = null;
			this.excludeList = null;
			this.targetNodes = null;
			this.selectors = null;
			this.sidebarElement = null;
			
			if(this.settings_form) {
				this.settings_form.destroy();
			}
			
			for(var i=0,ii=this.listeners.length; i<ii; i++) {
				this.listeners[i].detach();
			}
			
			this.listeners = null;
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base', 'supra.template']});YUI().add('supra.htmleditor-plugin-paste', function (Y) {
	
	var defaultConfiguration = {
		/* 
		 * Modes definition is missing, because plugin works in all modes
		 */
		
		/*
		 * If pasting from word remove spans
		 * SPAN is used for styles, but styles are removed, so no need for spans
		 */
		removeSpans: true,
		
		/*
		 * If pasting from word remove empty tags
		 */
		removeEmptyTags: true,
		
		/*
		 * If pasting from word remove following attributes
		 */
		removeAttributes: ['xmlns', 'style', 'lang', 'id', 'name', 'class', 'width', 'height', 'v:[a-z0-9\\-\\_]+', 'w:[a-z0-9\\-\\_]+']
	};
	
	var REMOVABLE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'blockquote', 'q', 'li', 'div', 'article', 'aside', 'details', 'figcaption', 'footer', 'header', 'hgroup', 'nav', 'section', 'pre', 'code', 'font', 'b', 'strong', 'em', 'i', 'u', 'a'];
	
	Supra.HTMLEditor.addPlugin('paste', defaultConfiguration, {
		
		/**
		 * Configuration
		 * @type {Object}
		 */
		config: null,
		
		/**
		 * Temporary placeholder for pasted content
		 * @type {HTMLElement}
		 */
		placeHolder: null,
		
		/**
		 * Selection before paste event
		 * @param {Object} event
		 */
		previousSelection: null,
		
		/**
		 * Cancel event
		 * @param {Event} event
		 */
		cancelEvent: function (event) {
			if (event.preventDefault) event.preventDefault();
			event.returnValue = false;
			return false;
		},
		
		/**
		 * Handle paste event
		 * @param {Object} event
		 */
		onPaste: function (event) {
			event = event || window.event;
			if (!this.htmleditor.editingAllowed || this.htmleditor.get('disabled')) return this.cancelEvent(event);
			
			//Save current selection
			var htmleditor	= this.htmleditor,
				selection	= htmleditor.getSelection();
			
			//If there's no selection, then skip
			if (!selection || !selection.start) return this.cancelEvent(event);
				
			var srcNode		= Y.Node.getDOMNode(htmleditor.get('srcNode')),		// editor content node
				doc			= htmleditor.get('doc'),							// editor iframe document
				win			= htmleditor.get('win'),							// editor iframe window
				body		= doc.body,											// editor iframe body
				node		= doc.createElement('DIV');							// temporary node
			
			/* Create node, which will be used as temporary storage for pasted value
			 * make sure it's outside the screen to prevent flickering */
			node.contentEditable = true;
			node.style.position = 'fixed';
			node.style.width = '2000px';
			node.style.left = '-9000px';
			node.style.top = '0px';
			node.style.opacity = 0;
			node.innerHTML = '&nbsp;';
			
			body.appendChild(node);
			
			//Change selection to new element (content will be pasted inside it)
			htmleditor.setSelection({
				'start': node,
				'end': node,
				'start_offset': 0,
				'end_offset': node.childNodes.length
			});
			
			Supra.immediate(this.afterPaste);
			
			this.placeHolder = node;
			this.previousSelection = selection;
		},
		
		/**
		 * After paste event retrieve pasted content, clean it and place
		 * it into content
		 */
		afterPaste: function () {
			var placeHolder = this.placeHolder,
				nodes = null,
				node  = null,
				tag   = null,
				
				htmleditor = null,
				html = null,
				
				children = null,
				
				tmp   = null,
				type  = null,
				split = true;
			
			if (this.previousSelection && placeHolder) {
				htmleditor	= this.htmleditor,
				html		= placeHolder.innerHTML;
				
				//Process HTML to make sure there is no garbage code
				html = this.cleanPastedHTML(html);
				
				//Convert into format browser can understand and work with
				html = html ? htmleditor.uncleanHTML(html) : html;
				
				//Check if we need to unwrap tag
				placeHolder.innerHTML = html;
				nodes = Y.Node(placeHolder).get('childNodes');
				
				//Table with one cell shouldn't be a table, unwrap
				//table leaving only cell content
				/*
				if (nodes.size() == 1) {
					node = nodes.item(0);
					
					if (node.get('nodeType') == 1 && node.get('tagName').toLowerCase() == 'table') {
						tmp = node.all('>tbody>tr>td,>tbody>tr>th,>tr>td,>tr>th');
						
						if (tmp.size() == 1) {
							// Only one TD or TH
							nodes = tmp.get('childNodes');
							node = tmp.item(0).getDOMNode();
							
							do {
								tmp = node; node = tmp.parentNode;
								htmleditor.unwrapNode(tmp);
							} while (node && node.tagName !== 'TABLE');
							
							html = placeHolder.innerHTML;
						}
					}
				}
				*/
				/*
				if (nodes.size() == 1 && nodes.item(0).test('table')) {
					// We are pasting table
					// Is user pasting inside another table?
					var sel_from = this.previousSelection.start,
						sel_end  = this.previousSelection.end;
					
					console.log(sel_from, sel_to);
				}
				*/
				
				//List with one item shouldn't be a list, unwrap
				//list leaving only content
				if (nodes.size() == 1 && nodes.item(0).test('ol, ul')) {
					node = nodes.item(0);
					children = node.get('childNodes'); // List of LI
					
					if (children.size() == 1){
						nodes = children.item(0).get('childNodes');
						htmleditor.unwrapNode(children.item(0).getDOMNode());
						htmleditor.unwrapNode(node.getDOMNode());
						html = placeHolder.innerHTML;
					} 
				}
				
				if (nodes.size() == 1) {
					node = nodes.item(0);
					type = node.get('nodeType');
					
					//If there is only a single tag in the list then unwrap it
					//if tag is in REMOVABLE_TAGS list
					if (type == 1) {
						tag = node.get('tagName').toLowerCase();
						
						if (Y.Array.indexOf(REMOVABLE_TAGS, tag) != -1) {
							htmleditor.unwrapNode(node.getDOMNode());
							html = placeHolder.innerHTML;
							split = false;
						}
					} else if (type == 3) {
						// Already a text, no need to split content
						split = false;
					}
				}
				
				if (split && nodes.size()) {
					// If content is not a simple text, then split existing tag and insert pasted nodes
					// where they should be
					this.afterPasteSplitInsert(nodes);
					return;
				}
				
				//Restore previous selection
				htmleditor.setSelection(this.previousSelection);
				this.previousSelection = null;
				
				//null or false <- prevent pasting
				if (html !== null && html !== false) {
					html = html || '';
					
					//Insert html 
					if (Y.UA.webkit) {
						//In webkit selection is set only after timeout
						Y.later(16, this, function () {
							htmleditor.replaceSelection(html, null);
							this.afterPasteFinalize();
						});
					} else {
						htmleditor.replaceSelection(html, null);
						this.afterPasteFinalize();
					}
				}
			}
		},
		
		/**
		 * Insert copied cell content into selected sell content
		 */
		afterPasteTableToTable: function (nodes) {
			
		},
		
		/**
		 * Insert content by splitting existing tag into two parts at cursor position
		 * and insert pasted content between them
		 */
		afterPasteSplitInsert: function (nodes) {
			var htmleditor	= this.htmleditor,
				insert = null;
			
			// 
			insert = Y.bind(function () {
				htmleditor.replaceSelection('');
				
				var parent = htmleditor.splitAt(this.previousSelection.start, this.previousSelection.start_offset),
					dom = nodes.getDOMNodes(),
					i = 0,
					ii = dom.length,
					first_element = null,
					last_element = null,
					prev_element = null,
					next_element = null;
				
				if (parent) {
					if (parent.tagName == 'LI' && dom[0].tagName != 'LI') {
						// List item, add to the beginning of it because pasting non-list items
						for (i=ii-1; i>=0; i--) {
							htmleditor.insertPrepend(dom[i], parent);
						}
					} else {
						for (; i<ii; i++) {
							htmleditor.insertBefore(dom[i], parent);
							first_element = first_element || dom[i];
							last_element = dom[i];
						}
					}
				}
				
				// Remove empty elements before pasted content
				while (first_element && first_element.previousElementSibling) {
					prev_element = first_element.previousElementSibling;
					
					if (prev_element && htmleditor.isNodeEmpty(prev_element)) {
						prev_element.parentNode.removeChild(prev_element);
					} else {
						first_element = null;
					}
				}
				
				// Remove empty elements after pasted content
				while (last_element && last_element.nextElementSibling) {
					next_element = last_element.nextElementSibling;
					
					if (next_element && htmleditor.isNodeEmpty(next_element)) {
						next_element.parentNode.removeChild(next_element);
					} else {
						last_element = null;
					}
				}
				
				// If reference node is empty then remove it
				// It's possible it has been removed already
				if (parent && parent.parentNode && htmleditor.isNodeEmpty(parent)) {
					parent.parentNode.removeChild(parent);
				}
				
				this.previousSelection = null;
				this.afterPasteFinalize();
			}, this);
			
			
			//Restore previous selection
			htmleditor.setSelection(this.previousSelection);
			
			if (Y.UA.webkit) {
				//In webkit selection is set only after timeout
				Y.later(16, this, insert);
			} else {
				insert();
			}
		},
		
		/**
		 * Clean up after paste
		 * @private
		 */
		afterPasteFinalize: function () {
			//Remove placeholder since it's not needed anymore
			this.placeHolder.parentNode.removeChild(this.placeHolder);
			delete(this.placeHolder);
			
			//
			this.htmleditor.fire('afterPaste');
			
			//Content was changed
			this.htmleditor._changed();
		},
		
		/**
		 * Clean pasted html
		 * @param {Object} html
		 */
		cleanPastedHTML: function (html) {
			var htmleditor = this.htmleditor,
				mode = htmleditor.get('mode');
			
			if (mode == Supra.HTMLEditor.MODE_STRING) {
				//Remove all tags
				html = html.replace(/<[^>]+>/g, '');
				
				//Calling, because plugins could be using 'cleanHTML' event
				html = htmleditor.cleanHTML(html);
			} else if (mode == Supra.HTMLEditor.MODE_TEXT) {
				
				if (html.indexOf('<') !== -1) {
					// Replace all block level ending tags with new lines
					var regex = new RegExp('(<br[^>]*>|<\\/(' + Supra.HTMLEditor.ELEMENTS_BLOCK_ARR.join('|') + ')[^>]*>)', 'ig');
					 
					// There are no new lines, 
					html = html.replace(/\n/g, '');
					html = html.replace(regex, '\n');
				}
				
				// Remove all tags
				html = html.replace(/<[^>]+>/g, '');
				
				// Remove whitespaces at the begining and at the end
				html = html.replace(/(^[\r\n\s]*|[\r\n\s]*$)/g, '');
				
				// Replace new lines with BRs
				html = html.replace(/\n/g, '<br />');
				
				//Calling, because plugins could be using 'cleanHTML' event
				html = htmleditor.cleanHTML(html);
			} else {
				
				//If content was pasted from MS Word, remove all MS tags/styles/comments
				html = this.cleanUpWordFormatting(html);
				
				//In case if content was copied from editor, then need to remove IDs, classes, etc.
				html = htmleditor.cleanHTML(html);
				
				//Remove script, style and link nodes
				html = html.replace(/<script[^>]*\/?>([\s\S]*?<\/script>)?/ig, '');
				html = html.replace(/<style[^>]*\/?>([\s\S]*?<\/style>)?/ig, '');
				html = html.replace(/<link[^>]*\/?>/ig, '');
				
				//WebKit may add BR, remove it
				html = html.replace(/<br\s?\/?>$/i, '');
				
				//Remove "su..." ids to prevent conflict
				html = html.replace(/id=("|')?su[0-9]+("|')?\s?/ig, '');
			}
			
			//Fire pasteHTML event and allow listeners to modify content
			var event = {'html': html};
			htmleditor.fire('pasteHTML', {}, event);
			
			return event.html;
		},
		
		/**
		 * Returns true if HTML is pasted from Microsoft Word
		 * 
		 * @param {String} html HTML which will be pasted
		 * @return True if html has Word formatting, otherwise false
		 * @type {Boolean}
		 */
		isContentFromWord: function (html) {
			if (html.indexOf('MsoNormal') != -1 || html.indexOf('WordDocument') != -1) return true;
			return false;
		},
		
		/**
		 * Remove MS Word formatting from html
		 * @param {String} html
		 * @return Cleaned html
		 * @type {String}
		 */
		cleanUpWordFormatting: function (html) {
			if (!this.isContentFromWord(html)) return html;
			
			//Remove comments
			html = html.replace(/<!--[\s\S]*?-->/ig, '');
			
			//Spans are not needed, because they don't have default style
			if (this.config.removeSpans) {
				html = html.replace(/<\/?span[^>]*>/ig, '');
			}
			
			//Since classname in word pasted text has semantic meaning, we need to
			//keep them to check after attributes are removed
			var remove_class_attr = false;
			if (Y.Array.indexOf(this.config.removeAttributes, 'class') != -1) {
				html = html.replace(/class="/g, 'class_su="');
				remove_class_attr = true;
			}
			
			//Content should be style using CSS files, not in-line styles
			//class-names don't match website classnames, should be removed also
			//lang attribute should be set on document, not in-line
			//v: and w: attributes are meaning-less
			if (this.config.removeAttributes && this.config.removeAttributes.length) {
				html = html.replace(new RegExp('\\s+(' + this.config.removeAttributes.join('|') + ')="[^"]*"', 'ig'), '');
			}
			
			//Remove empty tags
			if (this.config.removeEmptyTags) {
				html = html.replace(/<([^\s>]+)[^>]*><\/\1>/ig, '');
			}
			
			//Fix table headings by replacing <td><p class="TableHeading">...</p></td>
			//with <th><p>...</p></th>
			var attr = 'class';
			if (remove_class_attr) {
				attr = 'class_su';
			}
			
			html = html.replace(new RegExp('<td([^>]+)>\\s*<p ' + attr + '="TableHeading">(.*?)</p>\\s*<\/td>', 'gi'), '<th$1><p>$2</p><\/th>');
			
			if (remove_class_attr) {
				html = html.replace(new RegExp('\\s+' + attr + '="[^"]*"', 'ig'), '');
			}
			
			//Remove P tags from tables
			html = html.replace(/<(td|th)([^>]*)>\s*<p>(.*?)<\/p>/g, '<$1$2>$3');
			
			//Remove broken images
			html = html.replace(/<img[^>]+src="file:\/\/[^>]+>/ig, '');
			
			return html;
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			//If there is no configuration, skip everything
			if (!configuration) return false;
			
			//Set configuration
			this.config = configuration;
			
			//Preserve execution context
			this.afterPaste = Y.bind(this.afterPaste, this);
			
			var node = Y.Node.getDOMNode(htmleditor.get('srcNode'));
			if (node) {
				//Using traditional method, because other methods doesn't work cross-browser
				node.onpaste = Y.bind(this.onPaste, this);
			}
			
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}		
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-paragraph', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH],
		
		/*
		 * Selects whether pressing return inside a paragraph creates another paragraph or just inserts a <br> tag.
		 * By defaults it's disabled
		 */
		insertBrOnReturn: false
	};
	
	/*
	 * Regular expression to remove whitespace, BR and empty P tags from beginning of HTML
	 */
	var WHITESPACE_REGEX = /^(&nbsp;|\n|\r|\s|<\/?\s?br\s?\/?>)*<p[^>]*>(&nbsp;|\n|\r|\s|<\/?\s?br\s?\/?>)*<\/p>/i,
	
		KEY_RETURN         = 13,
		KEY_BACKSPACE      = 8,
		KEY_DELETE         = 46;
	
	
	Supra.HTMLEditor.addPlugin('paragraph', defaultConfiguration, {
		
		/**
		 * Handle keyDown in IE and WebKit browsers to insert BR
		 */
		_onBrKeyDown: function (event) {
			if (!event.stopped && event.keyCode == KEY_RETURN && !event.shiftKey && !event.alyKey && !event.ctrlKey) {
				var editor = this.htmleditor,
					node = new Y.Node(editor.getSelectedElement());
				
				/*
				if (Y.UA.ie) {
                    if (!sel.anchorNode || (!sel.anchorNode.test(LI) && !sel.anchorNode.ancestor(LI))) {
                        sel._selection.pasteHTML('<br>');
                        sel._selection.collapse(false);
                        sel._selection.select();
                        event.halt();
                    }
                }
				*/
				
                if (Y.UA.webkit) {
                    if (!node.test('LI') && !node.ancestor('LI')) {
                        editor.get('doc').execCommand('insertlinebreak', null);
                        event.halt();
                    }
                }
			}
		},
		
		/**
		 * Remove whitespace, BR and empty P tags from beginning of HTML
		 */
		_removeWhitespaces: function (event, data) {
			data.html = data.html.replace(WHITESPACE_REGEX, '');
		},
		
		/**
		 * On return key insert paragraph
		 */
		_insertParagraph: function (event) {
			if (!event.stopped && event.keyCode == KEY_RETURN && !event.shiftKey && !event.alyKey && !event.ctrlKey) {
				
				// Cursor is at the end of the inline node?
				// Create block level element, not inline (eg. <a class="button" />)
				var selected  = this.htmleditor.getSelectedElement(),
					inline    = Supra.HTMLEditor.ELEMENTS_INLINE,
					tagName   = '',
					node      = null,
					length    = 0;
				
				if (selected) {
					if (this.htmleditor.isCursorAtTheEndOf()) {
						node    = this.htmleditor.getSelectedElement('p, li, td, th');
						tagname = node ? node.tagName : 'P';
						
						if (tagname == 'TD' || tagname == 'TH') {
							// If inside TD or TH then insert <br />
							this._onBrKeyDown(event);
						} else if (tagname == 'LI') {
							// If inside LI then insert new li if there is non-selected content
							// inside this li, otherwise insert P after content
							 
							if (this.htmleditor.isNodeEmpty(node)) {
								if (this.htmleditor.getLastChild(node.parentNode) === node) {
									// Empty LI and it's last in the list, insert paragraph after list 
									this.insertHTML('P', node.parentNode);
									node.parentNode.removeChild(node);
									event.halt();
								} else {
									// Empty LI, but not last in the list, split list into two
									var doc  = this.htmleditor.get('doc'),
										list = doc.createElement(node.parentNode.tagName),
										p    = doc.createElement('P'),
										tmp  = null;
									
									this.htmleditor.insertAfter(list, node.parentNode);
									this.htmleditor.insertAfter(p, node.parentNode);
									
									while (node.nextSibling) {
										list.appendChild(node.nextSibling);
									}
									
									node.parentNode.removeChild(node);
									
									// Move cursor to P
									this.htmleditor.setSelection({'start': p, 'end': p, 'start_offset': 0, 'end_offset': 0});
									
									event.halt();
								}
							} else if (this.htmleditor.isAllNodeSelected(node)) {
								// All LI is selected, remove it and insert P after list
								this.insertHTML('P', node.parentNode);
								node.parentNode.removeChild(node);
								event.halt();
							} else {
								// Not empty LI, default behaviour of inserting LI is ok
							}
						} else {
							if (!this.htmleditor.selection.collapsed) {
								this.htmleditor.replaceSelection('');
							}
							this.insertHTML(tagname);
							event.halt();
						}
					}
				}
				
			}
		},
		
		/**
		 * On backspace key if at the begining of the tag or on delete key if at the end of the tag
		 * Content merge should result in not styles being applied
		 * 
		 * @private
		 */
		_mergeContent: function (event) {
			if (!event.stopped && !event.shiftKey && !event.alyKey && !event.ctrlKey) {
				
				if (event.keyCode == KEY_BACKSPACE) {
					if (this.htmleditor.isCursorAtTheBeginingOf()) {
						Supra.immediate(this, this._afterMergeContent);
					}
					
				} else if (event.keyCode == KEY_DELETE) {
					if (this.htmleditor.isCursorAtTheEndOf()) {
						Supra.immediate(this, this._afterMergeContent);
					}
				}
				
			}
		},
		
		/**
		 * Clean up after merge
		 * 
		 * @private
		 */
		_afterMergeContent: function () {
			this.htmleditor.resetSelectionCache();
			var node  = this.htmleditor.getSelectedElement(),
				nodes = null,
				i     = 0,
				style = '';
			
			if (!node) {
				// Outside the bounds, not editable element
				// In theory this should never happen
				Y.log('After backspace or delete key can\'t find selected element for cleanup.', 'warn');
				return;
			}
			
			// Get parent element of node
			node = Y.Node(node);
			if (node.test('SPAN')) {
				node = node.ancestor();
			}
			
			nodes = node.all(Supra.HTMLEditor.ELEMENTS_INLINE_ARR.join(',')).getDOMNodes();
			
			if (nodes) {
				for (i=nodes.length-1; i>=0; i--) {
					node = nodes[i];
					
					if (!Y.Lang.trim(node.className) && node.tagName == 'SPAN') {
						// No special styling using classname, remove element
						this.htmleditor.unwrapNode(node);
					} else {
						// Remove styles, but leave element
						node.removeAttribute('style');
					}
				}
			}
		},
		
		
		/**
		 * Insert after selection
		 * @param {Object} html
		 * @private
		 */
		insertHTML: function (tagname, target) {
			if (!tagname || this.htmleditor.get('disabled')) return;
			
			var html      = '<' + tagname + '></' + tagname + '>',
				selected  = target ? target : this.htmleditor.selection.end,
				reference = null,
				inline    = Supra.HTMLEditor.ELEMENTS_INLINE,
				srcNode   = this.htmleditor.get('srcNode').getDOMNode(),
				node      = Y.Node.create(html).getDOMNode();
			
			// Find first non-inline element
			while (selected && selected !== srcNode) {
				if (selected.nodeType == 1) {
					// If element is not inline and tags are different (P, LI, UL)
					if (!inline[selected.tagName.toLowerCase()] && selected.tagName != node.tagName) {
						break;
					}
				}
				reference = selected;
				selected = selected.parentNode;
			}
			
			// Insert node
			var SUP_BLOCK = {'P': 'P', 'H1': 'H1', 'H2': 'H2', 'H3': 'H3', 'H4': 'H4', 'H5': 'H5', 'UL': 'UL', 'OL': 'OL'},
				PAR_BLOCK = {'P': 'P', 'H1': 'H1', 'H2': 'H2', 'H3': 'H3', 'H4': 'H4', 'H5': 'H5', 'UL': 'UL', 'OL': 'OL', 'DIV': 'DIV'};
			
			if (SUP_BLOCK[tagname] && PAR_BLOCK[selected.tagName] && selected !== srcNode) {
				// Trying to insert P into H1, H1 into P, etc.
				// Don't allow that, insert this tag after selected element
				if (selected.nextSibling) {
					selected.parentNode.insertBefore(node, selected.nextSibling);
				} else {
					selected.parentNode.appendChild(node);
				}
			} else {
				if (reference && reference.nextSibling) {
					selected.insertBefore(node, reference.nextSibling);
				} else {
					selected.appendChild(node);
				}
			}
			
			//this.htmleditor.selectNode(node);
			
			this.htmleditor.setSelection({
				'start': node,
				'end': node,
				'start_offset': 0,
				'end_offset': node.childNodes.length
			});
		},
		
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			window.htmleditor = htmleditor;
			
			if (configuration.insertBrOnReturn) {
	            try {
	                htmleditor.get('doc').execCommand('insertbronreturn', null, true);
	            } catch (bre) {};
	
	            if (Y.UA.ie || Y.UA.webkit) {
	                htmleditor.get('srcNode').on('keydown', Y.bind(this._onBrKeyDown, this));
	            }
			} else {
				/*
				 * On return key insert P
				 */
				htmleditor.get('srcNode').on('keydown', Y.bind(this._insertParagraph, this));
			}
			
			/*
			 * After backspace/delete keys remove merge formatting
			 */
			htmleditor.get('srcNode').on('keydown', Y.bind(this._mergeContent, this));
			
			/*
			 * Remove whitespace from HTML
			 */
			htmleditor.on('getHTML', Y.bind(this._removeWhitespaces, this));
			htmleditor.on('setHTML', Y.bind(this._removeWhitespaces, this));
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-paragraph-string', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_STRING]
	};
	
	Supra.HTMLEditor.addPlugin('paragraph-string', defaultConfiguration, {
		
		/**
		 * Prevent return key
		 */
		_onReturnKey: function (event) {
			if (!event.stopped && event.keyCode == 13 && !event.alyKey && !event.ctrlKey) {
				event.preventDefault();
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			htmleditor.get('srcNode').on('keydown', Y.bind(this._onReturnKey, this));
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-paragraph-text', function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_TEXT]
	};
	
	Supra.HTMLEditor.addPlugin('paragraph-text', defaultConfiguration, {
		
		/**
		 * Prevent return key
		 */
		_onReturnKey: function (event) {
			if (!event.stopped && event.keyCode == 13 && !event.alyKey && !event.ctrlKey) {
				// Insert BR
				var editor = this.htmleditor,
					maxlength = editor.get('maxLength');
				
				if (!maxlength || maxlength > editor.getContentCharacterCount()) {
					editor.get('doc').execCommand('insertlinebreak', null);
				}
                event.halt();
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			htmleditor.on('keyDown', Y.bind(this._onReturnKey, this));
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI.add('supra.input-select-list', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Horizontal button list for selecting values
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-select-list';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		/**
		 * Allow selecting multiple values
		 */
		'multiple': {
			value: false
		},
		
		/**
		 * Style
		 */
		'style': {
			value: '',
			setter: '_setStyle'
		},
		
		/**
		 * Show empty value in the list
		 * @type {Boolean}
		 */
		'showEmptyValue': {
			value: true
		},
		
		/**
		 * Value/option list
		 */
		'values': {
			value: [],
			setter: '_setValues'
		}
	};
	
	Input.HTML_PARSER = {
		'values': function () {
			var input = this.get('inputNode'),
				values = [];
			
			if (input && input.test('select')) {
				var options = Y.Node.getDOMNode(input).options;
				for(var i=0,ii=options.length; i<ii; i++) {
					values.push({
						'id': options[i].value,
						'title': options[i].text
					});
				}
			} else {
				values = this.get('values') || [];
			}
			
			return values;
		},
		'style': function (srcNode) {
			if (srcNode.getAttribute('suStyle')) {
				return srcNode.getAttribute('suStyle') || '';
			}
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<select class="hidden"></select>',
		LABEL_TEMPLATE: '<label></label>',
		
		
		/**
		 * Button list
		 * @type {Object}
		 * @private
		 */
		buttons: {},
		
		/**
		 * List of values matching buttons
		 * @type {Object}
		 * @private
		 */
		button_value_map: null,
		
		/**
		 * Buttons has been rendered
		 * @type {Boolean}
		 * @private
		 */
		buttons_rendered: false,
		
		/**
		 * Last known value
		 * @type {String}
		 * @private
		 */
		last_value: null,
		
		
		bindUI: function () {
			var input = this.get('inputNode');
			input.on('focus', this._onFocus, this);
			input.on('blur', this._onBlur, this);
			
			//Handle value attribute change
			this.on('valueChange', this._afterValueChange, this);
		},
		
		renderUI: function () {
			this.button_value_map = {};
			
			Input.superclass.renderUI.apply(this, arguments);
			
			if (this.get('style')) {
				var classname = this.getClassName(this.get('style')),
					boundingBox = this.get('boundingBox');
				
				boundingBox.addClass(classname);
			}
			
			if (!this.buttons_rendered) {
				this.renderButtons(this.get('values'));
			}
		},
		
		renderButtons: function (values) {
			
			//Remove old buttons
			if (this.buttons) {
				for(var i in this.buttons) {
					this.buttons[i].destroy();
				}
			}
			
			this.buttons = {};
			
			var buttons = this.buttons,
				value = this._getInternalValue(),
				has_value_match = false,
				inputNode = this.get('inputNode'),
				input = inputNode.getDOMNode(),
				show_empty_value = this.get('showEmptyValue'),
				button_value_map = this.button_value_map;
			
			if (this.buttons_rendered && input.options && input.options.length) {
				//Remove old options
				while(input.options.length) {
					input.remove(input.options[0]);
				}
			}
			
			
			//Buttons will be placed instead of input
			inputNode.addClass('hidden');
			
			var button_width = 100 / values.length;
			
			for(var i=0,ii=values.length-1; i<=ii; i++) {
				if (values[i].id || show_empty_value) {
					if (this.renderButton(input, values[i], i == 0, i == ii, button_width)) {
						has_value_match = true;
					}
				}
			}
			
			if (!has_value_match) {
				if (values.length) {
					value = values[0].id;
					if (input) input.value = value;
					this.set('value', value);
				}
			}
			
			//Set value
			if (this.get('multiple') && Y.Lang.isArray(value)) {
				for(var id in buttons) {
					if (id in button_value_map) {
						id = button_value_map[id];
					}
					this.buttons[id].set('down', Y.Array.indexOf(value, id) != -1);
				}
			} else {
				inputNode.set('value', value);
				if (value in button_value_map) {
					value = button_value_map[value];
				}
				if (value in buttons) {
					buttons[value].set('down', true);
				}
			}
			
			//Buttons rendered
			this.buttons_rendered = true;
		},
		
		renderButton: function (input, definition, first, last, button_width) {
			var contentBox = this.get('contentBox'),
				button = new Supra.Button({
					'label': definition.title,
					'icon': definition.icon,
					'type': 'toggle',
					'style': '',
					'disabled': !!definition.disabled
				}),
				value = this._getInternalValue(),
				has_value_match = false;
			
			if (contentBox.test('input,select')) {
				contentBox = this.get('boundingBox');
			}
			
			button.ICON_TEMPLATE = '<span class="img"><img src="" alt="" /></span>';
			this.buttons[definition.id] = button;
			
			if (first) {
				button.get('boundingBox').addClass('su-button-first');
			}
			if (last) {
				button.get('boundingBox').addClass('su-button-last');
			}
			
			if (input && input.options) {
				//Add options to allow selecting value
				input.options[input.options.length] = new Option(definition.title, definition.id);
				if (value == definition.id) input.value = value;
			}
			
			if (definition.id == value) {
				//Mark value as found
				has_value_match = true;
			}
			
			button.render(contentBox);
			
			//Set button width
			if (this.get('style') != 'items') {
				button.get('boundingBox').setStyle('width', button_width + '%');
			}
			
			//On click update input value
			button.on('click', this._onClick, this, definition.id);
			
			return has_value_match;
		},
		
		
		/*
		 * ---------------------------------------- API ----------------------------------------
		 */
		
		
		/**
		 * Returns full data for value
		 * If value is an array of values then returns array of data
		 * 
		 * @param {String} value Optional, value for which to return full data
		 * @returns {Object} Value data
		 */
		getValueData: function (value, values) {
			var value  = value === null || typeof value === 'undefined' ? this._getInternalValue() : value,
				values = values || this.get('values'),
				i = 0,
				ii = values.length,
				tmp = null;
			
			if (Y.Lang.isArray(value)) {
				// Multiple values
				var out = [];
				for (; i<ii; i++) {
					if (Y.Array.indexOf(value, values[i].id) != -1) {
						out.push(values[i]);
					}
					if (values[i].values) {
						out = out.concat(this.getValueData(value, values[i].values));
					}
				}
				return out;
			} else {
				// Single value
				for (; i<ii; i++) {
					if (values[i].id == value) {
						return values[i];
					}
					if (values[i].values) {
						// Go through sub-values
						tmp = this.getValueData(value, values[i].values);
						if (tmp) {
							return tmp;
						}
					}
				}
			}
			
			return null;
		},
		
		/**
		 * Reset value to default
		 */
		resetValue: function () {
			var value = this.get('defaultValue'),
				values = this.get('values');
			
			this.set('value', value !== null ? value : (values.length ? values[0].id : ''));
			return this;
		},
		
		/**
		 * Returns true if list has options with given id
		 * 
		 * @param {String} id Option ID
		 * @return True if has option with given id, otherwise false
		 * @type {Boolean}
		 */
		hasValue: function (id) {
			var values = this.get("values"),
				i = 0,
				ii = values.length;
			
			 for (; i<ii; i++) if (values[i].id == id) return true;
			 return false
		},
		
		
		/*
		 * ---------------------------------------- EVENT LISTENERS ----------------------------------------
		 */
		
		
		/**
		 * On focus style input
		 * 
		 * @private
		 */
		_onFocus: function () {
			if (this.get('boundingBox').hasClass('yui3-input-focused')) return;
			
			this.get('boundingBox').addClass('yui3-input-focused');
			this.get('inputNode').focus();
		},
		
		/**
		 * On blur style input
		 * 
		 * @private
		 */
		_onBlur: function () {
			this.get('boundingBox').removeClass('yui3-input-focused');
		},
		
		/**
		 * On click update value
		 * 
		 * @param {Object} event Event facade object
		 * @param {String} id Value id on which user clicked
		 * @private
		 */
		_onClick: function (event, id) {
			if (this.get('multiple')) {
				this.set('value', this.get('value'));
			} else {
				this.set('value', id);
			}
		},
		
		/**
		 * Returns selected value
		 * 
		 * @returns {String} Selected value
		 * @private
		 */
		_getInternalValue: function () {
			return this.last_value;
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		
		/*
		 * ---------------------------------------- ATTRIBUTES ----------------------------------------
		 */
		
		
		/**
		 * Values attribute setter
		 * 
		 * @param {Array} values List of values
		 * @returns {Array} New values list
		 * @private
		 */
		_setValues: function (values) {
			if (this.get('rendered')) {
				this.renderButtons(values);
			}
			return values;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value Value id
		 * @returns {String} New value
		 * @private
		 */
		_setValue: function (value) {
			// Convert boolean values to string
			if (typeof value == 'boolean') {
				value = value ? "1" : "0";
			} else if (value && typeof value === 'object' && 'id' in value) {
				value = value.id;
			}
			
			if (!this.get('rendered')) {
				// Not rendered, there are no buttons yet
				this.last_value = value;
				return value;
			}
			
			//Input value is not valid if 'multiple' attribute is true
			this.get('inputNode').set('value', value);
			
			//Map for buttons and values
			var button_value_map = this.button_value_map;
			
			if (this.get('multiple') && Y.Lang.isArray(value)) {
				//Update button states
				for(var i in this.buttons) {
					if (i in button_value_map) {
						i = button_value_map[i];
					}
					this.buttons[i].set('down', Y.Array.indexOf(value, i) != -1);
				}
			} else {
				var _value = value;
				if (_value in button_value_map) {
					_value = button_value_map[value];
				}
				for(var i in this.buttons) {
					this.buttons[i].set('down', i == _value);
				}
			}
			
			this.last_value = value;
			return value;
		},
		
		/**
		 * Value attribute getter
		 * 
		 * @returns {String} Selected value
		 * @private
		 */
		_getValue: function (value) {
			var values = this.get('values');
			if (!values || !values.length) {
				// There are no options, so any value will be considered as ok
				return this.last_value;
			}
			
			if (this.get('multiple')) {
				var buttons = this.buttons,
					value = [];
				
				for(var i in this.buttons) {
					if (this.buttons[i].get('down')) {
						value.push(i);
					}
				}
				
				return value;
			} else {
				return this.last_value;
			}
		},
		
		_setDisabled: function (value) {
			value = Input.superclass._setDisabled.apply(this, arguments);
			
			//Disable buttons
			for(var i in this.buttons) {
				this.buttons[i].set('disabled', value);
			}
			
			return value;
		},
		
		/**
		 * Style attribute setter
		 * 
		 * @param {String} value Style value
		 * @returns {String} New style attribute value
		 * @private
		 */
		_setStyle: function (value) {
			var prev = this.get('style'),
				classname = null;
			
			if (prev != value) {
				if (prev) { 
					classname = this.getClassName(prev);
					this.get('boundingBox').removeClass(classname);
				}
				if (value) {
					classname = this.getClassName(value);
					this.get('boundingBox').addClass(classname);
				}
			}
			
			return value;
		}
	});
	
	Supra.Input.SelectList = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto', 'supra.button']});YUI.add('supra.input-select-visual', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Vertical button list for selecting value
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-select-visual';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	
	Input.ATTRS = {
		/**
		 * Icon background color
		 */
		'backgroundColor': {
			value: 'transparent',
			setter: '_setBackgroundColor'
		},
		
		/**
		 * Style:
		 * "" or "no-labels", "mid"
		 */
		'style': {
			value: '',
			setter: '_setStyle'
		},
		
		/**
		 * Icon image style:
		 * "center", "fill" or "button", "html"
		 */
		'iconStyle': {
			value: 'center',
			setter: '_setIconStyle'
		},
		
		/**
		 * Loading state
		 */
		'loading': {
			value: false,
			setter: '_setLoading'
		},
		
		/**
		 * Loading icon
		 */
		'nodeLoading': {
			value: null
		},
		
		/**
		 * Additional CSS if icon style is HTML
		 */
		"css": {
			value: null,
			setter: '_setCSS'
		},
		"cssNode": {
			value: null
		},
		
		/**
		 * Render widget into separate slide and add
		 * button to the place where this widget should be
		 */
		"separateSlide": {
			value: false
		},
		
		/**
		 * Button label in case of separate slide
		 */
		"labelButton": {
			value: ""
		}
	};
	
	Input.HTML_PARSER = {
		'backgroundColor': function (srcNode) {
			return srcNode.getAttribute('suBackgroundColor') || 'transparent';
		},
		'iconStyle': function (srcNode) {
			if (srcNode.getAttribute('suIconStyle')) {
				return srcNode.getAttribute('suIconStyle') || '';
			}
		}
	};
	
	Y.extend(Input, Supra.Input.SelectList, {
		
		widgets: null,
		
		
		/**
		 * On desctruction life cycle remove created slides
		 * and inputs
		 * 
		 * @private
		 */
		destructor: function () {
			if (this.widgets) {
				var slideshow = this.get('slideshow'),
					inputs = this.widgets.inputs,
					slides = this.widgets.slides,
					key = null;
				
				if (slideshow) {
					
					for (key in inputs) {
						inputs[key].destroy();
					}
					for (key in slides) {
						slideshow.removeSlide(key);
					}
					
				}
				
				this.widgets = null;
			}
		},
		
		renderUI: function () {
			this.widgets = {
				// Separate slide
				'slide': null,
				'button': null,
				
				// If using separate slide then
				// container for label and button
				'separateContainer': null,
				
				// Values slides and inputs
				'slides': {},
				'inputs': {}
			};
			
			Input.superclass.renderUI.apply(this, arguments);
			
			//Classnames, etc.
			var boundingBox = this.get("boundingBox"),
				classname;
			
			boundingBox.removeClass(Supra.Input.SelectList.CLASS_NAME);
			
			if (this.get('style')) {
				classname = Y.ClassNameManager.getClassName(Input.NAME, this.get('style'));
				boundingBox.addClass(classname);
			}
			
			if (this.get('iconStyle')) {
				classname = this.getClassName(this.get('iconStyle'));
				boundingBox.addClass(classname);
				
				if (this.get('iconStyle') == 'html') {
					this.set('css', this.get('css'));
				}
			}
			
			if (this.get('separateSlide')) {
				var slideshow = this.getSlideshow(),
					slide = null,
					button = null;
				
				if (slideshow) {
					var value = this.getValueData(this.get('value')),
						label = this.get('labelButton') || value.title;
					
					this.widgets.button = button = new Supra.Button({
						'label': label,
						'style': 'group',
						'groupStyle': this.get('style'),
						'iconStyle': this.get('iconStyle'),
						'icon': value && value.icon ? value.icon : '',
						'disabled': this.get('disabled')
					});
					
					this.widgets.slide = slide = slideshow.addSlide({
						'id': 'propertySlide' + this.get('id'),
						'title': this.get('label') || this.get('labelButton')
					});
					slide = slide.one('.su-slide-content');
					
					button.render();
					button.addClass('button-section');
					button.addClass(this.getClassName('slide', 'button'));
					button.on('click', this._slideshowChangeSlide, this);
					
					var labelNode = this.get('labelNode'),
						boundingBox = this.get('boundingBox'),
						container = this.widgets.separateContainer = Y.Node.create('<div class="yui3-widget yui3-input"></div>');
					
					if (!this.get('visible')) {
						container.addClass('hidden');
					}
					if (labelNode) {
						container.append(labelNode, 'before');
					}
					
					container.append(button.get('boundingBox'));
					boundingBox.insert(container, 'before');
					
					slide.append(boundingBox);
				} else {
					this.set('separateSlide', false);
				}
			}
		},
		
		renderButton: function (input, definition, first, last, button_width) {
			var contentBox = this.get('contentBox'),
				is_group = definition.values && definition.values.length,
				button = null,
				value = this._getInternalValue(),
				has_value_match = false,
				
				slideshow = this.getSlideshow(),
				slide = null,
				subinput = null,
				button_value_map = this.button_value_map;
			
			// Create button
			button = new Supra.Button({
				'label': definition.title,
				'type': is_group ? 'button' : 'toggle',
				'style': is_group ? 'small' : 'group',
				'groupStyle': this.get('style'),
				'iconStyle': this.get('iconStyle'),
				'icon': definition.icon,
				'iconHTML': definition.html,
				'disabled': !!definition.disabled
			});
			
			//Decorate button style
			this.decorateButton(definition, button);
			
			if (contentBox.test('input,select')) {
				contentBox = this.get('boundingBox');
			}
			
			this.buttons[definition.id] = button;
			
			if (first) {
				button.get('boundingBox').addClass('su-button-first');
			}
			if (last) {
				button.get('boundingBox').addClass('su-button-last');
			}
			
			if (is_group && slideshow) {
				button.get('boundingBox').addClass('button-section');
				slide = slideshow.addSlide('propertySlide' + this.get('id') + definition.id);
				
				// Create input (self)
				subinput = new Input(
					Supra.mix({
						'values': definition.values,
						'label': definition.title
					}, this.getAttrs(['value', 'backgroundColor', 'css', 'cssNode', 'defaultValue', 'iconStyle', 'multiple', 'renderer', 'showEmptyValue', 'style', 'value']))
				);
				
				subinput.render(slide.one('.su-slide-content'));
				subinput.set('value', this.get('value'));
				
				this.widgets.slides[definition.id] = slide;
				this.widgets.inputs[definition.id] = subinput;
				
				subinput.after('valueChange', this._afterDescendantValueChange, this, definition.id);
				
				// Add sub values to the value list
				if (input && input.options) {
					for (var i=0, ii=definition.values.length; i<ii; i++) {
						input.options[input.options.length] = new Option(definition.values[i].title, definition.values[i].id);
						button_value_map[definition.values[i].id] = definition.id;
					}
				} else {
					for (var i=0, ii=definition.values.length; i<ii; i++) {
						button_value_map[definition.values[i].id] = definition.id;
					}
				}
			}
			
			if (input && input.options) {
				//Add options to allow selecting value
				input.options[input.options.length] = new Option(definition.title, definition.id);
				if (value == definition.id) input.value = value;
			}
			
			if (definition.id == value) {
				//Mark value as found
				has_value_match = true;
			}
			
			button.render(contentBox);
			
			//Render description
			if (definition.description) {
				var description = Y.Node.create(this.DESCRIPTION_TEMPLATE);
				description.set('text', definition.description);
				description.insert()
				
				//button.get('boundingBox').insert(description, 'after');
				contentBox.append(description);
			}
			
			//Set button width
			button.get('boundingBox').setStyle('width', button_width + '%');
			
			// Group button should fill all available space
			if (is_group) {
				button.addClass('su-button-fill');
			}
			
			//On click update input value
			if (definition.values && slideshow) {
				button.on('click', this._slideshowChangeSlide, this, definition.id);
			} else {
				button.on('click', this._onClick, this, definition.id);
			}
			
			return has_value_match;
		},
		
		/**
		 * Decorate button
		 * May be used by extended classes
		 * 
		 * @param {Object} definition Option definition, configuration
		 * @param {Object} button Button
		 * @private
		 */
		decorateButton: function (definition, button) {
			
			button.after('render', function () {
				if (definition.backgroundColor) {
					var nodes = button.get('boundingBox').all('.su-button-bg div');
					nodes.setStyle('backgroundColor', definition.backgroundColor);
				}
			});
			
		},
		
		
		/*
		 * ---------------------------------------- EVENT LISTENERS ----------------------------------------
		 */
		
		
		/**
		 * Change slideshow slide to values list
		 * 
		 * @private
		 */
		_slideshowChangeSlide: function (event, id) {
			var slideshow = this.getSlideshow(),
				slide_id  = 'propertySlide' + this.get('id');
			
			if (id) {
				slide_id += id;
			}
			
			slideshow.set('slide', slide_id);
		},
		
		/**
		 * After value change
		 * 
		 * @param {Object} evt Event facade object
		 * @private
		 */
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
				
				var inputs = this.widgets.inputs,
					id = null;
				
				for (id in inputs) {
					if (inputs[id].get('value') != evt.newVal) {
						inputs[id].set('value', evt.newVal);
					}
				}
			}
		},
		
		/**
		 * After sub-input value change
		 * 
		 * @param {Object} evt Event facade object
		 * @param {Object} id Descendant id
		 * @private
		 */
		_afterDescendantValueChange: function (evt, id) {
			if (evt.prevVal != evt.newVal) {
				if (this.get('value') != evt.newVal) {
					this.set('value', evt.newVal);
				}
			}
		},
		
		/*
		 * ---------------------------------------- SLIDESHOW ----------------------------------------
		 */
		
		
		/**
		 * Returns parent widget by class name
		 * 
		 * @param {String} classname Parent widgets class name
		 * @return Widget instance or null if not found
		 * @private
		 */
		getParentWidget: function (classname) {
			var parent = this.get("parent");
			while (parent) {
				if (parent.isInstanceOf(classname)) return parent;
				parent = parent.get("parent");
			}
			return null;
		},
		
		/**
		 * Returns slideshow
		 * 
		 * @return Slideshow
		 * @type {Object}
		 * @private
		 */
		getSlideshow: function () {
			var form = this.getParentWidget("form");
			return form ? form.get("slideshow") : null;
		},
		
		
		/*
		 * ---------------------------------------- ATTRIBUTES ----------------------------------------
		 */
		
		
		/**
		 * Disabled attribute setter
		 * 
		 * @param {Array} values
		 * @return New values
		 * @type {Array}
		 * @private
		 */
		_setDisabled: function (value) {
			value = Input.superclass._setDisabled.apply(this, arguments);
			
			if (this.widgets && this.widgets.button) {
				this.widgets.button.set('disabled', value);
			}
			
			return value;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value Value id
		 * @returns {String} New value
		 * @private
		 */
		_setValue: function (value) {
			value = Input.superclass._setValue.call(this, value);
			
			if (this.widgets && this.widgets.button) {
				var data = this.getValueData(value);
				
				this.widgets.button.set('icon', data && data.icon ? data.icon : '');
				
				if (!this.get('labelButton')) {
					this.widgets.button.set('label', data && data.title ? data.title : '');
				}
			}
			
			return value;
		},
		
		/**
		 * Background color attribute setter
		 * 
		 * @param {String} value Background color
		 * @return New background color attribute value
		 * @type {String}
		 * @private
		 */
		_setBackgroundColor: function (value) {
			var nodes = this.get('boundingBox').all('.su-button-bg div');
			
			nodes.setStyle('backgroundColor', value);
			
			return value;
		},
		
		/**
		 * Icon style attribute setter
		 * 
		 * @param {String} value Style value
		 * @return New icon style attribute value
		 * @type {String}
		 * @private
		 */
		_setIconStyle: function (value) {
			var prev = this.get('iconStyle'),
				classname = null;
			
			if (prev != value) {
				if (prev) { 
					classname = this.getClassName(prev);
					this.get('boundingBox').removeClass(classname);
				}
				if (value) {
					classname = this.getClassName(value);
					this.get('boundingBox').addClass(classname);
				}
			}
			
			var buttons = this.buttons,
				id = null;
			
			if (buttons) {
				for (id in buttons) {
					buttons[id].set('iconStyle', value);
				}
			}
			
			return value;
		},
		
		/**
		 * Loading attribute setter
		 * 
		 * @param {Boolean} loading Loading attribute value
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setLoading: function (loading) {
			var box = this.get('contentBox');
			
			if (box) {
				if (loading && !this.get('nodeLoading')) {
					var node = Y.Node.create('<span class="loading-icon"></span>');
					box.append(node);
					this.set('nodeLoading', node);
				}
				
				box.toggleClass(this.getClassName('loading'), loading);
			}
			
			this.set('disabled', loading);
			return loading;
		},
		
		/**
		 * CSS attribute setter
		 * 
		 * @param {String} css CSS styles
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setCSS: function (css) {
			var box = this.get('boundingBox'),
				node = this.get('cssNode'),
				id = null;
			
			if (css && this.get('iconStyle') == 'html') {
				id = this.get('id');
				
				//Prepend styles with ID
				css = css.replace(/[^\{\}]+[\{]/g, function (match) {
					match = match.split(',');
					return '#' + id + ' ' + match.join(', #' + id + ' ');
				});
				
				if (!node) {
					node = Y.Node.create('<style></style>');
				}
				
				// Set style content
				var domNode = node.getDOMNode();
				if ('innerText' in domNode) {
					// Chrome
					node.getDOMNode().innerText = css;
				} else {
					// FF
					node.getDOMNode().innerHTML = css;
				}
				
				box.append(node);
				this.set('cssNode', node);
				
				//We want to set only once
				return '';
			}
			
			return css;
		},
		
		/**
		 * Style attribute setter
		 * We overwrite select list setter, because we don't want extended classes to
		 * have 'style' classnames prefixed with their names which would break
		 * existing styles
		 * 
		 * @param {String} value Style value
		 * @returns {String} New style attribute value
		 * @private
		 */
		_setStyle: function (value) {
			var prev = this.get('style'),
				classname = null;
			
			if (prev != value) {
				if (prev) { 
					classname = Y.ClassNameManager.getClassName(Input.NAME, prev);
					this.get('boundingBox').removeClass(classname);
				}
				if (value) {
					classname = Y.ClassNameManager.getClassName(Input.NAME, value);
					this.get('boundingBox').addClass(classname);
				}
				
				var buttons = this.buttons,
					id = null;
				
				if (buttons) {
					for (id in buttons) {
						buttons[id].set('groupStyle', value);
					}
				}
			}
			
			return value;
		},
		
		/**
		 * Visible attribute setter
		 * 
		 * @private
		 */
		_uiSetVisible: function (visible) {
			visible = Input.superclass._uiSetVisible.apply(this, arguments);
			
			/*
			var separateContainer = this.widgets.separateContainer;
			if (separateContainer) {
				separateContainer.toggleClass('hidden', !visible);
			}
			*/
			
			return visible;
		}
		
	});
	
	Supra.Input.SelectVisual = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-select-list']});YUI.add('supra.input-fonts', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * 
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-fonts';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	
	Input.ATTRS = {
		
		/**
		 * Loading state
		 */
		'loading': {
			value: false,
			setter: '_setLoading'
		},
		
		/**
		 * Loading icon
		 */
		'nodeLoading': {
			value: null
		},
		
		/**
		 * Button label in case of separate slide
		 */
		'labelButton': {
			value: ''
		},
		
		/**
		 * List of all fonts
		 */
		'values': {
			value: [],
			setter: '_setValues'
		},
		
		/**
		 * Fonts preview object
		 */
		'previewGoogleFonts': {
			value: null
		},
		
		/**
		 * Render widget into separate slide and add
		 * button to the place where this widget should be
		 */
		'separateSlide': {
			value: true
		}
		
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		
		INPUT_TEMPLATE: '<select class="hidden"></select>',
		LABEL_TEMPLATE: '<label></label>',
		
		FONT_ITEM_HEIGHT: 40,
		
		widgets: {
		},
		
		backButtonInitiallyVisible: null,
		
		renderUI: function () {
			this.backButtonInitiallyVisible = null;
			
			this.widgets = {
				// Separate slide
				'slide': null,
				'button': null,
				
				// Form
				'search': null,
				
				// Slideshow for font list
				'slideshow': null,
				
				// Scrollable groups
				'groups': {},
				
				// Container for label and button
				'separateContainer': null
			};
			
			Input.superclass.renderUI.apply(this, arguments);
			
			if (this.get('separateSlide')) {
				var slideshow = this.getSlideshow(),
					slide = null,
					button = null;
				
				if (slideshow) {
					var value = this.getValueData(this.get('value')),
						label = (value ? value.title || value.family : '') || this.get('labelButton') || '';
					
					this.widgets.button = button = new Supra.Button({
						'label': label,
						'style': 'group',
						'groupStyle': 'no-labels',
						'iconStyle': 'center',
						'icon': ''
					});
					
					this.widgets.slide = slide = slideshow.addSlide({
						'id': 'propertySlide' + this.get('id'),
						'scrollable': false,
						'title': this.get('label')
					});
					
					slide = slide.one('.su-slide-content');
					
					button.render();
					button.addClass('button-section');
					button.addClass(this.getClassName('slide', 'button'));
					button.on('click', this._slideshowChangeSlide, this);
					
					var labelNode = this.get('labelNode'),
						boundingBox = this.get('boundingBox'),
						container = this.widgets.separateContainer = Y.Node.create('<div class="yui3-widget yui3-input"></div>');
					
					if (labelNode) {
						container.append(labelNode, 'before');
					}
					
					container.append(button.get('boundingBox'));
					boundingBox.insert(container, 'before');
					 
					slide.append(boundingBox);
				} else {
					this.set('separateSlide', false);
				}
			}
			
			// Value
			var values = this.get('values'),
				promise = null,
				preview = new Supra.GoogleFonts();
			
			this.set('previewGoogleFonts', preview);
			
			if (values && values.length) {
				// Render fonts
				this._renderFontList(values);
			} else {
				// Load fonts
				promise = Supra.GoogleFonts.loadFonts();
				
				if (promise.state() == 'pending') {
					this.set('loading', true);
				}
				
				promise.done(function (fonts) {
					this.set('loading', false);
					this.set('values', fonts);
				}, this);
			}
		},
		
		bindUI: function () {
			this.get('contentBox').delegate('click', this._onItemClick, 'a', this);
			this.after('valueChange', this._afterValueChange, this);
		},
		
		
		/*
		 * ---------------------------------------- EVENT LISTENERS ----------------------------------------
		 */
		
		
		/**
		 * Handle item click
		 */
		_onItemClick: function (e) {
			var target = e.target.closest('a'),
				family = target.getAttribute('data-family');
			
			if (family) {
				this.set('value', family);
			}
		},
		
		/**
		 * Change slideshow slide to values list
		 * 
		 * @private
		 */
		_slideshowChangeSlide: function (event, id) {
			var slideshow = this.getSlideshow(),
				slide_id  = 'propertySlide' + this.get('id');
			
			if (id) {
				slide_id += id;
			}
			
			slideshow.set('slide', slide_id);
		},
		
		/**
		 * After value change
		 * 
		 * @param {Object} evt Event facade object
		 * @private
		 */
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
				
				var inputs = this.widgets.inputs,
					content = this.get('contentBox'),
					nodes = null,
					i = 0,
					ii = 0;
				
				nodes = evt.prevVal ? content.all('a[data-family="' + evt.prevVal.replace(/"/g, '') + '"]') : null;
				if (nodes) {
					for (i=0, ii=nodes.size(); i<ii; i++) {
						nodes.item(i).removeClass('active');
					}
				}
				
				nodes = evt.newVal ? content.all('a[data-family="' + evt.newVal.replace(/"/g, '') + '"]') : null;
				if (nodes) {
					for (i=0, ii=nodes.size(); i<ii; i++) {
						nodes.item(i).addClass('active');
					}
				}
			}
		},
		
		
		/*
		 * ---------------------------------------- SLIDESHOW ----------------------------------------
		 */
		
		
		/**
		 * Returns parent widget by class name
		 * 
		 * @param {String} classname Parent widgets class name
		 * @return Widget instance or null if not found
		 * @private
		 */
		getParentWidget: function (classname) {
			var parent = this.get("parent");
			while (parent) {
				if (parent.isInstanceOf(classname)) return parent;
				parent = parent.get("parent");
			}
			return null;
		},
		
		/**
		 * Returns slideshow
		 * 
		 * @return Slideshow
		 * @type {Object}
		 * @private
		 */
		getSlideshow: function () {
			var form = this.getParentWidget("form");
			return form ? form.get("slideshow") : null;
		},
		
		
		/*
		 * ---------------------------------------- API ----------------------------------------
		 */
		
		
		/**
		 * Returns full data for value
		 * 
		 * @param {String} value Optional, value for which to return full data
		 * @returns {Object} Value data
		 */
		getValueData: function (value, groups) {
			var value  = value === null || typeof value === 'undefined' ? this.get('value') : value,
				groups = groups || this.get('values'),
				i  = 0,
				ii = groups ? groups.length : 0,
				values = null,
				k  = 0,
				kk = 0,
				family = '';
			
			for (; i<ii; i++) {
				values = groups[i].fonts;
				
				for (k=0,kk=values.length; k<kk; k++) {
					// When setting data-family attribute quotes are removed, here we have to do the same
					family = values[k].family.replace(/"/g, '');
					
					if (family === value || values[k].apis === value) {
						return values[k];
					}
				}
			}
			
			return null;
		},
		
		
		/*
		 * ---------------------------------------- FONT LIST ----------------------------------------
		 */
		
		
		/**
		 * Render font list
		 * 
		 * @param {Array} fonts List of fonts grouped by categories
		 * @private
		 */
		_renderFontList: function (fonts) {
			var search = this.widgets.search,
				slideshow = this.widgets.slideshow,
				slide = null,
				id = null,
				i = 0,
				ii = fonts.length,
				button = this.widgets.button;
			
			if (!search) {
				search = new Supra.Input.String();
				search.render(this.get('contentBox'));
				search.addClass('search');
				
				window.font = this;
				search.on('input', this._onSearchInput, this);
				
				this.widgets.search = search;
			}
			
			if (!slideshow) {
				slideshow = new Supra.Slideshow();
				slideshow.render(this.get('contentBox'));
				slideshow.on('slideChange', this._updateBackButtonVisibility, this);
				this.widgets.slideshow = slideshow;
				
				// Main / root
				id = 'main' + this.get('id');
				slide = slideshow.addSlide({'id': id});
				this.widgets.groups['main'] = {
					id: id,
					node: slide.one('.su-slide-content, .su-multiview-slide-content'),
					buttons: []
				};
				
				// Search
				id = 'search' + this.get('id');
				this._renderFontGroup({
					'id': id,
					'title': 'search',
					'fonts': [],
					'visible': false,
					'namespace': 'search'
				});
			}
			
			// Create main slides
			slide = this.widgets.groups['main'].node;
			
			for (; i<ii; i++) {
				this._renderFontGroup(fonts[i]);
			}
			
			
			if (button) {
				var data = this.getValueData(this.get('value'), fonts),
					label = (data ? data.title || data.family : '') || this.get('labelButton') || '';
				
				button.set('icon', data && data.icon ? data.icon : '');
				button.set('label', label);
			}
		},
		
		/**
		 * Render font group
		 * 
		 * @param {String} title Group title
		 * @private
		 */
		_renderFontGroup: function (group) {
			var slideshow = this.widgets.slideshow,
				main = this.widgets.groups['main'].node,
				button = null,
				node = null,
				scrollable = null,
				id = group.id ? group.id : group.title + this.get('id'),
				slide = slideshow.addSlide({
					'id': id
				});
			
			// Button on main slide
			if (group.visible !== false) {
				button = new Supra.Button({
					style: 'small',
					label: group.title
				});
				button.addClass('button-section');
				button.render(main);
				
				button.on('click', this._handleFontGroupButtonClick, this, id);
			}
			
			// Slide content
			node = Y.Node.create('<div class="yui3-input-font-list" style="height: ' + (group.fonts.length * this.FONT_ITEM_HEIGHT) + 'px;"></div>');
			slide.one('.su-slide-content, .su-multiview-slide-content').append(node);
			
			scrollable = slide.getData('scrollable');
			
			this.widgets.groups[group.namespace || id] = {
				id: id,
				
				button: button,
				slide: slide,
				node: node,
				
				fonts: group.fonts,
				count: group.fonts.length,
				rendered: 0
			};
			
			scrollable.on('sync', this._updateFontList, this);
			
			window.font = this;
		},
		
		/**
		 * Render font list
		 * 
		 * @param {Object} group Font group
		 * @private
		 */
		_renderFontItems: function (group, from, to) {
			var fonts = group.fonts,
				node  = null,
				i = from,
				container = group.node,
				preview_fonts = [],
				preview = this.get('previewGoogleFonts'),
				value = this.get('value'),
				family = '';
			
			for (; i < to; i++) {
				if (fonts[i].apis) {
					preview_fonts.push(fonts[i]);
				}
				
				family = fonts[i].family.replace(/"/g, '');
				
				node = Y.Node.create('<a ' + (family == value ? 'class="active" ' : '') + '>' + fonts[i].title + '</a>');
				node.setStyle('fontFamily', fonts[i].family);
				node.setAttribute('data-family', family);
				container.append(node);
			}
			
			preview.addFonts(preview_fonts);
			
			group.rendered = to;
		},
		
		/**
		 * Draw additional fonts if needed
		 * 
		 * @private
		 */
		_updateFontList: function (group) {
			// Prevent loop caused by 'sync'
			if (this._isUpdatingFontList) return;
			this._isUpdatingFontList = true;
			
			var group = typeof group == 'string' ? group : this.widgets.slideshow.get('slide'),
				groups = this.widgets.groups,
				from = 0,
				to = 0,
				scroll = 0,
				view = 0,
				scrollable = null;
			
			if (group in groups) {
				group = groups[group];
				from = group.rendered;
				
				if (group.count > group.rendered) {
					// Check if we need to render more fonts
					scrollable = group.slide.getData('scrollable');
					scrollable.syncUI();
					scroll = scrollable.getScrollPosition();
					view = scrollable.getViewSize();
					
					if (scroll + view > group.rendered * this.FONT_ITEM_HEIGHT) {
						to = Math.min(Math.ceil((scroll + view * 2) / this.FONT_ITEM_HEIGHT), group.count);
						
						if (from != to) {
							this._renderFontItems(group, from, to);
						}
					}
				}
			}
			
			this._isUpdatingFontList = false;
		},
		
		/**
		 * On group button click open specific slideshow slide
		 * 
		 * @param {Object} event Event facade object
		 * @param {Object} data Additional event data
		 * @private
		 */
		_handleFontGroupButtonClick: function (event, data) {
			this._initView();
			this.widgets.slideshow.set('slide', data);
			this._updateFontList();
		},
		
		/**
		 * Handle back button click
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		_handleBackButtonClick: function (event) {
			var slideshow = this.widgets.slideshow,
				slide = slideshow.get('slide'),
				main = this.widgets.groups.main.id,
				search = this.widgets.groups.search.id;
			
			if (slide != main) {
				slideshow.scrollBack();
				
				if (slide == search) {
					this.widgets.search.set('value', '');
				}
				
				event.halt();
			}
		},
		
		
		/**
		 * On slide change update back button visibility
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		_updateBackButtonVisibility: function (event) {
			var was_visible = this.backButtonInitiallyVisible,
				sidebar = null,
				button = null;
			
			if (was_visible === false) {
				// It was not visible, so for main slide button shouldn't be visible
				sidebar = this.getParentWidget('ActionBase');
				
				if (sidebar) {
					button = sidebar.get('backButton');
					
					if (!event.newVal || !this.widgets.groups.main || event.newVal == this.widgets.groups.main.id) {
						button.hide();
					} else {
						button.show();
						this._viewActive = true;
					}
				}
				
			}
		},
		
		
		_viewActive: false,
		
		/**
		 * Check back button initial state
		 * Attach to form visible event to observe when sidebar is hidden
		 */
		_initView: function () {
			var was_visible = this.backButtonInitiallyVisible,
				sidebar = null,
				button = null,
				form = null;
			
			if (was_visible === null) {
				// Find if back button is visible and bind linstener
				sidebar = this.getParentWidget('ActionBase');
				was_visible = this.backButtonInitiallyVisible = false;
				
				if (sidebar) {
					// Back button
					button = sidebar.get('backButton');
					if (button) {
						was_visible = this.backButtonInitiallyVisible = button.get('visible');
						button.before('click', this._handleBackButtonClick, this);
					}
					
					// Control button
					button = sidebar.get('controlButton');
					if (button) {
						button.before('click', this._resetView, this);
					}
				}
				
				// When form is hidden reset 
				form = this.getParentWidget('form');
				form.on('visibleChange', function (event) {
					if (!event.newVal && event.prevVal) {
						this._resetView();
					}
				}, this);
			}
		},
		
		/**
		 * Reset view to inital state,
		 * set slideshow to first main slide, which will
		 * hide back button if needed
		 */
		_resetView: function (event) {
			if (this._viewActive) {
				this._viewActive = false;
				
				if (this.widgets.slideshow) {
					this.widgets.slideshow
							.set('noAnimations', true)
							.set('slide', this.widgets.groups.main.id)
							.set('noAnimations', false);
				}
			}
		},
		
		
		/*
		 * ---------------------------------------- SEARCH ----------------------------------------
		 */
		
		
		/**
		 * Handle search input event
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		_onSearchInput: function (event) {
			var slideshow = this.widgets.slideshow,
				slide = slideshow.get('slide'),
				groups = this.widgets.groups,
				animate = false,
				scrollable = null,
				search = groups.search;
			
			if (event.value) {
				if (slide != search.id) {
					
					if (slide != groups.main.id) {
						// Inside one of the groups, don't animate slideshow
						slideshow
							.set('noAnimations', true)
							.set('slide', groups.main.id)
							.set('slide', search.id)
							.set('noAnimations', false);
					} else {
						// Main view, animate slideshow
						slideshow.set('slide', search.id);
					}
				}
				
				if (search.query != event.value) {
					search.query = event.value;
					search.fonts = this._filterFonts(event.value);
					search.count = search.fonts.length;
					search.rendered = 0;
					search.node.empty();
					search.node.setStyle('height', search.fonts.length * this.FONT_ITEM_HEIGHT + 'px');
					
					scrollable = search.slide.getData('scrollable');
					scrollable.syncUI();
					
					this._updateFontList('search');
				}
			} else {
				if (slide != groups.main.id) {
					slideshow.set('slide', groups.main.id);
				}
			}
		},
		
		/**
		 * Filter font list to find fonts which match query string
		 * 
		 * @param {String} query Query string
		 * @returns {Array} List of match fonts
		 * @private
		 */
		_filterFonts: function (query) {
			var groups = this.get('values'),
				i = 0,
				ii = groups.length,
				fonts = null,
				f = 0,
				ff = 0,
				matches = [];
			
			// Lower case and trim
			query = Y.Lang.trim(query.toLowerCase());
			
			for (; i<ii; i++) {
				fonts = groups[i].fonts;
				for (f=0,ff=fonts.length; f<ff; f++) {
					if (fonts[f].title.toLowerCase().indexOf(query) != -1) {
						matches.push(fonts[f]);
					}
				}
			}
			
			return matches;
		},
		
		
		/*
		 * ---------------------------------------- ATTRIBUTES ----------------------------------------
		 */
		
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value Value id
		 * @returns {String} New value
		 * @private
		 */
		_setValue: function (value) {
			if (typeof value === 'object' && value.family) {
				value = value.family;
			}
			if (typeof value !== 'string') {
				value = '';
			}
			
			if (this.widgets && this.widgets.button) {
				var data = this.getValueData(value),
					label = (data ? data.title || data.family : '') || this.get('labelButton') || '';
				
				this.widgets.button.set('icon', data && data.icon ? data.icon : '');
				this.widgets.button.set('label', label);
			}
			
			return value;
		},
		
		/**
		 * Value attribute getter
		 * 
		 * @param {String} value Previous value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_getValue: function (value) {
			return value;
		},
		
		/**
		 * Values attribute setter
		 * 
		 * @param {Array} values List of values
		 * @returns {Array} New values list
		 * @private
		 */
		_setValues: function (values) {
			if (this.get('rendered')) {
				this._renderFontList(values);
			}
			return values;
		},
		
		/**
		 * Disabled attribute setter
		 * Disable / enable HTMLEditor
		 * 
		 * @param {Boolean} value New state value
		 * @return New state value
		 * @type {Boolean}
		 * @private
		 */
		_setDisabled: function (value) {
			var button = this.widgets.button,
				search = this.widgets.search;
			
			if (button) {
				button.set('disabled', !!value);
			}
			
			if (search) {
				search.set('disabled', !!value);
			}
			
			this.get('boundingBox').toggleClass('yui3-input-disabled', value);
			
			return !!value;
		},
		
		/**
		 * Loading attribute setter
		 * 
		 * @param {Boolean} loading Loading attribute value
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setLoading: function (loading) {
			var box = this.get('contentBox');
			
			if (box) {
				if (loading && !this.get('nodeLoading')) {
					var node = Y.Node.create('<span class="loading-icon"></span>');
					box.append(node);
					this.set('nodeLoading', node);
				}
				
				box.toggleClass(this.getClassName('loading'), loading);
			}
			
			this.set('disabled', loading);
			return loading;
		},
		
	});
	
	Supra.Input.Fonts = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.google-fonts']});YUI.add("supra.input-number", function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-number";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.HTML_PARSER = {};
	Input.ATTRS = {
		/**
		 * Min value
		 */
		'minValue': {
			value: null,
			setter: '_setMinValue'
		},
		
		/**
		 * Max value
		 */
		'maxValue': {
			value: null,
			setter: '_setMaxValue'
		},
		
		/**
		 * Value mask to allow only numbers
		 */
		'valueMask': {
			value: /^\-?[0-9]*$/
		},
		
		/**
		 * Default value
		 */
		'defaultValue': {
			value: 0
		},
		
		/**
		 * Add/subtract button step
		 */
		'step': {
			value: 1
		}
	};
	
	Y.extend(Input, Supra.Input.String, {
		
		/**
		 * Button to add 1 to the number
		 * @see Supra.Button
		 * @type {Object}
		 * @private
		 */
		button_add: null,
		
		/**
		 * Button to subtract 1 from the number
		 * @see Supra.Button
		 * @type {Object}
		 * @private
		 */
		button_sub: null,
		
		/**
		 * Add buttons
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			//Add +/- buttons
			this.button_add = new Supra.Button({'label': '+', 'style': 'small'});
			this.button_add.render(this.get('contentBox'));
			this.button_add.addClass('button-add');
			this.button_add.on('click', this._addOne, this);
			
			this.button_sub = new Supra.Button({'label': '-', 'style': 'small'});
			this.button_sub.render(this.get('contentBox'));
			this.button_sub.addClass('button-sub');
			this.button_sub.on('click', this._subOne, this);
		},
		
		/**
		 * Value setter.
		 * 
		 * @param {String} value Value
		 * @return New value
		 * @type {Number}
		 * @private
		 */
		_setValue: function (value) {
			var value = this._validateValue(value),
				min   = this.get('minValue'),
				max   = this.get('maxValue');
			
			this.get('inputNode').set('value', value);
			
			var node = this.get('replacementNode');
			if (node) {
				node.set('innerHTML', Y.Escape.html(value) || '0');
			}
			
			if (this.button_add) {
				this.button_add.set('disabled', max !== null && max == value);
			}
			if (this.button_sub) {
				this.button_sub.set('disabled', min !== null && min == value);
			}
			
			
			this._original_value = value;
			return value;
		},
		
		/**
		 * Value getter
		 * 
		 * @return Value
		 * @type {Number}
		 * @private
		 */
		_getValue: function () {
			var value = this.get('inputNode').get('value');
			return this._validateValue(value);
		},
		
		/**
		 * Validate value to make sure it's in min-max range
		 * 
		 * @param {Number} value Value
		 * @return Correct value
		 * @type {Number}
		 * @private
		 */
		_validateValue: function (value) {
			var value = parseInt(value, 10),
				min   = this.get('minValue'),
				max   = this.get('maxValue');
			
			if (isNaN(value)) {
				value = this.get('defaultValue');
			}
			
			//Swap min and max if needed
			if (min !== null && max !== null && min > max) {
				var tmp = min; min = max; max = tmp;
			}
			
			if (min !== null) value = Math.max(value, min);
			if (max !== null) value = Math.min(value, max);
			
			return value;
		},
		
		/**
		 * Min value setter
		 * To remove min value validation set to null
		 * 
		 * @param {Number} min Min value
		 * @return Min value
		 * @type {Number}
		 */
		_setMinValue: function (min) {
			var value = this.get('value');
			if (min !== null) {
				min = parseInt(min, 10);
				if (value < min) this.set('value', min);
			}
			return min;
		},
		
		/**
		 * Max value setter
		 * To remove max value validation set to null
		 * 
		 * @param {Number} min Max value
		 * @return Max value
		 * @type {Number}
		 */
		_setMaxValue: function (max) {
			var value = this.get('value');
			if (max !== null) {
				max = parseInt(max, 10);
				if (value > max) this.set('value', max);
			}
			return max;
		},
		
		/**
		 * Add one to the number
		 * 
		 * @private
		 */
		_addOne: function () {
			var value = this.get('value'),
				max = this.get('maxValue');
			
			if (max !== null && max == value) return;
			this.set('value', value + this.get('step'));
		},
		
		/**
		 * Remove one from the number
		 * 
		 * @private
		 */
		_subOne: function () {
			var value = this.get('value'),
				min = this.get('minValue');
			
			if (min !== null && min == value) return;
			this.set('value', value - this.get('step'));
		}
		
	});
	
	Supra.Input.Number = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-string"]});YUI.add('supra.input-path', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-path';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		'path': {
			value: '',
			setter: '_setPath'
		},
		'pathNode': {
			value: null
		}
	};
	
	Input.HTML_PARSER = {
		'path': function (srcNode) {
			return srcNode.getAttribute('suPath') || '';
		}
	};
	
	Y.extend(Input, Supra.Input.String, {
		
		/**
		 * Character which is used instead of invalid characters
		 */
		MASK_REPLACEMENT_CHARACTER: '-',
		
		_setPath: function (value) {
			var node = this.get('pathNode'),
				input = this.get('inputNode'),
				replacement = this.get('replacementNode');
			
			if (!node && replacement) {
				node = replacement.one('small');
			}
			if (!node) {
				node = input.previous('small');
			}
			if (!node) {
				node = Y.Node.create('<small></small>');
				
				if (replacement) {
					replacement.prepend(node);
				} else {
					input.insert(node, 'before');
				}
			}
			
			if (node) {
				this.set('pathNode', node);
				node.set('innerHTML', Y.Escape.html(value));
				node.toggleClass('empty', !value);
			}
			
			return value;
		},
		
		_onBlur: function () {
//			var input = this.get('inputNode');
//			this.set('value', input.get('value').replace(/[^a-z0-9\-\_]/gi, ''));
			
			Input.superclass._onBlur.apply(this, arguments);
			
			var node = this.get('replacementNode');
			if (node) {
				node.set('innerHTML', '<small>' + this.get('path') + '</small>' + this.get('value'));
				this.set('pathNode', node.one('small'));
			}
		},
		
		_setValue: function (value) {
			this.get('inputNode').set('value', value);
			var node = this.get('replacementNode');
			
			if (node) {
				node.set('innerHTML', '<small>' + this.get('path') + '</small>' + Y.Escape.html(value) || '&nbsp;');
				this.set('pathNode', node.one('small'));
			}
			
			this._original_value = value;
			return value;
		},
		
		renderUI: function () {
			var r = Input.superclass.renderUI.apply(this, arguments);
			
			//Replacement text
			var replacement_node = this.get('replacementNode');
			if (replacement_node) {
				replacement_node.set('innerHTML', '<small>' + Y.Escape.html(this.get('path')) + '</small>' + Y.Escape.html(this.get('value')));
			}
			
			//Path text
			var path = this.get('path');
			if (path && !this.get('useReplacement')) {
				this._setPath(path);
			}
			
			return r;
		},
		
		/**
		 * After value source input value change update this input value
		 * Overwrite String implementation for correct path value
		 * 
		 * @param {Object} evt
		 * @private
		 */
		_afterValueSourceInputChange: function (evt) {
			var value = evt.value,
				mask  = this.get('valueMask'),
				out   = '',
				i     = 0,
				ii    = value.length,
				repl  = this.MASK_REPLACEMENT_CHARACTER;
			
			if (mask) {
				for (; i<ii; i++) {
					if (mask.test(value[i])) {
						out += value[i];
					} else {
						out += repl;
					}
				}
				
				// Remove repeated characters
				if (repl) {
					out = out.replace(new RegExp('[' + Y.Escape.regex(repl) + ']{2,}', 'ig'), repl);
					out = out.replace(new RegExp('(^' + Y.Escape.regex(repl) + '|' + Y.Escape.regex(repl) + '$)', 'ig'), '');
				}
				
				// Path is lower case
				value = out.toLowerCase();
			}
			
			this.set('value', value);
		}
		
	});
	
	Supra.Input.Path = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto', 'supra.input-string']});YUI.add("supra.input-checkbox", function (Y) {
	//Invoke strict mode
	"use strict";
	
	
	var TEMPLATE = '<div class="yui3-input-checkbox-bg" tabindex="0">\
							<span class="label-a"></span>\
							<span class="label-b"></span>\
							<span class="pin"></span>\
					  </div>';
	
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-checkbox";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.HTML_PARSER = {
		'backgroundNode': function (srcNode) {
			var node = (srcNode.test('input') ? srcNode.previous() : srcNode.one('.yui3-input-checkbox-bg'));
			return (node && node.hasClass('yui3-input-checkbox-bg') ? node : null);
		},
		'labelNodeA': function (srcNode) {
			var background_node = this.get('backgroundNode');
			return background_node ? background_node.one('.label-a') : null;
		},
		'labelNodeB': function (srcNode) {
			var background_node = this.get('backgroundNode');
			return background_node ? background_node.one('.label-b') : null;
		},
		'pinNode': function (srcNode) {
			var background_node = this.get('backgroundNode');
			return background_node ? background_node.one('.pin') : null;
		}
	};
	Input.ATTRS = {
		/**
		 * Value/option list
		 */
		'labels': {
			value: ['{#buttons.yes#}', '{#buttons.no#}'],
			setter: '_setLabels'
		},
		
		/**
		 * Background node
		 */
		'backgroundNode': {
			value: null
		},
		
		/**
		 * First label 
		 */
		'labelNodeA': {
			value: null
		},
		
		/**
		 * Second label
		 */
		'labelNodeB': {
			value: null
		},
		
		/**
		 * Pin icon node
		 */
		'pinNode': {
			value: null
		},
		
		/**
		 * Default value
		 */
		'defaultValue': {
			value: true
		}
	};
	
	Input.HTML_PARSER = {
		'labels': function (srcNode) {
			var a = srcNode.getAttribute('suLabelA'),
				b = srcNode.getAttribute('suLabelB');
			
			if (a && b) {
				return [a, b];
			} else {
				return;
			}
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			//Add missing nodes
			var node = this.get('backgroundNode');
			if (!node) {
				node = Y.Node.create(TEMPLATE);
				this.set('backgroundNode', node);
				
				var label = node.one('.label-a');
				if (label) this.set('labelNodeA', label);
				
				var label = node.one('.label-b');
				if (label) this.set('labelNodeB', label);
				
				var pin = node.one('.pin');
				if (pin) this.set('pinNode', pin);
				
				node.toggleClass('active', this.get('value'));
			}
			
			this.get('labelNodeA').on('click', this._animateValueOn, this);
			this.get('labelNodeB').on('click', this._animateValueOff, this);
			this.get('pinNode').on('click', this._animateValueToggle, this);
			
			this.set('labels', this.get('labels'));
			
			//Fix overflow
			this.get('contentBox').addClass('clearfix');
			
			//On key press change selected value
			this.get('backgroundNode').on('click', this._animateValueToggle, this);
			this.get('backgroundNode').on('keyup', this._onKeyUp, this);
			
			//Hide INPUT or SELECT element
			this.get('inputNode').insert(this.get('backgroundNode'), 'before');
			this.get('inputNode').addClass('hidden');
			
			this.on('valueChange', this._afterValueChange, this);
		},
		
		/**
		 * On label change update values
		 * 
		 * @param {Array} labels Array of labels
		 * @return New labels attribute value
		 * @private
		 */
		_setLabels: function (labels) {
			var node = null;
			
			if (labels.length == 2) {
				node = this.get('labelNodeA');
				if (node) node.set('text', Supra.Intl.replace(labels[0] || ''));
				
				node = this.get('labelNodeB');
				if (node) node.set('text', Supra.Intl.replace(labels[1] || ''));
			}
			return labels;
		},
		
		/**
		 * Used when rendering buttons
		 * 
		 * @private
		 */
		_getInternalValue: function () {
			return this.get('value') ? '1' : '0';
		},
		
		/**
		 * Value getter.
		 * Returns value as boolean
		 * 
		 * @return Value
		 * @type {Boolean}
		 */
		_getValue: function () {
			return this.get('inputNode').get('value') == '1';
		},
		
		/**
		 * Value setter.
		 * 
		 * @param {Boolean} value Value
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setValue: function (value) {
			if (typeof value === 'string') {
				value = value === 'true' || value === '1' ? true : false;
			}
			
			//Check
			this.get('inputNode').set('value', value ? '1' : '0');
			
			//Update style
			var node = this.get('backgroundNode');
			if (node) node.toggleClass('active', value);
			
			return value;
		},
		
		_animate: function (from, to) {
			if (!this.pin_anim) {
				this.pin_anim = new Y.Anim({
					'node': this.get('pinNode'),
					'duration': 0.1
				});
				this.pin_anim.on('end', function () {
					this.get('pinNode').setStyle('left', null);
				}, this);
				this.get('pinNode').setStyle('left', from + 'px');
			}
			
			this.pin_anim.stop();
			this.get('pinNode').setStyle('left', from + 'px');
			this.pin_anim.set('from', {'left': from})
						 .set('to', {'left': to})
						 .run();
		},
		_animateValueToggle: function (evt) {
			if (this.get('disabled')) return;
			
			if (this.get('value')) {
				this._animateValueOff(evt);
			} else {
				this._animateValueOn(evt);
			}
		},
		_animateValueOn: function (evt) {
			if (this.get('disabled')) return;
			
			if (!this.get('value')) {
				this._animate(28, 0);
				this.set('value', true);
			}
			if (evt && evt.type == 'click') {
				evt.halt();
			}
		},
		_animateValueOff: function (evt) {
			if (this.get('disabled')) return;
			
			if (this.get('value')) {
				this._animate(0, 28);
				this.set('value', false);
			}
			if (evt && evt.type == 'click') {
				evt.halt();
			}
		},
		
		_onKeyUp: function (event) {
			if (this.get('disabled')) return;
			
			var key = event.keyCode;
			
			if (key == 32 || key == 13) {	//Space or return key
				this._animateValueToggle();
			} else if (key == 37) {			//Left arrow
				this._animateValueOn();
			} else if (key == 39) {			//Right arrow
				this._animateValueOff();
			}
		},
		
		/**
		 * After value change trigger event
		 */
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal === true || evt.newVal == '1' ? true : false});
			}
		}
		
	});
	
	Supra.Input.Checkbox = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto", "anim"]});/**
 * Handles file upload process
 */
YUI.add('supra.io-upload-legacy', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/*
	 * http://hacks.mozilla.org/category/fileapi/:
	 * 		http://hacks.mozilla.org/2011/01/how-to-develop-a-html5-image-uploader/
	 * 		http://hacks.mozilla.org/2011/03/the-shortest-image-uploader-ever/
	 */
	
	function UploaderIO (config) {
		UploaderIO.superclass.constructor.apply(this, arguments);
		this.on('destroy', this.onBeforeDestroy, this);
	}
	
	UploaderIO.NAME = 'uploader-io';
	
	UploaderIO.ATTRS = {
		/**
		 * URI where file should be uploaded
		 * @type {String}
		 */
		'requestUri': {
			value: null
		},
		
		/**
		 * Additional data which will be added to the POST body
		 * @type {Object}
		 */
		'data': {
			value: null
		},
		
		/**
		 * Additional data which will be added to event
		 * @type {Object}
		 */
		'eventData': {
			value: null
		},
		
		/**
		 * Form element
		 * @type {Object}
		 */
		'form': {
			value: null
		},
		
		/**
		 * Iframe element
		 * @type {Object}
		 */
		'iframe': {
			value: null
		}
		
	};
	
	Y.extend(UploaderIO, Y.Base, {
		
		/**
		 * XHR object
		 * @type {Object}
		 * @private
		 */
		xhr: null,
		
		/**
		 * Start file upload
		 */
		start: function () {
			var uri = this.get('requestUri'),
				
				form = this.get('form'),
				iframe = this.get('iframe'),
				input = null,
				
				limit = 500,					//file size limit
			  
				data = {
					"MAX_FILE_SIZE": limit * 1024 * 1024
				};
			
			//Add data to the form
			data = Supra.io.serialize(Supra.mix(data, this.get('data') || {}));
			
			for(var i in data) {
				input = Y.Node.create('<input type="hidden" />');
				input.setAttribute('name', i);
				input.setAttribute('value', decodeURIComponent(data[i]));
				form.append(input);
			}
			
			//Set action
			if (!uri.match(/:\/\//)) {
				uri = document.location.protocol + '//' + document.location.hostname + uri;
			}
			
			form.setAttribute('action', uri);
			
			//Send
			try {
				form.submit();
			} catch (e) {
				//Error occured
				this.fire('load', Supra.mix({'data': null}, this.get('eventData') || {}));
				return;
			}
			
			//Listeners
			iframe.once('load', this.onLoad, this);
		},
		
		/**
		 * Abort file upload
		 */
		abort: function () {
			//Not possible
		},
		
		/**
		 * On complete
		 * 
		 * @param {Event} evt
		 * @private
		 */
		onLoad: function (evt) {
			var event_data = this.get('eventData') || {},
				response_text = this.get('iframe').getDOMNode().contentWindow.document.body.innerHTML,
				response = Supra.io.parseResponse(this.get('requestUri'), {'type': 'json'}, response_text);
			
			//Handle error message if there is one
			Supra.io.handleResponse({}, response);
			
			if (response.status && response.data) {
				this.fire('load', Supra.mix({'data': response.data}, event_data));
			} else {
				this.fire('load', Supra.mix({'data': null}, event_data));
			}
			
			//Once file is uploaded, this object becomes useless
			this.destroy();
		},
		
		/**
		 * Handle destroy event
		 * 
		 * @param {Event} evt
		 * @private
		 */
		onBeforeDestroy: function (evt) {
			//Remove all hidden fields
			var form = this.get('form');
			form.all('input[type="hidden"]').remove();
			
			//Unset attributes
			this.set('form', null);
			this.set('iframe', null);
			this.set('data', null);
			this.set('eventData', null);
		}
		
	});
	
	Supra.IOUploadLegacy = UploaderIO;
	
	//Since this Widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['base', 'json']});/**
 * Handles file upload process
 */
YUI.add('supra.io-upload', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/*
	 * http://hacks.mozilla.org/category/fileapi/:
	 * 		http://hacks.mozilla.org/2011/01/how-to-develop-a-html5-image-uploader/
	 * 		http://hacks.mozilla.org/2011/03/the-shortest-image-uploader-ever/
	 */
	
	function UploaderIO (config) {
		UploaderIO.superclass.constructor.apply(this, arguments);
		this.on('destroy', this.onBeforeDestroy, this);
	}
	
	UploaderIO.NAME = 'uploader-io';
	
	UploaderIO.ATTRS = {
		/**
		 * URI where file should be uploaded
		 * @type {String}
		 */
		'requestUri': {
			value: null
		},
		
		/**
		 * Additional data which will be added to the POST body
		 * @type {Object}
		 */
		'data': {
			value: null
		},
		
		/**
		 * Additional data which will be added to event
		 * @type {Object}
		 */
		'eventData': {
			value: null
		},
		
		/**
		 * File which should be uploaded
		 * @type {Object}
		 */
		'file': {
			value: null
		}
	};
	
	Y.extend(UploaderIO, Y.Base, {
		
		/**
		 * XHR object
		 * @type {Object}
		 * @private
		 */
		xhr: null,
		
		/**
		 * Start file upload
		 */
		start: function () {
			//Use FormData
			var fd = new FormData(),
				data = Supra.io.serialize(this.get('data') || {}),
				uri = this.get('requestUri'),
				limit = 500;	//500 MB
			
			fd.append("MAX_FILE_SIZE", limit * 1024 * 1024);
			fd.append("file", this.get('file'));
			for(var i in data) {
				fd.append(i, decodeURIComponent(data[i]));
			}
			
			var xhr = this.xhr = new XMLHttpRequest();
			
			//Progress
			if ('upload' in xhr) {
				xhr.upload.addEventListener("progress", Y.bind(this.onProgress, this), false);
			}

			//Send
			xhr.onload = Y.bind(this.onLoad, this);
			xhr.open("POST", uri);
			xhr.send(fd);
		},
		
		/**
		 * Abort file upload
		 */
		abort: function () {
			if (this.xhr) {
				this.fire('abort');
				this.fire('load', Supra.mix({'data': null}, this.get('eventData') || {}));
				this.xhr.abort();
				this.destroy();
			} else {
				this.destroy();
			}
		},
		
		/**
		 * On complete
		 * 
		 * @param {Event} evt
		 * @private
		 */
		onLoad: function (evt) {
			var event_data = this.get('eventData') || {},
				response = Supra.io.parseResponse(this.get('requestUri'), {'type': 'json'}, this.xhr.responseText);
			
			//Handle error message if there is one
			Supra.io.handleResponse({}, response);
			
			if (response.status && response.data) {
				this.fire('load', Supra.mix({'data': response.data}, event_data));
			} else {
				this.fire('load', Supra.mix({'data': null}, event_data));
			}
			
			//Once file is uploaded, this object becomes useless
			this.destroy();
		},
		
		/**
		 * On progress fire event
		 * 
		 * @param {Event} evt
		 * @private
		 */
		onProgress: function (evt) {
			if (evt.lengthComputable) {
				var percentage = Math.round((evt.loaded * 100) / evt.total),
					event_data = this.get('eventData');
				
				this.fire('progress', Supra.mix({
					'total': evt.total,
					'loaded': evt.loaded,
					'percentage': percentage
				}, event_data));
			}
		},
		
		/**
		 * Handle destroy event
		 * 
		 * @param {Event} evt
		 * @private
		 */
		onBeforeDestroy: function (evt) {
			delete(this.xhr);
		}
		
	});
	
	Supra.IOUpload = UploaderIO;
	
	//Since this Widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.io-upload-legacy']});/**
 * File uploader
 */
YUI.add('supra.uploader', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var IO = Supra.IOUpload,
		IOLegacy = Supra.IOUploadLegacy,
		MediaLibraryList = Supra.MediaLibraryList;
	
	//Feature testing
	var FILE_API_SUPPORTED = typeof FileReader !== 'undefined';
	
	//File name black list
	var FILE_BLACKLIST = ['.DS_Store'];
	
	//File ID counter
	var FILE_COUNTER = 0;
	
	/**
	 * File upload
	 * Handles standard file upload, HTML5 drag & drop, simple input fallback
	 */
	function Uploader (config) {
		Uploader.superclass.constructor.apply(this, arguments);
	}
	
	Uploader.NAME = 'uploader';
	Uploader.CLASS_NAME = 'uploader';
	
	/**
	 * Constant, all data
	 * @type {Number}
	 */
	Uploader.TYPE_ALL = 0;
	
	/**
	 * Constant, only images
	 * @type {Number}
	 */
	Uploader.TYPE_IMAGES = 2;
	
	/**
	 * Constant, only files
	 * @type {Number}
	 */
	Uploader.TYPE_FILES = 3;
	
	
	Uploader.ATTRS = {
		/**
		 * Upload request URI
		 * @type {String}
		 */
		'requestUri': {
			value: null
		},
		
		/**
		 * Additional data which will be added to the POST body
		 */
		'data': {
			value: null
		},
		
		/**
		 * File upload disabled
		 * @type {Boolean}
		 */
		'disabled': {
			value: false,
			setter: '_setDisabled'
		},
		
		/**
		 * Number of max simultenious uploads
		 * @type {Number}
		 */
		'maxSimulteniousUploads': {
			value: 1
		},
		
		/**
		 * Create input for "Browse" functionality
		 * @type {Boolean}
		 */
		'allowBrowse': {
			value: true
		},
		
		/**
		 * Allow selecting and uploading multiple files
		 * @type {Boolean}
		 */
		'allowMultiple': {
			value: true
		},
		
		/**
		 * File upload folder id
		 * @type {String}
		 */
		'uploadFolderId': {
			value: 0
		},
		
		// ----- Validation -----
		
		/**
		 * File type: all, images or files
		 * @type {Number}
		 */
		'fileType': {
			value: Uploader.TYPE_ALL
		},
		
		/**
		 * File types which are accepted, mime type
		 * @type {String}
		 */
		'accept': {
			value: null
		},
		
		/**
		 * Custom file validation
		 * @type {Function}
		 */
		'validateFile': {
			value: null
		},
		
		// ----- Elements -----
		
		/**
		 * HTML5 Drag & Drop container node
		 * @type {Object}
		 */
		'dropTarget': {
			value: null
		},
		
		/**
		 * Click target
		 * @type {Object}
		 */
		'clickTarget': {
			value: null
		},
		
		/**
		 * File input
		 * @type {Object}
		 */
		'input': {
			value: null
		},
		
		// ----- Legacy browser support -----
		
		/**
		 * Form element for adding new file
		 * Used only if File API is not supported
		 * @type {Object}
		 */
		'form': {
			value: null
		},
		
		/**
		 * Iframe element
		 * Used only if File API is not supported
		 * @type {Object}
		 */
		'iframe': {
			value: null
		},
		
		/**
		 * File input for replacing file
		 * Used only if File API is not supported
		 * @type {Object}
		 */
		'input_replace': {
			value: null
		},
		
		/**
		 * Form element for replacing file
		 * Used only if File API is not supported
		 * @type {Object}
		 */
		'form_replace': {
			value: null
		},
		
		/**
		 * Iframe element for replacing file
		 * Used only if File API is not supported
		 * @type {Object}
		 */
		'iframe_replace': {
			value: null
		}
	};
	
	Y.extend(Uploader, Y.Base, {
		
		/**
		 * Last drop target element
		 * @type {Object}
		 */
		last_drop_target: null,
		
		/**
		 * Last drop target folder ID
		 * @type {Number}
		 */
		last_drop_id: null,
		
		/**
		 * Event subscribers
		 * @type {Array}
		 */
		subscribers: [],
		
		/**
		 * Drag element is valid
		 * @type {Boolean}
		 */
		valid_drag: true,
		
		
		
		/**
		 * Initialize plugin
		 */
		initializer: function () {
			this.subscribers = [];
			
			var input = null,
				node_id = null,
				uri = null,
				form = null,
				iframe = null,
				click_target = null;
			
			if (this.get('allowBrowse')) {
				if (FILE_API_SUPPORTED) {
					this.createInput();
					
					//Handle click on target
					click_target = this.get('clickTarget');
					if (click_target) {
						click_target.on('click', function () {
							this.openBrowser();
						}, this);
					}
				} else {
					var node = this.getClickTargetNode();
					if (node) {
						this.createLegacyInput(node, false);
					}
				}
			}
			
			//Enable
			if (!this.get('disabled')) {
				this.set('disabled', false);
			}
			
			//Load MediaLibrary localizations
			var Loader = Supra.Manager.Loader,
				Intl   = Supra.Intl,
				path   = Loader.getStaticPath() + Loader.getActionBasePath('MediaLibrary');
			
			Intl.loadAppData(path);
		},
		
		/**
		 * Create input for file upload
		 * 
		 * @private
		 */
		createInput: function () {
			var container = Y.one('body'),
				accept = this.get('accept'),
				multiple = this.get('allowMultiple'),
				input = null;
			
			//Create invisible input which will be used for "Browse file" window
			input = Y.Node.create('<input class="offscreen" type="file" ' + (multiple ? 'multiple="multiple" ' : '') + (accept ? 'accept="' + accept + '" ' : '') + '/>');
			input.on('change', this.onFileBrowse, this);
			container.append(input);
			
			this.set('input', input);
		},
		
		/**
		 * Create input for legacy browsers
		 * File insert and file replace will be two different forms
		 * inserted inside "Upload" and "Replace" buttons to capture mouse click
		 * 
		 * @private
		 */
		createLegacyInput: function (container, for_replace) {
			var uri = document.location.protocol + '//' + document.location.hostname + '/cms/lib/supra/build/io/blank.html',
				node_id = Y.guid(),
				iframe,
				form,
				input;
			
			iframe = Y.Node.create('<iframe class="offscreen" id="' + node_id + '" name="' + node_id + '" src="' + uri + '" />');
			form   = Y.Node.create('<form target="' + node_id + '" class="legacy-file-upload-form" method="post" action="" enctype="multipart/form-data">' +
										'<input suIgnore="true" type="file" name="file" class="upload-file-input" />' +
										'<button suIgnore="true" type="submit">Upload</button>' +
								  '</form>');
			
			input = form.one('input');
			input.on('change', function () {
				this.onLegacyFileBrowse(for_replace);
			}, this);
			
			Y.one('body').append(iframe);
			container.append(form);
			container.addClass('legacy-file-upload-container');
			
			if (!for_replace) {
				this.set('form', form);
				this.set('iframe', iframe);
				this.set('input', input);
			} else {
				if (this.get('iframe_replace')) this.get('iframe_replace').remove();
				if (this.get('form_replace')) this.get('form_replace').remove();
				if (this.get('input_replace')) this.get('input_replace').remove();
				
				this.set('form_replace', form);
				this.set('iframe_replace', iframe);
				this.set('input_replace', input);
			}
		},
		
		/**
		 * Returns container node for drag and drop
		 * 
		 * @return Container node
		 * @type {Object}
		 */
		getDropTargetNode: function () {
			return this.get('dropTarget');
		},
		
		/**
		 * Returns container node for input nodes
		 * 
		 * @return Container node
		 * @type {Object}
		 */
		getClickTargetNode: function () {
			var target = this.get('clickTarget'),
				node = null;
			
			if (target) {
				node = target;
				if (node.isInstanceOf && node.isInstanceOf('Widget')) {
					node = node.get('boundingBox');
				}
			}
			
			return node;
		},
		
		dragEnter: function (evt) {
			evt.halt();
		},
		
		dragExit: function (evt) {
			evt.halt();
		},
		
		dragStart: function (evt) {
			//Drag start is called only for elements, not files from outside
			//the document
			this.valid_drag = false;
		},
		
		dragEnd: function (evt) {
			this.valid_drag = true;
		},
		
		dragOver: function (evt) {
			if (!this.valid_drag) return;
			
			evt.halt();
			
			var folder_node = this.getDropTargetNode(),
				folder_id = this.getUploadFolder();
			
			if (folder_id !== this.last_drop_id) {
				if (this.last_drop_target) {
					this.last_drop_target.removeClass('yui3-html5-dd-target');
				}
				if (folder_node) {
					folder_node.addClass('yui3-html5-dd-target');
				}
				
				this.last_drop_target = folder_node;
				this.last_drop_id = folder_id;
			}
			
			if (folder_id || folder_id === 0) {
				evt._event.dataTransfer.dropEffect = 'copy';
			} else {
				evt._event.dataTransfer.dropEffect = 'none';
			}
		},
		
		dragDrop: function (evt) {
			if (!this.valid_drag) return;
			
			if (evt._event.dataTransfer.files.length) {
				evt.halt();
			}
			
			if (this.last_drop_target) {
				this.last_drop_target.removeClass('yui3-html5-dd-target');
				
				var folder = this.last_drop_id;
				
				if (evt._event.dataTransfer.files.length) {
					this.getDragDropFiles(evt._event.dataTransfer, function (files) {
						//Validate files
						files = this.testFiles(files);
						
						if (files.length) {
							//Upload all files
							this.uploadFiles(folder, files);
						} else {
							//No files detected
							Supra.Manager.executeAction('Confirmation', {
							    'message': '{#medialibrary.validation_error.invalid_drop#}',
							    'useMask': true,
							    'buttons': [
							        {'id': 'delete', 'label': 'OK'}
							    ]
							});
						}
					});
				}
			}
			
			this.last_drop_target = null;
			this.last_drop_id = null;
		},
		
		/**
		 * Returns all files from drop
		 * 
		 * @param {Object} data Data transfer object
		 * @param {Function} callback 
		 * @return {Array} Files list
		 * @private
		 */
		getDragDropFiles: function (data, callback) {
			if (!data.items) {
				return callback.call(this, data.files);
			}
			
			var entry = null,
				
				items = data.items,
				item  = null,
				i     = 0,
				ii    = items.length,
				
				files  = data.files,
				output = [],
				wait   = 0,
				
				self   = this;
			
			for (; i<ii; i++) {
				item = items[i];
				
				if (item.webkitGetAsEntry) {
					entry = item.webkitGetAsEntry();
				} else if (entry = item.mozGetAsEntry) {
					entry = item.mozGetAsEntry();
				} else if (entry = item.getAsEntry) {
					entry = item.getAsEntry();
				}
				
				if (entry) {
					wait++;
					this.traverseFileTree(entry, '', function (files) {
						output = output.concat(files);
						
						if (!--wait && i == ii) {
							callback.call(self, output);
						}
					});
				} else {
					//We can't get entry for files or folders, assume it's ok
					output.push(files[i]);
				}
			}
			
			if (!wait) {
				callback.call(this, output);
			}
		},
		
		/**
		 * 
		 */
		traverseFileTree: function (item, path, callback) {
			var self = this;
			path = path || '';
			
			if (item.isFile) {
				item.file(function (file) {
					file.path = path;
					callback([file]);
				});
			} else if (item.isDirectory) {
				var dirReader = item.createReader(),
					output = [];
				
				var readEntries = function () {
					dirReader.readEntries(function(entries) {
						if (entries.length) {
							var wait = 0;
							for (var i=0, ii=entries.length; i<ii; i++) {
								wait++;
								self.traverseFileTree.call(self, entries[i], path + (path ? '/' : '') + item.name, function (files) {
									output = output.concat(files);
									if (!--wait && i == ii) {
										//Last entry, try again
										readEntries();
									}
								});
							}
							//Keep reading until there are no more files/folder
							if (!wait) readEntries();
						} else {
							//That's it
							callback(output);
						}
					});	
				};
				
				readEntries();
			} else {
				//Is this even possible?
				callback([]);
			}
		},
		
		/**
		 * Open "Browse file" window
		 * 
		 * @param {Number} file_id Optional. File ID which will be replaced
		 */
		openBrowser: function (file_id /* File ID */) {
			//Open file browse window
			var input = this.get('input');
			var node = Y.Node.getDOMNode(input);
			
			if (file_id) {
				if (FILE_API_SUPPORTED) input.removeAttribute('multiple');
				input.setData('fileId', file_id);
			} else {
				if (FILE_API_SUPPORTED && this.get('allowMultiple')) input.setAttribute('multiple', 'multiple');
				input.setData('fileId', null);
			}
			
			node.click();
		},
		
		
		/**
		 * When files are browsed start uploading them
		 * @private
		 */
		onFileBrowse: function () {
			//Get files
			var files = Y.Node.getDOMNode(this.get('input')).files;
			
			if (!FILE_API_SUPPORTED) {
				//Will use default form submit without progress support
				files = false;
			} else if  (!files.length) {
				//No files were selected
				return;
			}
			
			//Find folder
			var file_id = this.get('input').getData('fileId'),
				folder = this.getUploadFolder();
			
			if (!file_id) {
				//Upload new files
				if (FILE_API_SUPPORTED) {
					this.uploadFiles(folder, files);
				} else {
					this.uploadFilesLegacy(folder);
				}
			} else {
				//Replace file
				if (FILE_API_SUPPORTED) {
					this.replaceFile(file_id, files);
				} else {
					this.replaceFileLegacy(file_id);
				}
			}
		},
		
		/**
		 * When files are browsed start uploading them
		 * Handler for legacy browsers
		 * @private
		 */
		onLegacyFileBrowse: function (for_replace) {
			this.onFileBrowse();
		},
		
		/**
		 * Returns folder into which files should be uploaded to
		 * 
		 * @returns {String} Folder ID into which files should be uploaded to
		 * @private
		 */
		getUploadFolder: function () {
			return this.get('uploadFolderId');
		},
		
		/**
		 * Upload files
		 * 
		 * @param {Number} folder Folder ID into which file will be uploaded
		 * @param {FileList} files File list
		 * @private
		 */
		uploadFiles: function (folder /* Folder ID */, files /* File list */) {
			/*
			 * !IMPORTANT
			 * If you are updating this file, please update also medialibrary/upload.js
			 */
			if (!files || !files.length) return;
			
			//Find folder
			var folder = folder ? folder : this.get('uploadFolderId'),
				data = Supra.mix({'folder': folder}, this.get('data') || {}),
				event_data = null,
				io = null,
				uri = this.get('requestUri'),
				file_id = null,
				file = null,
				file_name = null,
				queue = [],
				
				count = 0,
				loaded = 0;
			
			for(var i=0,ii=files.length; i<ii; i++) {
				//If validation fails, then skip this one
				if (!this.testFile(files[i])) continue;
				
				file = files[i];
				file_name = file.fileName || file.name;
				
				//Create temporary item
				FILE_COUNTER++;
				file_id = -FILE_COUNTER;
				
				//Set folder path
				data = Supra.mix({}, data, {
					'folderPath': file.path || ''
				});
				
				//Event data will be passed to 'load' and 'progress' event listeners
				event_data = {
					'folder': folder,
					'file_id': file_id,
					'file_name': file_name,
					'folderPath': data.folderPath
				};
				
				io = new IO({
					'file': file,
					'requestUri': uri,
					'data': data,
					'eventData': event_data
				});
				
				//Fire event
				this.fire('file:upload', {'title': file_name, 'filename': file_name, 'id': file_id, 'folderPath': data.folderPath});
				
				//Add event listeners
				count++;
				
				io.on('progress', this.onFileProgress, this);
				io.on('load', function (evt) {
					loaded++;
					var completed = count == loaded;
					
					this.onFileComplete(evt, completed);
					this.uploadFilesNext(queue);
				}, this);
				
				//Add file to queue				
				queue.push(io);
			}
			
			for (var i=0, ii=this.get('maxSimulteniousUploads'); i<ii; i++) {
				//Start uploading
				this.uploadFilesNext(queue);
			}
		},
		
		/**
		 * Upload next file from the list
		 */
		uploadFilesNext: function (queue) {
			if (queue.length) {
				var io = queue.shift();
				io.start();
			}
		},
		
		/**
		 * Upload files using standart form submit, instead of File API
		 * 
		 * @param {Number} folder Folder ID into which file will be uploaded
		 * @private
		 */
		uploadFilesLegacy: function (folder /* Folder ID */) {
			/*
			 * !IMPORTANT
			 * If you are updating this file, please update also medialibrary/upload.js
			 */
			var file_name = this.get('input').getDOMNode().value || '';
			
			file_name = file_name.replace(/.*(\\|\/)/, '');
			
			//If only images are displayed, then only images can be uploaded. Same with files
			if (!file_name || !this.testFileTypeExtension(file_name)) return;
			
			//Find folder
			var folder = folder ? folder : this.get('uploadFolderId'),
				data = {'folder': folder},
				event_data = null,
				io = null,
				uri = this.get('requestUri'),
				file_id = null,
				file = null;
			
			//Create temporary item
			FILE_COUNTER++;
			file_id = -FILE_COUNTER;
			
			//Event data will be passed to 'load' and 'progress' event listeners
			event_data = {
				'folder': folder,
				'file_id': file_id,
				'file_name': file_name,
				'folderPath': ''
			};
			
			io = new IOLegacy({
				'form': this.get('form'),
				'iframe': this.get('iframe'),
				'requestUri': uri,
				'data': data,
				'eventData': event_data
			});
			
			//Fire event
			this.fire('file:upload', {'title': file_name, 'filename': file_name, 'id': file_id, 'folderPath': ''});
				
			//Add event listeners
			io.on('load', function (evt) {
				this.onFileComplete(evt, true);
			}, this);
			
			//Start uploading
			io.start();
		},
		
		/**
		 * Replace file
		 * 
		 * @param {Number} file_id File ID which will be replaced
		 * @param {FileList} files File list
		 * @private
		 */
		replaceFile: function (file_id /* File ID */, files /* File list */) {
			if (!files || !files.length) return false;
			
			//Find folder
			var data = this.getReplaceFileData(file_id),
				event_data = null,
				io = null,
				uri = this.get('requestUri');
			
			for(var i=0,ii=files.length; i<ii; i++) {
				//If only images are displayed, then only images can be uploaded. Same with files
				if (!this.testFileType(files[i])) continue;
				
				//If only specific types are allowed, then file must match one of them
				if (!this.testFileAccept(files[i])) continue;
				
				//Event data will be passed to 'load' and 'progress' event listeners
				event_data = {
					'file_id': file_id
				};
				
				io = new IO({
					'file': files[i],
					'requestUri': uri,
					'data': data,
					'eventData': event_data
				});
				
				//Fire event
				this.fire('file:replace', event_data);
				
				//Add event listeners
				io.on('load', this.onFileComplete, this);
				io.on('progress', this.onFileProgress, this);
				
				//Start uploading
				io.start();
			}
		},
		
		/**
		 * Replace file using standart form submit, instead of File API
		 * 
		 * @param {Number} file_id File ID which will be replaced
		 * @private
		 */
		replaceFileLegacy: function (file_id /* File ID */) {
			var file_name = this.get('input_replace').getDOMNode().value || '';
			file_name = file_name.replace(/.*(\\|\/)/, '');
			
			//If only images are displayed, then only images can be uploaded. Same with files
			if (!file_name || !this.testFileTypeExtension(file_name)) return false;
			
			//Find folder
			var data = this.getReplaceFileData(file_id),
				event_data = null,
				io = null,
				uri = this.get('requestUri');
			
			//Event data will be passed to 'load' and 'progress' event listeners
			event_data = {
				'file_id': file_id
			};
			
			io = new IOLegacy({
				'form': this.get('form_replace'),
				'iframe': this.get('iframe_replace'),
				'requestUri': uri,
				'data': data,
				'eventData': event_data
			});
			
			//Fire event
			this.fire('file:replace', event_data);
			
			//Add event listeners
			io.on('load', this.onFileComplete, this);
			
			//Start uploading
			io.start();
		},
		
		/**
		 * Returns data for file replace
		 * 
		 * @param {String} file_id File ID
		 * @returns {Object} Upload data
		 * @private
		 */
		getReplaceFileData: function (file_id) {
			return Supra.mix({'file_id': file_id}, this.get('data'));
		},
		
		/**
		 * On file upload progress update progress bar
		 * 
		 * @param {Event} evt
		 * @private
		 */
		onFileProgress: function (evt) {
			if (evt.file_id) {
				this.fire('file:progress', {'id': evt.file_id, 'percentage': evt.percentage});
			}
		},
		
		/**
		 * On file upload complete change temporary item into real item
		 * This is called also if file upload failed
		 * 
		 * @param {Event} evt
		 * @param {Boolean} all_files_completed All file has been uploaded
		 * @private
		 */
		onFileComplete: function (evt, all_files_completed) {
			var data = evt.data,
				file_id = evt.file_id,
				folder = evt.folder;
			
			if (data) {
				this.fire('file:complete', Supra.mix({
					old_id: file_id
				}, data));
			} else {
				this.fire('file:error', {
					id: file_id
				});
				Y.log('Failed to upload "' + evt.file_name + '"', 'debug');
			}
		},
		
		/**
		 * Checks if file type is allowed to be uploaded for set fileType
		 * Testing is based on file mime type (extension)
		 * 
		 * @param {File} file
		 * @return True if file type is allowed, otherwise false
		 * @type {Boolean}
		 * @private
		 */
		testFileType: function (file) {
			switch(this.get('fileType')) {
				case Uploader.TYPE_IMAGES:
					var file_name = file.fileName || file.name;
					
					//SWF is data and image
					if (file_name.match(/\.swf$/)) return true;
					return !!file.type.match(/^image\//);
				case Uploader.TYPE_FILES:
					return !!(!file.type.match(/^image\//));
				default:
					return true;
			}
		},
		
		/**
		 * Checks if file type is allowed to be uploaded for set fileType
		 * Testing is based on file extension, because older browsers doesn't support
		 * file type
		 * 
		 * @param {File} file
		 * @return True if file type is allowed, otherwise false
		 * @type {Boolean}
		 * @private
		 */
		testFileTypeExtension: function (file_name) {
			switch(this.get('fileType')) {
				case Uploader.TYPE_ALL:
					return true;
				case Uploader.TYPE_IMAGES:
					return !!file_name.match(/\.(swf|jpeg|jpg|gif|png|bmp|tiff|iff)$/);
				case Uploader.TYPE_FILES:
					return !file_name.match(/\.(jpeg|jpg|gif|png|bmp|tiff|iff)$/);
				default:
					return true;
			}
		},
		
		/**
		 * Checks if file type is allowed to be uploaded for set 'accept'
		 * 
		 * @param {File} file
		 * @return True if file type is allowed, otherwise false
		 * @type {Boolean}
		 * @private
		 */
		testFileAccept: function (file) {
			var accept = this.get('accept'),
				reg = null;
			
			if (accept) {
				accept = accept.split(',');
				
				for(var i=0,ii=accept.length; i<ii; i++) {
					 reg = accept[i].replace(/\*/g, '.*');
					 reg = new RegExp('^' + Y.Lang.trim(reg) + '$', 'i');
					 
					 if (!file.type.match(reg)) {
					 	return false;
					 }
				}
			}
			
			return true;
		},
		
		/**
		 * Test for valid file name
		 * 
		 * @param {String} file_name File name
		 * @return {Boolean} True if file name is valid, otherwise false
		 * @private
		 */
		testValidFileName: function (file_name) {
			return Y.Array.indexOf(FILE_BLACKLIST, file_name) === -1;
		},
		
		/**
		 * Test file
		 * 
		 * @param {File} file
		 * @return {Boolean} True if file type is allowed, otherwise false
		 * @private
		 */
		testFile: function (file) {
			if (!file) {
				this.fire('file:validationerror');
				return false;
			} else if (!file.size) {
				//Folders doesn't have size in FF
				this.fire('file:validationerror');
				return false;
			} else if (!this.testFileType(file)) {
				//If only images are displayed, then only images can be uploaded. Same with files
				this.fire('file:validationerror');
				return false;
			} else if (!this.testFileAccept(file)) {
				//If only specific types are allowed, then file must match one of the types
				this.fire('file:validationerror');
				return false;
			} else if (!this.testValidFileName(file.fileName || file.name)) {
				//Probablly system file
				this.fire('file:validationerror');
				return false;
			} else {
				var fn = this.get('validateFile');
				if (fn && !fn(file, this)) {
					this.fire('file:validationerror');
					return false;
				}
				
				return true;
			}
		},
		
		/**
		 * Tests all files and returns only those which pass validation
		 * 
		 * @param {Array} files File list
		 * @return {Array} File list with only those files which pass validation
		 * @private
		 */
		testFiles: function (files) {
			var i = 0,
				ii = files.length,
				output = [];
			
			for (; i<ii; i++) {
				if (this.testFile(files[i])) {
					output.push(files[i]);
				}
			}
			
			return output;
		},
		
		/**
		 * Disabled attribute setter
		 */
		_setDisabled: function (disabled) {
			//Enable HTML5 drag & drop
			var node = this.getDropTargetNode();
			if (!node) return !!disabled;
			
			//Remove listeners
			for(var i=0,ii=this.subscribers.length; i<ii; i++) {
				this.subscribers[i].detach();
			}
			this.subscribers = [];
			
			//Add listeners
			if (!disabled) {
				if (FILE_API_SUPPORTED) {
					this.subscribers.push(node.on('dragstart', this.dragStart, this));
					this.subscribers.push(node.on('dragend',   this.dragEnd, this));
					this.subscribers.push(node.on('dragenter', this.dragEnter, this));
					this.subscribers.push(node.on('dragexit', this.dragExit, this));
					this.subscribers.push(node.on('dragover', this.dragOver, this));
					this.subscribers.push(node.on('drop', this.dragDrop, this));
				}
			}
			
			return !!disabled;
		}
		
	});
	
	
	Supra.Uploader = Uploader;
	
	//Since this Widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.io-upload', 'base']});YUI.add('supra.tooltip', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Panel class
	 * 
	 * @extends Supra.Panel
	 * @param {Object} config Attribute values
	 */
	function Tooltip (config) {
		Tooltip.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Tooltip.NAME = 'tooltip';
	Tooltip.CSS_PREFIX = 'su-' + Tooltip.NAME;
	Tooltip.CLASS_NAME = Y.ClassNameManager.getClassName(Tooltip.NAME);
	
	/*
	 * Tooltip attributes, default attribute values
	 */
	Tooltip.ATTRS = {
		/**
		 * Arrow visibility
		 */
		arrowVisible: {
			value: true,
			setter: '_setArrowVisible'
		},
		
		/**
		 * Text message
		 */
		textMessage: {
			value: null,
			setter: '_setTextMessage'
		},
		
		/**
		 * HTML message
		 */
		htmlMessage: {
			value: null,
			setter: '_setHTMLMessage'
		}
	};
	
	Y.extend(Tooltip, Supra.Panel, {
		
		/**
		 * Message node
		 */
		node_message: null,
		
		/**
		 * Escape and set tooltip message
		 * 
		 * @param {String} Tooltip mesasge
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setTextMessage: function (message) {
			if (message !== null && message !== undefined) {
				this.set('htmlMessage', Y.Escape.html(message || ''));
			}
			return message;
		},
		
		/**
		 * Set tooltip message
		 * 
		 * @param {String} Tooltip mesasge
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setHTMLMessage: function (message) {
			if (message) {
				var node = this.node_message;
				if (!node) {
					node = this.node_message = Y.Node.create('<p></p>');
					this.get('boundingBox').append(node);
				} else {
					node.removeClass('hidden');
				}
				node.set('innerHTML', message);
			} else {
				var node = this.get('boundingBox').one('P');
				if (this.node_message) {
					this.node_message.addClass('hidden');
				}
			}
			return message;
		},
		
		renderUI: function () {
			Tooltip.superclass.renderUI.apply(this, arguments);
			
			if (this.get('alignPosition')) {
				this._setAlignPosition(this.get('alignPosition'));
			}
			
			if (this.get('textMessage')) {
				this._setTextMessage(this.get('textMessage'));
			}
			
			if (this.get('htmlMessage')) {
				this._setHTMLMessage(this.get('htmlMessage'));
			}
		}
	});
	
	Supra.Tooltip = Tooltip;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.panel']});YUI.add("supra.input-file-upload", function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Fileupload (config) {
		Fileupload.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Fileupload.IS_INLINE = false;
	
	// Input is inside form
	Fileupload.IS_CONTAINED = true;
	
	Fileupload.NAME = "input-file-upload";
	Fileupload.CLASS_NAME = Y.ClassNameManager.getClassName(Fileupload.NAME);
	Fileupload.ATTRS = {
		
		/**
		 * File upload request URI
		 * @type {String}
		 */
		'requestUri': {
			value: null
		},
		
		/**
		 * Allow selecting multiple files
		 * @type {Boolean}
		 */
		'multiple': {
			value: false
		},
		
		/**
		 * Comma separated mime types which are allowed, eq. "image/*"
		 * @type {String}
		 */
		'accept': {
			value: false
		},
		
		/**
		 * File validation function
		 * @type {Function}
		 */
		'validateFile': {
			value: null
		},
		
		/**
		 * Additional data which will be added to the POST body
		 * @type {Object}
		 */
		'data': {
			value: null
		},
		
		/**
		 * Button node
		 * @type {Object}
		 */
		'buttonNode': {
			value: null
		},
		
		/**
		 * Button label
		 * @type {String}
		 */
		'buttonLabel': {
			value: null
		},
		
		/**
		 * Text node
		 */
		'textNode': {
			value: null
		},
		
		/**
		 * Text for drag and drop
		 */
		'textDragDrop': {
			value: 'or drag and drop file here'
		},
		
		/**
		 * Text for file count
		 */
		'textUploaded': {
			value: '<a>{count} file(s)</a> uploaded'
		}
	};
	
	Fileupload.HTML_PARSER = {
		'multiple': function (srcNode) {
			var input = this.get('inputNode'),
				multiple = input.getAttribute('multiple');
				
			if (multiple == 'false' || multiple == '0') {
				multiple = false;
			} else {
				multiple = true;
			}
			
			return multiple;
		},
		
		/**
		 * Check for accept attribute
		 * 
		 * @param {Object} srcNode Source node
		 * @return New value
		 * @private
		 */
		'accept': function (srcNode) {
			var input = this.get('inputNode'),
				accept = input.getAttribute('accept');
			
			return accept;
		},
		
		/**
		 * Upload request parameters
		 * 
		 * @param {Object} srcNode Source node
		 * @return New data
		 * @private
		 */
		'data': function (srcNode) {
			var input = this.get('inputNode'),
				data = input.getAttribute('suData');
				
			if (data) {
				return Y.QueryString.parse(data);
			} else {
				return data;
			}
		},
		
		/**
		 * File upload request URI
		 * 
		 * @param {Object} srcNode Source node
		 * @return New request uri
		 * @private
		 */
		'requestUri': function (srcNode) {
			var input = this.get('inputNode'),
				uri = this.get('requestUri'),
				attr = null;
			
			if (input && (attr = input.getAttribute('suRequestUri'))) {
				return attr;
			} else {
				return uri;
			}
		},
		
		/**
		 * Button label
		 * 
		 * @param {Object} srcNode Source node
		 * @return New button label
		 * @private
		 */
		'buttonLabel': function (srcNode) {
			var input = this.get('inputNode'),
				label = this.get('buttonLabel');
			
			if (!label && input) {
				label = input.getAttribute('value');
			}
			
			return label;
		},
		
		/**
		 * Get or create button node
		 * 
		 * @param {Object} srcNode Source node
		 * @return New button node
		 * @private
		 */
		'buttonNode': function (srcNode) {
			var input = this.get('inputNode'),
				button = input.next(),
				selector = 'button,input[type="button"],input[type="submit"]',
				label = null;
			
			if (button && button.test(selector)) {
				//Set label
				if (label = this.get('buttonLabel')) {
					button.set(button.test('button') ? 'text' : 'value', label);
				}
				
				return button;	
			} else {
				//Create button
				label = this.get('buttonLabel') || this.get('inputNode').getAttribute('value');
				button = Y.Node.create('<button type="button"></button>');
				button.set('text', label);
				input.insert(button, 'after');
				
				return button;
			}
			
			return null;
		},
		
		/**
		 * Get or create text node
		 * 
		 * @param {Object} srcNode Source node
		 * @return New text node
		 * @private
		 */
		'textNode': function (srcNode) {
			var input = this.get('inputNode'),
				node = input.next(),
				selector = 'em,b,i,strong,p,div',
				label = null;
			
			if (!node.test(selector)) {
				node = node.next();
				
				if (!node.test(selector)) {
					//Create node
					label = this.get('textDragDrop') || '';
					node = Y.Node.create('<em class="yui3-input-file-upload-text"></em>');
					node.insert(input.next(), 'after');
				}
			}
			
			if (label = this.get('textDragDrop')) {
				node.set('text', label);
			}
			
			if (node) {
				node.addClass(Y.ClassNameManager.getClassName(Fileupload.NAME, 'text'));
			}
			
			return node;
		}
	};
	
	Y.extend(Fileupload, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<input type="file" value="' + Supra.Intl.get(['buttons', 'browse']) + '" />',
		LABEL_TEMPLATE: '<label></label>',
		
		/**
		 * Browse button
		 * @type {Object}
		 * @private
		 */
		button: null,
		
		/**
		 * Text node
		 * @type {Object}
		 * @private
		 */
		text: null,
		
		/**
		 * Uploader widget
		 * @type {Object}
		 * @private
		 */
		uploader: null,
		
		/**
		 * File count
		 * @type {Number}
		 * @private
		 */
		uploading_count: 0,
		
		/**
		 * File titles
		 * @type {Array}
		 * @private
		 */
		titles: [],
		
		/**
		 * Tooltip
		 * @see Supra.Tooltip
		 * @type {Object}
		 * @private
		 */
		tooltip: null,
		
		/**
		 * Attach even listeners
		 */
		bindUI: function () {
			Fileupload.superclass.bindUI.apply(this, arguments);
			
			this.uploader.on('file:upload', this.onFileUpload, this);
			this.uploader.on('file:abort', this.onFileAbort, this);
			this.uploader.on('file:complete', this.onFileUploadComplete, this);
			
			var text = this.get('textNode');
			if (text) {
				text.delegate('mouseenter', this.showTooltip, 'a', this);
				text.delegate('mouseleave', this.hideTooltip, 'a', this);
			}
		},
		
		/**
		 * Create required nodes
		 */
		renderUI: function () {
			Fileupload.superclass.renderUI.apply(this, arguments);
			
			var button = this.get('buttonNode'),
				input = this.get('inputNode');
			
			//Move button node
			if (button) {
				input.insert(button, 'after');
			}
			
			//Move text node
			var text = this.get('textNode');
			if (text) {
				this.text = text;
				(button || input).insert(text, 'after');
			}
			
			//Create Browse button
			if (button) {
				this.button = new Supra.Button({
					'srcNode': button
				});
				this.button.render();
			}
			
			//Hide input, because button and text node is used instead
			var input = this.get('inputNode');
			input.hide();
			
			//Uploader
			this.uploader = new Supra.Uploader({
				'requestUri': this.get('requestUri'),
				'allowMultiple': this.get('multiple'),
				'data': this.get('data'),
				'validateFile': this.get('validateFile'),
				'clickTarget': this.get('buttonNode'),
				'dropTarget': this.get('boundingBox')
			});
		},
		
		/**
		 * Value setter
		 * Takes value and tries to convert it into array
		 * 
		 * @param {Array} value
		 * @return Value as array
		 * @type {Array}
		 */
		_setValue: function (value) {
			//Convert value into array
			if (typeof value == 'number') {
				value = [value];
			} else if (typeof value == 'string') {
				if (value) {
					//If value is a string "12,57" split into ["12","57"]
					value = value.split(',');
				} else {
					value = [];
				}
			} else if (!Supra.Y.Lang.isArray(value)) {
				value = [];
			}
			
			if (!value.length) {
				var text = this.get('textNode');
				if (text) {
					text.set('text', this.get('textDragDrop') || '');
				}
			}
			
			this._original_value = value;
			return value;
		},
		
		/**
		 * Value getter
		 * 
		 * @param {Array} value
		 * @return Value
		 * @type {Array}
		 */
		_getValue: function (value) {
			if (Supra.Y.Lang.isArray(value)) {
				return value;
			} else {
				return [];
			}
		},
		
		/**
		 * On file upload start
		 * 
		 * @param {Event} event Event
		 * @private
		 */
		onFileUpload: function (event) {
			var multiple = this.get('multiple');
			if (!multiple) {
				if (this.button) this.button.set('disabled', true);
				if (this.text) this.text.addClass('hidden');
			}
			
			this.uploading_count++;
			this.get('boundingBox').addClass(Y.ClassNameManager.getClassName(Fileupload.NAME, 'uploading'));
		},
		
		/**
		 * On file abort
		 * 
		 * @param {Event} event Event
		 * @private
		 */
		onFileAbort: function (event) {
			//Updates UI
			this.uploading_count--;
			if (!this.uploading_count) {
				if (this.button) this.button.set('disabled', false);
				if (this.text) this.text.removeClass('hidden');
				this.get('boundingBox').removeClass(Y.ClassNameManager.getClassName(Fileupload.NAME, 'uploading'));
			}
		},
		
		/**
		 * On file upload complete update value
		 * 
		 * @param {Event} event Event
		 * @private
		 */
		onFileUploadComplete: function (event) {
			var data = event.details[0];
			if (data) {
				//Update value
				var value = this.get('value'),
					multiple = this.get('multiple');
				
				if (multiple) {
					value.push(data.id);
					this.titles.push(data.title);
				} else {
					value = [data.id];
					this.titles = [data.title];
				}
				
				this.set('value', value);
				
				var text = this.get('textNode');
				if (text) {
					var lbl = Y.substitute(this.get('textUploaded') || '', {
						'count': this.titles.length
					});
					text.set('innerHTML', lbl);
				}
			}
			
			//Updates UI
			this.uploading_count--;
			if (!this.uploading_count) {
				if (this.button) this.button.set('disabled', false);
				if (this.text) this.text.removeClass('hidden');
				this.get('boundingBox').removeClass(Y.ClassNameManager.getClassName(Fileupload.NAME, 'uploading'));
			}
		},
		
		showTooltip: function () {
			var text = this.get('textNode');
			
			if (!this.tooltip && text) {
				this.tooltip = new Supra.Tooltip({
					'alignTarget': text.one('a'),
					'alignPosition': 'T',
					'zIndex': 10
				});
				this.tooltip.render();
				this.tooltip.get('contentBox').append('<p></p>');
			}
			
			if (this.tooltip) {
				var p = this.tooltip.get('contentBox').one('p'),
					titles = this.titles,
					titles_escaped = [];
				
				for(var i=0,ii=titles.length; i<ii; i++) titles_escaped.push(Y.Escape.html(titles[i]));
				p.set('innerHTML', titles_escaped.join('<br />'));
				
				this.tooltip.set('alignTarget', text.one('a'));
				this.tooltip.set('alignPosition', 'T');
				this.tooltip.show();
				this.tooltip.syncUI();
			}
		},
		
		hideTooltip: function () {
			if (this.tooltip) {
				this.tooltip.hide();
			}
		},
		
		/**
		 * Returns value as a string
		 * 
		 * @return Value
		 * @type {String}
		 */
		toString: function () {
			return this.value.join(',');
		}
	});
	
	Supra.Input.FileUpload = Fileupload;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto", "supra.uploader", "supra.tooltip"]});YUI.add('supra.scrollable', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var SCROLL_DISTANCE = 35;
	
	
	
	function Scrollable (config) {
		Scrollable.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Scrollable.NAME = 'scrollable';
	Scrollable.CSS_PREFIX = 'su-' + Scrollable.NAME;
	
	Scrollable.ATTRS = {
		'scrollbarNode': {
			value: null
		},
		'draggableNode': {
			value: null
		},
		
		/**
		 * Disabled state
		 */
		'disabled': {
			'value': false
		},
		
		/**
		 * Use throttle
		 */
		'throttle': {
			'value': 100
		},
		
		/**
		 * Scroll axis
		 */
		'axis': {
			'value': 'y'
		},
		
		/**
		 * Minimal size of the handle
		 */
		'minHandleSize': {
			'value': 50
		}
	};
	
	Y.extend(Scrollable, Y.Widget, {
		
		/**
		 * Content height
		 * @type {Number}
		 * @private
		 */
		contentSize: 0,
		
		/**
		 * Visible area height
		 * @type {Number}
		 * @private
		 */
		viewSize: 0,
		
		/**
		 * Pixel ration between scrollbar and view
		 * pixels
		 * @type {Number}
		 * @private
		 */
		pxRatio: 0,
		
		/**
		 * User is dragging scrollbar
		 * @type {Boolean}
		 * @private
		 */
		dragging: false,
		
		/**
		 * Scrollbar area width or height
		 * @type {Number}
		 * @private
		 */
		scrollbarAreaSize: 0,
		
		/**
		 * Animation object for content
		 * @type {Object}
		 * @private
		 */
		animContent: null,
		
		/**
		 * Animation object for scrollbar
		 * @type {Object}
		 * @private
		 */
		animScrollBar: null,
		
		/**
		 * Resize event listener
		 * @type {Object}
		 * @private
		 */
		resizeListener: null,
		
		
		
		/**
		 * Render UI
		 * 
		 * @private
		 */
		renderUI: function () {
			Scrollable.superclass.renderUI.apply(this, arguments);
			
			var boundingBox = this.get('boundingBox'),
				draggableNode = null,
				scrollbarNode = Y.Node.create('\
									<div class="' + this.getClassName('scrollbar') + ' ' + this.getClassName('invisible') + '">\
										<div class="' + this.getClassName('scrollbar', 'background') + '">\
											<div class="' + this.getClassName('draggable') + '"></div>\
										</div>\
									</div>');
			
			boundingBox.addClass(this.getClassName(this.get('axis')));
			
			draggableNode = scrollbarNode.one('div div');
			boundingBox.append(scrollbarNode);
			
			this.set('scrollbarNode', scrollbarNode);
			this.set('draggableNode', draggableNode);
		},
		
		/**
		 * Bind event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			Scrollable.superclass.bindUI.apply(this, arguments);
			
			this.bindUIResize();
			
			//Scroll
			var throttle = this.get('throttle');
			if (throttle) {
				this.syncUIPositionThrottled = Supra.throttle(this.syncUIPosition, this.get('throttle'), this);
			} else {
				this.syncUIPositionThrottled = Y.bind(this.syncUIPosition, this);
			}
			
			//Mouse wheel
			var node = this.get('contentBox');
			node.on('mousewheel', Y.bind(this.onMouseWheel, this));
			node.on('scroll', this.syncUIPositionThrottled);
			
			//Drag and drop
			node = this.get('draggableNode');
			node.on('mousedown', this.onDragStart, this);
			
			//Disabled state
			this.after('disabledChange', this.onDisabledChange, this);
			
			this.after('renderedChange', this.syncUI, this);
		},
		
		/**
		 * Rind resize event listeners
		 * 
		 * @private
		 */
		bindUIResize: function () {
			//On resize update scrollbars
			var throttle = this.get('throttle');
			if (throttle) {
				this.syncUIThrottled = Supra.throttle(this.syncUI, this.get('throttle'), this);
			} else {
				this.syncUIThrottled = Y.bind(this.syncUI, this);
			}
			
			var node = this.get('contentBox');
			node.on('contentResize', this.syncUIThrottled);
			node.get('parentNode').on('contentResize', this.syncUIThrottled);
			
			node = node.closest('.left-container, .right-container');
			if (node) {
				node.on('contentResize', this.syncUIThrottled);
			}
			
			this.resizeListener = Y.on('resize', this.syncUIThrottled);
		},
		
		/**
		 * Handle mouse wheel scrolling
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		onMouseWheel: function (e) {
			if (this.get('disabled')) return;
			
			//Check if mouse was scrolled inside container
			var node = e.target.closest('.su-scrollable-content');
			if (node !== this.get('contentBox')) {
				return;
			}
			
			//Update scroll position
			var node = this.get('contentBox'),
				scroll_distance = Math.min(this.viewSize, Math.abs(e.wheelDelta * SCROLL_DISTANCE));
			
			if (e.wheelDelta < 0) scroll_distance = -scroll_distance;
			if (scroll_distance) {
				
				node.set('scrollTop', node.get('scrollTop') - scroll_distance);
				
			}
		},
		
		/**
		 * Drag start
		 */
		onDragStart: function (e) {
			if (this.get('disabled')) return;
			
			this.get('draggableNode').addClass(this.getClassName('draggable-drag'));
			
			this.dragging = true;
			
			if (this.get('axis') == 'y') {
				this.dragStartPos = e.clientY;
				this.draggableStartPos = parseInt(this.get('draggableNode').getStyle('top'), 10);
				this.scrollStartPos = this.get('contentBox').get('scrollTop');
			} else {
				this.dragStartPos = e.clientX;
				this.draggableStartPos = parseInt(this.get('draggableNode').getStyle('left'), 10);
				this.scrollStartPos = -parseInt(this.get('contentBox').getStyle('marginLeft'), 10);
			}
			
			
			var doc = Y.Node(document);
			this.dragMoveEvent = doc.on('mousemove', this.onDrag, this);
			this.dragEndEvent = doc.on('mouseup', this.onDragEnd, this);
			
			e.halt();
		},
		
		/**
		 * On drag end remove listeners, etc.
		 */
		onDragEnd: function (e) {
			if (this.dragging) {
				this.dragging = false;
				
				this.dragMoveEvent.detach();
				this.dragMoveEvent = null;
				this.dragEndEvent.detach();
				this.dragEndEvent = null;
				
				this.get('draggableNode').removeClass(this.getClassName('draggable-drag'));
				
				this.fire('sync');
			}
		},
		
		onDrag: function (e) {
			if (!this.dragging) return;
			
			var axis = this.get('axis'),
				mousePos = (axis == 'y' ? e.clientY : e.clientX),
				maxDragPos = this.scrollbarAreaSize - this.scrollbarSize,
				diff = Math.min(mousePos - this.dragStartPos, maxDragPos - this.draggableStartPos),
				scroll = Math.max(0, ~~(this.scrollStartPos + diff * this.pxRatio)),
				pos = ~~Math.min(Math.max(0, this.draggableStartPos + diff), maxDragPos);
			
			if (axis == 'y') {
				this.get('contentBox').set('scrollTop', scroll);
				this.get('draggableNode').setStyle('top', pos);
			} else {
				this.get('contentBox').setStyle('marginLeft', -scroll);
				this.get('draggableNode').setStyle('left', pos);
			}
			
			this.fire('drag');
		},
		
		/**
		 * Update UI
		 */
		syncUI: function () {
			if (this.dragging || this.get('disabled') || !this.get('rendered')) return;
			
			var axis = this.get('axis'),
				axisSizeProperty = (axis == 'y' ? 'Height' : 'Width'),
				
				contentBox = this.get('contentBox'),
				draggableNode = this.get('draggableNode'),
				scrollbarNode = this.get('scrollbarNode'),
				backgroundNode = draggableNode.ancestor(),
				viewSize = contentBox.get('offset' + axisSizeProperty),
				scrollSize = contentBox.get('scroll' + axisSizeProperty) || viewSize,
				classInvisible = this.getClassName('invisible'),
				
				padding = null;
			
			if (!viewSize) return;
			
			//Gecho doesn't returns correct scrollWidth value
			if (axis == 'x' && Y.UA.gecko) {
				scrollSize = viewSize;
				
				contentBox.get('children').each(function (item) {
					scrollSize = Math.max(scrollSize, item.get('offsetLeft') + item.get('offsetWidth'));
				});
			}
			
			if (viewSize == scrollSize) {
				if (!scrollbarNode.hasClass(classInvisible)) {
					scrollbarNode.addClass(classInvisible);
				}
			} else {
				if (scrollbarNode.hasClass(classInvisible)) {
					scrollbarNode.removeClass(classInvisible);
				}
			}
			
			if (axis == 'y') {
				padding = parseInt(backgroundNode.getStyle('top'), 10) + parseInt(backgroundNode.getStyle('bottom'), 10) || 0;
			} else {
				padding = parseInt(backgroundNode.getStyle('left'), 10) + parseInt(backgroundNode.getStyle('right'), 10) || 0;
			}
			
			var scrollbarAreaSize = viewSize - padding,
				scrollPos = null,
				scrollbarSize = Math.max(this.get('minHandleSize'), ~~(viewSize / scrollSize * scrollbarAreaSize)),
				pxRatio = (scrollSize - viewSize) / (scrollbarAreaSize - scrollbarSize);
			
			if (axis == 'y') {
				scrollPos = contentBox.get('scrollTop');
			} else {
				scrollPos = - parseInt(contentBox.getStyle('marginLeft'), 10);
			}
			
			this.pxRatio = pxRatio;
			this.scrollbarAreaSize = scrollbarAreaSize;
			this.scrollbarSize = scrollbarSize;
			this.contentSize = scrollSize;
			this.viewSize = viewSize;
			
			if (axis == 'y') {
				draggableNode.setStyles({
					'height': scrollbarSize,
					'top': ~~(scrollPos / pxRatio)
				});
			} else {
				//Make sure all content is in view
				if (viewSize + scrollPos > scrollSize) {
					scrollPos = Math.max(0, scrollSize - viewSize);
					contentBox.setStyle('marginLeft', - scrollPos + 'px');
				}
				
				draggableNode.setStyles({
					'width': scrollbarSize,
					'left': ~~(scrollPos / pxRatio)
				});
			}
			
			this.fire('sync');
		},
		
		/**
		 * Sync scrollbar position
		 * 
		 * @private
		 */
		syncUIPosition: function () {
			if (this.get('disabled') || this.dragging) return;
			
			var axis = this.get('axis'),
				
				contentBox = this.get('contentBox'),
				draggableNode = this.get('draggableNode'),
				scrollPos = 0;
			
			if (axis == 'y') {
				scrollPos = contentBox.get('scrollTop');
				draggableNode.setStyle('top', ~~(scrollPos / this.pxRatio));
			} else {
				scrollPos = -parseInt(contentBox.get('margin-left'), 10);
				draggableNode.setStyle('left', ~~(scrollPos / this.pxRatio));
			}
			
			this.fire('sync');
		},
		
		/**
		 * Check if node is in view
		 * 
		 * @param {Object} node Node
		 * @return True if node is fully visible, otherwise false
		 * @type {Boolean}
		 */
		isInView: function (node) {
			var axis = this.get('axis'),
				axisSizeProperty = (axis == 'y' ? 'Height' : 'Width'),
				axisPosProperty  = (axis == 'y' ? 'Top' : 'Left'),
				
				contentBox = this.get('contentBox'),
				scrollPos = contentBox.get('scroll' + axisPosProperty),
				viewSize = this.viewSize,
				
				size = node.get('offset' + axisSizeProperty),
				pos = node.get('offset' + axisPosProperty);
			
			if (axis == 'y') {
				scrollPos = contentBox.get('scrollTop');
			} else {
				scrollPos = -parseInt(contentBox.get('margin-left'), 10);
			}
			
			if (pos >= scrollPos && (pos + size) < scrollPos + viewSize) {
				return true;
			} else {
				return false;
			}
		},
		
		/**
		 * Returns current scroll position
		 * 
		 * @return Scroll position
		 * @type {Number}
		 */
		getScrollPosition: function () {
			var axis = this.get('axis'),
				axisPosProperty  = (axis == 'y' ? 'Top' : 'Left'),
				
				contentBox = this.get('contentBox'),
				scrollPos = null;
			
			if (axis == 'y') {
				scrollPos = contentBox.get('scrollTop');
			} else {
				scrollPos = -parseInt(contentBox.getStyle('marginLeft'), 10) || 0;
			}
			
			return scrollPos;
		},
		
		/**
		 * Returns max scroll position
		 * 
		 * @return Max scroll position
		 * @type {Number}
		 */
		getMaxScrollPosition: function () {
			return Math.max(0, this.contentSize - this.viewSize);
		},
		
		/**
		 * Returns content size
		 * For horizontal scroller returns width, for vertical returns height
		 * 
		 * @return Content size
		 * @type {Number}
		 */
		getContentSize: function () {
			return this.contentSize;
		},
		
		/**
		 * Returns visible area size
		 * For horizontal scroller returns width, for vertical returns height
		 * 
		 * @return View size
		 * @type {Number}
		 */
		getViewSize: function () {
			return this.viewSize;
		},
		
		/**
		 * Scroll node in view
		 * 
		 * @param {Object} node Node
		 * @return True if scrolled to the node, false if node was already in view
		 * @type {Boolean}
		 */
		scrollInView: function (node) {
			if (this.get('disabled')) return;
			
			var axis = this.get('axis'),
				axisSizeProperty = (axis == 'y' ? 'Height' : 'Width'),
				axisPosProperty  = (axis == 'y' ? 'Top' : 'Left'),
				
				contentBox = this.get('contentBox'),
				scrollPos = contentBox.get('scroll' + axisPosProperty),
				viewSize = this.viewSize,
				
				size = node.get('offset' + axisSizeProperty),
				pos = node.get('offset' + axisPosProperty);
				
			if (pos < scrollPos) {
				contentBox.set('scroll' + axisPosProperty, pos);
				this.syncUIPosition();
			} else if ((pos + size) > (scrollPos + viewSize)) {
				contentBox.set('scroll' + axisPosProperty, pos + size - viewSize);
				this.syncUIPosition();
			} else {
				return false;
			}
		},
		
		/**
		 * Animate element into view
		 * 
		 * @param {Object} node Node
		 * @return True if scrolled to the node, false if node was already in view
		 * @type {Boolean}
		 */
		animateInView: function (node) {
			if (this.get('disabled')) return;
			
			var axis = this.get('axis'),
				axisSizeProperty = (axis == 'y' ? 'Height' : 'Width'),
				axisPosProperty  = (axis == 'y' ? 'Top' : 'Left'),
				
				contentBox = this.get('contentBox'),
				scrollPos = this.getScrollPosition(),
				viewSize = this.viewSize,
				
				size = node.get('offset' + axisSizeProperty),
				pos = node.get('offset' + axisPosProperty);
			
			if (pos < scrollPos) {
				this.animateTo( pos );
			} else if ((pos + size) > (scrollPos + viewSize)) {
				this.animateTo( pos + size - viewSize );
			} else {
				return false;
			}
		},
		
		/**
		 * Animate to position
		 * 
		 * @param {Number} pos Position
		 */
		animateTo: function (pos) {
			if (this.get('disabled')) return;
			
			var animContent   = this.animContent,
				animScrollBar = this.animScrollBar,
				
				toContent   = {},
				toScrollBar = {},
				
				axis = this.get('axis'),
				contentBox = this.get('contentBox');
			
			if (!animContent) {
				animContent = this.animContent = new Y.Anim({
					'node': contentBox,
					'duration': 0.35,
					'easing': 'easeBoth'
				});
				animScrollBar = this.animScrollBar = new Y.Anim({
					'node': this.get('draggableNode'),
					'duration': 0.35,
					'easing': 'easeBoth'
				});
			}
			
			if (axis == 'y') {
				toContent['scroll'] = [0, pos];
				toScrollBar['top'] = pos / this.pxRatio;
			} else {
				toContent['marginLeft'] = -pos;
				toScrollBar['left'] = pos / this.pxRatio;
			}
			
			animContent.stop();
			animContent.set('to', toContent);
			animContent.once('end', this.syncUI, this);
			animContent.run();
			
			animScrollBar.stop();
			animScrollBar.set('to', toScrollBar);
			animScrollBar.run();
		},
		
		/**
		 * Disabled change handler
		 * 
		 * @param {Event} evt Event facade object
		 * @private
		 */
		onDisabledChange: function (evt) {
			if (evt.newVal != evt.prevVal) {
				if (evt.newVal) {
					this.get('scrollbarNode').addClass(this.getClassName('invisible'));
				} else {
					this.syncUI();
				}
			}
		},
		
		/**
		 * Destructor
		 * Clean up
		 * 
		 * @private
		 */
		destructor: function () {
			if (this.resizeListener) {
				this.resizeListener.detach();
				this.resizeListener = null;
			}
			
			if (this.animScrollBar) {
				this.animScrollBar.destroy();
				this.animScrollBar = null;
			}
			
			if (this.animContent) {
				this.animContent.destroy();
				this.animContent = null;	
			}
			
			//Mouse wheel
			var node = this.get('contentBox');
			node.detach('mousewheel');
			node.detach('scroll', this.syncUIPositionThrottled);
			
			//Resize
			node.detach('contentResize', this.syncUIThrottled);
			
			var parent = node.get('parentNode');
			if (parent) parent.detach('contentResize', this.syncUIThrottled);
			
			//Container resize
			node = node.closest('.left-container, .right-container');
			if (node) {
				node.detach('contentResize', this.syncUIThrottled);
			}
			
			//Drag and drop
			node = this.get('draggableNode');
			node.detach('mousedown', this.onDragStart);
		}
	});
	
	Supra.Scrollable = Scrollable;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['widget', 'anim']});YUI.add("supra.input-select", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var LOOKUP_BLACKLIST = {
		9: true,  // Tab
		13: true, // Returns
		16: true, // Shift
		27: true, // Escape
		37: true, // Arrows
		38: true,
		39: true,
		40: true 
	};
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-select";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		/**
		 * List of values
		 * @type {Array}
		 */
		"values": {
			value: [],
			setter: "_setValues"
		},
		
		/**
		 * Loading icon
		 * @type {Boolean}
		 */
		"loading": {
			value: false,
			setter: "_setLoading"
		},
		
		/**
		 * Show empty value in the list
		 * @type {Boolean}
		 */
		"showEmptyValue": {
			value: true
		},
		
		/**
		 * Don"t use replacement
		 * @type {Boolean}
		 */
		"useReplacement": {
			readOnly: true,
			value: false
		},
		
		/**
		 * Custom select container node
		 * @type {Object}
		 */
		"innerNode": {
			value: null
		},
		
		/**
		 * Node for loading icon
		 * @type {Object}
		 */
		"loadingNode": {
			value: null
		},
		
		/**
		 * Text node
		 * @type {Object}
		 */
		"textNode": {
			value: null
		},
		/**
		 * Dropdown node
		 * @type {Object}
		 */
		"dropdownNode": {
			value: null
		},
		/**
		 * Dropdown content node
		 * @type {Object}
		 */
		"contentNode": {
			value: null
		},
		
		/**
		 * Dropdown is opened
		 * @type {Boolean}
		 */
		"opened": {
			value: false,
			setter: "_setDropdownOpened"
		},
		
		/**
		 * Dropdown is scrollable
		 */
		"scrollable": {
			value: true,
			writeOnce: true
		},
		
		/**
		 * Item renderer, allows to create
		 * custom styled items
		 * @type {Function}
		 */
		"itemRenderer": {
			value: null
		},
		
		/**
		 * Text renderer, allows to create
		 * different selected item text
		 * @type {Function}
		 */
		"textRenderer": {
			value: null
		}
	};
	
	Input.HTML_PARSER = {
		"values": function (srcNode) {
			var input = this.get("inputNode"),
				values = [];
			
			if (input && input.test("select")) {
				var options = Y.Node.getDOMNode(input).options;
				for(var i=0,ii=options.length; i<ii; i++) {
					values.push({
						"id": options[i].value,
						"title": options[i].text
					});
				}
			} else {
				values = this.get("values") || [];
			}
			
			return values;
		}
	};
	
	Y.extend(Input, Supra.Input.String, {
		CONTENT_TEMPLATE: "<div></div>",
		INPUT_TEMPLATE: "<select></select>",
		LABEL_TEMPLATE: "<label></label>",
		
		/**
		 * Dropdown opening animation
		 * @type {Object}
		 * @private
		 */
		anim_open: null,
		
		/**
		 * Dropdown close animation
		 * @type {Object}
		 * @private
		 */
		anim_close: null,
		
		/**
		 * Highlighted item id
		 * @type {String}
		 * @private
		 */
		highlight_id: 0,
		
		/**
		 * Scrollable instance
		 * @type {Object}
		 * @private
		 */
		scrollable: null,
		
		/**
		 * Add nodes needed for widget
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			//Add inner node
			var node = Y.Node.create(this.CONTENT_TEMPLATE);
			node.addClass(this.getClassName("inner"));
			node.setAttribute("tabindex", "0");
			this.get("inputNode").insert(node, "after");
			this.set("innerNode", node);
			
			//Input doesn't need to be visible
			this.get("inputNode").addClass("hidden");
			
			//Text node
			var text_node = Y.Node.create("<p></p>");
			this.get("innerNode").append(text_node);
			this.set("textNode", text_node);
			
			//Dropdown node
			var dropdown_node = Y.Node.create('\
					<div class="' + this.getClassName('dropdown') + '">\
						<div class="' + this.getClassName('arrow') + '"></div>\
						<div class="' + this.getClassName('dropdown-content') + '"></div>\
					</div>');
			
			this.set("dropdownNode", dropdown_node);
			this.set("contentNode", dropdown_node.one("." + this.getClassName("dropdown-content")));
			this.get("innerNode").append(dropdown_node);
			
			//Sync values
			this.set("values", this.get("values"));
			this.set("value", this.get("value"));
		},
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var inner_node = this.get("innerNode");
			inner_node.on("mouseenter", this._onMouseOver, this);
			inner_node.on("mouseleave", this._onMouseOut, this);
			inner_node.on("mousedown", this._onMouseDown, this);
			inner_node.on("keydown", this._onKeyPress, this);
			
			//Handle list item  click
			inner_node.delegate("click", this._onItemClick, "a[data-id]", this);
		},
		
		/**
		 * Overwrite focus UI event to prevent styling if input
		 * is disabled
		 */
		_uiSetFocused: function () {
			if (this.get("disabled")) return;
			Input.superclass._uiSetFocused.apply(this, arguments);
		},
		
		/**
		 * On mouse over set style
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onMouseOver: function (e) {
			if (this.get("disabled")) return;
			this.get("boundingBox").addClass(this.getClassName("mouse-over"));
		},
		
		/**
		 * On mouse out remove style
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onMouseOut: function (e) {
			if (this.get("disabled")) return;
			this.get("boundingBox").removeClass(this.getClassName("mouse-over"));
		},
		
		/**
		 * On mouse down open dropdown
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onMouseDown: function (e) {
			//If user clicked inside dropdown then ignore
			var target = e.target.closest("." + this.getClassName("dropdown"));
			if (target) return;
			
			this.set("opened", !this.get("opened"));
		},
		
		/**
		 * On return/escape key down open/close dropdown and allow up/down key navigation
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onKeyPress: function (e) {
			if (this.get("disabled")) return;
			
			var key = e.keyCode;
			
			if (!this.get("opened")) {
				if (key == 13 || key == 40) {
					//Return key or arrow down, open dropdown
					this.set("opened", true);;
				}
			} else {
				if (key == 27 || key == 9) {
					//Escape key or tab key, close dropdown
					this.set("opened", false);
				} else if (key == 40 || key == 38) {
					//Arrow down or up
					var dir = key == 40 ? "next" : "previous",
						node = this.get("dropdownNode"),
						item = node.one(".selected"),
						prev = item;
					
					if (!item) {
						item = node.one("." + this.getClassName("item"));
					} else {
						item = item[dir]();
					}
					
					//Find visible item
					while(item && item.hasClass("hidden")) {
						item = item[dir]();
					}
					
					//Style
					if (item) {
						this._highlightItem(item);
						
						/*
						if (prev) {
							prev.removeClass("selected");
						}
						item.addClass("selected");
						this.highlight_id = item.getAttribute("data-id");
						
						//Update scroll position
						if (this.scrollable) {
							this.scrollable.scrollInView(item);
						}
						*/
					}
				} else if (key == 13) {
					if (this.highlight_id !== null) {
						this.set("value", this.highlight_id);
					}
					
					this.set("opened", false);
				}
			}
			
			if (!(key in LOOKUP_BLACKLIST)) {
				var character = String.fromCharCode((96 <= key && key <= 105)? key-48 : key);
				if (character) {
					this._updateLookupString(character);
				}
			}
		},
		
		/**
		 * Highlight list item
		 * 
		 * @param {String} id Item id
		 * @private
		 */
		_highlightItem: function (id) {
			var node = this.get("dropdownNode"),
				prev_item = node.one(".selected"),
				new_item = null;
			
			if (id instanceof Y.Node) {	
				new_item = id;
				id = new_item.getAttribute('data-id');
			} else {
				new_item = node.one('[data-id="' + id + '"]');
			}
			
			if (new_item) {
				if (prev_item) {
					prev_item.removeClass('selected');
				}
				new_item.addClass('selected');
				
				this.highlight_id = id;
				
				//Update scroll position
				if (this.scrollable) {
					this.scrollable.scrollInView(new_item);
				}
			}
		},
		
		/**
		 * On item click change value and close dropdown
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onItemClick: function (e) {
			if (this.get("disabled")) return;
			
			var item = e.target.closest("a"),
				value = item.getAttribute("data-id");
			
			this.set("value", value);
			this.set("opened", false);
		},
		
		/**
		 * Open dropdown
		 * 
		 * @private
		 */
		_openDropDown: function () {
			if (this.get("disabled")) return;
			
			var inner_node = this.get("innerNode"),
				dropdown_node = this.get("dropdownNode"),
				bounding_node = this.get("boundingBox");
			
			bounding_node.addClass(this.getClassName("open"));
			dropdown_node.setStyles({
				"opacity": 0,
				"marginTop": -15,
				"minWidth": inner_node.get("offsetWidth") + "px"
			});
			
			//Animations
			if (!this.anim_open) {
				this.anim_open = new Y.Anim({
					node: dropdown_node,
				    duration: 0.25,
				    easing: Y.Easing.easeOutStrong,
					from: {opacity: 0, marginTop: -15},
					to: {opacity: 1, marginTop: 0}
				});
			}
			if (this.anim_close) {
				this.anim_close.stop();
			}
			
			this.anim_open
					.stop()
					.run();
			
			//Listeners
			this.close_event_listener = Y.one(document).on("mousedown", this._closeDropDownAttr, this);
			
			//Scrollable
			if (this.scrollable) {
				this.scrollable.syncUI();
			} else if (this.get("scrollable")) {
				//Scrollable content
				this.get("boundingBox").addClass(this.getClassName("scrollable"));
				
				this.scrollable = new Supra.Scrollable({
					"srcNode": this.get("contentNode"),
					"axis": "y"
				});
				
				this.scrollable.render();
				
				this.set("contentNode", this.scrollable.get("contentBox"));
			}
			
			//Highlight selected value
			this._highlightItem(this.get('value'));
		},
		
		/**
		 * Close dropdown by setting attribute
		 */
		_closeDropDownAttr: function (e) {
			//Check validity
			if (e && e.target) {
				var node = e.target.closest("." + this.getClassName("inner"));
				if (node && node === this.get("innerNode")) {
					return;
				}
			}
			
			if (this.get("opened")) {
				this.set("opened", false);
			}
		},
		
		/**
		 * Close dropdown without updating attribute value
		 */
		_closeDropDown: function () {
			//Remove listener
			if (this.close_event_listener) {
				this.close_event_listener.detach();
				this.close_event_listener = null;
			}
			
			//Animations
			if (!this.anim_close) {
				this.anim_close = new Y.Anim({
					node: this.get("dropdownNode"),
				    duration: 0.25,
				    easing: Y.Easing.easeOutStrong,
					from: {opacity: 1, marginTop: 0},
					to: {opacity: 0, marginTop: -15}
				});
				this.anim_close.on("end", function () {
					this.get("boundingBox").removeClass(this.getClassName("closing"));
				}, this);
			}
			if (this.anim_open) {
				this.anim_open.stop();
			}
			
			this.get("boundingBox").addClass(this.getClassName("closing"));
			this.get("boundingBox").removeClass(this.getClassName("open"));
			
			this.anim_close
					.stop()
					.run();
			
			//Remove item highlighting
			this.highlight_id = null;
			var item = this.get("dropdownNode").one(".selected");
			if (item) {
				item.removeClass("selected");
			}
		},
		
		/**
		 * 'Opened' attribute value setter
		 * 
		 * @param {Boolean} value Opened state
		 * @private
		 */
		_setDropdownOpened: function (value) {
			var prev = !!this.get("opened"),
				value = !!value;
			
			if (this.get("disabled")) {
				return false;
			}
			
			if (value != prev) {
				if (value) {
					this._openDropDown();
				} else {
					this._closeDropDown();
				}
			}
			
			return value;
		},
		
		/**
		 * Disabled attribute setter
		 * 
		 * @param {Array} values
		 * @return New values
		 * @type {Array}
		 * @private
		 */
		_setDisabled: function (value) {
			value = Input.superclass._setDisabled.apply(this, arguments);
			
			if (value && this.get("opened")) {
				this.set("opened", false);
			}
			
			return value;
		},
		
		/**
		 * Loading attribute setter
		 * 
		 * @param {Boolean} loading Loading attribute value
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setLoading: function (loading) {
			var box = this.get("innerNode");
			
			if (box) {
				if (loading && !this.get("nodeLoading")) {
					var node = Y.Node.create('<span class="loading-icon"></span>');
					box.append(node);
					this.set("nodeLoading", node);
				}
				
				box.toggleClass(this.getClassName("loading"), loading);
			}
			
			this.set("disabled", loading);
			return loading;
		},
		
		/**
		 * Values attribute setter
		 * 
		 * @param {Array} values
		 * @return New values
		 * @type {Array}
		 * @private
		 */
		_setValues: function (values) {
			if (!Y.Lang.isArray(values)) values = [];
			
			var inputNode = this.get("inputNode"),
				contentNode = this.get("contentNode"),
				item_class = this.getClassName("item"),
				renderer = this.get("itemRenderer"),
				textRenderer = this.get("textRenderer"),
				show_empty_value = this.get("showEmptyValue"),
				html = null,
				title = null;
			
			if (inputNode) {
				var domNode = Y.Node.getDOMNode(inputNode),
					value = this.get("value"),
					text_node = this.get("textNode"),
					has_value = false;
				
				//Remove all options
				for(var i = domNode.options.length - 1; i>=0; i--) {
					domNode.remove(i);
				}
				
				if (contentNode) {
					contentNode.empty();
				}
				
				//Check if value is in new values list
				for(var i=0,ii=values.length; i<ii; i++) {
					if (values[i].id == value) {
						has_value = true;
						break;
					}
				}
				
				if (values.length && !has_value) {
					value = values[0].id;
				}
				
				//Render
				for(var i=0,ii=values.length; i<ii; i++) {
					
					//Check if title is localized
					title = values[i].title;
					title = (title || title === 0 ? String(title) : '');
					
					if (title.indexOf("{#") != -1) {
						title = Supra.Intl.replace(title);
					}
					
					domNode.options[i] = new Option(title, values[i].id, values[i].id == value);
					
					if (values[i].id == value && text_node) {
						if (textRenderer) {
							text_node.set("innerHTML", textRenderer(values[i], i));
						} else {
							text_node.set("text", title);
						}
					}
					
					if (contentNode && (show_empty_value || values[i].id !== "")) {
						if (renderer) {
							html = renderer(values[i], i);
						} else {
							html = '<a class="' + item_class + '" data-id="' + values[i].id + '">' + Supra.Y.Escape.html(title) + '</a>';
						}
						if (html) {
							contentNode.append(html);
						}
					}
				}
				
				// Set correct value
				inputNode.set('value', value);
			}
			
			return values;
		},
		
		/**
		 * Returns object with dropdown elements by value id
		 * 
		 * @return Dropdown elements
		 * @type {Object}
		 */
		getValueNodes: function () {
			var nodes = this.get("contentNode").all("." + this.getClassName("item")),
				node = null,
				obj = {},
				i = 0,
				ii = nodes.size();
			
			for(; i<ii; i++) {
				node = nodes.item(i);
				obj[node.getAttribute("data-id")] = node;
			}
			
			return obj;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setValue: function (value) {
			value = Input.superclass._setValue.apply(this, arguments);
			
			//If not rendered yet, then textNode will not exist
			if (!this.get("textNode")) return value;
			
			var values = this.get("values"),
				title  = null,
				renderer = this.get("textRenderer");
			
			for(var i=0,ii=values.length; i<ii; i++) {
				if (values[i].id == value) {
					if (renderer) {
						this.setText(renderer(values[i], i) || "", false);
					} else {
						this.setText(values[i].title);
					}
					break;
				}
			}
			
			return value;
		},
		
		/**
		 * Set dropdown text
		 * Can be used when value is not in the list or for custom text
		 * 
		 * @param {String} title Text
		 */
		setText: function (title, escape) {
			var node = this.get("textNode");
			if (!node) return this;
			
			//Check if title is localized
			title = String(title || "");
			if (title.indexOf("{#") != -1) {
				title = Supra.Intl.replace(title);
			}
			
			if (escape === false) {
				node.set("innerHTML", title);
			} else {
				node.set("text", title);
			}
			return this;
		},
		
		/**
		 * Returns full data for value
		 * If value is an array of values then returns array of data
		 * 
		 * @param {String} value Optional, value for which to return full data
		 * @returns {Object} Value data
		 */
		getValueData: function (value) {
			var value  = value === null || typeof value === 'undefined' ? this.get('value') : value,
				values = this.get('values'),
				i = 0,
				ii = values.length;
			
			// Single value
			for (; i<ii; i++) {
				if (values[i].id == value) {
					return values[i];
				}
			}
			
			return null;
		},
		
		/**
		 * Returns true if list has options with given id
		 * 
		 * @param {String} id Option ID
		 * @return True if has option with given id, otherwise false
		 * @type {Boolean}
		 */
		hasValue: function (id) {
			var values = this.get("values"),
				i = 0,
				ii = values.length;
			
			 for (; i<ii; i++) if (values[i].id == id) return true;
			 return false
		},
		
		/**
		 * Reset value to default
		 */
		resetValue: function () {
			var value = this.get("defaultValue"),
				values = this.get("values");
			
			this.set("value", value !== null ? value : (values.length ? values[0].id : ""));
			return this;
		},
		
		/**
		 * On destroy remove animations and listeners
		 */
		destructor: function () {
			if (this.anim_open) this.anim_open.destroy();
			if (this.anim_close) this.anim_close.destroy();
			if (this.close_event_listener) {
				this.close_event_listener.detach();
				this.close_event_listener = null;
			}
			
			this.get("innerNode").destroy(true);
		},
		
		
		/* -------------------------- Find item matching entered string  -------------------------- */
		
		
		/**
		 * Timer to clear lookup string
		 * @type {Object}
		 * @private
		 */
		_lookupCooldownTimer: null,
		
		/**
		 * Lookup string
		 * @type {String}
		 * @private
		 */
		_lookupString: '',
		
		
		/**
		 * Find matching value
		 * 
		 * @param {String} str
		 */
		_findMatchingValue: function (str) {
			var values = this.get('values'),
				i = 0,
				ii = values.length;
			
			str = str.toUpperCase();
			
			for (; i<ii; i++) {
				if (values[i].title.toUpperCase().indexOf(str) === 0) {
					return values[i].id;
				}
		 	}
		 	
		 	return null;
		},
		
		/**
		 * Update lookup string
		 * @param {Object} character
		 */
		_updateLookupString: function (character) {
			if (this._lookupCooldownTimer) {
				this._lookupCooldownTimer.cancel();
			}
			this._lookupCooldownTimer = Y.later(500, this, this._clearLookupString);
			
			this._lookupString += character;
			
			var value = this._findMatchingValue(this._lookupString);
			if (value) {
				if (this.get('opened')) {
					this._highlightItem(value);
				} else {
					this.set('value', value);
				}
			}
		},
		
		/**
		 * Clear lookup string
		 * 
		 * @private
		 */
		_clearLookupString: function () {
			if (this._lookupCooldownTimer) {
				this._lookupCooldownTimer.cancel();
				this._lookupCooldownTimer = null;
			}
			
			this._lookupString = '';
		}
		
	});
	
	Supra.Input.Select = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-string", "anim", "supra.scrollable"]});
YUI.add('supra.input-slider', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-slider';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		/**
		 * Value/option list
		 */
		'values': {
			value: []
		},
		/**
		 * Slider length in px
		 */
		'length': {
			value: 200
		},
		
		/**
		 * Label "Less"
		 */
		'labelLess': {
			value: ''
		},
		
		/**
		 * Label "More"
		 */
		'labelMore': {
			value: ''
		}
	};
	
	Input.HTML_PARSER = {
		'values': function () {
			var input = this.get('inputNode'),
				values = [];
			
			if (input && input.test('select')) {
				var options = Y.Node.getDOMNode(input).options;
				for(var i=0,ii=options.length; i<ii; i++) {
					values.push({
						'id': options[i].value,
						'title': options[i].text
					});
				}
			} else {
				values = this.get('values') || [];
			}
			
			return values;
		},
		'length': function (srcNode) {
			var input = this.get('inputNode');
			return input.getAttribute('suLength') || 200;
		},
		'labelLess': function (srcNode) {
			var input = this.get('inputNode');
			return input.getAttribute('suLabelLess') || '';
		},
		'labelMore': function (srcNode) {
			var input = this.get('inputNode');
			return input.getAttribute('suLabelMore') || '';
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<select class="hidden"></select>',
		LABEL_TEMPLATE: '<label></label>',
		
		/**
		 * Slider instance
		 * @see Y.Slider
		 * @type {Object}
		 * @private
		 */
		slider: null,
		
		bindUI: function () {
			var input = this.get('inputNode');
			input.on('focus', this._onFocus, this);
			input.on('blur', this._onBlur, this);
			
			//Handle value attribute change
			this.on('valueChange', this._afterValueChange, this);
		},
		
		_onFocus: function () {
			if (this.get('boundingBox').hasClass('yui3-input-focused')) return;
			
			this.get('boundingBox').addClass('yui3-input-focused');
			this.get('inputNode').focus();
		},
		_onBlur: function () {
			this.get('boundingBox').removeClass('yui3-input-focused');
		},
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			this.buttons = {};
			
			var values = this.get('values'),
				value = this.get('value'),
				index = 0,
				has_value_match = false,
				contentBox = this.get('contentBox'),
				input = Y.Node.getDOMNode(this.get('inputNode'));
			
			//No need to add options if they already exist
			if (!input.options || input.options.length) {
				input = null;
			}
			
			if (contentBox.test('input,select')) {
				contentBox = this.get('boundingBox');
			}
			
			//Slide will be placed instead of input
			this.get('inputNode').addClass('hidden');
			
			for(var i=0,ii=values.length-1; i<=ii; i++) {
				
				if (input) {
					//Add options to allow selecting value
					input.options[input.options.length] = new Option(values[i].title, values[i].id);
					if (value == values[i].id) input.value = value;
				}
				
				if (values[i].id == value) {
					//Mark value as found
					has_value_match = true;
					index = i;
				}
				
			}
			
			//
			var labelLess = this.get('labelLess'),
				labelMore = this.get('labelMore');
			
			if (labelLess) {
				var node = Y.Node.create('<span class="less">' + labelLess + '</span>');
				contentBox.append(node);
				node.on('click', this._setValueMinus, this);
			}
			
			//Create slider
			this.slider = new Supra.Slider({
				'axis': 'x',
				'min': 0,
				'max': values.length - 1,
				'value': index,
				'length': this.get('length')
			});
			this.slider.after('slideEnd', this._onChange, this);
			this.slider.after('slideEnd', this.slider.syncUI, this.slider);
			this.slider.render(contentBox);
			
			if (labelMore) {
				var node = Y.Node.create('<span class="more">' + labelMore + '</span>');
				contentBox.append(node);
				node.on('click', this._setValuePlus, this);
			}
			
			//Set value
			if (!has_value_match) {
				if (values.length) {
					value = values[0].id;
					if (input) input.value = value;
				}
			}
			
		},
		
		/**
		 * Move to next value
		 * 
		 * @private
		 */
		_setValuePlus: function (e) {
			if (this.slider && !this.get('disabled')) {
				var index = this.slider.get('value'),
					values = this.get('values');
				
				if (index < values.length - 1) {
					this.set('value', values[index + 1].id);
				}
			}
			if (e) e.halt();
		},
		
		/**
		 * Move to previous value
		 * 
		 * @private
		 */
		_setValueMinus: function (e) {
			if (this.slider && !this.get('disabled')) {
				var index = this.slider.get('value'),
					values = this.get('values');
				
				if (index > 0) {
					this.set('value', values[index - 1].id);
				}
			}
			if (e) e.halt();
		},
		
		_onChange: function (event) {
			var index = this.slider.get('value'),
				values = this.get('values'),
				value = values[index].id;
			
			this.set('value', value);
		},
		
		_setValue: function (value) {
			this.get('inputNode').set('value', value);
			
			if (this.slider) {
				var index = 0,
					values = this.get('values');
				
				for(var i=0,ii=values.length; i<ii; i++) if (values[i].id == value) {
					index = i;
					break;
				}
				
				if (this.slider.get('value') != index) {
					this.slider.set('value', index);
				}
			}
			
			return value;
		},
		
		_getValue: function () {
			return this.get('inputNode').get('value');
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		_setDisabled: function (value) {
			value = Input.superclass._setDisabled.apply(this, arguments);
			
			//Disable slider
			if (this.slider) this.slider.set('disabled', value);
			
			return value;
		},
		
		/**
		 * Reset value to default
		 */
		resetValue: function () {
			var value = this.get('defaultValue'),
				values = this.get('values');
			
			this.set('value', value !== null ? value : (values.length ? values[0].id : ''));
			return this;
		},
		
	});
	
	Supra.Input.Slider = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto', 'supra.slider']});YUI.add('supra.input-link', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var Manager = Supra.Manager,
		DEFAULT_LABEL_SET = '{#form.set_link#}';
	
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Input.NAME = 'input-link';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		'labelSet': {
			'value': DEFAULT_LABEL_SET,
			'validator': Y.Lang.isString
		},
		'mode': {
			'value': 'link'
		},
		'groupsSelectable': {
			'value': false
		}
	};
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		/**
		 * Button is used instead of input
		 */
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * Button node
		 * @type {Object}
		 * @private
		 */
		button: null,
		
		/**
		 * Right container action settings to it restore after link
		 * manager is closed
		 * @type {Object}
		 * @private
		 */
		restore_action: null,
		
		/**
		 * Open link manager for redirect
		 */
		openLinkManager: function () {
			var value = this.get('value');
			
			//Save previous right layout container action to restore
			//it after 
			this.restore_action = null;
			if (Manager.Loader.isLoaded('LayoutRightContainer')) {
				
				var action_name = Manager.LayoutRightContainer.getActiveAction();
				if (action_name && Manager.Loader.isLoaded(action_name)) {
					var action = Manager.getAction(action_name);
					
					if (action_name == 'PageContentSettings') {
						this.restore_action = {
							'action': action,
							'args': [action.form, action.options]
						};
					} else if (action_name == 'PageSettings') {
						this.restore_action = {
							'action': action,
							'args': [true]
						};
					}
					
				}
			}
			
			Manager.executeAction('LinkManager', value, {
				'mode': this.get('mode'),
				'hideToolbar': true,
				'selectable': {
					'group_pages': this.get('groupsSelectable')
				}
			}, this.onLinkManagerClose, this);
		},
		
		/**
		 * Update value on change
		 *
		 * @param {Object} data
		 */
		onLinkManagerClose: function (data) {
			this.set('value', data);
			
			if (this.restore_action) {
				var conf = this.restore_action;
				conf.action.execute.apply(conf.action, conf.args);
			}
		},
		
		renderUI: function () {
			//Create button
			this.button = new Supra.Button({'label': this.get('labelSet')});
			this.button.render(this.get('contentBox'));
			this.button.on('click', this.openLinkManager, this);
			
			Input.superclass.renderUI.apply(this, arguments);
			
			//Insert button before input
			this.get('inputNode') .insert(this.button.get('boundingBox'), 'before');
			
			this.set('value', this.get('value'));
		},
		
		_setValue: function (data) {
			if (!data || (!data.href && !data.page_id && !data.file_id)) {
				data = '';
			}
			
			var title = (data && data.href ? data.title || data.href : Supra.Intl.replace(this.get('labelSet')));
			this.button.set('label', title);
			
			return data;
		},
		
		_getValue: function (data) {
			if (!data || (!data.href && !data.page_id && !data.file_id)) {
				return '';
			} else {
				return data;
			}
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		_setLabelSet: function (label) {
			if (typeof label !== 'string') {
				label = this.get('labelSet');
			}
			if (typeof label !== 'string') {
				label = DEFAULT_LABEL_SET;
			}
			return label;
		}
		
	});
	
	Supra.Input.Link = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});YUI.add('supra.input-image', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-image';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		'labelSet': {
			'value': '{#form.set_image#}'
		},
		'allowRemoveImage': {
			value: true,
			setter: "_setAllowRemoveImage"
		}
	};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		/**
		 * Button is used instead of input
		 */
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * Image preview size
		 * @type {String}
		 * @private
		 */
		PREVIEW_SIZE: '200x200',
		
		/**
		 * Button node
		 * @type {Object}
		 * @private
		 */
		button: null,
		
		/**
		 * Right container action settings to it restore after link
		 * manager is closed
		 * @type {Object}
		 * @private
		 */
		restore_action: null,
		
		/**
		 * Image was selected last time media library was closed
		 * @type {Boolean}
		 * @private
		 */
		image_was_selected: false,
		
		/**
		 * Button to remove image
		 * @type {Object}
		 * @private
		 */
		button_remove: null,
		
		
		/**
		 * Open link manager for redirect
		 */
		openMediaSidebar: function () {
			var value = this.get('value'),
				path = value ? [].concat(value.path).concat(value.id) : 0;
			
			this.image_was_selected = false;
			
			//Save previous right layout container action to restore
			//it after 
			this.restore_action = null;
			if (Manager.Loader.isLoaded('LayoutRightContainer')) {
				
				var action_name = Manager.LayoutRightContainer.getActiveAction();
				if (action_name && Manager.Loader.isLoaded(action_name)) {
					var action = Manager.getAction(action_name);
					
					if (action_name == 'PageContentSettings') {
						this.restore_action = {
							'action': action,
							'args': [action.form, action.options]
						};
					} else if (action_name == 'PageSettings') {
						this.restore_action = {
							'action': action,
							'args': [true]
						};
					}
					
				}
			}
			
			Manager.executeAction('MediaSidebar', {
				'item': path,
				'dndEnabled': false,
				'onselect': Y.bind(this.onMediaSidebarImage, this),
				'onclose': Y.bind(this.onMediaSidebarClose, this)
			});
		},
		
		/**
		 * Update value on change
		 *
		 * @param {Object} data
		 */
		onMediaSidebarImage: function (data) {
			this.set('value', data.image);
			
			this.image_was_selected = true;
			
			if (this.restore_action) {
				var conf = this.restore_action;
				conf.action.execute.apply(conf.action, conf.args);
			}
		},
		
		/**
		 * Update value on change
		 *
		 * @param {Object} data
		 */
		onMediaSidebarClose: function () {
			if (!this.image_was_selected) {
				this.set('value', '');
			}
			
			if (this.restore_action) {
				var conf = this.restore_action;
				conf.action.execute.apply(conf.action, conf.args);
			}
		},
		
		renderUI: function () {
			//Create button
			this.button = new Supra.Button({'label': this.get('labelSet')});
			this.button.render(this.get('contentBox'));
			this.button.on('click', this.openMediaSidebar, this);
			
			//Remove button
			var button = this.button_remove = new Supra.Button({
				"label": Supra.Intl.get(["form", "block", "remove_image"]),
				"style": "small-red"
			});
			button.on("click", function () { this.set('value', null)}, this);
			button.addClass("su-button-fill");
			button.set("disabled", !this._hasImage());
			button.set("visible", this.get('allowRemoveImage'));
			button.render(this.get('boundingBox'));
			
			this.button.get('boundingBox').insert(button.get('boundingBox'), 'after');
			
			Input.superclass.renderUI.apply(this, arguments);
			
			this.set('value', this.get('value'));
		},
		
		
		/* ------------------------------ Attributes -------------------------------- */
		
		
		/**
		 * Returns true if image is selected, otherwise false
		 * 
		 * @return True if image is selected
		 * @type {Boolean}
		 * @private
		 */
		_hasImage: function () {
			var value = this.get("value");
			return value && value.image;
		},
		
		_setValue: function (data) {
			var title = '';
			
			if (!data || !data.id) {
				data = '';
				title = Supra.Intl.replace(this.get('labelSet'));
			} else {
				title = data.filename;
			}
			
			this.button.set('label', title);
			
			if (this.button_remove) {
				this.button_remove.set('disabled', !data || !data.id);
			}
			
			return data;
		},
		
		_getValue: function (data) {
			if (!data || !data.id) {
				return '';
			} else {
				return data;
			}
		},
		
		/**
		 * Return only ID, all other information is already known on server
		 * 
		 * @return Data which will be sent to server, image ID or empty string
		 * @type {String}
		 * @private
		 */
		_getSaveValue: function () {
			var value = this.get('value');
			return value ? value.id : '';
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		/**
		 * Allow removing image / allow having no image
		 * @param {Boolean} value Attribute value
		 * @return {Boolean} New attribute value
		 */
		_setAllowRemoveImage: function (value) {
			var button = this.button_remove;
			if (button) {
				button.set("visible", value);
			}
			return value;
		}
		
	});
	
	Supra.Input.Image = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});YUI.add('supra.input-map', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-map';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		/**
		 * Button is used instead of input
		 */
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * Map instance
		 * @type {Object}
		 * @private
		 */
		map: null,
		
		/**
		 * Map marker
		 * @type {Object}
		 * @private
		 */
		marker: null,
		
		/**
		 * Location cache
		 * @type {Array}
		 * @private
		 */
		value: null,
		
		/**
		 * Map node
		 * @type {HTMLElement}
		 * @private
		 */
		node: null,
		
		
		renderUI: function () {
			//Create map
			Input.superclass.renderUI.apply(this, arguments);
			
			var node = Y.Node.create('<div></div>');
			node.setStyle('height', '300px');
			this.get('boundingBox').append(node);
			this.node = node.getDOMNode();
			
			Supra.Input.MapManager.prepare(document, window, this.createMap, this); 
		},
		
		/**
		 * Create map
		 */
		createMap: function () {
			if (this.map) return;
			
			if (!this.value) {
				this.value = this.get('defaultValue') || [0, 0];
			}
			
			var latlng = new google.maps.LatLng(this.value[0], this.value[1]),
				node = this.node,
				myOptions = {
					zoom: 8,
					center: latlng,
					streetViewControl: false,
					mapTypeId: google.maps.MapTypeId.ROADMAP
				},
				map,
				marker;
			
			map = this.map = new google.maps.Map(node, myOptions);
			
			//Add marker
			if (!latlng) {
				latlng = map.getCenter();
			}
			marker = this.marker = new google.maps.Marker({'position': latlng, 'map': map, 'draggable': true});
			
			//On marker drag trigger change event
			google.maps.event.addListener(marker, 'dragend', Y.bind(this._afterValueChange, this));
		},
		
		/**
		 * Value setter
		 * 
		 * @param {Array} data Latitude and longitude
		 * @private
		 */
		_setValue: function (data) {
			this.value = data;
			
			if (this.map) {
				if (data) {
					var latlng = new google.maps.LatLng(data[0], data[1]);
					this.map.setCenter(latlng);
					this.marker.setPosition(latlng);
				}
			}
			
			return data;
		},
		
		/**
		 * Value getter
		 * 
		 * @return Latitude and longitude
		 * @type {Array}
		 * @private
		 */
		_getValue: function () {
			if (!this.map || !this.marker) return this.value;
			
			var point = this.marker.getPosition();
			return point ? [point.lat(), point.lng()] : this.value;
		},
		
		/**
		 * After value change trigger event
		 */
		_afterValueChange: function () {
			this.fire('change', {'value': this.get('value')});
		}
		
	});
	
	Supra.Input.Map = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});YUI.add('supra.input-map-inline', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	//Default value
	var DEFAULT_VALUE = {
		'latitude': 56.95,
		'longitude': 24.1,
		'zoom': 14,
		'height': 0
	};
	
	//Minimal map height
	var MAP_MIN_HEIGHT = 80;
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-map-inline';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		// Image node which is edited
		'targetNode': {
			value: null,
			setter: 'createMap'
		},
		'doc': {
			value: null
		},
		'win': {
			value: null
		}
	};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		/**
		 * Constants
		 */
		LABEL_TEMPLATE: '',
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * Map instance
		 * @type {Object}
		 * @private
		 */
		map: null,
		
		/**
		 * Map marker
		 * @type {Object}
		 * @private
		 */
		marker: null,
		
		/**
		 * Info box
		 * @type {Object}
		 * @private
		 */
		info: null,
		
		/**
		 * Location cache
		 * @type {Array}
		 * @private
		 */
		value: null,
		
		/**
		 * Map node
		 * @type {HTMLElement}
		 * @private
		 */
		node: null,
		
		/**
		 * Silent value change
		 * @type {Boolean}
		 * @private
		 */
		silent: false,
		
		/**
		 * Event listeners have been attached
		 * @type {Boolean}
		 * @private
		 */
		eventsBinded: false,
		
		/**
		 * Map was created by this widget, not page itself
		 * @type {Boolean}
		 * @private
		 */
		mapSourceSelf: true,
		
		/**
		 * Dragend event listener
		 * @type {Object}
		 * @private
		 */
		dragendListener: null,
		
		/**
		 * Zoom change event listener
		 * @type {Object}
		 * @private
		 */
		zoomChangeListener: null,
		
		/**
		 * Size content box
		 * @type {Object}
		 * @private
		 */
		sizeBox: null,
		
		/**
		 * Width input
		 * @type {Object}
		 * @private
		 */
		inputWidth: null,
		
		/**
		 * Height input
		 * @type {Object}
		 * @private
		 */
		inputHeight: null,
		
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			//Bind to context
			this._afterValueChange = Y.bind(this._afterValueChange, this);
			
			//Create size input
			this.createSizeInput();
			
			//MapManager.prepare(this.createMap, this);
			this.createMap(this.get('targetNode'));
		},
		
		startEditing: function () {
			if (!this.get('disabled')) {
				this.bindMapEvents();
			}
			
			return Input.superclass.startEditing.apply(this, arguments);
		},
		
		stopEditing: function () {
			Input.superclass.stopEditing.apply(this, arguments);
			this.unbindMapEvents();
		},
		
		/**
		 * Start editing
		 * Enable marker drag and drop
		 */
		bindMapEvents: function () {
			if (this.marker && !this.eventsBinded) {
				var global = this.get('win');
				
				if (this.dragendListener) {
					// Remove in case if old reference
					global.google.maps.event.removeListener(this.dragendListener);
				}
				if (this.zoomChangeListener) {
					// Remove in case if old reference
					global.google.maps.event.removeListener(this.zoomChangeListener);
				}
				
				// Hide info box while editing
				if (this.info) {
					this.info.close();
				}
				
				this.marker.set('draggable', true);
				this.dragendListener = global.google.maps.event.addListener(this.marker, 'dragend', this._afterValueChange);
				this.zoomChangeListener = global.google.maps.event.addListener(this.map, 'zoom_changed', this._afterValueChange);
				
				this.eventsBinded = true;
				
				this.map.set('center', this.marker.get('position'));
				this.map.set('zoom', this.get('value').zoom);
			}
		},
		
		/**
		 * Stop editing
		 * Disable marker drag and drop
		 */
		unbindMapEvents: function () {
			if (this.marker && this.eventsBinded) {
				var global = this.get('win');
				
				if (this.info && this.mapSourceSelf) {
					this.info.open(this.map, this.marker);
				}
				
				global.google.maps.event.removeListener(this.dragendListener);
				global.google.maps.event.removeListener(this.zoomChangeListener);
				
				this.marker.set('draggable', false);
				
				this.zoomChangeListener = null;
				this.dragendListener = null;
				this.eventsBinded = false;
			}
		},
		
		/**
		 * Create map
		 * 
		 * @param {Object} targetNode Element inside which to create map
		 */
		createMap: function (targetNode) {
			if (targetNode && targetNode !== this.get('targetNode')) {
				this.unbindMapEvents();
				this.map = null;
				this.marker = null;
				this.info = null;
				
				MapManager.prepare(this.get('doc'), this.get('win'), function () {
					this._createMap(targetNode);
				}, this);
				
				
				var input_height = this.inputHeight,
					input_width = this.inputWidth,
					value = this.get('value');
				
				if (input_height) {
					if (value && value.height) {
						input_height.set('value', targetNode.get('offsetHeight'));
					} else {
						input_height.set('value', targetNode.get('offsetHeight'));
					}
				}
				
				if (input_width) {
					input_width.set('value', targetNode.get('offsetWidth'));
				}
			}
			return targetNode;
		},
		
		_createMap: function (targetNode) {
			var global = this.get('win'),
				doc    = this.get('doc'),
				value  = this.get('value'),
				cont   = targetNode,
				node   = null,
				map    = null,
				marker = null,
				latlng = null,
				options = null,
				
				g_node = null,
				g_instance = null;
			
			if (!cont) return;
			node = cont.getDOMNode();
			cont.addClass('supra-map');
			
			if (global.jQuery) {
				g_node = global.jQuery(node);
				g_instance = g_node.data('map');
				
				if (g_instance && g_instance.map) {
					// We can get existing map instance
					this.map = g_instance.map;
					this.marker = g_instance.marker;
					this.info = g_instance.info;
					this.mapSourceSelf = false;
					
					return;
				}
			}
			
			cont.empty(); // in case there already is a map
			
			latlng = new global.google.maps.LatLng(value.latitude, value.longitude);
			options = {
				zoom: value.zoom,
				center: latlng,
				streetViewControl: false,
				mapTypeId: global.google.maps.MapTypeId.ROADMAP
			};
			
			map = this.map = new global.google.maps.Map(node, options);
			
			//Add marker
			if (!latlng) {
				latlng = map.getCenter();
			}
			marker = this.marker = new global.google.maps.Marker({'position': latlng, 'map': map, 'draggable': true});
			
			this.mapSourceSelf = true;
		},
		
		_handleMapResize: function () {
			var win = this.get('win'),
				map = this.map;
			
			if (win && map) {
				win.google.maps.event.trigger(this.map, "resize");
			}
		},
		
		
		/* -------------------------------------- SIZE -------------------------------------- */
		
		
		createSizeInput: function () {
			var properties = this.getParentWidget('page-content-properties'),
				contentBox = this.get('contentBox'),
				label      = Supra.Intl.get(['inputs', 'resize_map']),
				sizeBox    = this.sizeBox = Y.Node.create('<div class="clearfix su-sizebox"><p class="label">' + label + '</p></div>');
			
			this.sizeBox = Y.Node.create();
			
			// Width
			var width = this.inputWidth = new Supra.Input.String({
				'type': 'String',
				'style': 'size',
				'valueMask': /^[0-9]*$/,
				'label': Supra.Intl.get(['inputs', 'resize_width']),
				'value': 0
			});
			
			width.render(sizeBox);
			width.set('disabled', true);
			
			// Size button
			var btn = new Supra.Button({"label": "", "style": "small-gray"});
				btn.render(sizeBox);
				btn.set("disabled", true);
				btn.addClass("su-button-ratio");
			
			// Height
			var height = this.inputHeight = new Supra.Input.String({
				'type': 'String',
				'style': 'size',
				'valueMask': /^[0-9]*$/,
				'label': Supra.Intl.get(['inputs', 'resize_height']),
				'value': 0
			});
			
			height.render(sizeBox);
			contentBox.prepend(sizeBox);
			
			height.after('valueChange', this._uiOnHeightInputChange, this);
			height.on('input', Supra.throttle(function (e) {
				if (this.inputHeight.get('focused')) {
					this._uiOnHeightInputInput(e.value);
				}
			}, 250, this, true), this);
		},
		
		_uiSetMapHeight: function (height) {
			var targetNode   = this.get('targetNode'),
				height       = Math.max(MAP_MIN_HEIGHT, height),
				input_width  = this.inputWidth,
				input_height = this.inputHeight,
				prev         = this._uiSilentHeightUpdate;
			
			if (targetNode) {
				if (height != targetNode.get('offsetHeight')) {
					targetNode.setStyle('height', height + 'px');
					this._handleMapResize();
				}
			}
			if (input_height && input_height.get('value') != height) {
				this._uiSilentHeightUpdate = true;
				input_height.set('value', height);
				this._uiSilentHeightUpdate = prev;
				
				if (targetNode) {
					input_width.set('value', targetNode.get('offsetWidth'));
				}
			}
		},
		
		/**
		 * Returns map height from target node or input
		 * 
		 * @returns {Number} Map height in pixels
		 * @private
		 */
		_uiGetMapHeight: function () {
			var targetNode = this.get('targetNode'),
				input      = this.inputHeight,
				height     = 0;
			
			if (targetNode) {
				height = targetNode.get('offsetHeight');
			}
			if (input && !height) {
				height = parseInt(input.get('value'), 10) || 0;
			}
			
			return Math.max(height, MAP_MIN_HEIGHT); 
		},
		
		_uiGetMapWidth: function (targetNode) {
			var targetNode = targetNode || this.get('targetNode');
			if (targetNode) {
				return targetNode.get('offsetHeight');
			} else {
				return 0;
			}
		},
		
		_uiOnHeightInputChange: function () {
			if (this._uiSilentHeightUpdate) return;
			this._uiSilentHeightUpdate = true;
			
			var value  = parseInt(this.inputHeight.get('value'), 10) || 0,
				height = Math.max(value, MAP_MIN_HEIGHT);
			
			this._uiSetMapHeight(height);
			this._afterValueChange();
			
			this._uiSilentHeightUpdate = false;
		},
		
		_uiOnHeightInputInput: function (value) {
			var value  = parseInt(this.inputHeight.get('value'), 10) || 0,
				height = Math.max(value, MAP_MIN_HEIGHT),
				targetNode = this.get('targetNode');
			
			if (targetNode) {
				targetNode.setStyle('height', height + 'px');
				this._handleMapResize();
			}
		},
		
		
		/* -------------------------------------- ATTRIBUTES -------------------------------------- */
		
		
		/**
		 * Disabled attribute change
		 * 
		 * @param {Boolean} disabled
		 * @returns {Boolean} New attribute value
		 * @private
		 */
		/*_setDisabled: function (disabled) {
			if (disabled === true) {
				this.stopEditing();
			} else if (disabled === false){
				this.startEditing();
			}
			
			return false;
		},*/
		
		/**
		 * Value setter
		 * 
		 * @param {Object} value Object with latitude and longitude properties
		 * @returns New attribute value
		 * @private
		 */
		_setValue: function (value) {
			if (this.silent) return value;
			
			var latlng = null,
				map = this.map,
				marker = this.marker,
				global = this.get('win'),
				input_height = this.inputHeight;
			
			value = Supra.mix({}, DEFAULT_VALUE, this.get('defaultValue'), value);
			
			// Validate values
			value.zoom = parseInt(value.zoom, 10) || DEFAULT_VALUE.zoom;
			value.latitude = parseFloat(value.latitude) || 0;
			value.longitude = parseFloat(value.longitude) || 0; 
			value.height = parseInt(value.height, 10) || 0;
			
			if (map && marker) {
				latlng = new global.google.maps.LatLng(value.latitude, value.longitude);
				map.setCenter(latlng);
				map.setZoom(value.zoom || DEFAULT_VALUE.zoom);
				marker.setPosition(latlng);
			}
			
			if (!value.height) {
				// Old version didn't had height, for compatibiliy take it from content
				value.height = this._uiGetMapHeight();
			}
			
			this._uiSetMapHeight(value.height);
			
			return value;
		},
		
		/**
		 * Value getter
		 * 
		 * @returns {Object} Object with latitude and longitude properties
		 * @private
		 */
		_getValue: function (value) {
			var value = Supra.mix({}, DEFAULT_VALUE, this.get('defaultValue'), value),
				point = null,
				map = this.map,
				marker = this.marker,
				input = this.inputHeight;
			
			if (map && marker) {
				point = marker.getPosition();
				value.latitude = point.lat();
				value.longitude = point.lng();
			}
			if (input) {
				value.height = Math.max(parseInt(input.get('value'), 10) || 0, MAP_MIN_HEIGHT);
			}
			
			return value;
		},
		
		/**
		 * After value change trigger event
		 */
		_afterValueChange: function () {
			var value = this.get('value');
			
			if (this.map) {
				value.zoom = this.map.get('zoom');
			}
			
			this.silent = true;
			this.set('value', value);
			this.silent = false;
			
			this.fire('change', {'value': value});
		}
		
	});
	
	Supra.Input.InlineMap = Input;
	
	
	/**
	 * Handle loading Google Maps API and call callback when done
	 */
	var MapManager = Supra.Input.MapManager = {
		
		/**
		 * Property name which is set on document
		 */
		DOCUMENT_PROPERTY: 'supraGoogleMapsGuid',
		
		/**
		 * Function prefix which is set on window
		 */
		WINDOW_FUNCTION: 'supraGoogleMapsReady',
		
		/**
		 * Unique ID counter
		 */
		guid: 1,
		
		/**
		 * Maps
		 */
		maps: {},
		
		/**
		 * List of event listeners
		 * @type {Array}
		 */
		listeners: [],
		
		/**
		 * 
		 */
		prepare: function (doc, win, callback, context) {
			var guid = doc[this.DOCUMENT_PROPERTY],
				map  = null;
			
			if (!guid) {
				guid = this.create(doc, win);
			}
			
			map = this.maps[guid];
			
			if (map.loaded && callback) {
				callback.call(context || window);
			} else if (map.loading && callback) {
				map.listeners.push({'fn': callback, 'obj': context || window});
			}
		},
		
		create: function (doc, win) {
			// Create callback
			var guid = this.guid++,
				fn   = this.WINDOW_FUNCTION + guid,
				self = this;
			
			doc[this.DOCUMENT_PROPERTY] = guid;
			win[fn] = function () { self.ready(guid); };
			
			// Create object
			this.maps[guid] = {
				'loaded': false,
				'loading': true,
				'listeners': []
			};
			
			if (win.google && (win.google.maps || win.google.load)) {
				if (win.google.maps) {
					// Google Maps loaded
					this.maps[guid].loading = false;
					this.maps[guid].loaded = true;
				} else {
					// Google API loaded, load Maps
					win.google.load("maps", "3",  {callback: win[fn], other_params:"sensor=false"});
				}
			} else {
				// Load Google Maps
				var script = document.createElement('script');
					script.type = 'text/javascript';
					script.src  = document.location.protocol + '//maps.googleapis.com/maps/api/js?sensor=false&callback=' + fn;
				
				doc.body.appendChild(script);
			}
			
			return guid;
		},
		
		ready: function (guid) {
			var map = this.maps[guid],
				listeners = map.listeners,
				i = 0,
				ii = listeners.length;
			
			map.listeners = [];
			map.loading = false;
			map.loaded = true;
			
			for(; i<ii; i++) {
				listeners[i].fn.call(listeners[i].obj);
			}
		}
	};
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});/*
 * Add color parsing and formatting
 */
YUI.add('supra.datatype-color', function(Y) {
	//Invoke strict mode
	"use strict";
	
	var Color = Y.namespace("DataType.Color");
	
	//Regular expressions
	var REGEX_RGB = Color.REGEX_RGB = /^rgb(a)?\((\d+)\s?,\s?(\d+)\s?,\s?(\d+)/i,
		REGEX_HEX = Color.REGEX_HEX = /^#[0-9ABCDEF]{3}([0-9ABCDEF]{3})?/i,
		REGEX_HEX_LONG_TO_RGB = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
		REGEX_HEX_SHORT_TO_RGB = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	
	
	
	/**
	 * Parse string color and convert to RGB object with keys
	 * 'red', 'blue' and 'green'
	 * 
	 * @param {String} value Color value
	 * @return Object with red, blue and green keys
	 * @type {Object}
	 */
	Color.parse = function (value) {
		
		if (typeof value === 'string') {
			var match = null;
			
			if (match = value.match(REGEX_RGB)) {
				return {
					'red': parseInt(match[2], 10),
					'green': parseInt(match[3], 10),
					'blue': parseInt(match[4], 10)
				};
			} else if (REGEX_HEX.test(value)) {
				return Color.convert.HEXtoRGB(value);
			}
		} else if (typeof value === 'object' && value) {
			if ('red' in value && 'green' in value && 'blue' in value) {
				return value;
			} else if ('hue' in value && 'saturation' in value && 'brightness' in value) {
				return Color.convert.HSBtoRGB(object);
			} else {
				//Unknown format
				return null;
			}
		} else {
			//Unknown format
			return null;
		}
		
	};
	
	/**
	 * Format color object into a string
	 * 
	 * @param {Object} object Color object in RGB or HSB formats
	 * @return Color in HEX format
	 * @type {String}
	 */
	Color.format = function (object) {
		if (typeof object === 'object' && object) {
			
			if ('red' in object && 'green' in object && 'blue' in object) {
				return Color.convert.RGBtoHEX(object);
			} else if ('hue' in object && 'saturation' in object && 'brightness' in object) {
				return Color.convert.HSBtoHEX(object);
			}
			
		} else if (typeof object === 'string') {
			return object;
		} else {
			//Unknown format
			return '';
		}
	};
	
	
	
	
	/**
	 * Math functions for colors
	 */
	Color.math = {
		/**
		 * Returns difference between colors
		 * 
		 * @param {Object} a Color a
		 * @param {Object} b Color b
		 * @return Difference between colors as RGB color object
		 * @type {Object}
		 */
		'diff': function (a, b) {
			a = Color.parse(a);
			b = Color.parse(b);
			
			if (a && b) {
				return {'red': a.red - b.red, 'green': a.green - b.green, 'blue': a.blue - b.blue};
			} else {
				return {'red': 0, 'green': 0, 'blue': 0};
			}
		},
		
		/**
		 * Add color b to a
		 * 
		 * @param {Object} a Color a
		 * @param {Object} b Color b
		 * @return RGB color
		 * @type {Object}
		 */
		'add': function (a, b) {
			a = Color.parse(a);
			b = Color.parse(b);
			
			return this.normalize({
				'red': a.red + b.red,
				'green': a.green + b.green,
				'blue': a.blue + b.blue
			});
		},
		
		/**
		 * Subtract color b from a
		 * 
		 * @param {Object} a Color a
		 * @param {Object} b Color b
		 * @return RGB color
		 * @type {Object}
		 */
		'subtract': function (a, b) {
			a = Color.parse(a);
			b = Color.parse(b);
			
			return this.normalize({
				'red': a.red - b.red,
				'green': a.green - b.green,
				'blue': a.blue - b.blue
			});
		},
		
		/**
		 * Multiply color a by b
		 * 
		 * @param {Object} a Color a
		 * @param {Object} b Color b or number to multiply by
		 * @return RGB color
		 * @type {Object}
		 */
		'multiply': function (a, b) {
			a = Color.parse(a);
			b = (typeof b === 'number' ? {'red': b, 'green': b, 'blue': b} : Color.parse(b));
			
			return this.normalize({
				'red': ~~(a.red * b.red),
				'green': ~~(a.green * b.green),
				'blue': ~~(a.blue * b.blue)
			});
		},
		
		/**
		 * Normalize RGB or HSB color object by validating all properties
		 * 
		 * @param {Object} object Color object
		 * @param {Boolean} clone Clone color object instead of changing passed in
		 * @return Normalized color object
		 * @type {Object}
		 */
		'normalize': function (object, clone) {
			if (clone) {
				object = Supra.mix({}, object);
			}
			
			if ('red' in object && 'green' in object && 'blue' in object) {
				//RGB
				object.red   = Math.min(255, Math.max(0, object.red));
				object.green = Math.min(255, Math.max(0, object.green));
				object.blue  = Math.min(255, Math.max(0, object.blue));
			} else {
				//HSB
				object.hue         = Math.min(255, Math.max(0, object.hue));
				object.saturation  = Math.min(100, Math.max(0, object.saturation));
				object.brightness  = Math.min(100, Math.max(0, object.brightness));
			}
			
			return object;
		},
		
		/**
		 * Returns average color between a and b
		 * 
		 * @param {Object} a Color a
		 * @param {Object} b Color b
		 * @return RGB color
		 * @type {Object}
		 */
		'average': function () {
			a = Color.parse(a);
			b = Color.parse(b);
			
			return this.normalize({
				'red': ~~((a.red + b.red) / 2),
				'green': ~~((a.green + b.green) / 2),
				'blue': ~~((a.blue + b.blue) / 2)
			});
		},
		
		/**
		 * Brighten or darken a with b
		 * 
		 * @param {Object} a Color a
		 * @param {Object} b Color b
		 * @return RGB color
		 * @type {Object}
		 */
		'overlay': function (a, b) {
			a = Color.parse(a);
			b = Color.parse(b);
			
			if (!a || !b) return null;
			
			var d = {
				'red': b.red - 128,
				'green': b.green - 128,
				'blue': b.blue - 128
			};
			
			return this.add(a, d);
			
			/*
			var brightness = Color.convert.RGBtoHSB(a).brightness;
			
			var d = {
				'red': ((b.red - 128) / 128),
				'green': ((b.green - 128) / 128),
				'blue': ((b.blue - 128) / 128)
			};
			
			return this.normalize({
				'red': ~~((a.red + b.red) / 2),
				'green': ~~((a.green + b.green) / 2),
				'blue': ~~((a.blue + b.blue) / 2)
			});
			*/
		},
		
		/**
		 * Convert color to grayscale
		 * 
		 * @param {Object} color Color
		 * @return Grayscale color
		 * @type {Object}
		 */
		'grayscale': function (color) {
			color = Color.parse(color);
			color = Color.convert.RGBtoHSB(color);
			color.saturation = 0;
			return Color.convert.HSBtoRGB(color);
		},
		
		/**
		 * Invert color
		 * 
		 * @param {Object} color Color
		 * @return Inverted color
		 * @type {Object}
		 */
		'invert': function (color) {
			color = Color.parse(color);
			return {
				'red': 255 - color.red,
				'green': 255 - color.green,
				'blue': 255 - color.blue
			};
		}
	};
	
	
	
	
	/**
	 * Pad string with "0"
	 */
	function strPad (str) {
		if (str.length == 1) return '0' + str;
		return str;
	}

	/**
	 * Color format convertation
	 */
	Color.convert = {
		/**
		 * Convert RGB color into HSB
		 * 
		 * @param {Object} rgb RGB color object with red, green and blue keys
		 * @return Object with hue (0 - 360), saturation (0 - 100) and brightness (0 - 100) keys
		 * @type {Object}
		 */
		RGBtoHSB: function (rgb) {
			var minRGB = null,
				maxRGB = null,
				delta  = 0,
				h      = 0,
				s      = 0,
				b      = 0;
			
			minRGB = Math.min(Math.min(rgb.red, rgb.green), rgb.blue);
			maxRGB = Math.max(Math.max(rgb.red, rgb.green), rgb.blue);
			
			delta = maxRGB - minRGB;
			b = maxRGB;
			
			if (maxRGB) {
				s = 255 * delta / maxRGB;
			
				if (s) {
					if (rgb.red == maxRGB) {
						h = (rgb.green - rgb.blue) / delta;
					} else if (rgb.green == maxRGB) {
						h = 2 + (rgb.blue - rgb.red) / delta;
					} else if (rgb.blue == maxRGB) {
						h = 4 + (rgb.red - rgb.green) / delta;
					}
				} else {
					h = -1;
				}
			} else {
				h = 0;
			}
			
			h *= 60;
			if (h < 0) h += 360;
			
			return {
				"hue": h,
				"saturation": s * 100 / 255,
				"brightness": b * 100 / 255
			};
		},
		
		/**
		 * Convert HSB color into RGB
		 * 
		 * @param {Object} hsb HSBB color object with hue, saturation and brightness keys
		 * @return Object with red, green and blue keys
		 * @type {Object}
		 */
		HSBtoRGB: function (hsb) {
			var r = 0, g = 0, b = 0,
				h = hsb.hue, s = hsb.saturation / 100, v = hsb.brightness / 100,
				
				i = 0,
				f = 0,
				p = 0,
				q = 0,
				t = 0;
			
			if (s == 0){
				r = g = b = v;
			} else {
	
				h /= 60;
				i = Math.floor(h);
				f = h - i;
				p = v * (1 - s);
				q = v * (1 - s * f);
				t = v * (1 - s * (1 - f));
				
				switch(i) {
					case 0:
						r = v; g = t; b = p; break;
					case 1:
						r = q; g = v; b = p; break;
					case 2:
						r = p; g = v; b = t; break;
					case 3:
						r = p; g = q; b = v; break;
					case 4:
						r = t; g = p; b = v; break;
					default:
						r = v; g = p; b = q; break;
				}
			}
			
			return {
				"red": Math.round(r * 255),
				"green": Math.round(g * 255),
				"blue": Math.round(b * 255)
			};
		},
		
		/**
		 * Convert RGB color into HEX
		 * 
		 * @param {Object} rgb RGB color object with red, green and blue keys
		 * @return Color in hex format
		 * @type {String}
		 */
		RGBtoHEX: function (rgb) {
			var str = strPad(rgb.red.toString(16)) +
					  strPad(rgb.green.toString(16)) +
					  strPad(rgb.blue.toString(16));
			
			return "#" + str.toUpperCase();
		},
		
		/**
		 * Convert HEX color into RGB
		 * 
		 * @param {String} hex Color in hex format
		 * @return Object with red, green and blue keys
		 * @type {Object}
		 */
		HEXtoRGB: function (hex) {
			var result = REGEX_HEX_LONG_TO_RGB.exec(hex);
			
			if (result) {
				return {
					red:   parseInt(result[1], 16),
					green: parseInt(result[2], 16),
					blue:  parseInt(result[3], 16)
				};
			} else {
				result = REGEX_HEX_SHORT_TO_RGB.exec(hex);
				return result ? {
					red:   parseInt(result[1] + result[1], 16),
					green: parseInt(result[2] + result[2], 16),
					blue:  parseInt(result[3] + result[3], 16)
				} : null;
			}
		},
		
		/**
		 * Convert HSB color into HEX
		 * 
		 * @param {Object} hsb HSBB color object with hue, saturation and brightness keys
		 * @return Color in hex format
		 * @type {Object}
		 */
		HSBtoHEX: function (hsb) {
			var rgb = Color.convert.HSBtoRGB(hsb);
			return Color.convert.RGBtoHEX(rgb);
		},
		
		/**
		 * Convert HEX color into HSB
		 * 
		 * @param {String} hex Color in hex format
		 * @return Object with hue (0 - 360), saturation (0 - 100) and brightness (0 - 100) keys
		 * @type {Object}
		 */
		HEXtoHSB: function (hex) {
			var rgb = Color.convert.HEXtoRGB(hex);
			return Color.convert.RGBtoHSB(rgb);
		}
	};
	
}, YUI.version);YUI.add("supra.input-color", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Color = Y.DataType.Color;
	
	var TEMPLATE = Supra.Template.compile('\
						<div class="input-heading">\
							<div class="color"></div>\
						</div>\
						<div class="input-content">\
							{% if allowUnset or presets %}\
								<div class="presets clearfix">\
									{% if presets %}{% for preset in presets %}\
										<a class="preset" style="background-color: {{ preset }};" data-color="{{ preset|upper }}"></a>\
									{% endfor %}{% endif %}\
									{% if allowUnset %}\
										<a class="unset" title="{{ labelUnset|escape }}"></a>\
									{% endif %}\
								</div>\
							{% endif %}\
							<div class="picker">\
								<div class="map"><div class="handle"></div><div class="cursor hidden"></div></div>\
								<div class="bar"><div class="handle"></div></div>\
								<div class="right-side">\
									<label>{{ "inputs.color_new"|intl|default("new") }}</label>\
									<div class="preview-new"></div>\
									<div class="preview-old"></div>\
									<label>{{ "inputs.color_current"|intl|default("current") }}</label>\
									\
									<span>#</span>\
									<input type="text" name="hex" maxlength="6" /><br />\
								</div>\
								<div class="clear"></div>\
								<span>{{ "inputs.red"|intl|default("R") }}</span>\
								<input type="text" name="red" maxlength="3" class="rgb" />\
								<span>{{ "inputs.green"|intl|default("G") }}</span>\
								<input type="text" name="green" maxlength="3" class="rgb" />\
								<span>{{ "inputs.blue"|intl|default("B") }}</span>\
								<input type="text" name="blue" maxlength="3" class="rgb" />\
							</div>\
						</div>\
					');
	
	/**
	 * Color picker input
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		
		this.hex = "#000000";
		this.rgb = {"red": 0, "green": 0, "blue": 0};
		this.hsb = {"hue": 0, "saturation": 0, "brightness": 0};
		
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-color";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		"value": {
			"value": ""
		},
		// Heading node
		"nodeHeading": {
			"value": null
		},
		// Heading current color node
		"nodeHeadingColor": {
			"value": null
		},
		// Content node
		"nodeContent": {
			"value": null
		},
		// Map node
		"nodeMap": {
			"value": null
		},
		// Map handle node
		"nodeMapHandle": {
			"value": null
		},
		// Map cursor node
		"nodeMapCursor": {
			"value": null
		},
		// Bar node
		"nodeBar": {
			"value": null
		},
		// Bar handle node
		"nodeBarHandle": {
			"value": null
		},
		// New color preview node
		"nodePreviewNew": {
			"value": null
		},
		// Old color preview node
		"nodePreviewOld": {
			"value": null
		},
		//HEX input
		"nodeInputHEX": {
			"value": null
		},
		//Red input
		"nodeInputRed": {
			"value": null
		},
		//Green input
		"nodeInputGreen": {
			"value": null
		},
		//Blue input
		"nodeInputBlue": {
			"value": null
		},
		//Node to unset color
		"nodeUnset": {
			"value": null
		},
		//Allow to unset color
		"allowUnset": {
			"value": false
		},
		//Unset button text
		"labelUnset": {
			"value": "No color"
		},
		//Shim node
		"nodeShim": {
			"value": null
		},
		//Preset list of colors
		"presets": {
			"value": null
		},
		//Color preset nodes
		"nodePresets": {
			"value": null
		},
		
		//Color picker is expanded
		"expanded": {
			"value": false
		},
		
		//Don't use animations for expand/collapse
		"noAnimation": {
			"value": false
		}
	};
	
	Input.HTML_PARSER = {
		"allowUnset": function (srcNode) {
			var input = this.get("inputNode"),
				unset = srcNode.getAttribute("suAllowUnset") == "true" || (input && input.getAttribute("suAllowUnset") == "true");
			
			return unset === true ? true : null;
		},
		"presets": function (srcNode) {
			var input = this.get("inputNode"),
				presets = srcNode.getAttribute("suPresets") || (input && input.getAttribute("suPresets"));
			
			return presets ? presets.split(',') : null;
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: "<input type=\"hidden\" value=\"\" />",
		LABEL_TEMPLATE: "<label></label>",
		
		/**
		 * Value is unset
		 * @type {Boolean}
		 * @private
		 */
		unset: false,
		
		/**
		 * Old unset value
		 * Value which was set when color widget was expanded
		 * @type {Boolean}
		 * @private
		 */
		unset_old: false,
		
		/**
		 * Preset index which is choosen
		 * @type {Number}
		 * @private
		 */
		preset: -1,
		
		/**
		 * Value as HEX
		 * @type {String}
		 * @private
		 */
		hex: "#000000",
		
		/**
		 * Old value as HEX
		 * Value which was set when color widget was expanded
		 * @type {String}
		 * @private
		 */
		hex_old: "#000000",
		
		/**
		 * Values as RGB
		 * @type {Object}
		 * @private
		 */
		rgb: null,
		
		/**
		 * Values as HSB
		 * @type {Object}
		 * @private
		 */
		hsb: null,
		
		/**
		 * Map node position relative to the page
		 * @type {Array}
		 * @private
		 */
		mapPosition: null,
		
		/**
		 * Map cursor style is dark
		 * @type {Boolean}
		 * @private
		 */
		mapCursorDark: true,
		mapHandleDark: true,
		
		/**
		 * Mouse is down on map
		 * @type {Boolean}
		 * @private
		 */
		mapCursorDown: false,
		
		/**
		 * Subscription object for document move
		 * @type {Object}
		 * @private
		 */
		cursorMoveEvent: null,
		cursorUpEvent: null,
		
		/**
		 * Map width and height
		 * @type {Number}
		 * @private
		 */
		mapSize: -1,
		
		/**
		 * Bar height
		 * @type {Number}
		 * @private
		 */
		barSize: -1,
		
		
		/**
		 * Bar node position relative to the page
		 * @type {Array}
		 * @private
		 */
		barPosition: null,
		
		/**
		 * Mouse is down on bar
		 * @type {Boolean}
		 * @private
		 */
		barCursorDown: false,
		
		/**
		 * While frozen UI will not be updated
		 * @type {Boolean}
		 * @private
		 */
		uiFrozen: false,
		
		/**
		 * While frozen previous value will not be updated
		 * @type {Boolean}
		 * @private
		 */
		uiPrevFrozen: false,
		
		
		
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			var contentBox = this.get("contentBox"),
				template = Y.Node.create(TEMPLATE({
					"allowUnset": this.get("allowUnset"),
					"labelUnset": this.get("labelUnset"),
					"presets": this.get("presets")
				})),
				heading = template.one(".input-heading");
			
			//Attributes
			this.set("nodeHeading", heading);
			this.set("nodeHeadingColor", heading.one(".color"));
			this.set("nodeContent", template.one(".input-content"));
			
			this.set("nodePreviewNew", template.one(".preview-new"));
			this.set("nodePreviewOld", template.one(".preview-old"));
			this.set("nodeMap", template.one(".map"));
			this.set("nodeMapHandle", template.one(".map .handle"));
			this.set("nodeMapCursor", template.one(".map .cursor"));
			this.set("nodeBar", template.one(".bar"));
			this.set("nodeBarHandle", template.one(".bar .handle"));
			this.set("nodeInputHEX", template.one("input[name=\"hex\"]"));
			this.set("nodeInputRed", template.one("input[name=\"red\"]"));
			this.set("nodeInputGreen", template.one("input[name=\"green\"]"));
			this.set("nodeInputBlue", template.one("input[name=\"blue\"]"));
			
			if (this.get("allowUnset")) {
				this.set("nodeUnset", template.one("div.presets a.unset"));
			}
			if (this.get("presets")) {
				this.set("nodePresets", template.all("div.presets a.preset"));
			}
			
			//Render template
			if (contentBox.test('input')) {
				contentBox.addClass('hidden');
				this.get('boundingBox').append(template.size ? template.get("children") : template);
			} else {
				contentBox.append(template.size ? template.get("children") : template);
			}
			
			//Label
			heading.prepend(this.get("labelNode"));
			
			//Value
			var value = this.get('value'),
				fixed = (value || "#000000").toUpperCase(),
				presets = this.get('presets');
			
			this.hex = fixed;
			this.rgb = Color.convert.HEXtoRGB(fixed);
			this.hsb = Color.convert.RGBtoHSB(this.rgb);
			
			if (this.get("allowUnset") && !value) {
				this.unset = true;
			}
			
			if (presets && presets.length) {
				var i   = 0,
					ii  = presets.length,
					hex = this.hex;
				
				for (; i<ii; i++) {
					if (presets[i].toUpperCase() == hex) {
						this.preset = i; break;
					}
				}
			}
		},
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var nodeMap = this.get("nodeMap"),
				nodeBar = this.get("nodeBar"),
				heading = this.get("nodeHeading"),
				slideshow = this.getSlideshow();
			
			nodeMap.on("mouseenter", this._showMapCursor, this);
			nodeMap.on("mouseleave", this._hideMapCursor, this);
			nodeMap.on("mousemove", this._moveMapCursor, this);
			nodeMap.on("mousedown", this._downMapCursor, this);
			nodeMap.on("mouseup", this._upMapCursor, this);
			
			nodeBar.on("mousedown", this._downBarCursor, this);
			nodeBar.on("mouseup", this._upBarCursor, this);
			
			heading.on("mousedown", this._toggle, this);
			
			this.after("expandedChange", this._uiExpandedChange, this);
			
			this.get("nodeInputHEX").on("blur", this._onBlurHEX, this);
			this.get("nodeInputRed").on("blur", this._onBlurRGB, this);
			this.get("nodeInputGreen").on("blur", this._onBlurRGB, this);
			this.get("nodeInputBlue").on("blur", this._onBlurRGB, this);
			
			this.get("nodeInputHEX").on("keyup", this._onKeyHEX, this);
			this.get("nodeInputRed").on("keyup", this._onKeyRGB, this);
			this.get("nodeInputGreen").on("keyup", this._onKeyRGB, this);
			this.get("nodeInputBlue").on("keyup", this._onKeyRGB, this);
			
			if (this.get("allowUnset")) {
				this.get("nodeUnset").on("mousedown", this._onUnset, this);
			}
			if (this.get("presets")) {
				this.get("nodePresets").on("mousedown", this._onPreset, this);
			}
			
			this.get('nodePreviewOld').on('mousedown', this._onReset, this);
			
			//Handle value attribute change
			this.on('valueChange', this._afterValueChange, this);
			
			this.after('visibleChange', this._afterVisibleChange, this);
			
			// On slideshow slide change reset old value
			if (slideshow) {
				slideshow.after('slideChange', this._afterSlideChange, this);
			}
			
			this.syncUI();
		},
		
		syncUI: function () {
			this.syncUIMap();
			this.syncUIBar();
			this.syncUIRGB();
			this.syncUIHEX();
			this.syncUIPreview();
			this.syncUIPreviewOld();
		},
		
		/**
		 * Update map UI
		 * @private
		 */
		syncUIMap: function () {
			if (this.get("nodeMap") && !this.uiFrozen) {
				//Background color
				var size = this.mapSize,
					background = {'hue': this.hsb.hue, 'saturation': 100, 'brightness': 100};
				
				this.get("nodeMap").setStyle("backgroundColor", Color.convert.HSBtoHEX(background));
				
				//Handle position
				this.get("nodeMapHandle").setStyles({
					"left": Math.round(this.hsb.saturation / 100 * size) + "px",
					"top": size - Math.round(this.hsb.brightness / 100 * size) + "px"
				});
				
				//
				if (100 - this.hsb.brightness + this.hsb.saturation > 50) {
					this.get("nodeMapHandle").addClass("light");
					this.mapHandleDark = false;
				} else {
					this.get("nodeMapHandle").removeClass("light");
					this.mapHandleDark = true;
				}
			}
		},
		
		/**
		 * Update bar UI
		 * @private
		 */
		syncUIBar: function () {
			if (this.get("nodeBarHandle") && !this.uiFrozen) {
				var size = this.barSize,
					pos = size - Math.round(this.hsb.hue / 359 * size),
					cur = parseInt(this.get("nodeBarHandle").getStyle("top"), 10);
				
				if (pos != cur) {
					this.get("nodeBarHandle").setStyle("top", pos + "px");
				}
			}
		},
		
		syncUIRGB: function () {
			if (this.get("nodeInputRed") && !this.uiFrozen) {
				this.get("nodeInputRed").set("value", this.rgb.red);
				this.get("nodeInputGreen").set("value", this.rgb.green);
				this.get("nodeInputBlue").set("value", this.rgb.blue);
			}
		},
		
		syncUIHEX: function () {
			var input = this.get("nodeInputHEX"),
				value = null;
			
			if (input && !this.uiFrozen) {
				value = this.hex.replace('#', '');
				if (input.get('value') != value) {
					input.set("value", value);
				}
			}
		},
		
		/**
		 * Update preview UI
		 * @private
		 */
		syncUIPreview: function () {
			var nodePreview = this.get("nodePreviewNew");
			
			if (nodePreview && !this.uiFrozen) {
				var nodeUnset = this.get("nodeUnset"),
					nodePresets = this.get("nodePresets"),
					nodeHeading = this.get("nodeHeadingColor");
				
				if (this.unset) {
					if (nodeUnset) nodeUnset.addClass("active");
					nodePreview.addClass("preview-unset");
					nodePreview.setStyle("backgroundColor", this.hex);
					
					nodeHeading.addClass("preview-unset");
					nodeHeading.setStyle("backgroundColor", this.hex);
				} else {
					if (nodeUnset) nodeUnset.removeClass("active");
					nodePreview.removeClass("preview-unset");
					nodePreview.setStyle("backgroundColor", this.hex);
					
					nodeHeading.removeClass("preview-unset");
					nodeHeading.setStyle("backgroundColor", this.hex);
				}
				
				if (nodePresets) {
					nodePresets.removeClass("active");
					if (this.preset >= 0) {
						nodePresets.item(this.preset).addClass("active");
					}
				}
			}
		},
		
		/**
		 * Update preview UI for previous color
		 * @private
		 */
		syncUIPreviewOld: function () {
			if (!this.uiPrevFrozen) {
				var nodePreview = this.get("nodePreviewOld");
				this.hex_old = this.hex;
				this.unset_old = this.unset;
				
				if (nodePreview) {
					
					if (this.unset_old) {
						nodePreview.addClass("preview-unset");
						nodePreview.setStyle("backgroundColor", this.hex_old);
					} else {
						nodePreview.removeClass("preview-unset");
						nodePreview.setStyle("backgroundColor", this.hex_old);
					}
					
				}
			}
		},
		
		/**
		 * Prevent ui from changing when input value changes
		 * 
		 * @private
		 */
		uiFreeze: function () {
			this.uiFrozen = true;
			this.uiPrevFrozen = true;
		},
		
		/**
		 * Allow ui to change when input value changes
		 * 
		 * @private
		 */
		uiUnfreeze: function () {
			this.uiFrozen = false;
			this.uiPrevFrozen = false;
		},
		
		/**
		 * Prevent previous value from changing when input value changes
		 * 
		 * @private
		 */
		uiFreezePreviousValue: function () {
			this.uiPrevFrozen = true;
		},
		
		/**
		 * Allow previous value to change when input value changes
		 * 
		 * @private
		 */
		uiUnfreezePreviousValue: function () {
			this.uiPrevFrozen = false;
		},
		
		
		/**
		 * -------------------------------- EXPAND / COLLAPSE -----------------------------
		 */
		
		
		/**
		 * Toggle expanded state
		 * 
		 * @private
		 */
		_toggle: function (e) {
			this.set('expanded', !this.get('expanded'));
			e.preventDefault();
		},
		
		/**
		 * Animate expand or collapse
		 * 
		 * @private
		 */
		_uiExpandedChange: function (e) {
			if (e.newVal != e.prevVal) {
				var box     = this.get("boundingBox"),
					content = this.get("nodeContent"),
					height  = 0,
					anim    = !this.get("noAnimation") && this.get("visible"),
					timer   = this._toggleTimer;
				
				// If there is animation running, then stop it
				if (timer) {
					timer.cancel();
					this._toggleTimer = null;
				}
				
				if (!anim) {
					// Don't animate
					
					if (e.newVal) {
						box.addClass("expanded");
						content.setStyles({
							"display": "block",
							"height": "auto"
						});
						
						// Update preview
						this.syncUIPreviewOld();
						
						if (this._uiResizeMapAndBar()) {
							// If size was updated then update scrollbar
							this._uiAfterResize();
						}
					} else {
						box.removeClass("expanded");
						content.setStyles({
							"display": "none",
							"height": "0px"
						});
						
						// Trigger resize to update scrollbars if there are any
						this._uiAfterResize();
					}
				} else {
					// Animate
					
					if (e.newVal) {
						// Calculate new height
						content.setStyles({
							"display": "block",
							"height": "auto"
						});
						
						this._uiResizeMapAndBar();
						
						height = content.get("offsetHeight") + "px";
						
						// Expand
						content.setStyles({
							"height": "0px"
						});
						
						box.addClass("expanded");
						
						content.transition({
							"easing": "ease-out",
							"duration": 0.35,
							"height": height + "px"
						});
						content.setStyles({
							"height": height
						});
						
						// Trigger resize to update scrollbars if there are any
						this._toggleTimer = Y.later(350, this, function () {
							this._toggleTimer = null;
							this._uiAfterResize();
							content.setStyles({
								"transition": "none",
								"height": "auto"
							});
						});
						
						// Update preview
						this.syncUIPreviewOld();
					} else {
						// Collapse
						content.setStyles({
							"height": content.get("offsetHeight") + "px"
						});
						
						Y.later(1, this, function (){
							content.transition({
								"easing": "ease-out",
								"duration": 0.35,
								"height": "0px"
							}); 
						});
						
						this._toggleTimer = Y.later(350, this, function () {
							box.removeClass("expanded");
							content.setStyles({
								"display": "none"
							});
							
							// Trigger resize to update scrollbars if there are any
							this._toggleTimer = null;
							this._uiAfterResize();
						});
					}
					
				}
				
				if (e.newVal) {
					// On window resize update map and bar size
					this.eventResize = Y.on('resize', Supra.throttle(function () {
						if (this._uiResizeMapAndBar()) {
							// If size was updated then update scrollbar
							this._uiAfterResize();
						}
					}, 200, this));
				} else {
					if (this.eventResize) {
						this.eventResize.detach();
						this.eventResize = null;
					}
				}
			}
		},
		
		_uiResizeMapAndBar: function () {
			var map = this.get("nodeMap"),
				bar = this.get("nodeBar"),
				height = map.get("offsetWidth");
			
			if (height && height != this.mapSize) {
				map.setStyle("height", height + "px");
				bar.setStyle("height", height + "px");
				
				this.mapSize = height;
				this.barSize = height;
				
				this.syncUIMap();
				this.syncUIBar();
				
				return true;
			} else {
				return false;
			}
		},
		
		_uiAfterResize: function () {
			var box = this.get('boundingBox'),
				scrollable = box.closest('.su-scrollable');
			
			if (scrollable) {
				scrollable.fire('contentResize');
			}
		},
		
		/**
		 * When widget becomes visible update map and bar size
		 * if it's expanded
		 * 
		 * @private
		 */
		_afterVisibleChange: function (e) {
			if (e.newVal && this.get('expanded')) {
				this._uiResizeMapAndBar();
				this._uiAfterResize();
			}
		},
		
		/**
		 * After parent slideshow change old value to current value
		 * 
		 * @private
		 */
		_afterSlideChange: function () {
			if (this.hex_old != this.hex || this.unset_old != this.unset) {
				this.hex_old = this.hex;
				this.unset_old = this.unset;
				this.syncUIPreviewOld();
			}
		},
		
		
		/**
		 * -------------------------------- INPUT CHANGE -----------------------------
		 */
		
		
		/**
		 * On HEX input blur update color
		 */
		_onBlurHEX: function () {
			var node = this.get("nodeInputHEX"),
				value = "#" + node.get("value").toUpperCase(),
				m = null;
			
			if (this.hex != value) {
				if (m = value.match(/^#([0-9ABCDEF]{3})?[0-9ABCDEF]{3}$/)) {
					//Convert from #ABC to #AABBCC
					if (!m[1]) value = "#" + value[1] + value[1] + value[2] + value[2] + value[3] + value[3];
					
					//Update value
					this.uiFreezePreviousValue();
					this.set("value", value);
					this.uiUnfreezePreviousValue();
				} else {
					//Error
					node.set("value", this.hex.replace('#', ''));
				}
			}
		},
		
		/**
		 * On HEX input change update color
		 */
		_onKeyHEX: function (e) {
			var node = this.get("nodeInputHEX"),
				value = "#" + node.get("value").toUpperCase();
			
			// if full color or return key pressed then apply color
			if (this.hex != value && (value.match(/^#[0-9ABCDEF]{6}$/) || e.keyCode == 13)) {
				this._onBlurHEX();
			}
		},
		
		/**
		 * On RGB input blur update color
		 */
		_onBlurRGB: function () {
			var nodeRed = this.get("nodeInputRed"),
				nodeGreen = this.get("nodeInputGreen"),
				nodeBlue = this.get("nodeInputBlue"),
				red = nodeRed.get("value"),
				green = nodeGreen.get("value"),
				blue = nodeBlue.get("value"),
				reg_num = /^[1-9][0-9]{0,2}$/;
			
			if (!red.match(reg_num) || parseInt(red) > 255) {
				nodeRed.set("value", this.rgb.red);
				red = this.rgb.red;
			}
			if (!green.match(reg_num) || parseInt(green) > 255) {
				nodeGreen.set("value", this.rgb.green);
				green = this.rgb.green;
			}
			if (!blue.match(reg_num) || parseInt(blue) > 255) {
				nodeBlue.set("value", this.rgb.blue);
				blue = this.rgb.blue;
			}
			
			red = parseInt(red, 10);
			green = parseInt(green, 10);
			blue = parseInt(blue, 10);
			
			if (this.rgb.red != red || this.rgb.green != green || this.rgb.blue != blue) {
				this.uiFreezePreviousValue();
				this.setRGB(red, green, blue);
				this.set("value", this.hex);
				this.uiUnfreezePreviousValue();
			}
		},
		
		/**
		 * On RGB input change update color
		 */
		_onKeyRGB: function (e) {
			var nodeRed = this.get("nodeInputRed"),
				nodeGreen = this.get("nodeInputGreen"),
				nodeBlue = this.get("nodeInputBlue"),
				red = nodeRed.get("value"),
				green = nodeGreen.get("value"),
				blue = nodeBlue.get("value"),
				reg_num = /^[1-9][0-9]{0,2}$/;
			
			if (red.match(reg_num) && parseInt(red) < 255 &&
				green.match(reg_num) && parseInt(green) < 255 &&
				blue.match(reg_num) && parseInt(blue) < 255) {
				
				this._onBlurRGB();
			}
		},
		
		/**
		 * On unset update color
		 * 
		 * @private
		 */
		_onUnset: function () {
			this.uiFreezePreviousValue();
			this.setRGB(255, 255, 255);
			this.set("value", "");
			this.uiUnfreezePreviousValue();
		},
		
		/**
		 * On preset update color
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onPreset: function (e) {
			var target = Y.Node(e.target),
				color  = target.getAttribute("data-color");
			
			if (color) {
				this.uiFreezePreviousValue();
				this.set("value", color);
				this.uiUnfreezePreviousValue();
			}
		},
		
		/**
		 * On reset set color to initial value
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onReset: function () {
			this.uiFreezePreviousValue();
			
			if (this.unset_old) {
				this.setRGB(255, 255, 255);
				this.set("value", "");
			} else {
				this.set("value", this.hex_old);
			}
			
			this.uiUnfreezePreviousValue();
		},
		
		
		/**
		 * -------------------------------- BAR MOUSE -----------------------------
		 */
		
		
		/**
		 * Mouse down on map
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_downBarCursor: function (e) {
			this.barCursorDown = true;
			this.unset = false;
			this.preset = -1;
			e.halt();
			
			var doc = Y.Node(document);
			this.barPosition = this.get("nodeBar").getY();
			
			if (this.cursorMoveEvent) this.cursorMoveEvent.detach();
			this.cursorMoveEvent = doc.on("mousemove", Supra.throttle(this._updateBarColor, 40, this));
			
			if (this.cursorUpEvent) this.cursorUpEvent.detach();
			this.cursorUpEvent = doc.on("mouseup", this._upBarCursor, this);
			
			this._showShim();
		},
		
		/**
		 * Mouse up on bar
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_upBarCursor: function (e) {
			if (this.barCursorDown) {
				this._updateBarColor(e);
			}
			
			this.barCursorDown = false;
			
			//Save HSB
			var hsb = this.hsb;
			
			this.uiFreeze();
			this.set("value", this.hex);
			this.uiUnfreeze();
			
			this.hsb = hsb;
			
			if (this.cursorUpEvent) {
				this.cursorUpEvent.detach();
				this.cursorUpEvent = null;
			}
			if (this.cursorMoveEvent) {
				this.cursorMoveEvent.detach();
				this.cursorMoveEvent = null;
			}
			
			this._hideShim();
		},
		
		/**
		 * Update color based on cursor position
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_updateBarColor: function (e) {
			var size = this.barSize,
				y = Math.min(size, Math.max(0, e.pageY - this.barPosition)),
				h = ~~(359 - (y / size) * 359),
				node = this.get("nodeBarHandle");
			
			this.setHue(h);
			
			node.setStyles({
				"top": y
			});
			
			this.fire("input", {"newVal": this.hex});
		},
		
		/**
		 * Create element to prevent drag stopping when over iframe
		 * 
		 * @private
		 */
		_showShim: function () {
			var shim = this.get("nodeShim");
			if (!shim) {
				shim = Y.Node.create("<div></div>");
				shim.setStyles({
					"position": "absolute",
					"z-index": 1,
					"top": 0,
					"right": 0,
					"bottom": 0,
					"left": 0,
					"background": "#fff",
					"opacity": 0,
					"cursor": "none"
				});
				this.set("nodeShim", shim);
			}
			
			shim.appendTo(document.body);
		},
		
		/**
		 * Hide shim node
		 * 
		 * @private
		 */
		_hideShim: function () {
			var shim = this.get("nodeShim");
			if (shim) {
				shim.remove();
			}
		},
		
		
		/**
		 * -------------------------------- MAP MOUSE -----------------------------
		 */
		
		
		/**
		 * Show map cursor
		 * 
		 * @private
		 */
		_showMapCursor: function () {
			this.get("nodeMapCursor").removeClass("hidden");
			this.mapPosition = this.get("nodeMap").getXY();
		},
		
		/**
		 * Hide map cursor
		 * 
		 * @private
		 */
		_hideMapCursor: function () {
			this.get("nodeMapCursor").addClass("hidden");
		},
		
		/**
		 * Move map cursor to the mouse position
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_moveMapCursor: function (e) {
			if (!this.mapPosition) return;
			
			var size = this.mapSize,
				x = Math.min(size, Math.max(0, e.pageX - this.mapPosition[0])),
				y = Math.min(size, Math.max(0, e.pageY - this.mapPosition[1])),
				dark = ((x + y) < size / 2),
				node = this.get("nodeMapCursor");
			
			if (dark != this.mapCursorDark) {
				this.mapCursorDark = dark;
				node.toggleClass("light", !dark);
			}
			
			node.setStyles({
				"left": x,
				"top": y
			});
		},
		
		/**
		 * Mouse down on map
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_downMapCursor: function (e) {
			this.mapCursorDown = true;
			this.unset = false;
			this.preset = -1;
			e.halt();
			
			var doc = Y.Node(document);
			
			if (this.cursorMoveEvent) this.cursorMoveEvent.detach();
			this.cursorMoveEvent = doc.on("mousemove", Supra.throttle(this._updateMapColor, 40, this));
			
			if (this.cursorUpEvent) this.cursorUpEvent.detach();
			this.cursorUpEvent = doc.on("mouseup", this._upMapCursor, this);
			
			this._showShim();
		},
		
		/**
		 * Mouse down on map
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_upMapCursor: function (e) {
			if (this.mapCursorDown) {
				this._updateMapColor(e);
			}
			
			this.mapCursorDown = false;
			
			//Save HSB
			var hsb = this.hsb;
			
			this.uiFreeze();
			this.set("value", this.hex);
			this.uiUnfreeze();
			
			//Restore HSB, because changing hex will invalidate HSB
			this.hsb = hsb;
			
			if (this.cursorUpEvent) {
				this.cursorUpEvent.detach();
				this.cursorUpEvent = null;
			}
			if (this.cursorMoveEvent) {
				this.cursorMoveEvent.detach();
				this.cursorMoveEvent = null;
			}
			
			this._hideShim();
		},
		
		/**
		 * Update color based on cursor position
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_updateMapColor: function (e) {
			if (!this.mapPosition) return;
			
			var size = this.mapSize,
				ratio = size / 100,
				x = Math.min(size, Math.max(0, e.pageX - this.mapPosition[0])),
				y = Math.min(size, Math.max(0, e.pageY - this.mapPosition[1])),
				dark = (x + y) < size / 2,
				
				s = x / ratio,
				b = 100 - y / ratio,
					
				node = this.get("nodeMapHandle");
			
			this.setSaturationBrightness(s, b);
			
			node.setStyles({
				"left": x,
				"top": y
			});
			
			if (dark != this.mapHandleDark) {
				node.toggleClass("light", !dark);
				this.mapHandleDark = dark;
			}
			
			this.fire("input", {"newVal": this.hex});
		},
		
		
		/**
		 * -------------------------------- SETTERS -----------------------------
		 */
		
		/**
		 * Set HSB colors hue component
		 * 
		 * @param {Number} hue Hue component
		 */
		setHue: function (hue) {
			this.hsb.hue = hue;
			this.rgb = Color.convert.HSBtoRGB(this.hsb);
			this.hex = Color.convert.RGBtoHEX(this.rgb);
			
			//HUE is set using a bar
			this.syncUIMap();
			this.syncUIRGB();
			this.syncUIHEX();
			this.syncUIPreview();
		},
		
		/**
		 * Set HSB colors saturation component
		 * 
		 * @param {Number} saturation Saturation component
		 */
		setSaturation: function (saturation) {
			this.hsb.saturation = saturation;
			this.rgb = Color.convert.HSBtoRGB(this.hsb);
			this.hex = Color.convert.RGBtoHEX(this.rgb);
			
			//Saturation is set using a map
			this.syncUIRGB();
			this.syncUIHEX();
			this.syncUIPreview();
		},
		
		/**
		 * Set HSB colors brightness component
		 * 
		 * @param {Number} brightness Brightness component
		 */
		setBrightness: function (brightness) {
			this.hsb.brightness = brightness;
			this.rgb = Color.convert.HSBtoRGB(this.hsb);
			this.hex = Color.convert.RGBtoHEX(this.rgb);
			
			//Brightness is set using a map
			this.syncUIRGB();
			this.syncUIHEX();
			this.syncUIPreview();
		},
		
		/**
		 * Set HSB colors saturation component
		 * 
		 * @param {Number} saturation Saturation component
		 * @param {Number} brightness Brightness component
		 */
		setSaturationBrightness: function (saturation, brightness) {
			this.hsb.saturation = saturation;
			this.hsb.brightness = brightness;
			this.rgb = Color.convert.HSBtoRGB(this.hsb);
			this.hex = Color.convert.RGBtoHEX(this.rgb);
			
			//Saturation and brightness is set using a map
			this.syncUIRGB();
			this.syncUIHEX();
			this.syncUIPreview();
		},
		
		/**
		 * Set RGB colors red component
		 * 
		 * @param {Number} red Red component
		 * @param {Number} green Green component
		 * @param {Number} blue Blue component
		 */
		setRGB: function (red, green, blue) {
			this.rgb.red = red;
			this.rgb.green = green;
			this.rgb.blue = blue;
			
			this.hsb = Color.convert.RGBtoHSB(this.rgb);
			this.hex = Color.convert.RGBtoHEX(this.rgb);
		},
		
		/**
		 * Set HEX color
		 * 
		 * @param {String} hex HEX color
		 */
		setHEX: function (hex) {
			this.hex = hex;
			this.rgb = Color.convert.HEXtoRGB(hex);
			this.hsb = Color.convert.RGBtoHSB(this.rgb);
			
			//HEX is set using an input
			this.syncUIMap();
			this.syncUIBar();
			this.syncUIRGB();
			this.syncUIPreview();
		},
		
		
		/**
		 * Returns value as RGB
		 * 
		 * @return Object with red, green and blue keys
		 * @type {Object}
		 */
		getValueAsRGB: function () {
			return this.rgb;
		},
		
		
		/**
		 * Returns value as HEX
		 * 
		 * @return String representing color in HEX format
		 * @type {String}
		 */
		getValueAsHEX: function () {
			return this.hex;
		},
		
		
		/**
		 * ---------------------------- ATTRIBUTES -------------------------
		 */
		
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value New value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setValue: function (value) {
			//Handle transparent CSS value, this is not a valid color
			if (value == "transparent") value = "";
			
			var fixed = (value || "#000000").toUpperCase();
			
			this.rgb = Color.parse(fixed) || {'red': 0, 'green': 0, 'blue': 0};
			this.hsb = Color.convert.RGBtoHSB(this.rgb);
			this.hex = Color.convert.RGBtoHEX(this.rgb);
			
			if (this.get("allowUnset") && !value) {
				fixed = "";
				this.unset = true;
			} else {
				fixed = this.hex;
				this.unset = false;
			}
			
			// Check if any preset is choosen
			this.preset = -1;
			
			var presets = this.get("presets"),
				hex     = this.hex,
				i       = 0,
				ii      = 0;
			
			if (presets && hex) {
				for (ii=presets.length; i<ii; i++) {
					if (presets[i].toUpperCase() == hex) {
						this.preset = i; break;
					}
				}
			}
			
			//Super
			Input.superclass._setValue.apply(this, [fixed]);
			
			//Update UI
			this.syncUI();
			
			return fixed;
		},
		
		/**
		 * After value change trigger event
		 * @param {Object} evt
		 */
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		}
		
	});
	
	Supra.Input.Color = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto"]});YUI.add("supra.calendar", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var YDate = Y.DataType.Date;
	
	/**
	 * Calendar class 
	 * 
	 * @alias Supra.Calendar
	 * @param {Object} config Configuration
	 */
	function Calendar (config) {
		Calendar.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Calendar.NAME = "calendar";
	Calendar.CSS_PREFIX = 'su-' + Calendar.NAME;
	
	Calendar.ATTRS = {
		'firstWeekDay': Supra.data.get('dateFirstWeekDay'),
		
		'navigationNode': null,
		'bodyNode': null,
		'datesNode': null,
		
		/**
		 * Date
		 * Setter accepts raw and formatted date
		 * Getter returns formatted date
		 */
		'date': {
			value: new Date(),
			setter: '_setDate',
			getter: '_getDate'
		},
		
		'rawDate': {
			value: new Date()
		},
		
		/**
		 * Predefined date list
		 */
		'dates': {
			value: [],
			setter: '_setDates'
		},
		
		/**
		 * Currently visible month
		 */
		'displayDate': {
			value: null,
			setter: '_setDisplayDate'
		},
		
		/**
		 * Min date
		 */
		'minDate': {
			value: null,
			setter: '_setMinDate'
		},
		
		/**
		 * Max date
		 */
		'maxDate': {
			value: null,
			setter: '_setMaxDate'
		},
		
		/**
		 * Don't use animations
		 */
		'noAnimations': {
			value: false
		}
	};
	
	Calendar.HTML_PARSER = {
		'navigationNode': function (srcNode) {
			return srcNode.one('.' + this.getClassName('nav'));
		},
		'bodyNode': function (srcNode) {
			return srcNode.one('.' + this.getClassName('body'));
		},
		'datesNode': function (srcNode) {
			return srcNode.one('.' + this.getClassName('dates'));
		}
	};
	
	Y.extend(Calendar, Y.Widget, {
		/**
		 * Calendar animation object
		 * @type {Object}
		 */
		anim: null,
		animReverse: null,
		animDir: -1,
		
		renderUI: function () {
			var contentNode = this.get('contentBox'),
				navNode = this.get('navigationNode'),
				bodyNode = this.get('bodyNode'),
				suggestionsNode = this.get('suggestionsNode');
			
			if (!navNode) {
				navNode = Y.Node.create(
					'<div class="' + this.getClassName('nav') + '">\
						<a class="' + this.getClassName('prev') + '"></a>\
						<a class="' + this.getClassName('next') + '"></a>\
						<p></p>\
					</div>');
				
				contentNode.prepend(navNode);
				this.set('navigationNode', navNode);
				
				navNode.one('.su-calendar-prev').on('mousedown', this.goPrevMonth, this);
				navNode.one('.su-calendar-next').on('mousedown', this.goNextMonth, this);
			}
			
			if (!bodyNode) {
				bodyNode = Y.Node.create(
					'<div class="' + this.getClassName('body') + '"></div>');
				
				navNode.insert(bodyNode, 'after');
				this.set('bodyNode', bodyNode);
				
				bodyNode.delegate('click', Y.bind(this._selectDate, this), 'td');
			}
			
			if (!suggestionsNode) {
				suggestionsNode = Y.Node.create(
					'<div class="' + this.getClassName('suggestions') + '"></div>');
				
				contentNode.append(suggestionsNode);
				this.set('suggestionsNode', suggestionsNode);
			}
			
			this.set('displayDate', this.get('rawDate'));
			this.set('date', this.get('rawDate'));
			this.set('dates', this.get('dates'));
			
			//Redraw when date chagnes
			this.after('dateChange', this.syncUISelected, this);
			
			//Redraw when display date changes
			this.after('displayDateChange', this.onDisplayDateChange, this);
			
			//Create animation 
			this.anim = new Y.Anim({
				node: bodyNode,
			    duration: 0.1,
			    easing: Y.Easing.easeOutStrong,
				from: {opacity: 1, left: 0},
				to: {opacity: 0, left: -16}
			});
			this.anim.on('end', function () {
				this.syncUI();
				this.animReverse.set('from', {opacity: 0, left: this.animDir * -16});
				this.animReverse.run();
			}, this);
			
			this.animReverse = new Y.Anim({
				node: bodyNode,
			    duration: 0.1,
			    easing: Y.Easing.easeOut,
				from: {opacity: 0, left: 16},
				to: {opacity: 1, left: 0}
			});
		},
		
		onDisplayDateChange: function (e) {
			if (e.prevVal.getFullYear() != e.newVal.getFullYear() || e.prevVal.getMonth() != e.newVal.getMonth()) {
				
				if (!this.get('noAnimations')) {
					this.animDir = e.newVal.getTime() > e.prevVal.getTime() ? -1 : 1;
					this.anim.set('to', {opacity: 0, left: this.animDir * 16});
					this.anim.run();
				} else {
					this.syncUI();
					this.anim.get('node').setStyles({
						'left': 0,
						'opacity': 1
					});
				}
			}
		},
		
		renderCalendarBody: function () {
			var date = this._dateGetDateOnly(this.get('rawDate')),
				dateTime = date.getTime(),
				minDate = this.get('minDate'),
				maxDate = this.get('maxDate'),
				minDateTime = 0,
				maxDateTime = 0,
				curDate = this._dateGetDateOnly(this.get('displayDate')),
				curDateTime = 0,
				curMonth = curDate.getMonth(),
				lastDate = new Date(curDate),
				lastDateTime = null,
				firstWeekDay = parseInt(this.get('firstWeekDay'), 10) || 1,
				weekDayNames = Y.Intl.get('datatype-date-format').a,
				bodyNode = this.get('bodyNode'),
				headHTML = [],
				bodyHTML = [],
				rowHTML = [],
				k,
				classname = '';
			
			if (minDate) minDateTime = this._dateGetDateOnly(minDate).getTime();
			if (maxDate) maxDateTime = this._dateGetDateOnly(maxDate).getTime();
			
			//Set date to first which is visible in calendar (possibly last month)
			curDate.setDate(1);
			var day = firstWeekDay - curDate.getDay() + 1;
			curDate.setDate(day > 1 ? day - 7 : day);
			curDateTime = curDate.getTime();
			
			//Set date to last which is visible in calendar (possible next month)
			lastDate = new Date(curDate);
			lastDate.setDate(curDate.getDate() + 41);
			/*
			lastDate.setDate(1);
			lastDate.setMonth(lastDate.getMonth() + 1);
			
			if (lastDate.getDay() != (firstWeekDay + 6) % 7) {
				lastDate.setDate(lastDate.getDate() + (7 - lastDate.getDay() + firstWeekDay));
			}
			*/
			lastDateTime = lastDate.getTime();
			
			//Render header
			for(var i=firstWeekDay,ii=7+firstWeekDay; i<ii; i++) {
				k = i % 7;
				headHTML.push('<th>' + weekDayNames[k].toLowerCase() + '</th>');
			}
			
			//Render body
			k = 0;
			
			while(curDateTime <= lastDateTime) {
				classname = '';
				if (curDateTime == dateTime) {
					classname += ' selected';
				}
				
				if ((minDateTime && minDateTime > curDateTime) || (maxDateTime && maxDateTime < curDateTime)) {
					classname += ' disabled';
				}
				if (curMonth != curDate.getMonth()) {
					classname += ' out';
				}
				
				rowHTML.push('<td data-date="' + YDate.reformat(curDate, 'raw', 'in_date') + '"' + (classname ? ' class="' + classname + '"' : '') + '><span>' + curDate.getDate() + '</span></td>');
				
				k++;
				if (k == 7) {
					k = 0;
					bodyHTML.push('<tr>' + rowHTML.join('') + '</tr>');
					rowHTML = [];
				}
				
				curDate.setDate(curDate.getDate()+1);
				curDateTime = curDate.getTime();
			}
			
			if (rowHTML.length) bodyHTML.push('<tr>' + rowHTML.join('') + '</tr>');
			
			bodyNode.set('innerHTML', '<table><thead><tr>' + headHTML.join('') + '</tr></thead><tbody>' + bodyHTML.join('') + '</tbody></table>');
		},
		
		syncUI: function () {
			var date = this.get('displayDate');
			
			//Set navigation month
			var monthName = YDate.format(date, {format: '%B %Y'});
			this.get('navigationNode').one('p').set('innerHTML', monthName);
			
			this.renderCalendarBody();
		},
		
		syncUISelected: function () {
			var bodyNode = this.get('bodyNode'),
				nodeSelected = bodyNode.one('.selected'),
				date = YDate.reformat(this.get('rawDate'), 'raw', 'in_date');
			
			//Unmark old element
			if (nodeSelected) nodeSelected.removeClass('selected')
			
			//Mark new element
			nodeSelected = bodyNode.one('td[data-date="' + date + '"]');
			if (nodeSelected) nodeSelected.addClass('selected');
		},
		
		/**
		 * Show previous month
		 */
		goPrevMonth: function (e) {
			var date = new Date(this.get('displayDate'));
			date.setMonth(date.getMonth() - 1);
			this.set('displayDate', date);
			
			if (e) e.halt();
		},
		
		/**
		 * Show next month
		 */
		goNextMonth: function (e) {
			var date = new Date(this.get('displayDate'));
			date.setMonth(date.getMonth() + 1);
			this.set('displayDate', date);
			
			if (e) e.halt();
		},
		
		/**
		 * Set selected date
		 * 
		 * @param {Event} e
		 */
		_selectDate: function (e) {
			var target = e.target;
				target = target.test('TD') ? target : target.ancestor('TD');
			
			if (target.hasClass('disabled')) return;
			
			var attr = target.getAttribute('data-date'),
				date = YDate.reformat(attr, 'in_date', 'raw');
			
			this.set('date', date);
		},
		
		/**
		 * Validate and set date
		 * 
		 * @param {Date} date
		 * @return Date
		 * @type {Date}
		 */
		_setDate: function (date) {
			var minDate = this.get('minDate'),
				maxDate = this.get('maxDate');
			
			date = date ? YDate.reformat(date, 'out_date', 'raw') || YDate.reformat(date, 'in_date', 'raw') : null;
			date = date || this.get('rawDate') || new Date();
			
			if (minDate && date.getTime() < minDate.getTime()) {
				date = new Date(minDate);
			} else if (maxDate && date.getTime() > maxDate.getTime()) {
				date = new Date(maxDate);
			}
			
			this.set('rawDate', date);
			
			return date;
		},
		
		/**
		 * Returns formatted date
		 * 
		 * @param {Date} date
		 * @return Date string
		 * @type {String}
		 */
		_getDate: function (date) {
			return YDate.reformat(date, 'raw', 'out_date');
		},
		
		/**
		 * Validate and set date
		 * 
		 * @param {Date} date
		 * @return Date
		 * @type {Date}
		 * @private
		 */
		_setDisplayDate: function (date) {
			date = date ? YDate.reformat(date, 'out_date', 'raw') || YDate.reformat(date, 'in_date', 'raw') : null;
			date = date || this.get('displayDate') || new Date();
			
			return date;
		},
		
		/**
		 * Validate and set min-date
		 * 
		 * @param {Date} date
		 * @return Date
		 * @type {Date}
		 * @private
		 */
		_setMinDate: function (minDate) {
			var date = this.get('rawDate') || new Date();
			
			minDate = minDate ? YDate.reformat(minDate, 'out_date', 'raw') || YDate.reformat(minDate, 'in_date', 'raw') : null;
			if (minDate && date.getTime() < minDate.getTime()) {
				this.set('date', new Date(minDate));
			}
			return minDate;
		},
		
		/**
		 * Validate and set max-date
		 * 
		 * @param {Date} date
		 * @return Date
		 * @type {Date}
		 * @private
		 */
		_setMaxDate: function (maxDate) {
			var date = this.get('rawDate') || new Date();
			
			maxDate = maxDate ? YDate.reformat(maxDate, 'out_date', 'raw') || YDate.reformat(maxDate, 'in_date', 'raw') : null;
			if (maxDate && date.getTime() < maxDate.getTime()) {
				this.set('date', new Date(maxDate));
			}
			return maxDate;
		},
		
		/**
		 * Removes time from date (sets to 00:00:00)
		 * 
		 * @param {Date} date
		 * @return Date object with time 00:00:00
		 * @type {Date}
		 */
		_dateGetDateOnly: function (date) {
			var d = new Date(date);
			d.setHours(0);
			d.setMinutes(0);
			d.setSeconds(0);
			d.setMilliseconds(0);
			return d;
		},
		
		/**
		 * Draw predefined date list
		 * 
		 * @param {Array} dates Date list
		 */
		_setDates: function (dates) {
			var datesNode = this.get('datesNode');
			
			if (Y.Lang.isArray(dates) && dates.length) {
				if (!datesNode) {
					datesNode = Y.Node.create('<div class="' + this.getClassName('dates') + '"></div>');
					datesNode.delegate('click', Y.bind(this._onDatesItemClick, this), 'a');
					this.set('datesNode', datesNode);
				} else {
					datesNode.all('a').remove();
				}
				
				var date = '',
					title = '';
				
				for(var i=0,ii=dates.length; i<ii; i++) {
					date = YDate.reformat(dates[i].date, 'in_date', 'in_date');
					title = Supra.Intl.replace(dates[i].title);
					
					datesNode.append(Y.Node.create('<a data-date="' + date + '">' + title + '</a>'));
				}
				
				this.get('contentBox').append(datesNode);
			} else if (datesNode) {
				datesNode.remove();
				this.set('datesNode', null);
			}
			
			return dates;
		},
		
		/**
		 * Handle click on dates item
		 */
		_onDatesItemClick: function (e) {
			var target = e.target;
			var date = target.getAttribute('data-date');
			
			date = YDate.reformat(date, 'in_date', 'raw');
			
			this.set('date', date);
			this.set('displayDate', date);
		}
		
	});
	
	
	Supra.Calendar = Calendar;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["widget", "anim", "datatype-date"]});YUI.add("supra.input-date", function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Date picker input
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-date";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		// If set, then new slide with calendar will be added
		"slideshow": {
			"value": null
		},
		
		// Maximal selectable date
		"maxDate": {
			"value": null,
			"setter": "_setMaxDate"
		},
		
		// Minimal selectable date
		"minDate": {
			"value": null,
			"setter": "_setMinDate"
		},
		
		// Allow to set also time
		"time": {
			"value": true
		},
		
		// Label for button when no date is selected
		"labelSet": {
			"value": "Select a date"
		},
		
		// Label for button to clear selected date
		"labelClear": {
			"value": "Clear all"
		}
	};
	
	Input.HTML_PARSER = {
		// suMinDate attribute for minDate
		"minDate": function (srcNode) {
			var date = srcNode.getAttribute("suMinDate");
			if (date) return date;
		},
		
		// suMaxDate attribute for maxDate
		"maxDate": function (srcNode) {
			var date = srcNode.getAttribute("suMaxDate");
			if (date) return date;
		},
		
		// Label when no date is selected
		"labelSet": function (srcNode) {
			var label = srcNode.getAttribute("suLabelSet");
			if (label) return label;
		},
		
		// Label to clear selection
		"labelClear": function (srcNode) {
			var label = srcNode.getAttribute("suLabelClear");
			if (label) return label;
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: "<input type=\"hidden\" value=\"\" />",
		LABEL_TEMPLATE: "<label></label>",
		
		
		/**
		 * Widgets list
		 * @private
		 */
		widgets: {},
		
		/**
		 * Value will not be changed while silent
		 * @private
		 */
		silent: false,
		
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.widgets = {
				"button": null,
				
				"calendar": null,
				
				"time": null,
				"hours": null,
				"minutes": null,
				"clear": null,
				
				"slide": null,
				"slideId": null,
				
				"popup": null
			};
			
			// Try finding slideshow which is above this node in DOM, but still inside form
			var slideshow = this.get("slideshow");
			if (!slideshow) {
				slideshow = this.get("boundingBox").closest(".su-slideshow");
				if (slideshow) {
					var form = slideshow.closest(".yui3-form");
					if (form) {
						slideshow = Y.Widget.getByNode(slideshow);
						this.set("slideshow", slideshow);
					}
				}
			}
			
			//Create button widget
			var contentBox = this.get("contentBox");
			var button = this.widgets.button = new Supra.Button({
				"style": "small-gray",
				"label": ""
			});
			
			button.addClass("button-section");
			button.on("click", this.openCalendar, this);
			
			if (contentBox.test("input")) {
				contentBox.addClass("hidden");
				button.render(this.get("boundingBox"));
			} else {
				button.render(contentBox);
			}
		},
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
		},
		
		syncUI: function () {
			if (this.widgets.button) {
				var value = this.get("inputNode").get("value"),
					date = value ? Y.DataType.Date.reformat(value, this.getFormat("in"), this.getFormat("out")) : "";
				
				if (!date) {
					date = this.get("labelSet");
				}
			
				this.widgets.button.set("label", date);
			}
		},
		
		destructor: function () {
			var widgets = this.widgets,
				key = null;
			
			for(key in widgets) {
				if (widgets[key] && widgets[key].destroy) {
					widgets[key].destroy();
				}
			}
			
			delete(this.widgets);
		},
		
		
		/**
		 * ---------------------------- API -------------------------
		 */
		
		
		/**
		 * Open calendar in popup or in slide
		 */
		openCalendar: function () {
			if (this.get("slideshow")) {
				this.openCalendarSlide();
			} else {
				this.openCalendarPopup();
			}
			
			this.widgets.calendar.set("date", this.get("value"));
			this.setCalendarTime(this.get("value"));
		},
		
		/**
		 * Close calendar slide or popup
		 */
		closeCalendar: function () {
			if (this.get("slideshow")) {
				this.closeCalendarSlide();
			} else {
				this.closeCalendarPopup();
			}
		},
		
		/**
		 * Reset value
		 */
		resetCalendar: function () {
			this.silent = true;
			this.closeCalendar(true);
			this.silent = false;
			this.set("value", "");
		},
		
		
		/**
		 * ---------------------------- SLIDESHOW -------------------------
		 */
		
		
		/**
		 * Open calendar slide
		 * 
		 * @private
		 */
		openCalendarSlide: function () {
			var slideshow = this.get("slideshow");
			if (slideshow) {
				if (!this.widgets.slide) {
					this.renderCalendarSlide();
				}
				
				slideshow.set("slide", this.widgets.slideId);
			}
		},
		
		/**
		 * Close calendar slide
		 * 
		 * @private
		 */
		closeCalendarSlide: function () {
			var slideshow = this.get("slideshow");
			if (slideshow) {
				slideshow.scrollBack();
			}
		},
		
		/**
		 * Render calendar in a slide
		 * 
		 * @private
		 */
		renderCalendarSlide: function () {
			//Create slide
			this.widgets.slideId = Y.guid();
			
			var slideshow = this.get("slideshow"),
				slide = this.widgets.slide = slideshow.addSlide({
					'id': this.widgets.slideId,
					'title': this.get('label')
				});
			
			//If slideshow is in sidebar we want an icon and title changed
			slide.setAttribute("data-icon", "/cms/lib/supra/img/sidebar/icons/settings-schedule.png");
			slide.setAttribute("data-title", this.get("label"));
			
			//Create calendar
			var calendar = this.renderCalendar(slide.one(".su-slide-content, .su-multiview-slide-content"));
			
			//On slide change update value
			slideshow.on("slideChange", this.handleSlideChange, this);
		},
		
		/**
		 * When slide is hidden set input value
		 * 
		 * @private
		 */
		handleSlideChange: function (evt) {
			var slide		= evt.prevVal,
				calendar	= this.widgets.calendar,
				date		= null;
			
			if (calendar && slide == this.widgets.slideId) {
				var date = this.getCalendarDate();
				if (date != this.get("value")) {
					this.set("value", date);
				}
			}
		},
		
		
		/**
		 * ---------------------------- POPUP -------------------------
		 */
		
		
		/**
		 * Open calendar popup
		 * 
		 * @private
		 */
		openCalendarPopup: function () {
			//@TODO
		},
		
		/**
		 * Close calendar popup
		 * 
		 * @private
		 */
		closeCalendarPopup: function () {
			if (this.widgets.popup) {
				this.widgets.popup.fadeOut();
			}
		},
		
		/**
		 * Render calendar in a popup
		 * 
		 * @private
		 */
		renderCalendarPopup: function () {
			//@TODO
		},
		
		
		/**
		 * ---------------------------- CALENDAR -------------------------
		 */
		
		
		/**
		 * Render calendar widget
		 * 
		 * @private
		 */
		renderCalendar: function (container) {
			var calendar = this.widgets.calendar = new Supra.Calendar({
				"date": this.get("value"),
				"minDate": this.get("minDate"),
				"maxDate": this.get("maxDate")
			});
			
			
			calendar.render(container);
			
			if (this.get("time")) {
				var html = '<div class="yui3-input-date-time">\
								<input type="text" name="hours" value="00" suValueMask="^([0-1][0-9]|2[0-4]|[0-9])$" maxlength="2" />\
								<span>:</span>\
								<input type="text" name="minutes" value="00" suValueMask="^([0-5][0-9]|60|[0-9])$" maxlength="2" />\
								\
								<br />\
								\
								<button type="button" suStyle="small"><p>' + this.get("labelClear") + '</p></button>\
							</div>';
				
				var node	= this.widgets.time    = Y.Node.create(html),
					hours	= this.widgets.hours   = new Supra.Input.Text({"srcNode": node.one("input[name='hours']")}),
					minutes	= this.widgets.minutes = new Supra.Input.Text({"srcNode": node.one("input[name='minutes']")});
				
				container.append(node);
				
				hours.render();
				minutes.render();
				
			} else {
				var html = '<div class="yui3-input-date-time">\
								<button type="button" suStyle="small"><p>' + this.get("labelClear") + '</p></button>\
							</div>';
				
				var node	= this.widgets.time    = Y.Node.create(html);
				container.append(node);
			}
			
			//Clear button
			var clear = this.widgets.clear = new Supra.Button({
				"srcNode": node.one("button"),
				"style": "small",
				"label": this.get("labelClear")
			});
			
			clear.render();
			clear.on("click", this.resetCalendar, this);
			
			return calendar;
		},
		
		/**
		 * Set calendar time
		 * 
		 * @private
		 */
		setCalendarTime: function (date) {
			var time = (date ? date.match(/(\d{1,2}):(\d{1,2})/) : null) || ['', 0, 0],
				hours = parseInt(time[1], 10),
				minutes = parseInt(time[2], 10);
			
			this.widgets.hours.set('value', hours < 10 ? "0" + hours : hours);
			this.widgets.minutes.set('value', minutes < 10 ? "0" + minutes : minutes);
		},
		
		/**
		 * Returns calendar date and time
		 * This is not inputs value
		 * 
		 * @private
		 */
		getCalendarDate: function () {
			var calendar = this.widgets.calendar,
				date = "";
			
			if (calendar) {
				date = new Date(calendar.get("rawDate"));
				
				if (this.get("time")) {
					var hours = parseInt(this.widgets.hours.get("value"), 10) || 0,
						minutes = parseInt(this.widgets.minutes.get("value"), 10) || 0;
					
					date.setHours(hours);
					date.setMinutes(minutes);
				}
				
				date = Y.DataType.Date.reformat(date, "raw", this.getFormat("in"));
				return date || "";
			} else {
				return this.get("value");
			}
		},
		
		
		/**
		 * ---------------------------- DATE AND TIME -------------------------
		 */
		
		
		/**
		 * Returns format
		 * 
		 * @param {String} prefix Format prefix
		 * @return Date format
		 * @private
		 */
		getFormat: function (prefix) {
			return prefix + (this.get("time") ? "_datetime_short" : "_date");
		},
		
		
		/**
		 * ---------------------------- ATTRIBUTES -------------------------
		 */
		
		
		/**
		 * Value attribute setter
		 * 
		 * @param {String} value New value
		 * @return New value
		 * @type {String}
		 * @private
		 */
		_setValue: function (value) {
			if (this.widgets.calendar) {
				this.widgets.calendar.set("date", value);
				
				if (this.get("time")) {
					this.setCalendarTime(value); 
				}
				
				//For validation we use calendar to get value
				value = value ? this.getCalendarDate() : "";
			}
			
			//Super
			Input.superclass._setValue.apply(this, [value]);
			
			//Update UI
			this.syncUI();
			
			return value;
		},
		
		/**
		 * Set min-date
		 * 
		 * @param {Date} date
		 * @return Date
		 * @type {Date}
		 * @private
		 */
		_setMinDate: function (minDate) {
			if (this.widgets.calendar) {
				this.widgets.calendar.set("minDate", minDate);
				return this.widgets.calendar.get("minDate");
			}
			
			return minDate;
		},
		
		/**
		 * Set max-date
		 * 
		 * @param {Date} date
		 * @return Date
		 * @type {Date}
		 * @private
		 */
		_setMaxDate: function (maxDate) {
			if (this.widgets.calendar) {
				this.widgets.calendar.set("maxDate", maxDate);
				return this.widgets.calendar.get("maxDate");
			}
			
			return maxDate;
		}
	
	});
	
	Supra.Input.Date = Input;
	
	//Since this widget has Supra namespace, it doesn"t need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto", "supra.calendar"]});YUI.add("supra.input-block-background", function (Y) {
	//Invoke strict mode
	"use strict";
	
	// Shortcuts
	var Manager = Supra.Manager;
	
	/*
	 * Block background input, should be used only in block properties
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "block-background";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		// Node to which should be applied background
		"targetNode": {
			value: null
		},
		// Tag name used to identify styles for block
		"selectorTagName": {
			value: "BLOCK"
		},
		// Select list values attribute getter
		"values": {
			value: null,
			getter: "_getSelectListValues"
		},
		"editImageAutomatically": {
			value: true,
			setter: "_setEditImageAutomatically"
		},
		"allowRemoveImage": {
			value: true,
			setter: "_setAllowRemoveImage"
		},
		/**
		 * Render widget into separate slide and add
		 * button to the place where this widget should be
		 */
		"separateSlide": {
			value: true
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * List of supporting widgets:
		 *   selectList
		 *   buttonCustom
		 *   buttonSet
		 *   buttonEdit
		 *   buttonRemove
		 *   imageResizer
		 * @type {Object}
		 * @private
		 */
		widgets: null,
		
		/**
		 * Selected custom image info
		 * @type {Object}
		 * @private
		 */
		image: null,
		
		/**
		 * Slideshow slide containing "Set", "Manage", "Remove" buttons
		 * @type {Object}
		 * @private
		 */
		slide: null,
		
		
		/**
		 * Render needed widgets
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.widgets = {};
			this.image = null;
			
			var inputNode = this.get("inputNode"),
				renderTarget = inputNode.get("parentNode"),
				values = this.getBackgroundStyles(),
				value = this.get("value");
			
			// Select list
			// Visible only if there are other options than "No image" and "Custom"
			var selectList = new Supra.Input.SelectVisual({
				"values": values,
				"value": value ? (value.image ? "_custom" : value.classname || "") : "",
				"visible": values.length > 2
			});
			
			selectList.render(renderTarget);
			inputNode.insert(selectList.get("boundingBox"), "before");
			selectList.buttons._custom.hide();
			
			this.widgets.selectList = selectList;
			
			// Button "Custom image"
			if (this.get('separateSlide')) {
				
				var button = new Supra.Button({
					'label': Supra.Intl.get(["form", "block", "custom_image"]),
					'style': 'group',
					'groupStyle': 'mid',
					'iconStyle': '',
					'icon': ''
				});
				
				button.addClass("button-section");
				button.on("click", this.openSlide, this);
				button.render(renderTarget);
				inputNode.insert(button.get("boundingBox"), "before");
				
				this.widgets.buttonCustom = button;
			} else {
				this.openSlide();
			}
			
			//Handle value attribute change
			selectList.on("valueChange", this._afterValueChange, this);
		},
		
		/**
		 * Attach event listeners
		 */
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
		},
		
		/**
		 * Returns parent widget by class name
		 * 
		 * @param {String} classname Parent widgets class name
		 * @return Widget instance or null if not found
		 * @private
		 */
		getParentWidget: function (classname) {
			var parent = this.get("parent");
			while (parent) {
				if (parent.isInstanceOf(classname)) return parent;
				parent = parent.get("parent");
			}
			return null;
		},
		
		/**
		 * Returns properties widget
		 */
		getPropertiesWidget: function () {
			var form = this.getParentWidget("form"),
				parent = form ? form.get("parent") : null;
			
			if (parent && parent.isInstanceOf('page-content-properties')) {
				return parent
			}
			
			return null;
		},
		
		
		/* ------------------------------ Sidebar -------------------------------- */
		
		
		/**
		 * Show settings form
		 */
		showSettingsSidebar: function () {
			var form = this.getParentWidget("form"), 
				properties = this.getPropertiesWidget(),
				group = null;
			
			if (form && properties) {
				//We can get input group from input definition
				group = (form.getConfig(this.get("id")) || {}).group || "";
				
				properties.showPropertiesForm(group);
			} else {
				//Not part of block properties, search for Action
				var parent = this.getParentWidget("ActionBase");
				if (parent && parent.plugins.getPlugin("PluginSidebar")) {
					//Has sidebar plugin, so this action is in sidebar
					if (parent.get("frozen")) {
						//In frozen state show/execute are not called, so we have to
						//force it to show content
						parent.showFrozen();
						parent.set("frozen", false);
					} else {
						parent.execute();
					}
				}
			}
			
			if (this.image) {
				this.startEditing();
			}
		},
		
		
		/* ----------------------------- Image edit ------------------------------- */
		
		
		/**
		 * Start image editing
		 */
		startEditing: function () {
			var imageResizer = this.widgets.imageResizer,
				block = this.get("root"),
				node = this.get("targetNode") || (block && block.getNode ? block.getNode().one("*") : null),
				size = this.image.image.sizes.original;
			
			if (!node) {
				// There are no nodes for this block
				return false;
			}
			
			if (!imageResizer) {
				imageResizer = this.widgets.imageResizer = new Supra.ImageResizer({
					"mode": Supra.ImageResizer.MODE_BACKGROUND
				});
				imageResizer.on("resize", function (event) {
					var value = this.get("value"),
						image = value.image;
					
					//Update crop, etc.
					image.crop_top = event.cropTop;
					image.crop_left = event.cropLeft;
					image.crop_width = event.cropWidth;
					image.crop_height = event.cropHeight;
					image.size_width = event.imageWidth;
					image.size_height = event.imageHeight;
					
					this.set("value", value);
					
					if (!event.silent) {
						this.blur();
					}
				}, this);
			}
			
			imageResizer.set("maxImageHeight", size.height);
			imageResizer.set("maxImageWidth", size.width);
			imageResizer.set("image", node);
			
			this.focus();
			return true;
		},
		
		/**
		 * Stop editing image
		 */
		stopEditing: function () {
			var imageResizer = this.widgets.imageResizer;
			if (imageResizer) {
				imageResizer.set("image", null);
				this.blur();
			}
		},
		
		/**
		 * Remove selected image
		 */
		removeImage: function () {
			this.stopEditing();
			
			this.set("value", {
				"classname": "",
				"image": null
			});
			
			this.closeSlide();
		},
		
		/**
		 * Returns background styles from stylesheet
		 * 
		 * @return List of styles
		 * @type {Array}
		 * @private
		 */
		getBackgroundStyles: function () {
			var block = this.get("root"),
				styles = [],
				result = [],
				tagName = null;
			
			result.push({
				"id": "",
				"title": Supra.Intl.get(["form", "block", "no_image"]),
				"icon": "/cms/lib/supra/build/input/assets/skins/supra/icons/icon-block-background-none.png"
			});
			
			if (block && block.getStylesheetParser) {
				tagName = this.get("selectorTagName");
				styles = block.getStylesheetParser().getSelectorsByTag(tagName);
				
				for (var i=0, ii=styles.length; i<ii; i++) {
					result.push({
						"id": styles[i].classname,
						"title": styles[i].attributes.title,
						"icon": styles[i].attributes.icon
					});
				}
			}
			
			// This option is not visible
			result.push({
				"id": "_custom",
				"title": ""
			});
			
			return result;
		},
		
		/**
		 * Apply image styles after input value changes
		 * 
		 * @private
		 */
		applyImageStyle: function (image) {
			var styles = {'backgroundImage': 'none', 'backgroundSize': 'auto', 'backgroundPosition': '0 0'},
				block = this.get("root"),
				node = this.get("targetNode") || (block && block.getNode ? block.getNode().one("*") : null),
				size = null;
			
			if (node) {
				if (image) {
					size = image.image.sizes.original;
					if (size) {
						styles = {	
							'backgroundImage': 'url(' + size.external_path + ')',
							'backgroundSize': image.size_width + 'px ' + image.size_height + 'px',
							'backgroundPosition': -image.crop_left + 'px ' + (-image.crop_top) + 'px'
						};
					}
				}
				
				node.setStyles(styles);
			}
		},
		
		
		/* ---------------------------- Media sidebar ------------------------------ */
		
		
		/**
		 * Set image
		 */
		openMediaSidebar: function () {
			// Close settings form
			var properties = this.getPropertiesWidget(),
				deferred = new Supra.Deferred();
			
			if (properties) {
				properties.hidePropertiesForm({
					"keepToolbarButtons": true // we keep them because settings sidebar is hidden temporary
				});
			} else {
				// Not part of block properties, search for Action
				var parent = this.getParentWidget("ActionBase");
				if (parent && parent.plugins.getPlugin("PluginSidebar")) {
					// Freeze to prevent from closing, so that we can restore the state
					// after media sidebar is closed
					parent.set("frozen", true);
				}
			}
			
			// Stop editing image
			this.stopEditing();
			
			//Open MediaSidebar
			var mediasidebar = Supra.Manager.getAction("MediaSidebar"),
				form = this.getParentWidget("form"),
				path = this.image && this.image.image ? [].concat(this.image.image.path).concat(this.image.image.id) : 0;
			
			mediasidebar.execute({
				"onselect": Y.bind(function (data) {
					this.insertImage(data);
					deferred.resolve([data]);
				}, this),
				"onclose": Y.bind(function () {
					this.showSettingsSidebar();
					deferred.resolve([this.get('value')]);
				}, this),
				"hideToolbar": true,
				"item": path,
				"dndEnabled": false
			});
			
			return deferred.promise();
		},
		
		/**
		 * On image insert change input value
		 * 
		 * @private
		 */
		insertImage: function (data) {
			this.set("value", {
				"classname": "_custom",
				"image": {
					"image": data.image,
					"crop_left": 0,
					"crop_top": 0,
					"crop_width": data.image.sizes.original.width,
					"crop_height": data.image.sizes.original.height,
					"size_width": data.image.sizes.original.width,
					"size_height": data.image.sizes.original.height
				}
			});
			
			//Start editing image
			if (this.get("editImageAutomatically")) {
				//Small delay to allow media library to close before doing anything
				Y.later(100, this, function () {
					if (this._hasImage()) {
						this.startEditing();
					}
				});
			}
		},
		
		
		/* ------------------------------ Slideshow -------------------------------- */
		
		
		/**
		 * Open slideshow slide
		 */
		openSlide: function () {
			var slideshow = this.getSlideshow(),
				slide = this.getSlideshowSlide();
			
			if (!this.get('separateSlide')) {
				
				if (this.get("editImageAutomatically") && this._hasImage()) {
					this.startEditing();
				}
				
			} else if (slideshow && slide) {
				
				slideshow.set("slide", this.get("id") + "_slide");
				
				if (this.get("editImageAutomatically") && this._hasImage()) {
					this.startEditing();
				}
				
			}
		},
		
		/**
		 * Close slideshow slide
		 */
		closeSlide: function () {
			var slideshow = this.getSlideshow();
			if (slideshow && slideshow.get("slide") == this.get("id") + "_slide") {
				slideshow.scrollBack();
			}
		},
		
		/**
		 * When slideshow slide changes back then stop editing
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		onSlideshowSlideChange: function (event) {
			var slide_id = this.get("id") + "_slide";
			
			if (event.newVal != event.prevVal) {
				if (event.prevVal == slide_id) {
					this.stopEditing();
				}
			}
		},
		
		/**
		 * Returns slideshow slide for image controls
		 * 
		 * @return Slideshow slide
		 * @type {Object}
		 * @private
		 */
		getSlideshowSlide: function () {
			if (this.slide) return this.slide;
			
			var slideshow = this.getSlideshow(),
				has_image = this._hasImage(),
				slide = null,
				slide_id = this.get("id") + "_slide",
				button = null,
				separate = this.get("separateSlide"),
				
				container = null,
				boundingBox = null;
			
			if (slideshow || !separate) {
				if (separate) {
					slide = this.slide = slideshow.addSlide({
						'id': slide_id,
						'title': this.get('label')
					});
					container = slide.one(".su-slide-content");
					slideshow.on("slideChange", this.onSlideshowSlideChange, this);
				} else {
					boundingBox = this.get('boundingBox');
					container = boundingBox.ancestor();
				}
				
				//Set button
				button = this.widgets.buttonSet = (new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "set_image"]),
					"style": "small"
				}));
				button.on("click", this.openMediaSidebar, this);
				button.addClass("su-button-fill");
				button.render(container);
				
				if (boundingBox) {
					boundingBox.insert(button.get('boundingBox'), 'before');
				}
				
				//Edit button
				button = this.widgets.buttonEdit = (new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "edit_image"]),
					"style": "small"
				}));
				button.on("click", this.startEditing, this);
				button.addClass("su-button-fill");
				button.set("disabled", !has_image);
				button.render(container);
				
				if (boundingBox) {
					boundingBox.insert(button.get('boundingBox'), 'before');
				}
				
				if (this.get("editImageAutomatically")) {
					button.hide();
				}
				
				//Remove button
				button = this.widgets.buttonRemove = (new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "remove_image"]),
					"style": "small-red"
				}));
				button.on("click", this.removeImage, this);
				button.addClass("su-button-fill");
				button.set("disabled", !has_image);
				button.set("visible", this.get("allowRemoveImage"));
				button.render(container);
				
				if (boundingBox) {
					boundingBox.insert(button.get('boundingBox'), 'before');
				}
				
				//When slide is hidden stop editing image
				if (separate) {
					slideshow.on("slideChange", function (evt) {
						if (evt.prevVal == slide_id && this.widgets.imageResizer) {
							this.widgets.imageResizer.set("image", null);
							this.blur();
						}
					}, this);
				}
				
				return slide;
			}
			
			return null;
		},
		
		/**
		 * Returns slideshow
		 * 
		 * @return Slideshow
		 * @type {Object}
		 * @private
		 */
		getSlideshow: function () {
			var form = this.getParentWidget("form");
			return form ? form.get("slideshow") : null;
		},
		
		
		/* ------------------------------ Attributes -------------------------------- */
		
		
		/**
		 * Returns true if image is selected, otherwise false
		 * 
		 * @return True if image is selected
		 * @type {Boolean}
		 * @private
		 */
		_hasImage: function () {
			var value = this.get("value");
			return value && value.image;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {Object} value Value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_setValue: function (value) {
			value = (value === undefined || value === null ? "" : value);
			
			this.image = value && value.image ? value.image : "";
			
			if (this.widgets) {
				//Update UI
				var classname = value && value.classname ? value.classname : (value.image ? "_custom" : "");
				this.widgets.selectList.set("value", classname);
				
				if (this.widgets.buttonSet) {
					if (this.image) {
						this.widgets.buttonSet.set("label", Supra.Intl.get(["form", "block", "change_image"]));
					} else {
						this.widgets.buttonSet.set("label", Supra.Intl.get(["form", "block", "set_image"]));
					}
				}
				if (this.widgets.buttonRemove) {
					if (this.image) {
						this.widgets.buttonRemove.set("disabled", false);
					} else {
						this.widgets.buttonRemove.set("disabled", true);
					}
				}
				if (this.widgets.buttonEdit) {
					if (this.image) {
						this.widgets.buttonEdit.set("disabled", false);
					} else {
						this.widgets.buttonEdit.set("disabled", true);
					}
				}
				
				// Standalone button background preview
				if (this.widgets.buttonCustom) {
					var button = this.widgets.buttonCustom,
						style = '',
						icon = null;
					
					if (value && value.image && value.image.image) {
						icon = Supra.getObjectValue(value, ['image', 'image', 'sizes', '200x200', 'external_path']);
					}
					
					if (icon) {
						button.set('iconStyle', '');
					} else {
						button.set('iconStyle', 'center');
						style = 'center';
						icon = '/cms/lib/supra/build/input/assets/skins/supra/icons/select-visual-none.png'
					}
					
					if (button.get('iconStyle') != style) {
						button.set('iconStyle', style);
					}
					
					button.set('icon', icon);					
				}
			}
			
			this.applyImageStyle(this.image);
			
			/*
			 * value == {
			 * 	   classname: "",
			 *     image: ""
			 * }
			 * 
			 */
			this._original_value = value;
			return value;
		},
		
		/**
		 * Value attribute getter
		 * Returns input value, object with "classname" and "image" keys
		 * 
		 * @return {Object}
		 * @private
		 */
		_getValue: function () {
			if (!this.widgets || !this.widgets.selectList) {
				return {
					"classname": "",
					"image": ""
				};
			}
			
			var value = {
				"classname": this.widgets.selectList.get("value") || "",
				"image": this.image ? this.image : ""
			};
			
			if (value.classname == "_custom") {
				value.classname = "";
			} else {
				value.image = "";
			}
			
			/*
			 * value == {
			 * 	   "classname": "",
			 *     "image": {
			 * 	       "image": { ... image data ... },
			 *         "crop_height": Number, "crop_width": Number, "crop_left": Number, "crop_top": Number,
			 *         "size_width": Number, "size_height": Number
			 *     }
			 * }
			 */
			return value;
		},
		
		/**
		 * Returns value for saving
		 * 
		 * @return {Object}
		 * @private
		 */
		_getSaveValue: function () {
			var value = this.get("value");
			
			if (value.image && value.image.image) {
				//We want to send only image ID
				//We clone image info to be sure that we don't overwrite info
				value.image = Supra.mix({}, value.image, {
					"image": value.image.image.id
				});
			}
			
			/*
			 * value == {
			 * 	   "classname": "",
			 *     "image": {
			 * 	       "image": "...id...",
			 *         "crop_height": Number, "crop_width": Number, "crop_left": Number, "crop_top": Number,
			 *         "size_width": Number, "size_height": Number
			 *     }
			 * }
			 */
			return value;
		},
		
		/**
		 * Values attribute getter
		 * Returns select list values
		 * 
		 * @return {Array}
		 * @private
		 */
		_getSelectListValues: function () {
			return this.widgets && this.widgets.selectList ? this.widgets.selectList.get("values") : [];
		},
		
		/**
		 * After value change trigger event
		 * @param {Object} evt
		 */
		_afterValueChange: function (evt) {
			this.fire("change", {"value": this.get("value")});
		},
		
		/**
		 * When slide is opened start editing instead of waiting for user to click "Edit" button
		 * @param {Boolean} value Attribute value
		 * @return {Boolean} New attribute value
		 */
		_setEditImageAutomatically: function (value) {
			var button = this.widgets.buttonEdit;
			if (button) {
				button.set("visible", !value);
			}
			return value;
		},
		
		/**
		 * Allow removing image / allow having no image
		 * @param {Boolean} value Attribute value
		 * @return {Boolean} New attribute value
		 */
		_setAllowRemoveImage: function (value) {
			var button = this.widgets.buttonRemove;
			if (button) {
				button.set("visible", value);
			}
			return value;
		}
		
	});
	
	Supra.Input.BlockBackground = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto"]});YUI.add('supra.input-image-inline', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-image-inline';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		// Image node which is edited
		"targetNode": {
			value: null
		},
		//Blank image URI or data URI
		"blankImageUrl": {
			value: "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="
		},
		// Resize image crop to smaller size on zoom if needed
		"allowZoomResize": {
			value: false
		},
		// Change zoom on crop resize if needed
		"allowCropZooming": {
			value: false
		},
		// Stop editing when clicked outside image
		"autoClose": {
			value: true
		},
		// Max crop width is fixed and container can't increase in size
		"fixedMaxCropWidth": {
			value: true
		}
	};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.BlockBackground, {
		
		/**
		 * Render needed widgets
		 */
		renderUI: function () {
			Supra.Input.BlockBackground.superclass.renderUI.apply(this, arguments);
			
			this.widgets = {};
			this.image = null;
			
			var inputNode = this.get("inputNode"),
				renderTarget = inputNode.get("parentNode"),
				value = this.get("value");
			
			// Button "Custom image"
			if (this.get('separateSlide')) {
				var buttonCustom = new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "custom_image"]),
					"style": "small-gray"
				});
				buttonCustom.addClass("button-section");
				buttonCustom.on("click", this.openSlide, this);
				buttonCustom.render(renderTarget);
				inputNode.insert(buttonCustom.get("boundingBox"), "before");
				
				this.widgets.buttonCustom = buttonCustom;
			} else {
				this.openSlide();
			}
		},
		
		/**
		 * Update inline editable style
		 */
		syncUI: function () {
			this._applyStyle(this.get('value'));
		},
		
		
		/* ----------------------------- Image edit ------------------------------- */
		
		
		/**
		 * Start image editing
		 */
		startEditing: function () {
			if (!this.image || !this.image.image) {
				// No data for image to edit
				return false;
			}
			
			var imageResizer = this.widgets.imageResizer,
				node = this.get("targetNode"),
				size = this.image.image.sizes.original;
			
			if (!node) {
				return false;
			}
			
			if (!imageResizer) {
				imageResizer = this.widgets.imageResizer = new Supra.ImageResizer({
					"mode": Supra.ImageResizer.MODE_IMAGE,
					"allowZoomResize": this.get("allowZoomResize"),
					"allowCropZooming": this.get("allowCropZooming"),
					"autoClose": this.get("autoClose")
				});
				imageResizer.on("resize", function (event) {
					var value = this.get("value");
					
					//Update crop, etc.
					value.crop_top = event.cropTop;
					value.crop_left = event.cropLeft;
					value.crop_width = event.cropWidth;
					value.crop_height = event.cropHeight;
					value.size_width = event.imageWidth;
					value.size_height = event.imageHeight;
					
					this.set("value", value);
					
					if (!event.silent) {
						this.blur();
					}
				}, this);
			}
			
			imageResizer.set("maxCropWidth", this.get('fixedMaxCropWidth') ? Math.min(size.width, this._getContainerWidth()) : 0);
			imageResizer.set("maxImageHeight", size.height);
			imageResizer.set("maxImageWidth", size.width);
			imageResizer.set("minImageHeight", 32);
			imageResizer.set("minImageWidth", 32);
			imageResizer.set("image", node);
			
			this.focus();
			return true;
		},
		
		/**
		 * Remove selected image
		 */
		removeImage: function () {
			this.set("value", null);
			this.closeSlide();
		},
		
		
		/* ---------------------------- Media sidebar ------------------------------ */
		
		
		/**
		 * On image insert change input value
		 * 
		 * @private
		 */
		insertImage: function (data) {
			var container_width = this._getContainerWidth(),
				width  = data.image.sizes.original.width,
				height = data.image.sizes.original.height,
				ratio  = 0;
			
			if (!this.get('fixedMaxCropWidth') && container_width < 100) {
				container_width = 100;
			}
			
			if (container_width && width > container_width) {
				ratio = width / height;
				width = container_width;
				height = Math.round(width / ratio);
			}
			
			this.set("value", {
				"image": data.image,
				"crop_left": 0,
				"crop_top": 0,
				"crop_width": width,
				"crop_height": height,
				"size_width": width,
				"size_height": height
			});
			
			//Start editing image
			if (this.get("editImageAutomatically")) {
				//Small delay to allow icon sidebar to close before doing anything (eg. opening settings sidebar)
				Y.later(100, this, function () {
					if (this._hasImage()) {
						this.startEditing();
					}
				});
			}
		},
		
		
		/* ------------------------------ Attributes -------------------------------- */
		
		
		/**
		 * Returns true if image is selected, otherwise false
		 * 
		 * @return True if image is selected
		 * @type {Boolean}
		 * @private
		 */
		_hasImage: function () {
			var value = this.get("value");
			return value;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {Object} value Value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_setValue: function (value) {
			value = (value === undefined || value === null || typeof value !== "object" ? "" : value);
			
			if (value) {
				value.crop_left = value.crop_left || 0;
				value.crop_top = value.crop_top || 0;
			}
			
			this.image = value ? value : "";
			
			if (this.widgets) {
				//Update UI
				if (this.widgets.buttonSet) {
					if (this.image) {
						this.widgets.buttonSet.set("label", Supra.Intl.get(["form", "block", "change_image"]));
					} else {
						this.widgets.buttonSet.set("label", Supra.Intl.get(["form", "block", "set_image"]));
					}
				}
				if (this.widgets.buttonRemove) {
					if (this.image) {
						this.widgets.buttonRemove.set("disabled", false);
					} else {
						this.widgets.buttonRemove.set("disabled", true);
					}
				}
				if (this.widgets.buttonEdit) {
					if (this.image) {
						this.widgets.buttonEdit.set("disabled", false);
					} else {
						this.widgets.buttonEdit.set("disabled", true);
					}
				}
			}
			
			this._applyStyle(value);
			
			/*
			 * value == {
			 * 	   "" // or image
			 * }
			 * 
			 */
			this._original_value = value;
			return value;
		},
		
		/**
		 * Value attribute getter
		 * Returns input value
		 * 
		 * @return {Object}
		 * @private
		 */
		_getValue: function () {
			return this.image ? this.image : "";
			
			/*
			 * value == {
			 * 	   "image": { ... image data ... },
			 *     "crop_height": Number, "crop_width": Number, "crop_left": Number, "crop_top": Number,
			 *     "size_width": Number, "size_height": Number
			 * }
			 */
		},
		
		/**
		 * Returns value for saving
		 * 
		 * @return {Object}
		 * @private
		 */
		_getSaveValue: function () {
			var value = this.get("value");
			
			if (value && value.image) {
				//We want to send only image ID
				//We clone image info to be sure that we don't overwrite info
				value = Supra.mix({}, value, {
					"image": value.image.id
				});
			}
			
			/*
			 * value == {
			 * 	   "image": "...id...",
			 *     "crop_height": Number, "crop_width": Number, "crop_left": Number, "crop_top": Number,
			 *     "size_width": Number, "size_height": Number
			 * }
			 */
			return value;
		},
		
		/**
		 * Apply style
		 * 
		 * @private
		 */
		_applyStyle: function (value) {
			var node = this.get("targetNode"),
				container = null;
			
			if (!node || !node.getDOMNode()) return;
			container = node.ancestor();
			
			if (value) {
				if (this.get('fixedMaxCropWidth')) {
					value.crop_width = Math.min(value.crop_width, this._getContainerWidth());
				}
				
				if (!container.hasClass("supra-image")) {
					var doc = node.getDOMNode().ownerDocument;
					container = Y.Node(doc.createElement("span"));
					
					node.insert(container, "after");
					container.addClass("supra-image");
					container.append(node);
				}
				
				node.setStyles({
					"margin": -value.crop_top + "px 0 0 -" + value.crop_left + "px",
					"width": value.size_width + "px",
					"height": value.size_height + "px"
				});
				node.setAttribute("width", value.size_width);
				node.setAttribute("height", value.size_height);
				node.setAttribute("src", Supra.getObjectValue(value, ['image', 'sizes', 'original', 'external_path']) || this.get('blankImageUrl'));
				
				container.setStyles({
					"width": value.crop_width + "px",
					"height": value.crop_height + "px"
				});
			} else {
				node.setStyles({
					"margin": "0",
					"width": "",
					"height": ""
				});
				
				node.setAttribute("src", this.get("blankImageUrl"));
				node.removeAttribute("width");
				node.removeAttribute("height");
				
				if (container && container.hasClass("supra-image")) {
					container.setStyles({
						"width": "auto",
						"height": "auto"
					});
				}
			}
		},
		
		/**
		 * Returns container node width / max crop width
		 * 
		 * @private
		 */
		_getContainerWidth: function () {
			var node = this.get("targetNode"),
				container = null,
				width = 0;
			
			if (!node) return 0;
			
			container = node.ancestor();
			if (!container) return 0;
			
			// Find container width to calculate max possible width
			while (container.test('.supra-image, .supra-image-inner')) {
				container = container.ancestor();
			}
			
			return container.get("offsetWidth");
		}
		
	});
	
	Supra.Input.InlineImage = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-block-background"]});YUI.add("supra.input-icon-inline", function (Y) {
	//Invoke strict mode
	"use strict";
	
	// Shortcuts
	var Manager = Supra.Manager;
	
	/*
	 * Block background input, should be used only in block properties
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-icon-inline";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		// Node to which should be applied background
		"targetNode": {
			value: null
		},
		// Tag name used to identify styles for block
		"selectorTagName": {
			value: "BLOCK"
		},
		
		"editImageAutomatically": {
			value: true,
			setter: "_setEditImageAutomatically"
		},
		"allowRemoveImage": {
			value: true,
			setter: "_setAllowRemoveImage"
		},
		/**
		 * Render widget into separate slide and add
		 * button to the place where this widget should be
		 */
		"separateSlide": {
			value: true
		},
		
		// Resize image crop to smaller size on zoom if needed
		"allowZoomResize": {
			value: true
		},
		// Stop editing when clicked outside image
		"autoClose": {
			value: true
		},
		// Max crop width is fixed and container can't increase in size
		"fixedMaxCropWidth": {
			value: true
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * List of supporting widgets:
		 *   selectList
		 *   buttonCustom
		 *   buttonSet
		 *   buttonEdit
		 *   buttonRemove
		 *   imageResizer
		 * @type {Object}
		 * @private
		 */
		widgets: null,
		
		/**
		 * Selected icon info
		 * @type {Object}
		 * @private
		 */
		icon: null,
		
		/**
		 * Slideshow slide containing "Set", "Manage", "Remove" buttons
		 * @type {Object}
		 * @private
		 */
		slide: null,
		
		
		/**
		 * Render needed widgets
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.widgets = {};
			this.icon = null;
			
			var inputNode = this.get("inputNode"),
				renderTarget = inputNode.get("parentNode"),
				value = this.get("value");
			
			// Button "Custom image"
			if (this.get('separateSlide')) {
				var buttonCustom = new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "custom_icon"]),
					"style": "small-gray"
				});
				buttonCustom.addClass("button-section");
				buttonCustom.on("click", this.openSlide, this);
				buttonCustom.render(renderTarget);
				inputNode.insert(buttonCustom.get("boundingBox"), "before");
				
				this.widgets.buttonCustom = buttonCustom;
			} else {
				this.openSlide();
			}
		},
		
		/**
		 * Attach event listeners
		 */
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
		},
		
		/**
		 * Update inline editable style
		 */
		syncUI: function () {
			this._applyStyle(this.get('value'));
		},
		
		/**
		 * Returns parent widget by class name
		 * 
		 * @param {String} classname Parent widgets class name
		 * @return Widget instance or null if not found
		 * @private
		 */
		getParentWidget: function (classname) {
			var parent = this.get("parent");
			while (parent) {
				if (parent.isInstanceOf(classname)) return parent;
				parent = parent.get("parent");
			}
			return null;
		},
		
		/**
		 * Returns properties widget
		 */
		getPropertiesWidget: function () {
			var form = this.getParentWidget("form"),
				parent = form ? form.get("parent") : null;
			
			if (parent && parent.isInstanceOf('page-content-properties')) {
				return parent
			}
			
			return null;
		},
		
		
		/* ------------------------------ Sidebar -------------------------------- */
		
		
		/**
		 * Show settings form
		 */
		showSettingsSidebar: function () {
			var form = this.getParentWidget("form"), 
				properties = this.getPropertiesWidget(),
				group = null;
			
			if (form && properties) {
				//We can get input group from input definition
				group = (form.getConfig(this.get("id")) || {}).group || "";
				
				properties.showPropertiesForm(group);
			} else {
				//Not part of block properties, search for Action
				var parent = this.getParentWidget("ActionBase");
				if (parent && parent.plugins.getPlugin("PluginSidebar")) {
					//Has sidebar plugin, so this action is in sidebar
					if (parent.get("frozen")) {
						//In frozen state show/execute are not called, so we have to
						//force it to show content
						parent.showFrozen();
						parent.set("frozen", false);
					} else {
						parent.execute();
					}
				}
			}
			
			if (this.icon) {
				this.startEditing();
			}
		},
		
		
		/* ----------------------------- Image edit ------------------------------- */
		
		
		/**
		 * Start image editing
		 */
		startEditing: function () {
			if (!this.icon || !this.icon.isDataComplete()) {
				// No data for image to edit
				return false;
			}
			
			var imageResizer = this.widgets.imageResizer,
				node = this.get("targetNode"),
				
				ratio = this.icon.width / this.icon.height,
				min_width = 16,
				min_height = Math.round(min_width / ratio),
				max_width = 940,
				max_height = Math.round(max_width / ratio);
			
			if (!node) {
				return false;
			}
			
			if (!imageResizer) {
				imageResizer = this.widgets.imageResizer = new Supra.ImageResizer({
					"mode": Supra.ImageResizer.MODE_ICON,
					"allowZoomResize": this.get("allowZoomResize"),
					"autoClose": this.get("autoClose"),
					"minCropWidth": min_width,
					"minCropHeight": min_height
				});
				imageResizer.on("resize", function (event) {
					var value = this.get("value");
					
					//Update size
					value.width = event.imageWidth;
					value.height = event.imageHeight;
					
					this.set("value", value);
					
					if (!event.silent) {
						this.blur();
					}
				}, this);
			}
			
			if (this.get('fixedMaxCropWidth')) {
				max_width = Math.min(max_width, this._getContainerWidth());
				max_height = Math.round(max_width / ratio);
			}
			
			imageResizer.set("maxImageHeight", max_height);
			imageResizer.set("maxImageWidth", max_width);
			imageResizer.set("minImageHeight", min_height);
			imageResizer.set("minImageWidth", min_width);
			imageResizer.set("image", node);
			
			this.focus();
			return true;
		},
		
		/**
		 * Stop editing image
		 */
		stopEditing: function () {
			var imageResizer = this.widgets.imageResizer;
			if (imageResizer) {
				imageResizer.set("image", null);
				this.blur();
			}
		},
		
		/**
		 * Remove selected image
		 */
		removeImage: function () {
			this.stopEditing();
			
			this.set("value", {
				"classname": "",
				"image": null
			});
			
			this.closeSlide();
		},
		
		
		/* ---------------------------- Media sidebar ------------------------------ */
		
		
		/**
		 * Set image
		 */
		openIconSidebar: function () {
			// Close settings form
			var properties = this.getPropertiesWidget();
			if (properties) {
				properties.hidePropertiesForm({
					"keepToolbarButtons": true // we keep them because settings sidebar is hidden temporary
				});
			} else {
				// Not part of block properties, search for Action
				var parent = this.getParentWidget("ActionBase");
				if (parent && parent.plugins.getPlugin("PluginSidebar")) {
					// Freeze to prevent from closing, so that we can restore the state
					// after media sidebar is closed
					parent.set("frozen", true);
				}
			}
			
			// Stop editing image
			this.stopEditing();
			
			//Open MediaSidebar
			var iconsidebar = Supra.Manager.getAction("IconSidebar"),
				form = this.getParentWidget("form");
			
			iconsidebar.execute({
				"onselect": Y.bind(this.insertIcon, this),
				"onclose": Y.bind(this.showSettingsSidebar, this),
				"hideToolbar": true,
				"item": [this.icon ? this.icon.id || 0 : 0],
				"dndEnabled": false
			});
		},
		
		/**
		 * On image insert change input value
		 * 
		 * @private
		 */
		insertIcon: function (data) {
			var container_width = this._getContainerWidth(),
				width  = data.width,
				height = data.height,
				ratio = width / height,
				
				min_width = 16,
				min_height = Math.round(min_width / ratio),
				max_width = 940,
				max_height = Math.round(max_width / ratio);
				
			if (!this.get('fixedMaxCropWidth') && container_width < min_width) {
				container_width = min_width;
			}
			
			if (container_width && width > container_width) {
				ratio = width / height;
				width = container_width;
				height = Math.round(width / ratio);
			}
			
			data.width = width;
			data.height = height;
			this.set("value", data);
			
			//Start editing image
			if (this.get("editImageAutomatically")) {
				//Small delay to allow icon sidebar to close before doing anything (eg. opening settings sidebar)
				Y.later(100, this, function () {
					if (this._hasIcon()) {
						this.startEditing();
					}
				});
			}
		},
		
		
		/* ------------------------------ Slideshow -------------------------------- */
		
		
		/**
		 * Open slideshow slide
		 */
		openSlide: function () {
			var slideshow = this.getSlideshow(),
				slide = this.getSlideshowSlide();
			
			if (!this.get('separateSlide')) {
				
				if (this.get("editImageAutomatically") && this._hasIcon()) {
					this.startEditing();
				}
				
			} else if (slideshow && slide) {
				
				slideshow.set("slide", this.get("id") + "_slide");
				
				if (this.get("editImageAutomatically") && this._hasIcon()) {
					this.startEditing();
				}
				
			}
		},
		
		/**
		 * Close slideshow slide
		 */
		closeSlide: function () {
			var slideshow = this.getSlideshow();
			if (slideshow && slideshow.get("slide") == this.get("id") + "_slide") {
				slideshow.scrollBack();
			}
		},
		
		/**
		 * When slideshow slide changes back then stop editing
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		onSlideshowSlideChange: function (event) {
			var slide_id = this.get("id") + "_slide";
			
			if (event.newVal != event.prevVal) {
				if (event.prevVal == slide_id) {
					this.stopEditing();
				}
			}
		},
		
		/**
		 * Returns slideshow slide for image controls
		 * 
		 * @return Slideshow slide
		 * @type {Object}
		 * @private
		 */
		getSlideshowSlide: function () {
			if (this.slide) return this.slide;
			
			var slideshow = this.getSlideshow(),
				has_icon = this._hasIcon(),
				slide = null,
				slide_id = this.get("id") + "_slide",
				button = null,
				separate = this.get("separateSlide"),
				
				container = null,
				boundingBox = null;
			
			if (slideshow || !separate) {
				if (separate) {
					slide = this.slide = slideshow.addSlide(slide_id);
					container = slide.one(".su-slide-content");
					slideshow.on("slideChange", this.onSlideshowSlideChange, this);
				} else {
					boundingBox = this.get('boundingBox');
					container = boundingBox.ancestor();
				}
				
				//Set button
				button = this.widgets.buttonSet = (new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "set_icon"]),
					"style": "small"
				}));
				button.on("click", this.openIconSidebar, this);
				button.addClass("su-button-fill");
				button.render(container);
				
				if (boundingBox) {
					boundingBox.insert(button.get('boundingBox'), 'before');
				}
				
				//Edit button
				button = this.widgets.buttonEdit = (new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "edit_icon"]),
					"style": "small"
				}));
				button.on("click", this.startEditing, this);
				button.addClass("su-button-fill");
				button.set("disabled", !has_icon);
				button.render(container);
				
				if (boundingBox) {
					boundingBox.insert(button.get('boundingBox'), 'before');
				}
				
				if (this.get("editImageAutomatically")) {
					button.hide();
				}
				
				//Remove button
				button = this.widgets.buttonRemove = (new Supra.Button({
					"label": Supra.Intl.get(["form", "block", "remove_icon"]),
					"style": "small-red"
				}));
				button.on("click", this.removeImage, this);
				button.addClass("su-button-fill");
				button.set("disabled", !has_icon);
				button.set("visible", this.get("allowRemoveImage"));
				button.render(container);
				
				if (boundingBox) {
					boundingBox.insert(button.get('boundingBox'), 'before');
				}
				
				//When slide is hidden stop editing image
				if (separate) {
					slideshow.on("slideChange", function (evt) {
						if (evt.prevVal == slide_id && this.widgets.imageResizer) {
							this.widgets.imageResizer.set("image", null);
							this.blur();
						}
					}, this);
				}
				
				return slide;
			}
			
			return null;
		},
		
		/**
		 * Returns slideshow
		 * 
		 * @return Slideshow
		 * @type {Object}
		 * @private
		 */
		getSlideshow: function () {
			var form = this.getParentWidget("form");
			return form ? form.get("slideshow") : null;
		},
		
		
		/* ------------------------------ Attributes -------------------------------- */
		
		
		/**
		 * Returns true if image is selected, otherwise false
		 * 
		 * @return True if image is selected
		 * @type {Boolean}
		 * @private
		 */
		_hasIcon: function () {
			var value = this.get("value");
			return value;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {Object} value Value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_setValue: function (value) {
			value = (value === undefined || value === null || typeof value !== "object" ? "" : value);
			
			if (value && !(value instanceof Y.DataType.Icon)) {
				value = new Y.DataType.Icon(value);
			}
			
			this.icon = value ? value : "";
			
			if (this.widgets) {
				//Update UI
				if (this.widgets.buttonSet) {
					if (this.icon) {
						this.widgets.buttonSet.set("label", Supra.Intl.get(["form", "block", "change_icon"]));
					} else {
						this.widgets.buttonSet.set("label", Supra.Intl.get(["form", "block", "set_icon"]));
					}
				}
				if (this.widgets.buttonRemove) {
					if (this.icon) {
						this.widgets.buttonRemove.set("disabled", false);
					} else {
						this.widgets.buttonRemove.set("disabled", true);
					}
				}
				if (this.widgets.buttonEdit) {
					if (this.icon) {
						this.widgets.buttonEdit.set("disabled", false);
					} else {
						this.widgets.buttonEdit.set("disabled", true);
					}
				}
			}
			
			this._applyStyle(value);
			
			/*
			 * value == "" // or Y.DataType.Icon
			 * 
			 */
			this._original_value = value;
			return value;
		},
		
		/**
		 * Value attribute getter
		 * Returns input value
		 * 
		 * @return {Object}
		 * @private
		 */
		_getValue: function () {
			return this.icon ? this.icon : "";
			/*
			 * value == "" // or Y.DataType.Icon
			 */
		},
		
		/**
		 * Returns value for saving
		 * 
		 * @return {Object}
		 * @private
		 */
		_getSaveValue: function () {
			return this.get("value");
		},
		
		/**
		 * Apply style
		 * 
		 * @private
		 */
		_applyStyle: function (value) {
			var node = this.get("targetNode"),
				container = null;
			
			if (!node || !node.getDOMNode()) return;
			container = node.ancestor();
			
			if (value) {
				if (this.get('fixedMaxCropWidth')) {
					value.width = Math.min(value.width, this._getContainerWidth());
				}
				
				if (!container.hasClass("supra-icon")) {
					var doc = node.getDOMNode().ownerDocument;
					container = Y.Node(doc.createElement("span"));
					
					node.insert(container, "after");
					container.addClass("supra-icon");
					container.append(node);
				}
				
				value.render(node);
				
				container.setStyle('display', '');
				
				container.setStyles({
					"width": value.width,
					"height": value.height
				});
				
			} else {
				container.setStyle('display', 'none');
			}
		},
		
		/**
		 * After value change trigger event
		 * @param {Object} evt
		 */
		_afterValueChange: function (evt) {
			this.fire("change", {"value": this.get("value")});
		},
		
		/**
		 * When slide is opened start editing instead of waiting for user to click "Edit" button
		 * @param {Boolean} value Attribute value
		 * @return {Boolean} New attribute value
		 */
		_setEditImageAutomatically: function (value) {
			var button = this.widgets.buttonEdit;
			if (button) {
				button.set("visible", !value);
			}
			return value;
		},
		
		/**
		 * Allow removing image / allow having no image
		 * @param {Boolean} value Attribute value
		 * @return {Boolean} New attribute value
		 */
		_setAllowRemoveImage: function (value) {
			var button = this.widgets.buttonRemove;
			if (button) {
				button.set("visible", value);
			}
			return value;
		},
		
		/**
		 * Returns container node width / max crop width
		 * 
		 * @private
		 */
		_getContainerWidth: function () {
			var node = this.get("targetNode"),
				container = null,
				width = 0;
			
			if (!node) return 0;
			
			container = node.ancestor();
			if (!container) return 0;
			
			// Find container width to calculate max possible width
			while (container.test('.supra-icon, .supra-image-inner')) {
				container = container.ancestor();
			}
			
			return container.get("offsetWidth");
		}
		
	});
	
	Supra.Input.InlineIcon = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto"]});YUI.add('supra.input-video', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var REGEX_YOUTUBE  = /(http(s)?:)?\/\/(www\.)?(youtu\.be|youtube.[a-z]+)(\/embed\/|\/v\/|\/.*\&v=|\/.*\?v=|\/)([a-z0-9_\-]+)/i,
		REGEX_VIMEO    = /(http(s)?:)?\/\/(www\.)?(vimeo.com)(\/)([a-z0-9_\-]+)/i,
		REGEX_FACEBOOK = /(http(s)?:)?\/\/(www\.)?(facebook.com)(\/.*video_id=)([a-z0-9_\-]+)/i;
	
	/**
	 * Video input type
	 * 
	 * Value format if entered an embed code or link:
	 * 		resource: "source",
	 * 		source: "...", // embed code or link url
	 * 
	 * Value format if entered a link:
	 * 		resource: "link",
	 * 		service: "...", // service name "youtube" or "vimeo"
	 * 		id: "...", // youtube or vimeo video ID
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-video';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		'allowAlign': {
			'value': false,
			'setter': '_setAllowAlign'
		},
		'minWidth': {
			value: 160
		},
		'maxWidth': {
			value: 0
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		LABEL_TEMPLATE: '', // No label on this widget
		
		/**
		 * Sub widgets, 'source'
		 * @type {Object}
		 * @private
		 */
		widgets: null,
		
		/**
		 * Last known value
		 * @type {Object}
		 * @private
		 */
		_last_value: null,
		
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.widgets = {};
			
			var source = this.widgets.source = new Supra.Input.Text({
				'label': this.get('label'),
				'value': this.get('value').source,
				'description': this.get('description'),
				'parent': this
			});
			
			source.render(this.get('contentBox'));
			
			// Align box
			var align = this.widgets.align = new Supra.Input.SelectList({
				"style": "minimal",
				"type": "SelectList",
				"label": Supra.Intl.get(["htmleditor", "video_alignment"]),
				"value": "middle",
				"values": [
					{"id": "left", "title": Supra.Intl.get(["htmleditor", "alignment_left"]), "icon": "/cms/lib/supra/img/htmleditor/align-left-button.png"},
					{"id": "middle", "title": Supra.Intl.get(["htmleditor", "alignment_center"]), "icon": "/cms/lib/supra/img/htmleditor/align-center-button.png"},
					{"id": "right", "title": Supra.Intl.get(["htmleditor", "alignment_right"]), "icon": "/cms/lib/supra/img/htmleditor/align-right-button.png"}
				]
			});
			
			align.render(this.get('contentBox'));
			
			if (!this.get('allowAlign')) {
				align.hide();
			}
			
			// Size box
			var sizeBox = this.widgets.sizeBox = Y.Node.create('<div class="clearfix su-sizebox"></div>');
			sizeBox.append('<p class="label">' + Supra.Intl.get(["inputs", "resize_video"]) + '</p>');
			
			// Width
			var width = this.widgets.width = new Supra.Input.String({
				'type': 'String',
				'style': 'size',
				'valueMask': /^[0-9]*$/,
				'label': Supra.Intl.get(['inputs', 'resize_width']),
				'value': 0
			});
			
			width.render(sizeBox);
			
			// Size button
			var btn = new Supra.Button({"label": "", "style": "small-gray"});
				btn.render(sizeBox);
				btn.set("disabled", true);
				btn.addClass("su-button-ratio");
				btn.addClass("su-button-locked");
			
			// Height
			var height = this.widgets.height = new Supra.Input.String({
				'type': 'String',
				'style': 'size',
				'valueMask': /^[0-9]*$/,
				'label': Supra.Intl.get(['inputs', 'resize_height']),
				'value': 0
			});
			
			height.render(sizeBox);
			this.get('contentBox').append(sizeBox);
		},
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			//Handle value attribute change
			this.on('valueChange', this._afterValueChange, this);
			
			//On inputs change update this widget too
			this.widgets.source.after('valueChange', this._onWidgetsChange, this, 'source');
			this.widgets.width.after('valueChange', this._onWidgetsChange, this, 'width');
			this.widgets.height.after('valueChange', this._onWidgetsChange, this, 'height');
			this.widgets.align.after('valueChange', this._onWidgetsChange, this, 'align');
			
			this.widgets.width.on('input', Supra.throttle(function (e) {
				if (this.widgets.width.get('focused')) {
					this._onWidthWidgetChange(e.value);
				}
			}, 250, this, true));
			
			this.widgets.height.on('input', Supra.throttle(function (e) {
				if (this.widgets.height.get('focused')) {
					this._onHeightWidgetChange(e.value);
				}
			}, 250, this, true));
			
			this.widgets.height.on('blur', function () {
				this._setValueTrigger = true;
				this.widgets.height.set('value', this._last_value.height); 
				this._setValueTrigger = false;
			}, this);
			
			this.widgets.width.on('blur', function () {
				this._setValueTrigger = true;
				this.widgets.width.set('value', this._last_value.width); 
				this._setValueTrigger = false;
			}, this);
		},
		
		/**
		 * Convert 'link' video data into 'source'
		 * 
		 * @param {Object} data Video data
		 * @returns {Object} Normalized video data
		 */
		normalizeData: function (data) {
			if (!data || !data.resource) {
				data = {'resource': 'source', 'source': '', 'width': 0, 'height': 0};
			} else if (data.resource == 'link'){
				data = Supra.mix({}, data);
				data.resource = 'source';
				
				switch (data.service) {
					case 'youtube':
						data.source = document.location.protocol + '//' + data.service + '.com/?v=' + data.id;
						break;
					case 'vimeo':
						data.source = document.location.protocol + '//' + data.service + '.com/' + data.id;
						break;
				}
				
				delete(data.id);
				delete(data.service);
			}
			
			if (this.get('allowAlign')) {
				if (data.align != 'left' && data.align != 'right' && data.align != 'middle') {
					data.align = 'middle';
				}
			}
			
			var ratio    = Input.getVideoSizeRatio(data),
				minWidth = this.get('minWidth'),
				maxWidth = this.get('maxWidth');
			
			if (data.width < minWidth) {
				data.width = minWidth;
				data.height = ~~(minWidth / ratio);
			} else if (maxWidth && data.width > maxWidth) {
				data.width = maxWidth;
				data.height = ~~(maxWidth / ratio);
			}
			
			return data;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {Object} data New input value
		 * @returns {Object} New input value
		 * @private
		 */
		_setValue: function (data) {
			this._setValueTrigger = true;
			
			var value  = '',
				// May not be rendered yet
				input  = this.widgets ? this.widgets.source : null,
				width  = this.widgets ? this.widgets.width : null,
				height = this.widgets ? this.widgets.height : null,
				align  = this.widgets ? this.widgets.align : null;
			
			data = this.normalizeData(data);
			value = data.source || '';
			
			if (input && input.get('value') !== value) {
				input.set('value', value);
			}
			if (width && width.get('value') !== data.width && !width.get('focused')) {
				width.set('value', data.width);
			}
			if (height && height.get('value') !== data.height && !height.get('focused')) {
				height.set('value', data.height);
			}
			if (align && align.get('value') !== data.align) {
				align.set('value', data.align);
			}
			
			this._last_value = data;
			this._setValueTrigger = false;
			
			return data;
		},
		
		/**
		 * Value attribute getter
		 * 
		 * @param {Object} data Old value
		 * @returns {Object} New value
		 * @private
		 */
		_getValue: function (data) {
			var source = this.widgets ? this.widgets.source : null,
				width  = this.widgets ? this.widgets.width : null,
				height = this.widgets ? this.widgets.height : null,
				align  = this.widgets ? this.widgets.align : null,
				value  = null; // May not be rendered yet
			
			value = {
				'resource': data && data.resource ? data.resource : 'source',
				'source': source ? source.get('value') : data.source || '',
				'width': parseInt(width ? width.get('value') : data.width, 10) || data.width || 0,
				'height': parseInt(height ? height.get('value') : data.height, 10) || data.height || 0
			};
			
			if (width && width.get('focused')) {
				value.width = data.width;
			}
			if (height && height.get('focused')) {
				value.height = data.height;
			}
			
			if (align && this.get('allowAlign')) {
				value.align = this.widgets.align.get('value');
			}
			
			return value;
		},
		
		/**
		 * Trigger change event when value changes
		 * 
		 * @param {Object} evt
		 */
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		/**
		 * Description attribute setter
		 * Set description on source input not this element
		 * 
		 * @param {String} descr Description text
		 * @return New description
		 * @type {String}
		 * @private
		 */
		_setDescription: function (descr) {
			if (this.widgets && this.widgets.source) {
				this.widgets.source.set('description', descr);
			}
			return descr;
		},
		
		/**
		 * Align property attribute setter
		 * 
		 * @param {Boolean} allow Allow align property setting
		 * @returns {Boolean} New attribute value
		 * @private
		 */
		_setAllowAlign: function (allow) {
			allow = !!allow;
			
			if (this.widgets && this.widgets.align) {
				if (allow) {
					this.widgets.align.show();
				} else {
					this.widgets.align.hide();
				}
			}
			
			return allow;
		},
		
		/**
		 * When widgets value changes update value for self
		 * 
		 * @param {Object} evt Event facade object
		 * @private
		 */
		_onWidgetsChange: function (evt, name) {
			if (this._setValueTrigger) return;
			
			if (name !== 'align') {
				this._setValueTrigger = true;
				
				var source = this.widgets.source.get('value'),
					match  = null,
					width  = 0,
					height = 0,
					value  = {},
					
					ratio  = Input.getVideoSizeRatio({
						'resource': 'source',
						'source': source
					});
				
				if (name == 'height') {
					height = parseInt(this.widgets.height.get('value'), 10) || 0;
					width = ~~(height * ratio);
					value.width = width;
					value.height = height;
					this.widgets.width.set('value', width);
				} else {
					width = parseInt(this.widgets.width.get('value'), 10) || 0;
					height = ~~(width / ratio);
					value.width = width;
					value.height = height;
					this.widgets.height.set('value', height);
				}
				
				if (name == 'source') {
					match = source.match(/width="?([\d]+)/);
					value.source = source;
					
					if (match) {
						width = parseInt(match[1], 10) || width;
						height = ~~(width / ratio); // we use original service ratio
						
						value.width = width;
						value.height = height;
						
						this.widgets.width.set('value', width);
						this.widgets.height.set('value', height);
					}
				}
				
				this._setValueTrigger = false;
			}
			
			this.set('value', Supra.mix(this.get('value'), value));
		},
		
		_onWidthWidgetChange: function (width) {
			var ratio = Input.getVideoSizeRatio({
					'resource': 'source',
					'source': this.widgets.source.get('value')
				}),
				height = ~~(width / ratio);
			
			this.set('value', Supra.mix(this.get('value'), {'width': width, 'height': height}));
		},
		
		_onHeightWidgetChange: function (height) {
			var ratio = Input.getVideoSizeRatio({
					'resource': 'source',
					'source': this.widgets.source.get('value')
				}),
				width = ~~(height * ratio);
			
			this.set('value', Supra.mix(this.get('value'), {'width': width, 'height': height}));
		}
		
	});
	
	/**
	 * Returns video width / height ratio
	 * 
	 * @param {Object} data Video data
	 * @returns {Number} Size ratio
	 */
	Input.getVideoSizeRatio = function (data) {
		var service = null,
			match = null,
			
			// http://youtu.be/...
			// http://www.youtube.com/v/...
			// http://www.youtube.com/...?v=...
			regex_youtube = REGEX_YOUTUBE,
			// http://vimeo.com/...
			regex_vimeo = REGEX_VIMEO,
			
			ratio_youtube = 16/9,
			ratio_vimeo   = 7/3;
		
		if (data) {
			if (data.resource == "link") {
				service = data.service;
			} else if (data.resource == "source") {
				if (match = data.source.match(regex_youtube)) {
					service = 'youtube';
				} else if (match = data.source.match(regex_vimeo)) {
					service = 'vimeo';
				}
			}
		}
		
		if (service == 'youtube') {
			return ratio_youtube;
		} else if (service == 'vimeo') {
			return ratio_vimeo;
		} else {
			// Default
			return ratio_youtube;
		}
	};
	
	/**
	 * Extract image url from video data
	 * 
	 * @param {Object} data Video data
	 * @returns {String} Image url
	 */
	Input.getVideoPreviewUrl = function (data) {
		var service = null,
			video_id = null,
			match = null,
			
			// http://youtu.be/...
			// http://www.youtube.com/v/...
			// http://www.youtube.com/...?v=...
			regex_youtube = REGEX_YOUTUBE,
			// http://vimeo.com/...
			regex_vimeo = REGEX_VIMEO,
			
			deferred = new Supra.Deferred();
		
		if (data) {
			if (data.resource == "link") {
				service = data.service;
				video_id = data.id;
			} else if (data.resource == "source") {
				if (match = data.source.match(regex_youtube)) {
					service = 'youtube';
					video_id = match[6];
				} else if (match = data.source.match(regex_vimeo)) {
					service = 'vimeo';
					video_id = match[6];
				}
			}
		}
		
		if (service == 'youtube') {
			deferred.resolveWith(this, [document.location.protocol + '//img.youtube.com/vi/' + video_id + '/0.jpg']);
		} else if (service == 'vimeo') {
			//
			var url = document.location.protocol + '//vimeo.com/api/v2/video/' + video_id + '.json';
			Supra.io(url, {
				'suppress_errors': true, // don't display errors
				'context': this,
				'on': {
					'complete': function (data, success) {
						if (data && data[0]) {
							deferred.resolveWith(this, [data[0].thumbnail_large]);
						} else {
							deferred.rejectWith(this, []);
						}
					}
				}
			});
		} else {
			deferred.rejectWith(this, []);
		}
		
		return deferred.promise();
	};
	
	
	
	Supra.Input.Video = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});YUI.add('supra.input-media-inline', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Vertical button list for selecting value
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-media-inline';
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	
	Input.ATTRS = {
		// Render widget into separate form
		// needed because image can be edited inline and in main form
		// InlineImage input may not be welcome
		'separateForm': {
			value: true
		},
		
		// Node inside which should be placed image or video
		'targetNode': {
			value: null,
			setter: '_setTargetNode'
		},
		
		// Button label to add video
		'labelAddVideo': {
			value: ''
		},
		
		// Button label to add image
		'labelAddImage': {
			value: ''
		},
		
		//Blank image URI or data URI
		'blankImageUrl': {
			value: "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="
		},
		
		// Allow file upload using drag and drop
		'allowDropUpload': {
			value: true
		},
		
		// Image upload folder id
		'uploadFolderId': {
			value: 0
		},
		
		// Editing state
		'editing': {
			value: false
		},
		
		// Stop editing when clicked outside image
		"autoClose": {
			value: true
		},
		
		// Allow inserting video
		"allowVideo": {
			value: true
		},
		
		// Allow inserting image
		'allowImage': {
			value: true
		},
		
		// Max crop width is fixed to container width and container can't increase 
		'fixedMaxCropWidth': {
			value: true
		},
		
		// Resize image crop to smaller size on zoom if needed
		'allowZoomResize': {
			value: false
		},
		// Change zoom on crop
		'allowCropZooming': {
			value: false
		}
	};
	
	Input.HTML_PARSER = {
		
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		LABEL_TEMPLATE: '',
		DESCRIPTION_TEMPLATE: '',
		
		widgets: null,
		
		/**
		 * Value type 'video', 'image' or empty stirng if not set yet
		 * @type {String}
		 * @private
		 */
		type: '',
		
		/**
		 * Value is being updated by input, don't change UI
		 * @type {Boolean}
		 * @private
		 */
		silentValueUpdate: false,
		
		/**
		 * Video or image input value is being updated by this input
		 * @type {Boolean}
		 * @private
		 */
		silentChildValueUpdate: false,
		
		
		/**
		 * On desctruction life cycle clean up
		 * 
		 * @private
		 */
		destructor: function () {
			if (this.widgets) {
				var slideshow = this.get('slideshow'),
					inputs = this.widgets.inputs,
					slides = this.widgets.slides,
					uploader = this.widgets.uploader,
					key = null;
				
				if (slideshow) {
					
					for (key in inputs) {
						inputs[key].destroy();
					}
					for (key in slides) {
						slideshow.removeSlide(key);
					}
					
				}
				
				if (uploader) {
					uploader.destroy();
				}
				
				this.widgets = null;
			}
		},
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			var form = this.getParentWidget("form"),
				slideshow = this.getSlideshow(),
				input_image = null,
				input_video = null,
				slide_image = slideshow.addSlide({'id': this.get('id') + '_slide_image', 'title': this.get('label') || ''}),
				slide_video = slideshow.addSlide({'id': this.get('id') + '_slide_video', 'title': this.get('label') || ''}),
				delete_image = null,
				delete_video = null,
				uploader = null,
				target = null;
			
			// Drag and drop upload
			if (this.get('allowDropUpload')) {
				target = this.get('targetNode');
				uploader = new Supra.Uploader({
					'clickTarget': null,
					'dropTarget': this._getDropTargetNode(target),
					
					'allowBrowse': false,
					'allowMultiple': false,
					'accept': 'image/*',
					
					'requestUri': Supra.Manager.getAction('MediaLibrary').getDataPath('upload'),
					'uploadFolderId': this.get('uploadFolderId')

				});
			}
			
			// Since we are using InlineImage and Video we don't need to show this input
			this.get('boundingBox').addClass('hidden');
			
			// Inputs
			input_image = new Supra.Input.InlineImage({
				'id': this.get('id') + '_input_image',
				'label': Supra.Intl.get(['inputs', 'image']),
				'parent': this,
				'value': null,
				'separateSlide': false,
				'allowRemoveImage': false,
				'autoClose': this.get('autoClose'),
				'fixedMaxCropWidth': this.get('fixedMaxCropWidth'),
				'allowZoomResize': this.get('allowZoomResize'),
				'allowCropZooming': this.get('allowCropZooming')
			});
			
			input_video = new Supra.Input.Video({
				'id': this.get('id') + '_input_video',
				'label': Supra.Intl.get(['inputs', 'video_label']),
				'description': Supra.Intl.get(['inputs', 'video_description']),
				'parent': this,
				'value': null
			});
			
			input_image.render(slide_image.one('.su-slide-content'));
			input_video.render(slide_video.one('.su-slide-content'));
			
			// Buttons
			delete_image = new Supra.Button({
				'style': 'small-red',
				'label': Supra.Intl.get(['inputs', 'media', 'delete_image'])
			});
			
			delete_video = new Supra.Button({
				'style': 'small-red',
				'label': Supra.Intl.get(['inputs', 'media', 'delete_video'])
			});
			
			delete_image.render(slide_image.one('.su-slide-content'));
			delete_video.render(slide_video.one('.su-slide-content'));
			
			delete_image.addClass("su-button-fill");
			delete_video.addClass("su-button-fill");
			
			this.widgets = {
				// Separate slides
				'slide_image': slide_image,
				'slide_video': slide_video,
				
				// Inputs
				'input_image': input_image,
				'input_video': input_video,
				
				// Buttons
				'delete_image': delete_image,
				'delete_video': delete_video,
				
				// File uploader
				'uploader': uploader
			};
			
			this.renderContent(this.get('targetNode'), this.get('value'));
		},
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var input_image  = this.widgets.input_image,
				input_video  = this.widgets.input_video,
				
				delete_image = this.widgets.delete_image,
				delete_video = this.widgets.delete_video,
				
				uploader     = this.widgets.uploader;
			
			// Video input events
			input_video.on('focus', this.focus, this);
			//input_video.on('blur', this.blur, this); // any sub-input blur causes this, we can't use it!
			
			input_video.on('change', function () {
				this.updateVideoPreviewImage();
				this._fireValueChange();
			}, this);
			
			// Image input events
			input_image.on('focus', this.focus, this);
			input_image.on('blur', this.blur, this);
			
			input_image.on('change', function () {
				this._fireValueChange();
			}, this);
			input_image.on('valueChange', function () {
				this._fireValueChange();
			}, this);
			
			// Button events
			delete_image.on('click', this.removeMedia, this);
			delete_video.on('click', this.removeMedia, this);
			
			// Change event
			this.on('valueChange', this._afterValueChange, this);
			
			// Uploader events
			if (uploader) {
				uploader.on('file:upload',   this._onFileUploadStart, this);
				uploader.on('file:complete', this._onFileUploadEnd, this);
				uploader.on('file:error',    this._onFileUploadError, this);
			}
		},
		
		
		/*
		 * ---------------------------------------- FILE UPLOAD ----------------------------------------
		 */
		
		
		/**
		 * Handle file upload start
		 * 
		 * @private
		 */
		_onFileUploadStart: function (e) {
			// data.title, data.filename, data.id
			var data = e.details[0];
		},
		
		/**
		 * Handle file upload end
		 * 
		 * @private
		 */
		_onFileUploadEnd: function (e) {
			var data = e.details[0]
			this.insertImageData(data);
		},
		
		/**
		 * Handle file upload error
		 * 
		 * @private
		 */
		_onFileUploadError: function (e) {
			// Error
		},
		
		/**
		 * Returns drag and drop target node
		 * 
		 * @private
		 */
		_getDropTargetNode: function (node) {
			return node ? node.closest('.supra-slideshowmanager-wrapper') || node : null;
		},
		
		
		/*
		 * ---------------------------------------- SLIDESHOW ----------------------------------------
		 */
		
		
		/**
		 * Open specific slide
		 * 
		 * @param {String} slide_id Slide id
		 * @private
		 */
		openSpecificSlide: function (slide_id) {
			var slideshow = this.getSlideshow();
			
			slideshow.set('noAnimations', true);
			slideshow.set('slide', slide_id);
			slideshow.set('noAnimations', false);
			
			if (this.get('separateSlide')) {
				Supra.Manager.PageContentSettings.get('backButton').hide();
			} else {
				var evt = slideshow.on('slideChange', function (e) {
					if (e.newVal != e.prevVal && e.prevVal == slide_id) {
						evt.detach();
						
						if (this.get('focused')) {
							this.set('editing', false);
							this.stopEditing();
						}
					}
				}, this);
			}
		},
		
		/**
		 * Open slide matching value
		 */
		openSlide: function () {
			if (this.type === 'video') {
				this.openSpecificSlide(this.get('id') + '_slide_video');
			} else if (this.type === 'image') {
				this.openSpecificSlide(this.get('id') + '_slide_image');
			}
		},
		
		/**
		 * Close slide
		 */
		closeSlide: function () {
			var slideshow = this.getSlideshow(),
				current = null,
				slide_image = this.get('id') + '_slide_image',
				slide_video = this.get('id') + '_slide_video';
			
			if (slideshow) {
				current = slideshow.get("slide");
				if (current == slide_image || current == slide_video) {
					slideshow.scrollBack();
				}
			}
		},
		
		
		/* ------------------------------ SIDEBAR -------------------------------- */
		
		
		/**
		 * Show settings form
		 */
		showSettingsSidebar: function () {
			var form = this.getParentWidget("form"), 
				properties = this.getParentWidget("page-content-properties"),
				group = null;
			
			if (form && properties) {
				//We can get input group from input definition
				group = (form.getConfig(this.get("id")) || {}).group || "";
				
				properties.showPropertiesForm(group);
			} else {
				//Not part of block properties, search for Action
				var parent = this.getParentWidget("ActionBase");
				if (parent && parent.plugins.getPlugin("PluginSidebar")) {
					//Has sidebar plugin, so this action is in sidebar
					if (parent.get("frozen")) {
						//In frozen state show/execute are not called, so we have to
						//force it to show content
						parent.showFrozen();
						parent.set("frozen", false);
					} else {
						parent.execute(form);
					}
				}
			}
			
			this.openSlide();
		},
		
		/**
		 * Hide settings form
		 */
		hideSettingsSidebar: function () {
			var form = this.getParentWidget("form"), 
				properties = this.getParentWidget("page-content-properties"),
				group = null;
			
			if (form && properties) {
				this.closeSlide();
				properties.hidePropertiesForm();
			} else {
				//Not part of block properties, search for Action
				var parent = this.getParentWidget("ActionBase");
				if (parent && parent.plugins.getPlugin("PluginSidebar")) {
					//Has sidebar plugin, so this action is in sidebar
					parent.hide();
				}
			}
		},
		
		
		/*
		 * ---------------------------------------- EDITING ----------------------------------------
		 */
		
		
		_setTargetNode: function (node) {
			if (this.get('rendered')) {
				this.renderContent(node, this.get('value'));
				
				var uploader = this.widgets.uploader;
				if (uploader) {
					uploader.set('dropTarget', this._getDropTargetNode(node));
					uploader.set('disabled', this.get('disabled'));
				}
				
				var input = this.widgets.input_video;
				if (input) {
					if (this.get('fixedMaxCropWidth') && node) {
						input.set('maxWidth', node.get('offsetWidth'));
					} else {
						input.set('maxWidth', 0);
					}
				}
			}
			return node;
		},
		
		/**
		 * Start editing input
		 */
		startEditing: function () {
			var state = false;
			
			if (!this.get('disabled') && !this.get('editing')) {
				if (this.type === 'video' || this.type === 'image') {
					this.set('editing', true);
					this.focus();
					
					this.showSettingsSidebar();
					
					if (this.type === 'video') {
						if (this.get('fixedMaxCropWidth')) {
							this.widgets.input_video.set('maxWidth', this.get('targetNode').get('offsetWidth'));
						} else {
							this.widgets.input_video.set('maxWidth', 0);
						}
						
						state = this.widgets.input_video.startEditing();
					} else {
						state = this.widgets.input_image.startEditing();
						
						if (!this.get('value').image) {
							// Open media library to choose image
							var promise = this.widgets.input_image.openMediaSidebar();
							promise.done(function (value) {
								if (!value) {
									// Image isn't selected, show "Image" / "Video" choice
									this.removeMedia();
									this.stopEditing();
								}
							}, this);
						}
					}
				}
			}
			
			return state;
		},
		
		/**
		 * Stop editing input
		 */
		stopEditing: function () {
			this.blur();
			
			if (this.type === 'video') {
				this.widgets.input_video.stopEditing();
			} else if (this.type === 'image') {
				this.widgets.input_image.stopEditing();
			}
			
			if (this.get('editing')) {
				this.hideSettingsSidebar();
				this.set('editing', false);
			}
		},
		
		insertImage: function () {
			this.set('value', {
				'type': 'image'
			});
			
			this.startEditing();
		},
		
		insertImageData: function (data) {
			var node = this.get('targetNode'),
				size = data.sizes.original,
				width = Math.min(size.width, node.get('offsetWidth')) || size.width,
				height = size.height;
			
			if (width != size.width) {
				// Change height
				height = Math.round(width / (size.width / size.height));
			}
			
			this.set('value', {
				'type': 'image',
				'crop_left': 0,
				'crop_top': 0,
				'crop_width': width,
				'crop_height': height,
				'size_height': height,
				'size_width': width,
				'image': data
			});
		},
		
		insertVideo: function () {
			var node   = this.get('targetNode'),
				ratio  = Supra.Input.Video.getVideoSizeRatio(),
				width  = node.get('offsetWidth'),
				height = ~~(width / ratio);
			
			this.set('value', {
				'type': 'video',
				'resource': 'source',
				'source': '',
				'width': width,
				'height': height
			});
			
			this.startEditing();
		},
		
		/**
		 * Remove image or video
		 * 
		 * @private
		 */
		removeMedia: function () {
			this.set('value', {'type': ''});
			this.hideSettingsSidebar();
			this.set('editing', false);
		},
		
		/**
		 * Render value inside content
		 * 
		 * @param {Object} node Node in which to render
		 * @param {Object} data Media data
		 * @private
		 */
		renderContent: function (node, data) {
			var node = node,
				type = data.type || this.type;
			
			if (!node) {
				this.widgets.input_image.set('targetNode', null);
				return;
			}
			
			if (data && type == 'image') {
				var style = null,
					//html = '<img class="as-layer" src="' + this.get('blankImageUrl') + '" width="100%" height="220" style="background: #e5e5e5 url(/cms/lib/supra/img/medialibrary/icon-broken-plain.png) 50% 50% no-repeat;" alt="" />';
					html = '<img class="as-layer" src="' + this.get('blankImageUrl') + '" width="100%" height="220" alt="" />';
				
				node.set('innerHTML', html);
				this.widgets.input_image.set('targetNode', node.one('img'));
				this.widgets.input_image.syncUI();
			} else {
				this.widgets.input_image.stopEditing();
				this.widgets.input_image.set('targetNode', null);
			}
			
			if (data && type == 'video') {
				var Input = Supra.Input.Video,
					width = data.width || node.get('offsetWidth'),
					height = ~~(width / Input.getVideoSizeRatio(data)),
					html = '<div class="supra-video" style="width: ' + width + 'px; height: ' + height + 'px;"></div>';
				
				node.set('innerHTML', html);
				this.updateVideoPreviewImage(data);
			}
			
			if (!data || (type !== 'image' && type !== 'video')) {
				// Empty with buttons
				var allow_video = this.get('allowVideo'),
					allow_image = this.get('allowImage'),
					tmp = null,
					
					label = this.get('label'),
					description = this.get('description'),
					
					html = (label ? '<h2>' + Y.Escape.html(label) + '</h2>' : '') +
						   (description ? '<p>' + Y.Escape.html(description) + '</p>' : '') +
						   '<div align="center" class="yui3-box-reset">' +
						       (allow_image ? ('<a class="supra-button" data-supra-action="addImage">' + (this.get('labelAddImage') || Supra.Intl.get(['inputs', 'media', 'add_image'])) + '</a>') : '') +
						       (allow_video ? ('<a class="supra-button" data-supra-action="addVideo">' + (this.get('labelAddVideo') || Supra.Intl.get(['inputs', 'media', 'add_video'])) + '</a>') : '') +
						   '</div>';
				
				node.addClass(this.getClassName('empty'));
				node.set('innerHTML', html);
				
				tmp = node.one('a[data-supra-action="addImage"]');
				if (tmp) tmp.on('click', this.insertImage, this);
				
				tmp = node.one('a[data-supra-action="addVideo"]');
				if (tmp) tmp.on('click', this.insertVideo, this);
			} else {
				node.removeClass(this.getClassName('empty'));
			}
		},
		
		/**
		 * Update video preview image size
		 * 
		 * @param {Object} data Video data
		 * @private
		 */
		updateVideoSize: function (node, data) {
			if (!node) return;
			
			var Input = Supra.Input.Video,
				width = parseInt(data.width, 10) || node.get('offsetWidth'),
				height = ~~(width / Input.getVideoSizeRatio(data));
			
			if (data.width != width) {
				data.width = width;
				data.height = height;
			}
			
			node.setStyles({
				'width': data.width + 'px',
				'height': data.height + 'px'
			});
		},
		
		/**
		 * Update video preview image
		 * 
		 * @param {Object} data Video data
		 * @private
		 */
		updateVideoPreviewImage: function (data) {
			var targetNode = this.get('targetNode');
			if (!targetNode) return;
			
			var Input = Supra.Input.Video,
				node = targetNode.one('.supra-video'),
				data = data || this.widgets.input_video.get('value');
			
			if (node) {
				Input.getVideoPreviewUrl(data).always(function (url) {
					if (url) {
						// Using setAttribute because it's not possible to use !important in styles
						node.setAttribute('style', 'background: #000000 url("' + url + '") no-repeat scroll center center !important; background-size: 100% !important;')
					} else {
						node.removeAttribute('style')
					}
					
					this.updateVideoSize(node, data);
				}, this);
			}
		},
		
		
		/*
		 * ---------------------------------------- VALUE ----------------------------------------
		 */
		
		
		/**
		 * Trigger value change events
		 * 
		 * @private
		 */
		_fireValueChange: function () {
			if (this.silentChildValueUpdate) return;
			
			this.silentValueUpdate = true;
			this.set('value', this.get('value'));
			this.silentValueUpdate = false;
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {Object} value New value
		 * @returns {Object} New value
		 * @private
		 */
		_setValue: function (value) {
			if (!this.widgets || this.silentValueUpdate) return value;
			this.silentChildValueUpdate = true;
			
			var data = Supra.mix({'type': ''}, value || {}),
				type = data.type;
			
			delete(data.type);
			
			if (type == 'image' && Y.Object.size(data)) {
				this.widgets.input_image.set('value', data);
			} else {
				this.widgets.input_image.set('value', null);
			}
			
			if (type == 'video') {
				if (data && !data.width) {
					var node = this.get('targetNode');
					if (node) {
						data.width = node.get('offsetWidth');
						data.height = ~~(data.width / Supra.Input.Video.getVideoSizeRatio(data));
					}
				}
				
				this.widgets.input_video.set('value', data);
			} else {
				this.widgets.input_video.set('value', null);
			}
			
			this.type = type;
			
			this.renderContent(this.get('targetNode'), data);
			
			this.silentChildValueUpdate = false;
			return value;
		},
		
		/**
		 * Value attribute getter
		 * 
		 * @returns {Object} Value
		 * @private
		 */
		_getValue: function (value) {
			if (!this.widgets) return value;
			
			var type = this.type,
				data = null;
			
			if (type == 'image') {
				data = this.widgets.input_image.get('value');
			} else if (type == 'video') {
				data = this.widgets.input_video.get('value');
			}
			
			if (data) {
				return Supra.mix({'type': type}, data);
			} else if (type) {
				return {'type': type};
			} else {
				return '';
			}
		},
		
		/**
		 * Returns value for saving
		 * 
		 * @return {Object}
		 * @private
		 */
		_getSaveValue: function () {
			var value = this.get("value");
			
			if (value && value.image) {
				//We want to send only image ID
				//We clone image info to be sure that we don't overwrite info
				value = Supra.mix({}, value, {
					"image": value.image.id
				});
			}
			
			/*
			 * value == {
			 * 	   "type": "image",
			 * 	   "image": "...id...",
			 *     "crop_height": Number, "crop_width": Number, "crop_left": Number, "crop_top": Number,
			 *     "size_width": Number, "size_height": Number
			 * }
			 */
			return value;
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		},
		
		/**
		 * Returns 'video' or 'image'
		 */
		getValueType: function () {
			var value = this.get('value');
		},
		
		/**
		 * Visible attribute setter
		 * 
		 * @private
		 */
		_uiSetVisible: function (visible) {
			return visible;
		}
		
	});
	
	Supra.Input.InlineMedia = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto', 'supra.uploader']});/**
 * Keyword input
 */
YUI.add("supra.input-keywords", function (Y) {
	//Invoke strict mode
	"use strict";
	
	/*
	 * Template
	 */
	var TEMPLATE_VALUES = Supra.Template.compile('<span class="suggestion-msg">Suggested:</span>\
				{% for value in values %}\
					<span data-value="{{ value|e }}">{{ value|e }}</span>\
				{% endfor %}\
			');
	
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-keywords";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		"inputNode": {
			value: null
		},
		"inputListNode": {
			value: null
		},
		"suggestionsNode": {
			value: null
		},
		"suggestionsListNode": {
			value: null
		},
		"suggestionRequestUri": {
			value: null
		},
		"values": {
			value: null
		},
		
		"suggestionsEnabled": {
			value: false,
			setter: '_setSuggestionsEnabled'
		}
	};
	
	Input.HTML_PARSER = {
		'suggestionsEnabled': function (srcNode) {
			var value = srcNode.getAttribute('suSuggestionsEnabled');
			if (value === "true" || value === true || value === 1) {
				return true;
			} else {
				return false;
			}
		}
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '<input type="text" value="" />',
		
		
		
		/**
		 * Key code constants
		 */
		KEY_RETURN:    13,
		KEY_ESCAPE:    27,
		KEY_COMMA:     188,
		KEY_SEMICOLON: 186,
		
		/**
		 * List of suggestions
		 * @private
		 */
		suggestions: [],
		
		/**
		 * Add needed nodes, etc.
		 * 
		 * @private
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.suggestions = [];
			
			var inputNode = this.get('inputNode'),
				inputListNode = Y.Node.create('<div class="input-list"></div>'),
				suggestionsNode = Y.Node.create('<div class="suggestions"></div>'),
				suggestionsButton = new Supra.Button({'label': '{#settings.suggestions#}', 'style': 'small', 'id': 'button-suggestions'}),
				suggestionsListNode = Y.Node.create('<div class="suggestions-list hidden"></div>'),
				suggestionsEnabled = this.get('suggestionsEnabled'),
				
				clearAllLabel = Supra.Intl.get(['settings', 'clear_all']),
				clearAllLink = new Y.Node.create('<a class="link-clear-all hidden">' + clearAllLabel + '</div>');

			inputNode.insert(inputListNode, 'after');
			inputListNode.append(inputNode);

			inputListNode.insert(suggestionsNode, 'after');
			suggestionsButton.render(suggestionsNode);
			suggestionsNode.append(suggestionsListNode);
			suggestionsNode.append(clearAllLink);

			this.set('suggestionsNode', suggestionsNode);
			this.set('suggestionsButton', suggestionsButton);
			this.set('suggestionsListNode', suggestionsListNode);
			this.set('clearAllLink', clearAllLink);
			this.set('inputListNode', inputListNode);
			
			if (!suggestionsEnabled) {
				suggestionsNode.addClass('hidden');
			}
			if (this.get('disabled')) {
				suggestionsButton.set('disabled', true);
			}
		},
		
		/**
		 * Attach event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var inputListNode = this.get('inputListNode'),
				suggestionsButton = this.get('suggestionsButton'),
				suggestionsListNode = this.get('suggestionsListNode'),
				clearAllLink = this.get('clearAllLink'),
				inputNode = this.get('inputNode');
			
			//On item click remove it
			inputListNode.delegate('click', this._onRemoveItem, 'a', this);
			
			//On click inside focus on input
			inputListNode.on('click', this.focus, this);

			//On button click load Items into suggestionList
			suggestionsButton.on('click', this.loadItems, this);

			//On item sugesstion click add it to suggestionsList
			suggestionsListNode.delegate('click', this.addSuggestion, 'span', this);

			//Onhide suggestion list
			clearAllLink.on('click', this.closeSuggestionsList, this);

			//Handle return and escape keys
			inputNode.on('keydown', this._onKeyDown, this);
			
			//Remove default behaviour, which is updating value on 'change'
			inputNode.detach('change');
			
			//On blur update item list
			inputNode.on('blur', this._onBlur, this);
			
			//Update value
			this.syncUI();
		},
		
		/**
		 * Update item list
		 */
		syncUI: function () {
			Input.superclass.syncUI.apply(this, arguments);
			
			var values = this.get('values'),
				inputListNode = this.get('inputListNode'),
				tempNode = null;
			
			if (!values) {
				values = [];
				this.set('values', values);
			}
			
			if (inputListNode) {
				inputListNode.all('span').remove();
				
				for(var i=values.length-1; i>=0; i--) {
					tempNode = Y.Node.create('<span></span>');
					tempNode.set('text', values[i]);
					tempNode.setAttribute('data-value', values[i]);
					tempNode.appendChild('<a></a>');
					inputListNode.prepend(tempNode);
				}
			}
			
			this.get('inputNode').set('value', '');
			
			this.updateScrollbars();
			
		},
		
		/**
		 * Load list of suggestions and populate list
		 * 
		 * @private
		 */
		loadItems: function () {
			this.get('suggestionsButton').set('loading', true);
			
			Supra.io(this.get('suggestionRequestUri'), {
				'data': {
					'page_id': Supra.data.get(['page', 'id'])
				},
				'on': {
					'complete': this.onLoadItems
				}
			}, this);
		},
		
		/**
		 * Handle suggestion load event
		 * 
		 * @param {Object} data Request response data
		 * @param {Boolean} status Request response status
		 * @private
		 */
		onLoadItems: function (data, status) {
			var suggestionsListNode = this.get('suggestionsListNode'),
				clearAllLink = this.get('clearAllLink'),
				values = this.get('values');
				
			if (status && data.length) {
				this.suggestions = data;
				suggestionsListNode.set('innerHTML', TEMPLATE_VALUES({'values': data}));
				
				this.showSuggestionList();
				
				if(values) {
					//Traverse all kewords and hide which are in suggestions list
					for(var j=0; j<=values.length-1; j++) {
						
						var node = Y.one('.suggestions-list span[data-value="' + values[j] + '"]');
						if (node) {
							node.addClass('hidden');
						}
					}
				}
					
			} else {
				this.suggestions = [];
				suggestionsListNode.set('innerHTML', '');
			}

			this.get('suggestionsButton').set('loading', false);
			this.updateScrollbars();
		},
		
		/**
		 * On blur add item to the list
		 * 
		 * @private
		 */
		_onBlur: function () {
			this.addItem(this.get('inputNode').get('value'));
			this.get('inputNode').set('value', '');
		},
		
		/**
		 * Handle escape and return keys
		 * 
		 * @param {Event} e Event fascade object
		 * @private
		 */
		_onKeyDown: function (e) {
			if (e.keyCode == this.KEY_RETURN || e.keyCode == this.KEY_COMMA || e.keyCode == this.KEY_SEMICOLON) {
				var inputValue = this.get('inputNode').get('value');
				this.addItem(inputValue);
				this.hideSuggestion(inputValue);
				this.get('inputNode').set('value', '');
				e.preventDefault();
			} else if (e.keyCode == this.KEY_ESCAPE) {
				this.get('inputNode').set('value', '');
				e.preventDefault();
			}
		},
		
		/**
		 * Remove item
		 * 
		 * @param {Event} e Event facade object
		 * @private
		 */
		_onRemoveItem: function (e) {
			if (this.get('disabled')) return;
			
			var target = e.target.closest('span'),
				value = target.getAttribute('data-value'),
				values = this.get('values'),
				index = null;
			
			if (!values) {
				values = [];
				this.set('values', values);
			}
			
			index = Y.Array.indexOf(values, value);
			
			if (index != -1) {
				values.splice(index, 1);
				target.remove();
			}
			
			// check if item was a suggestion and unhide it in suggestions list
			this.showSuggestion(value);
		},

		/**
		 * Add suggestion the list 
		 * 
		 * @param {Event} event
		 */
		addSuggestion: function (event) {
			if (this.get('disabled')) return;
			
			var target = event.target.closest('span'),
				value = target.getAttribute('data-value');
			
			this.addItem(value);
			this.hideSuggestion(value);
		},


		/**
		 * Hide suggestion in suggestion list 
		 * 
		 * @param {String} suggestion
		 */
		hideSuggestion: function (suggestion) {
			//check if suggestion is in items
			var escaped = Y.Escape.html(suggestion),
				node = Y.one('.suggestions-list span[data-value="' + escaped + '"]');
			
			if (node) {
				node.addClass('hidden');
			}
			
			this.updateScrollbars();
		},

		/**
		 * Show prevouisly hidden suggestion from suggestion list 
		 * 
		 * @param {String} suggestion
		 */
		showSuggestion: function (suggestion) {
			//check if suggestion is in items
			var escaped = Y.Escape.html(suggestion),
				node = Y.one('.suggestions-list span[data-value="' + escaped + '"]');
			
			if (node) {
				node.removeClass('hidden');
			}
			
			this.updateScrollbars();
		},
		
		/**
		 * Show suggestion list
		 * 
		 * @private
		 */
		showSuggestionList: function () {
			this.get('suggestionsButton').hide();
			this.get('suggestionsListNode').removeClass('hidden');
			this.get('clearAllLink').removeClass('hidden');
		},

		/**
		 * Hide Suggestion List
		 * 
		 * @private
		 */
		closeSuggestionsList: function () {
			if (this.get('disabled')) return;
			
			var suggestionsButton = this.get('suggestionsButton'),
				suggestionsListNode = this.get('suggestionsListNode'),
				clearAllLink = this.get('clearAllLink');

			if (suggestionsListNode) {
				suggestionsListNode.addClass('hidden');
			}
			if (clearAllLink) {
				clearAllLink.addClass('hidden');
			}
			if (suggestionsButton) {
				suggestionsButton.show();	
			}
			
			this.updateScrollbars();
		},
		

		/**
		 * Add item the list 
		 * 
		 * @param {String} value
		 */
		addItem: function (value) {
			var values = this.get('values'),
				index = -1,
				inputNode = this.get('inputNode'),
				tempNode = Y.Node.create('<span></span>');
							
			if (!values) {
				values = [];
				this.set('values', values);
			}
			
			//Validate
			value = Y.Lang.trim(value);
			if (!value.length) {
				// Empty
				return;
			}
			if (value.split(/\s+/).length > 5) {
				// More than 5 words, why this limit exists???
				return;
			}
			if (values.join(';').toLowerCase().indexOf(value.toLowerCase()) != -1) {
				// Already is in list
				return;
			}
			
			//Add item
			values.push(value);
			
			//Add node
			tempNode.set('text', value);
			tempNode.setAttribute('data-value', value);
			tempNode.appendChild('<a></a>');
			
			inputNode.insert(tempNode, 'before');
			
			this.updateScrollbars();
			
			//Events
			this.fire('change', {'value': this.get('value')});
		},
		
		/**
		 * Update scrollbar position and size
		 * 
		 * @private
		 */
		updateScrollbars: function () {
			var node = this.get('boundingBox').closest('.su-scrollable-content');
			if (node) {
				node.fire('contentResize');
			}
		},
		
		
		/* ------------------------------- ATTRIBUTES ------------------------------- */
		
		
		_setValue: function (value) {
			this.get('inputNode').set('value', value);
			this.set('values', value ? value.split(';') : []);
			this.closeSuggestionsList();
			
			this.syncUI();
			return value;
		},
		
		_getValue: function () {
			return (this.get('values') || []).join(';');
		},
		
		/**
		 * SuggestionsEnabled attribute setter
		 * 
		 * @param {Boolean} value
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setSuggestionsEnabled: function (enabled) {
			if (!this.get('rendered')) return !!enabled;
			
			if (enabled) {
				this.get('suggestionsNode').removeClass('hidden');
			} else {
				this.closeSuggestionsList();
				this.get('suggestionsNode').addClass('hidden');
			}
			
			return !!enabled;
		},
		
		/**
		 * Disabled attribute setter
		 * 
		 * @param {Boolean} value
		 * @return New value
		 * @type {Boolean}
		 * @private
		 */
		_setDisabled: function (value) {
			value = Input.superclass._setDisabled.apply(this, arguments);
			
			var button = this.get('suggestionsButton');
			if (button) {
				button.set('disabled', value);
			}
			
			return value;
		},
	
	});
	
	Supra.Input.Keywords = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn);this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto"]});
YUI.add('supra.input-set', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * List of input groups with controls to add or remove
	 * groups
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'input-set';
	Input.CSS_PREFIX = 'su-' + Input.NAME;
	Input.CLASS_NAME = 'su-input-set';
	
	Input.ATTRS = {
		
		// Properties for each set
		'properties': {
			value: null
		},
		
		// Render widget into separate slide and add
		// button to the place where this widget should be
		'separateSlide': {
			value: true
		},
		
		// Add more button label
		'labelAdd': {
			value: 'Add more'
		},
		
		// Remove button label
		'labelRemove': {
			value: 'Remove'
		},
		
		// Item number label
		'labelItem': {
			value: '#%s'
		},
		
		// Button label to use instead of "Label"
		'labelButton': {
			value: ''
		},
		
		// Button icon to use
		'icon': {
			value: null
		},
		
		// Minimal set count
		'minCount': {
			value: 0
		},
		
		// Maximal set count
		'maxCount': {
			value: 0
		}
	};
	
	Input.HTML_PARSER = {
		
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		
		/**
		 * Set count
		 * @type {Number}
		 * @private
		 */
		_count: 0,
		
		/**
		 * Slide content node
		 * @type {Object}
		 * @private
		 */
		_slideContent: null,
		
		/**
		 * Button to open slide
		 * @type {Object}
		 * @private
		 */
		_slideButton: null,
		
		/**
		 * Slide name
		 * @type {String}
		 * @private
		 */
		_slideId: null,
		
		/**
		 * "Add more" button
		 * @type {Object}
		 * @private
		 */
		_addButton: null,
		
		/**
		 * List of set nodes
		 * @type {Object}
		 * @private
		 */
		_nodes: null,
		
		/**
		 * List of set inputs, array of objects
		 * @type {Array}
		 * @private
		 */
		_inputs: null,
		
		/**
		 * Value is beeing updated by setter
		 * Don't trigger event
		 * @type {Boolean}
		 * @private
		 */
		_silentValueUpdate: false,
		
		/**
		 * Values has been rendered
		 * @type {Boolean}
		 * @private
		 */
		_valuesRendered: false,
		
		/**
		 * Focused list index
		 * @type {Number}
		 * @private
		 */
		_focusedSetIndex: 0,
		
		
		
		/**
		 * On desctruction life cycle clean up
		 * 
		 * @private
		 */
		destructor: function () {
			var count = this._count,
				i = count-1;
			
			for (; i >= 0; i--) {
				this._removeSet(i);
			}
			
			if (this._slideId) {
				var slideshow = this.getSlideshow();
				slideshow.removeSlide(this._slideId);
			}
			
			this._slideContent = null;
			this._slideId = null;
			this._inputs = [];
			this._nodes = [];
			this._count = 0;
			
			this._fireResizeEvent();
		},
		
		/**
		 * Life cycle method, render input
		 * 
		 * @private
		 */
		renderUI: function () {
			this._count = 0;
			this._nodes = [];
			this._inputs = [];
			
			// Create sets?
			if (this.get('separateSlide')) {
				var slideshow = this.getSlideshow();
				if (!slideshow) {
					this.set('separateSlide', false);
					Y.log('Unable to create new slide for Supra.Input.Set "' + this.get('id') + '", because slideshow can\'t be detected');
				} else {
					// Don't create description, we have a button
					this.DESCRIPTION_TEMPLATE = null;
				}
			}
			
			Input.superclass.renderUI.apply(this, arguments);
			
			// New item button
			var button = this._addButton = new Supra.Button({
				'label': this.get('labelAdd'),
				'style': 'small-gray'
			});
			button.addClass(button.getClassName('fill'));
			
			// Create slide or render data
			if (!this.get('separateSlide')) {
				this._createAllSets();
				button.render(this.get('contentBox'));
			} else {
				this._createSlide();
				button.render(this._slideContent);
			}
		},
		
		/**
		 * Life cycle method, attach event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			// When slide is opened for first time create inputs
			if (this.get('separateSlide')) {
				var slideshow = this.getSlideshow();
				var evt_handle = slideshow.on('slideChange', function (evt) {
					if (evt.newVal == this._slideId) {
						evt_handle.detach();
						this._createAllSets();
					}
				}, this);
				
				// On button click open slide
				this._slideButton.on('click', this._openSlide, this);
				
				// Disabled change
				this.on('disabledChange', function (event) {
					this._slideButton.set('disabled', event.newVal);
				}, this);
			}
			
			// Add new item on "Add more" click
			this._addButton.on('click', this.addSet, this);
			
			// Change event
			this.on('valueChange', this._afterValueChange, this);
		},
		
		
		/*
		 * ---------------------------------------- SETS ----------------------------------------
		 */
		
		
		/**
		 * Recreate sets from data
		 * 
		 * @private
		 */
		_createAllSets: function () {
			var data = this.get('value'),
				i = 0,
				ii = data.length;
			
			for (; i<ii; i++) {
				this._addSet(data[i]);
			}
			
			this._valuesRendered = true;
			this._fireResizeEvent();
			
			this.fire('setRender');
		},
		
		/**
		 * Add new set
		 * 
		 * @param {Object} data Set default input values
		 * @param {Boolean} animate Animate UI
		 * @private
		 */
		_addSet: function (data, animate) {
			var properties = this.get('properties'),
				i = 0,
				count = properties.length,
				form  = this.getForm(),
				node = Y.Node.create('<div class="' + this.getClassName('group') + '"></div>'),
				index = this._count,
				
				id = null,
				input = null,
				inputs = {},
				
				heading = null,
				button = null,
				
				container = null;
			
			data = data || {};
			
			// Create container node
			if (this.get('separateSlide')) {
				container = this._slideContent;
			} else {
				container = this.get('contentBox');
			}
			
			container.append(node);
			
			if (this._addButton) {
				container.append(this._addButton.get('boundingBox'));
			}
			
			// Create heading
			heading = inputs.nodeHeading = Y.Node.create('<h3>' + this.get('labelItem').replace('%s', index + 1) + '</h3>');
			node.append(heading);
			
			// Create inputs
			for (; i<count; i++) {
				id = properties[i].id;
				
				input = form.factoryField(Supra.mix({}, properties[i], {
					'id': id + '_' + Y.guid(),
					'name': id,
					'value': data[id],
					'parent': this
				}));
				
				input.render(node);
				
				//input.after('change', this._fireChangeEvent, this);
				input.after('valueChange', this._fireChangeEvent, this);
				input.on('focus', this._onInputFocus, this);
				input.on('input', this._fireInputEvent, this, id);
				
				inputs[id] = input;
			}
			
			// "Remove" button
			button = inputs.buttonRemove = new Supra.Button({
				'label': this.get('labelRemove'),
				'style': 'small-red'
			});
			button.addClass(button.getClassName('fill'));
			button.render(node);
			button.on('click', this._removeTargetSet, this, node);
			
			this._count++;
			this._nodes.push(node);
			this._inputs.push(inputs);
			
			if (animate) {
				this._animateIn(node);
			}
			
			if (this._valuesRendered) {
				this.fire('setRender', {'data': data});
			}
		},
		
		/**
		 * Remove set
		 * 
		 * @param {Number} index Set index
		 * @param {Boolean} animate Animate UI
		 * @private
		 */
		_removeSet: function (index, animate) {
			var nodes = this._nodes,
				inputs = this._inputs,
				count = this._count,
				
				tmp = null,
				key = null,
				
				node = null;
			
			if (index >=0 && index < count) {
				tmp = inputs[index];
				node = nodes[index];
				
				if (animate) {
					this._animateOut(node, tmp);
				} else {
					// Destroy inputs
					for (key in tmp) {
						if (tmp[key] && tmp[key].destroy) {
							tmp[key].destroy(true);
						}
					}
					
					node.remove(true);
				}
				
				inputs.splice(index, 1);
				nodes.splice(index, 1);
				this._count--;
				
				// Update all other set headings
				var i = index,
					ii = count - 1;
				
				for (; i<ii; i++) {
					inputs[i].nodeHeading.set('innerHTML', this.get('labelItem').replace('%s', i + 1));
				}
			}
		},
		
		/**
		 * Remove set in which "Remove" button was clicked
		 * 
		 * @param {Object} event Event facade object
		 * @param {Object} node Set node which needs to be removed
		 * @private
		 */
		_removeTargetSet: function (event, node) {
			var index = this._getSetIndex(node);
			this.removeSet(index);
		},
		
		addSet: function (data) {
			this._addSet(data, true);
			this._fireResizeEvent();
			this._fireChangeEvent();
			this.fire('add', data);
		},
		
		removeSet: function (index) {
			this.fire('remove', index);
			this._removeSet(index, true);
			this._fireResizeEvent();
			this._fireChangeEvent();
		},
		
		/**
		 * Returns set count
		 * 
		 * @returns {Number} Set count
		 */
		size: function () {
			return this._count;
		},
		
		/**
		 * Returns set index by node
		 * 
		 * @param {Object} node Set container node
		 * @returns {Number} Set index
		 * @private
		 */
		_getSetIndex: function (node) {
			var index = 0,
				selector = '.' + this.getClassName('group');
			
			node = node.closest(selector);
			
			while (node) {
				node = node.previous(selector);
				if (node) {
					index++;
				}
			}
			
			return index;
		},
		
		/**
		 * On input focus save set index
		 * 
		 * @param {Object} event Event facade object
		 * @private
		 */
		_onInputFocus: function (event) {
			this._focusedSetIndex = this._getSetIndex(event.target.get('srcNode'));
		},
		
		/**
		 * Returns widgets for set
		 * 
		 * @param {Number} index Set index
		 * @returns {Object} List of all widgets for set
		 */
		getSetWidgets: function (index) {
			if (index >= 0 && index < this._count) {
				return this._inputs[index];
			}
		},
		
		
		/*
		 * ---------------------------------------- ANIMATIONS ----------------------------------------
		 */
		
		
		/**
		 * Fade and slide in node
		 * 
		 * @param {Object} node Slide node which will be animated
		 * @private
		 */
		_animateIn: function (node) {
			var height = node.get('offsetHeight');
			
			node.setStyles({
				'overflow': 'hidden',
				'height': '0px',
				'opacity': 0
			});
			node.transition({
				'height': height + 'px',
				'opacity': 1,
				'duration': 0.35
			}, function () {
				node.removeAttribute('style');
			});
		},
		
		_animateOut: function (node, inputs) {
			node.setStyles({
				'overflow': 'hidden',
				'margin': 0,
				'padding': 0
			});
			node.transition({
				'height': '0px',
				'opacity': 0,
				'duration': 0.35
			}, function () {
				//Destroy inputs
				if (inputs) {
					for (var key in inputs) {
						if (inputs[key] && inputs[key].destroy) {
							inputs[key].destroy(true);
						}
					}
				}
				// Remove node
				node.remove(true);
			});
		},
		
		
		/*
		 * ---------------------------------------- SLIDESHOW ----------------------------------------
		 */
		
		
		/**
		 * Add slide to the slideshow
		 * 
		 * @private
		 */
		_createSlide: function () {
			var label = this.get('label'),
				labelButton = this.get('labelButton'),
				icon = this.get('icon'),
				
				slideshow = this.getSlideshow(),
				slide_id = this.get('id') + '_' + Y.guid(),
				slide = slideshow.addSlide({
					'id': slide_id,
					'title': label || labelButton
				});
			
			this._slideContent = slide.one('.su-slide-content');
			this._slideId = slide_id;
			
			// Button
			var button = new Supra.Button({
				'style': icon ? 'icon' : 'small',
				'label': labelButton || label,
				'icon': icon
			});
			
			button.addClass('button-section');
			button.render(this.get('contentBox'));
			
			this._slideButton = button;
		},
		
		_openSlide: function () {
			var slideshow = this.getSlideshow();
			slideshow.set('slide', this._slideId);
		},
		
		/**
		 * Fire resize event
		 * 
		 * @param {Object} node Node which content changed
		 * @private
		 */
		_fireResizeEvent: function () {
			var container = null;
			
			if (this.get('separateSlide')) {
				container = this._slideContent;
			} else {
				container = this.get('contentBox');
			}
			
			if (container) {
				container = container.closest('.su-scrollable-content');
				
				if (container) {
					container.fire('contentResize');
				}
			}
		},
		
		
		/*
		 * ---------------------------------------- VALUE ----------------------------------------
		 */
		
		
		/**
		 * Trigger value change events
		 * 
		 * @private
		 */
		_fireChangeEvent: function () {
			this._silentValueUpdate = true;
			this.set('value', this.get('value'));
			this._silentValueUpdate = false;
		},
		
		_fireInputEvent: function (event, property) {
			var index = this._focusedSetIndex;
			
			this.fire('input', {
				'value': event.value,
				'index': index,
				'property': property
			});
		},
		
		/**
		 * Value attribute setter
		 * 
		 * @param {Object} value New value
		 * @returns {Object} New value
		 * @private
		 */
		_setValue: function (value) {
			value = value || [];
			
			// If we are updating 'value' then don't change UI
			// If inputs hasn't been rendered then we can't set value
			if (!this.get('rendered') || this._silentValueUpdate || !this._valuesRendered) return value;
			
			// Remove old values
			var count = this._count,
				i = count-1;
			
			for (; i >= 0; i--) {
				this._removeSet(i);
			}
			
			// Add new values
			count = value.length;
			i = 0;
			
			for (; i<count; i++) {
				this._addSet(value[i]);
			}
			
			if (value) {
				// Value is missing when resetting form, not need to
				// fire resize event in that case
				this._fireResizeEvent();
			}
			
			return value;
		},
		
		/**
		 * Value attribute getter
		 * 
		 * @returns {Object} Value
		 * @private
		 */
		_getValue: function (value) {
			// If inputs hasn't been rendered then we can't get values from
			// inputs which doesn't exist
			if (!this.get('rendered') || !this._valuesRendered) return value;
			
			var i = 0,
				ii = this._count,
				data = [],
				item = null,
				properties = this.get('properties'),
				id = null,
				k = 0,
				kk = properties.length,
				inputs = this._inputs;
			
			for (; i<ii; i++) {
				item = {};
				
				for (k=0; k<kk; k++) {
					id = properties[k].id;
					item[id] = inputs[i][id].get('saveValue');
				}
				
				data.push(item);
			}
			
			return data;
		},
		
		_afterValueChange: function (evt) {
			this.fire('change', {'value': evt.newVal});
		}
		
	});
	
	Supra.Input.Set = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});
YUI.add('supra.input-group', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * List of input groups with controls to add or remove
	 * groups
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = 'group';
	Input.CSS_PREFIX = 'su-' + Input.NAME;
	Input.CLASS_NAME = 'su-input-group';
	
	Input.ATTRS = {
		
		// Properties for each set
		'properties': {
			value: null
		},
		
		// Only valid as separate slide
		'separateSlide': {
			value: true,
			readOnly: true
		},
		
		// Slide button style
		'buttonStyle': {
			value: 'small'
		},
		
		// Slide button label
		'labelButton': {
			value: ''
		},
		
		// Slide button icon
		'icon': {
			value: ''
		}
		
	};
	
	Input.HTML_PARSER = {
		
	};
	
	Y.extend(Input, Supra.Input.Proto, {
		
		INPUT_TEMPLATE: '<input type="hidden" value="" />',
		
		/**
		 * Slide content node
		 * @type {Object}
		 * @private
		 */
		_slideContent: null,
		
		/**
		 * Button to open slide
		 * @type {Object}
		 * @private
		 */
		_slideButton: null,
		
		/**
		 * Slide name
		 * @type {String}
		 * @private
		 */
		_slideId: null,
		
		/**
		 * List of inputs
		 * @type {Object}
		 * @private
		 */
		_inputs: null,
		
		
		
		/**
		 * On desctruction life cycle clean up
		 * 
		 * @private
		 */
		destructor: function () {
			if (this._slideId) {
				var slideshow = this.getSlideshow();
				slideshow.removeSlide(this._slideId);
			}
			
			this._slideContent = null;
			this._slideId = null;
		},
		
		/**
		 * Life cycle method, render input
		 * 
		 * @private
		 */
		renderUI: function () {
			// Create sets?
			if (this.get('separateSlide')) {
				var slideshow = this.getSlideshow();
				if (!slideshow) {
					this.set('separateSlide', false);
					Y.log('Unable to create new slide for Supra.Input.Group, because slideshow can\'t be detected');
				} else {
					// Don't create description, we have a button
					this.DESCRIPTION_TEMPLATE = null;
				}
			}
			
			Input.superclass.renderUI.apply(this, arguments);
			
			this._inputs = {};
			this._createSlide();
			this._createInputs();
			this._createButton();
		},
		
		/**
		 * Life cycle method, attach event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			// When slide is opened for first time create inputs
			if (this.get('separateSlide')) {
				var slideshow = this.getSlideshow();
				
				// On button click open slide
				if (this._slideButton) {
					this._slideButton.on('click', this._openSlide, this);
					
					// Disabled change
					this.on('disabledChange', function (event) {
						this._slideButton.set('disabled', event.newVal);
					}, this);
				}
			}
		},
		
		/**
		 * Returns all inputs in group
		 * 
		 * @returns {Object} Inputs in group
		 */
		getInputs: function () {
			return this._inputs || {};
		},
	

		/*
		 * ---------------------------------------- PROPERTIES ----------------------------------------
		 */
		
		
		_createInputs: function () {
			var properties = this.get('properties');
			if (!properties) return;
			
			var i = 0,
				count = properties.length,
				form  = this.getForm(),
				index = this._count,
				
				id = null,
				input = null,
				inputs = this._inputs = this._inputs || {},
				definition = null,
				
				heading = null,
				button = null,
				
				container = this._slideContent;
			
			// Create inputs
			for (; i<count; i++) {
				id = properties[i].id;
				
				definition = Supra.mix({}, properties[i], {
					'id': id,
					'name': id,
					'parent': this
				});
				
				input = form.factoryField(definition);
				input.render(container);
				
				form.addInput(input, definition);
				input.set('parent', this);
				
				inputs[id] = input;
			}
		},
		
		
		/*
		 * ---------------------------------------- SLIDESHOW ----------------------------------------
		 */
		
		
		/**
		 * Add slide to the slideshow
		 * 
		 * @private
		 */
		_createSlide: function () {
			var label = this.get('label'),
				labelButton = this.get('labelButton'),
				
				slideshow = this.getSlideshow(),
				slide_id = this.get('id') + '_' + Y.guid(),
				slide = slideshow.addSlide({'id': slide_id, 'title': label || labelButton});
			
			this._slideContent = slide.one('.su-slide-content');
			this._slideId = slide_id;
		},
		
		/**
		 * Add button to the main slide
		 * 
		 * @private
		 */
		_createButton: function () {
			var label = this.get('label'),
				labelButton = this.get('labelButton'),
				icon = this.get('icon'),
				style = this.get('buttonStyle');
			
			// Button
			var button = new Supra.Button({
				'style': style,
				'label': labelButton || label,
				'icon': icon ? icon : null
			});
			
			if (style == 'small' || style == 'small-gray') {
				button.addClass('button-section');
			} else {
				button.addClass('su-button-fill');
			}
			
			button.render(this.get('contentBox'));
			
			this._slideButton = button;
		},
		
		_openSlide: function () {
			var slideshow = this.getSlideshow();
			slideshow.set('slide', this._slideId);
		},
	
		
		/*
		 * ---------------------------------------- ATTRIBUTES ----------------------------------------
		 */
		
		
		/**
		 * Value attribute getter
		 * 
		 * @returns {Undefined} Undefined, group doesn't have its own value
		 * @private
		 */
		_getValue: function () {
		},
		
		/**
		 * Value attribute setter
		 */
		_setValue: function () {
		}
		
	});
	
	Supra.Input.Group = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.input-proto']});
YUI.add("supra.input", function (Y) {
	//Invoke strict mode
	"use strict";
	
	//supra.input is just a wrapper for everything else
	//should this be changed to alias instead?
	
}, YUI.version, {requires:["supra.form"]});YUI.add('supra.manager-action-plugin-form', function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Action = Supra.Manager.Action;
	
	function PluginForm () {
		PluginForm.superclass.constructor.apply(this, arguments);
	};
	
	PluginForm.NAME = 'PluginForm';
	
	Y.extend(PluginForm, Action.PluginBase, {
		
		initialize: function () {
			
			if (!this.placeholders) {
				Y.log('Can\'t find container to create Form for Action ' + this.host.NAME + '. Please make sure there is a template', 'error');
				return;
			}
			
			//Find container node
			var node = this.host.one('form');
			if (!node) {
				//Use panels content box if form is not found
				var panel = this.plugins.getPlugin('PluginPanel');
				if (panel) node = panel.getWidget('panel').get('contentBox');
			}
			if (!node) {
				//Use first found item
				node = this.host.one();
			}
			
			//Create form
			var form = new Supra.Form({ 'srcNode': node });
			this.addWidget(form);
			
			form.setURLLoad(this.host.getDataPath());
		},
		
		render: function () {
			PluginForm.superclass.render.apply(this, arguments);
		},
		
		execute: function () {
			PluginForm.superclass.execute.apply(this, arguments);
			
			// @TODO reset form values; auto-load form data
		}
		
	});
	
	Action.PluginForm = PluginForm;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['supra.manager-action-plugin-base', 'supra.input']});YUI.add('supra.manager', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Dummy function

}, YUI.version, {requires: ['supra.permission', 'supra.manager-base', 'supra.manager-loader', 'supra.manager-loader-actions', 'supra.manager-action', 'supra.manager-action-base', 'supra.manager-action-plugin-manager', 'supra.manager-action-plugin-base', 'supra.manager-action-plugin-panel', 'supra.manager-action-plugin-form', 'supra.manager-action-plugin-footer', 'supra.manager-action-plugin-container']});
YUI().add('supra.htmleditor-plugin-fullscreen', function (Y) {
	
	//Shortcut
	var Manager = Supra.Manager;
	var Action = Manager.Action;
	var Loader = Manager.Loader;
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	Supra.HTMLEditor.addPlugin('fullscreen', defaultConfiguration, {
		/**
		 * Fullscreen state
		 * @type {Boolean}
		 * @private
		 */
		fullscreen: false,
		
		/**
		 * DOM Node reference point
		 */
		reference_point: null,
		
		/**
		 * Enable fullscreen mode
		 * 
		 * @private
		 */
		enableFullScreenMode: function () {
			if (this.fullscreen) return;
			this.fullscreen = true;
			
			var node = this.htmleditor.get('srcNode').closest('.yui3-content'),
				body = node.closest('body');
			
			this.reference_point = Y.DOM.removeFromDOM(node);
			
			node.addClass('yui3-fullscreen');
			body.addClass('yui3-fullscreen');
			body.append(node);
		},
		
		/**
		 * Disable fullscreen mode
		 * 
		 * @private
		 */
		disableFullScreenMode: function () {
			if (!this.fullscreen) return;
			this.fullscreen = false;
			
			var htmleditor = this.htmleditor,
				body = htmleditor.get('srcNode').closest('body'),
				toolbar = htmleditor.get('toolbar'),
				button = toolbar ? toolbar.getButton('fullscreen') : null;
			
			button.set('down', false);
			
			this.reference_point.node.removeClass('yui3-fullscreen');
			body.removeClass('yui3-fullscreen');
			
			Y.DOM.restoreInDOM(this.reference_point);
		},
		
		/**
		 * Toggle fullscreen mode
		 */
		toggleFullScreenMode: function () {
			var toolbar = this.htmleditor.get('toolbar'),
				button = toolbar ? toolbar.getButton('fullscreen') : null;
			
			if (button.get('down')) {
				this.enableFullScreenMode();
			} else {
				this.disableFullScreenMode();
			}
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			var toolbar = htmleditor.get('toolbar'),
				button = toolbar ? toolbar.getButton('fullscreen') : null;
			
			// Add command
			htmleditor.addCommand('fullscreen', Y.bind(this.toggleFullScreenMode, this));
			
			if (button) {
				//When un-editable node is selected disable fullscreen mode
				htmleditor.on('editingAllowedChange', function (event) {
					if (!event.allowed) this.disableFullScreenMode();
					button.set('disabled', !event.allowed);
				}, this);
			}
			
			//On editor disable hide source editor
			htmleditor.on('disable', this.disableFullScreenMode, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			this.disableFullScreenMode();
		}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.manager', 'supra.htmleditor-base']});YUI().add('supra.htmleditor-plugin-source', function (Y) {
	
	//Shortcut
	var Manager = Supra.Manager;
	var Action = Manager.Action;
	var Loader = Manager.Loader;
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	Supra.HTMLEditor.addPlugin('source', defaultConfiguration, {
		
		showSourceEditor: function () {
			
			this.htmleditor.resetSelection();
			this.htmleditor.fire('nodeChange', {});
			
			if (Manager.getAction('PageContentSettings')) {
				Manager.PageContentSettings.hide();
			}
			
			Manager.executeAction('PageSourceEditor', {
				'html': this.htmleditor.getHTML(),
				'callback': Y.bind(this.updateSource, this)
			});
		},
		
		/**
		 * Update source
		 * 
		 * @param {String} html HTML code
		 */
		updateSource: function (html) {
			this.htmleditor.setHTML(html);
			this.htmleditor._changed();
		},
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor, configuration) {
			var sourceeditor = Manager.getAction('PageSourceEditor'),
				toolbar = htmleditor.get('toolbar'),
				button = toolbar ? toolbar.getButton('source') : null;
			
			// Add command
			htmleditor.addCommand('source', Y.bind(this.showSourceEditor, this));
			
			if (button) {
				//When un-editable node is selected disable mediasidebar toolbar button
				htmleditor.on('editingAllowedChange', function (event) {
					button.set('disabled', !event.allowed);
				});
			}
			
			//On editor disable hide source editor
			htmleditor.on('disable', this.hideMediaSidebar, this);
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {}
		
	});
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['supra.manager', 'supra.htmleditor-base']});/**
 * Font sidebar
 */
YUI().add("supra.htmleditor-plugin-fonts", function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	/*
	 * Font plugin handles font selection
	 */
	Supra.HTMLEditor.addPlugin("fonts", defaultConfiguration, {
		
		// Font input
		fontInput: null,
		
		// Font button
		fontFamilyInput: null,
		
		// Fore color button
		foreColorInput: null,
		
		// Back color button
		backColorInput: null,
		
		// Font size button
		fontSizeInput: null,
		
		// Updating input to reflect selected element styles
		silentUpdating: false,
		
		// Font list
		fonts: null,
		
		// Select color type, "fore" or "back"
		colorType: null,
		
		// Font size input change listener
		toolbarFontSizeChangeListener: null,
		
		googleFonts: null,
		
		
		/**
		 * Update selected element font
		 * 
		 * @private
		 */
		updateFont: function () {
			if (!this.silentUpdating && !this.htmleditor.get("disabled")) {
				var value = this.fontInput.get("value"),
					data  = value ? this.fontInput.getValueData(value) : null,
					fonts = this.googleFonts;
				
				if (data) {
					if (!fonts) {
						fonts = new Supra.GoogleFonts({
							"doc": this.htmleditor.get("doc")
						});
					}
					
					fonts.addFonts([data]);
				}
				
				this.exec(value, "fontname");
				this.htmleditor._changed();
			}
		},
		
		/**
		 * Update selected element text or background color
		 * 
		 * @private
		 */
		updateColor: function () {
			if (!this.silentUpdating && !this.htmleditor.get('disabled')) {
				var value = this.colorInput.get("value");
				this.exec(value, this.colorType + "color");
				this.htmleditor._changed();
			}
		},
		
		/**
		 * Update selected element font size
		 * 
		 * @private
		 */
		updateFontSize: function () {
			if (!this.silentUpdating && !this.htmleditor.get('disabled')) {
				var value = this.fontSizeInput.get("value");
				this.exec(value, "fontsize");
				this.htmleditor._changed();
			}
		},
		
		/**
		 * When node changes update font, font size and color input values
		 * 
		 * @param {Object} event
		 * @private
		 */
		handleNodeChange: function (event) {
			var allowEditing = this.htmleditor.editingAllowed,
				element = this.htmleditor.getSelectedElement();
			
			this.silentUpdating = true;
			
			if (this.color_settings_form && this.color_settings_form.get("visible")) {
				
				var color = "";
				if (element) {
					
					//Traverse up the tree
					var tmpElement = element,
						srcElement = this.htmleditor.get("srcNode").getDOMNode();
					
					while (tmpElement && tmpElement.style) {
						
						if (this.colorType == "fore") {
							//Text color
							color = tmpElement.tagName === "FONT" ? tmpElement.getAttribute("color") : "";
						} else {
							//Background color
							color = tmpElement.style.backgroundColor || "";
						}
						
						if (color) {
							//Color found, stop traverse
							tmpElement = null;
						} else {
							tmpElement = tmpElement.parentNode;
							if (tmpElement === srcElement) tmpElement = null;
						}
					}
				}
				
				this.colorInput.set("value", color);
				
			} else if (this.font_settings_form && this.font_settings_form.get("visible")) {
				var face = null;
				if (element && element.tagName === "FONT") {
					face = element.getAttribute("face");
				} else {
					//Try finding font from the list, which matches selected font
					face = Y.Node(element).getStyle("fontFamily") || "";
				}
				this.fontInput.set("value", face);
			}
			
			if (element) {
				var size = parseInt(Y.Node(element).getStyle("fontSize"), 10) || "";
				if (this.fontSizeInput.hasValue(size)) {
					this.fontSizeInput.set("value", size);
				} else {
					//In case elements font size is not in the list
					this.fontSizeInput.setText(size);
				}
			}
			
			this.fontSizeInput.set("opened", false);
			this.silentUpdating = false;
		},
		
		/**
		 * When editing allowed changes update sidebar visibility
		 * 
		 * @param {Object} event
		 * @private
		 */
		handleEditingAllowChange: function (event) {
			if (!event.allowed) {
				this.hideSidebar();
			}
			
			this.fontSizeInput.set("disabled", !event.allowed);
			this.fontFamilyInput.set("disabled", !event.allowed);
			this.foreColorInput.set("disabled", !event.allowed);
			this.backColorInput.set("disabled", !event.allowed);
		},
		
		/**
		 * Disabled attribute change
		 * 
		 * @param {Object} event Attribute change event facade object
		 * @private
		 */
		handleDisabledChange: function (event) {
			var listener = this.toolbarFontSizeChangeListener;
			
			if (event.newVal && listener) {
				//Disable
				listener.detach();
				this.toolbarFontSizeChangeListener = null;
			} else if (!event.newVal && !listener) {
				//Enable
				this.toolbarFontSizeChangeListener = this.fontSizeInput.after("valueChange", this.updateFontSize, this);
			}
		},
		
		
		/* -------------------------------------- API ---------------------------------------- */
		
		
		/**
		 * Execute command
		 * 
		 * @param {Object} data
		 * @param {String} command
		 * @return True on success, false on failure
		 * @type {Boolean}
		 */
		exec: function (data, command) {
			var editor = this.htmleditor,
				node,
				testNode,
				fontname,
				realSize;
			
			if (editor.selectionIsCollapsed()) {
				//Increase selection to all element if there isn't any
				node = editor.getSelectedElement();
				if (!node) return;
				
				editor.selectNode(node);
			}
			
			if (command == "fontname") {
				node = editor.getSelectedElement();
				testNode = (node.tagName == "FONT" ? node.parentNode : node);
				
				//If node font family is the same as new font, then don't set "face"
				fontname = Y.Node(testNode).getStyle("fontFamily");
				if (fontname && fontname.indexOf(data.replace(/,.*/, "")) !== -1) {
					if (node.tagName == "FONT") {
						node.removeAttribute("face");
						
						if (this.cleanUpNode(node)) {
							editor._changed();
							editor.refresh(true);
						}
					}
					return;
				}
			} else if (command == "forecolor") {
				
				node = editor.getSelectedElement("FONT");
				
				if (!data) {
					if (node && node.tagName == "FONT") {
						node.style.color = "";
						node.removeAttribute("color");
						
						if (this.cleanUpNode(node)) {
							editor._changed();
							editor.refresh(true);
						}
						return;
					}
				} else {
					if (node && node.tagName == "FONT") {
						//Update FONT element if we can
						node.setAttribute("color", data);
						return;
					}
				}
				
			} else if (command == "backcolor") {
				
				node = editor.getSelectedElement();
				
				if (!data) {
					var tmpNode = node,
						srcNode = this.htmleditor.get("srcNode").getDOMNode();
					
					//Find closest element with background color
					while(tmpNode && tmpNode !== srcNode) {
						if (tmpNode && tmpNode.style.backgroundColor) {
							node = tmpNode;
							tmpNode = null;
						} else {
							tmpNode = tmpNode.parentNode;
						}
					}
					
					if (node && node !== srcNode && node.style.backgroundColor) {
						if (node.tagName == "SPAN") {
							this.htmleditor.unwrapNode(node);
						} else {
							//FONT element without any styles will be removed in cleanUp
							node.style.backgroundColor = "";
						}
						
						this.cleanUp();
						
						editor._changed();
						editor.refresh(true);
						
						return;
					}
				} else {
					if (node && node.tagName == "FONT") {
						//Update FONT element if we can
						node.style.backgroundColor = data;
						return;
					}
				}
				
			}
			
			//Inserts <font> for color, fontsize, fontname andbackground color
			var targetNode = null;
			
			if (command == "backcolor") {
				var selection = editor.selection;
				if (selection.start === selection.end && selection.start_offset !== selection.end_offset) {
					node = this.htmleditor.replaceSelection(null, "FONT");
					if (node) {
						targetNode = node;
						node.style.backgroundColor = data;
					}
				} else {
					editor.get("doc").execCommand(command, null, data);
				}
			} else {
				editor.get("doc").execCommand(command, null, data);
			}
			
			if (targetNode) {
				editor.selectNode(targetNode);
				editor.refresh(true);
			} else {
				// If all text inside DIV, P, ... was selected, then selection didn't changed
				// (according to text), but new wrapper element was added, so need to reset
				editor.resetSelectionCache();
			}
			
			if (command == "fontsize") {
				//Get <font /> element
				node = editor.getSelectedElement();
				
				if (node) {
					//Remove "size" attribute, since we will be using classname
					node.removeAttribute("size");
					node.className = "";
					
					//We want to make sure classname if is actually needed
					realSize = parseInt(Y.Node(node).getStyle("fontSize"), 10);
					
					if (data && data != realSize) {
						//Fontsize set as classname
						node.className = "font-" + data;
					} else {
						node.className = "";
					}
				}
			} else if (command == "backcolor" || command == "forecolor") {
				//Get <span /> element
				node = editor.getSelectedElement();
				
				if (node && node.tagName == "SPAN" && (node.style.backgroundColor || node.style.color || node.getAttribute("color"))) {
					//Replace SPAN with FONT
					var tempNode = editor.get("doc").createElement("FONT");
					node.parentNode.insertBefore(tempNode, node);
					
					while(node.firstChild) {
						tempNode.appendChild(node.firstChild);
					}
					
					if (command == "backcolor") {
						tempNode.style.backgroundColor = node.style.backgroundColor;
					} else if (command == "forecolor") {
						if (node.style.color) {
							tempNode.setAttribute("color", node.style.color); // Gecko
						} else if (node.getAttribute("color")) {
							tempNode.setAttribute("color", node.getAttribute("color")); // WebKit
						}
					}
					
					node.parentNode.removeChild(node);
					editor.selectNode(tempNode);
				}
			}
			
			//Remove <font> which don't have font size and font family and color 
			this.cleanUp();
			
			editor._changed();
			editor.refresh(true);
		},
		
		/**
		 * Remove node if doesn't have any styles
		 * 
		 * @param {Object} node Node
		 * @return True if node was removed, otherwise false
		 */
		cleanUpNode: function (node) {
			node = node.getDOMNode ? node.getDOMNode() : node;
			node.removeAttribute("size");
			
			if (!node.getAttribute("face") && !node.className && !node.getAttribute("color") && !node.style.backgroundColor) {
				this.htmleditor.unwrapNode(node);
				return true;
			}
			return false;
		},
		
		/**
		 * Remove all <font> nodes which don't have any style
		 */
		cleanUp: function () {
			var nodes = this.htmleditor.get("srcNode").all("font");
			nodes.each(Y.bind(this.cleanUpNode, this));
		},
		
		/**
		 * Returns list of used fonts
		 * 
		 * @return List of font API ids
		 */
		getUsedFonts: function () {
			var editor = this.htmleditor,
				nodes = this.htmleditor.get("srcNode").all("font"),
				used = [];
			
			nodes.each(function (node) {
				var face  = node.getAttribute("face"),
					fonts = null,
					i     = 0,
					ii    = 0,
					safe  = Supra.GoogleFonts.SAFE_FONTS;
				
				if (face) {
					fonts = face.split(/\s*,\s*/g);
					for (ii=fonts.length; i<ii; i++) {
						if (Y.Array.indexOf(safe, fonts[i]) !== -1) {
							// Font is in the safe list, don't send it to server
							return;
						}
					}
					used.push(face);
				}
			});
			
			return Y.Array.unique(used);
		},
		
		/**
		 * Returns list of all fonts
		 * 
		 * @return List of all fonts from configuration
		 */
		getAllFonts: function () {
			return Supra.data.get(["supra.htmleditor", "fonts"]) || [];
		},
		
		
		/* -------------------------------------- Sidebar ---------------------------------------- */
		
		
		/**
		 * Create font sidebar
		 */
		createFontSidebar: function () {
			//Get form placeholder
			var content = Manager.getAction("PageContentSettings").get("contentInnerNode");
			if (!content) return;
			
			var form_config = {
					"inputs": [{
						"id": "font",
						"type": "Fonts",
						"label": "",
						"values": []
					}],
					"style": "vertical"
				};
			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			//When user selects a value, update content
			this.fontInput = form.getInput("font");
			this.fontInput.after("valueChange", this.updateFont, this);
			
			this.font_settings_form = form;
			return form;
		},
		
		/**
		 * Show fonts sidebar
		 */
		showFontSidebar: function () {
			//Make sure PageContentSettings is rendered
			var form = this.font_settings_form || this.createFontSidebar(),
				action = Manager.getAction("PageContentSettings"),
				toolbarName = "htmleditor-plugin";
			
			if (!form) {
				if (action.get("loaded")) {
					if (!action.get("created")) {
						action.renderAction();
						this.showFontSidebar(target);
					}
				} else {
					action.once("loaded", function () {
						this.showFontSidebar(target);
					}, this);
					action.load();
				}
				return false;
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons(toolbarName)) {
				Manager.getAction('PageToolbar').addActionButtons(toolbarName, []);
				Manager.getAction('PageButtons').addActionButtons(toolbarName, []);
			}
			
			action.execute(form, {
				"doneCallback": Y.bind(this.hideSidebar, this),
				"hideCallback": Y.bind(this.onSidebarHide, this),
				
				"title": Supra.Intl.get(["htmleditor", "fonts"]),
				"scrollable": true,
				"toolbarActionName": toolbarName
			});
			
			//Fonts toolbar button
			this.htmleditor.get("toolbar").getButton("fonts").set("down", true);
		},
		
		/**
		 * Create color sidebar
		 */
		createColorSidebar: function () {
			//Get form placeholder
			var content = Manager.getAction("PageContentSettings").get("contentInnerNode");
			if (!content) return;
			
			//Find presets
			var presets = [],
				container = this.htmleditor.get("srcNode"),
				styles = this.htmleditor.get("stylesheetParser").getSelectorsByNodeMatch(container)["COLOR"],
				i = 0,
				ii = styles.length;
			
			for (; i<ii; i++) {
				if (styles[i].attributes.color) {
					presets.push(styles[i].attributes.color);
				}
			}
			
			//Properties form
			var form_config = {
				"inputs": [{
					"id": "color",
					"type": "Color",
					"label": "",
					"allowUnset": true,
					"presets": presets
				}],
				"style": "vertical"
			};
			
			var form = new Supra.Form(form_config);
				form.render(content);
				form.hide();
			
			//When user selects a value, update content
			this.colorInput = form.getInput("color");
			this.colorInput.after("valueChange", this.updateColor, this);
			
			this.color_settings_form = form;
			return form;
		},
		
		/**
		 * Show color sidebar
		 */
		showColorSidebar: function () {
			//Make sure PageContentSettings is rendered
			var form = this.color_settings_form || this.createColorSidebar(),
				action = Manager.getAction("PageContentSettings"),
				toolbarName = "htmleditor-plugin",
				label = Supra.Intl.get(["htmleditor", this.colorType + "color"]);
			
			if (!form) {
				if (action.get("loaded")) {
					if (!action.get("created")) {
						action.renderAction();
						this.showColorSidebar(target);
					}
				} else {
					action.once("loaded", function () {
						this.showColorSidebar(target);
					}, this);
					action.load();
				}
				return false;
			}
			
			if (!Manager.getAction('PageToolbar').hasActionButtons(toolbarName)) {
				Manager.getAction('PageToolbar').addActionButtons(toolbarName, []);
				Manager.getAction('PageButtons').addActionButtons(toolbarName, []);
			}
			
			//Change color input label
			form.getInput('color').set('label', label) 
			
			//Show form
			action.execute(form, {
				"doneCallback": Y.bind(this.hideSidebar, this),
				"hideCallback": Y.bind(this.onSidebarHide, this),
				
				"title": label,
				"scrollable": true,
				"toolbarActionName": toolbarName
			});
			
			//Color toolbar button
			this.htmleditor.get("toolbar").getButton(this.colorType + "color").set("down", true);
			this.htmleditor.get("toolbar").getButton((this.colorType == "fore" ? "back" : "fore") + "color").set("down", false);
			
			//Update selected text/back color, because color picker could be showing for wrong one
			this.handleNodeChange({});
		},
		
		/**
		 * Show text color sidebar
		 */
		showBackColorSidebar: function () {
			this.colorType = "back";
			this.showColorSidebar();
		},
		
		/**
		 * Show text color sidebar
		 */
		showTextColorSidebar: function () {
			this.colorType = "fore";
			this.showColorSidebar();
		},
		
		/**
		 * Hide fonts sidebar
		 */
		hideSidebar: function () {
			if (this.font_settings_form && this.font_settings_form.get("visible")) {
				Manager.PageContentSettings.hide();
			} else if (this.color_settings_form && this.color_settings_form.get("visible")) {
				Manager.PageContentSettings.hide();
			}
		},
		
		/**
		 * When fonts sidebar is hidden update toolbar button to reflect that
		 * 
		 * @private
		 */
		onSidebarHide: function () {
			//Unstyle toolbar button
			this.htmleditor.get("toolbar").getButton("fonts").set("down", false);
			this.htmleditor.get("toolbar").getButton("forecolor").set("down", false);
			this.htmleditor.get("toolbar").getButton("backcolor").set("down", false);
		},
		
		
		/* -------------------------------------- Plugin ---------------------------------------- */
		
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			var toolbar = htmleditor.get("toolbar");
			
			this.silentUpdating = true;
			this.listeners = [];
			
			htmleditor.addCommand("fonts", Y.bind(this.showFontSidebar, this));
			htmleditor.addCommand("forecolor", Y.bind(this.showTextColorSidebar, this));
			htmleditor.addCommand("backcolor", Y.bind(this.showBackColorSidebar, this));
			
			// Show inputs / buttons
			var inputs = ["fonts", "fontsize", "forecolor", "backcolor"],
				i = 0,
				ii = inputs.length;
			
			for (;i<ii; i++) {
				toolbar.getButton(inputs[i]).set("visible", true);
			}
			
			// Inputs
			this.fontFamilyInput = toolbar.getButton("fonts");
			this.foreColorInput  = toolbar.getButton("forecolor");
			this.backColorInput  = toolbar.getButton("backcolor");
			
			var input = this.fontSizeInput = toolbar.getButton("fontsize"),
				values = input.get('values');
			
			//Special style
			input.addClass("align-center");
			
			//On enable/disable add or remove listener 
			this.listeners.push(
				htmleditor.on("disabledChange", this.handleDisabledChange, this)
			);
			
			//When un-editable node is selected disable toolbar button
			this.listeners.push(
				htmleditor.on("editingAllowedChange", this.handleEditingAllowChange, this)
			);
			this.listeners.push(
				htmleditor.on("nodeChange", this.handleNodeChange, this)
			);
			
			this.silentUpdating = false;
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			for(var i=0,ii=this.listeners.length; i<ii; i++) {
				this.listeners[i].detach();
			}
			
			this.listeners = null;
			this.fontInput = null;
			
			if (this.font_settings_form) {
				this.font_settings_form.destroy();
			}
			if (this.color_settings_form) {
				this.color_settings_form.destroy();
			}
		}
		
	});
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {"requires": ["supra.htmleditor-base", "supra.template", "supra.google-fonts"]});/**
 * Font sidebar
 */
YUI().add("supra.htmleditor-plugin-align", function (Y) {
	
	var defaultConfiguration = {
		/* Modes which plugin supports */
		modes: [Supra.HTMLEditor.MODE_SIMPLE, Supra.HTMLEditor.MODE_RICH]
	};
	
	//Shortcuts
	var Manager = Supra.Manager;
	
	var ALIGN_TAG_NAMES = {
		"DIV": true, "P": true, "BLOCKQUOTE": true, "Q": true, 
		"LI": true, "TD": true, "TH": true, "DL": true, "DD": true,
		"H1": true, "H2": true, "H3": true, "H4": true, "H5": true,
		"ARTICLE": true, "ASIDE": true, "DETAILS": true, "FIGCAPTION": true, "FIGURE": true, "FOOTER": true, "HEADER": true, "NAV": true, "SECTION": true
	};
	
	/*
	 * Font plugin handles font selection
	 */
	Supra.HTMLEditor.addPlugin("align", defaultConfiguration, {
		
		// Align input
		alignInput: null,
		
		// Updating input to reflect selected element styles
		silentUpdating: false,
		
		
		/**
		 * When node changes update align input value
		 * 
		 * @param {Object} event
		 * @private
		 */
		handleNodeChange: function (event) {
			var htmleditor = this.htmleditor,
				allowEditing = htmleditor.editingAllowed,
				element = this.getElement(),
				align = null;
			
			this.silentUpdating = true;
			
			if (element) {
				align = element.getAttribute("align");
			}
			if (!align) {
			 	element = element || Y.Node(htmleditor.getSelectedElement());
			 	if (element) {
			 		align = element.getStyle("textAlign");
			 		if (align != "left" && align != "right" && align != "center" && align != "justify") {
			 			align = "left";
			 		}
			 	}
			}
			
			this.alignInput.set("value", align || "left");
			this.alignInput.set("opened", false);
			this.silentUpdating = false;
		},
		
		/**
		 * Returns closest element to selection to which align can be applied
		 * 
		 * @return Element to which align can be applied
		 * @type {Object}
		 * @private
		 */
		getElement: function () {
			var htmleditor = this.htmleditor,
				element = htmleditor.getSelectedElement(),
				tagName = "",
				container = htmleditor.get("srcNode").getDOMNode();
			
			if (element) {
				element = Y.Node(element);
			} else {
				return null;
			}
			
			while (element) {
				tagName = element.get("tagName");
				
				if (tagName in ALIGN_TAG_NAMES) {
					//Found it
					break;
				}
				
				element = element.ancestor();
				if (element && element.compareTo(container)) {
					element = null;
				}
			}
			
			return element;
		},
		
		/**
		 * When editing allowed changes update UI
		 * 
		 * @param {Object} event
		 * @private
		 */
		handleEditingAllowChange: function (event) {
			if (!event.allowed) {
				
			}
		},
		
		/**
		 * Handle align input value change
		 * 
		 * @param {Object} event
		 * @private
		 */
		handleAlignChange: function (event) {
			this.exec(event.newVal, "align");
		},
		
		
		/* -------------------------------------- API ---------------------------------------- */
		
		
		/**
		 * Set text align position
		 */
		exec: function (data, command) {
			if (!this.silentUpdating && command === "align") {
				var element = this.getElement();
				if (element) {
					element.setAttribute("align", data);
				}
			}
		},
		
		
		/* -------------------------------------- Plugin ---------------------------------------- */
		
		
		/**
		 * Initialize plugin for editor,
		 * Called when editor instance is initialized
		 * 
		 * @param {Object} htmleditor HTMLEditor instance
		 * @constructor
		 */
		init: function (htmleditor) {
			var toolbar = htmleditor.get("toolbar");
			
			this.silentUpdating = true;
			this.listeners = [];
			
			htmleditor.addCommand("align", Y.bind(this.exec, this));
			
			// Font size input
			var input = this.alignInput = toolbar.getButton("align");
			input.set("value", "left");
			input.after("valueChange", this.handleAlignChange, this);
			
			//When un-editable node is selected disable toolbar button
			this.listeners.push(
				htmleditor.on("editingAllowedChange", this.handleEditingAllowChange, this)
			);
			this.listeners.push(
				htmleditor.on("nodeChange", this.handleNodeChange, this)
			);
			
			this.silentUpdating = false;
		},
		
		/**
		 * Clean up after plugin
		 * Called when editor instance is destroyed
		 */
		destroy: function () {
			for(var i=0,ii=this.listeners.length; i<ii; i++) {
				this.listeners[i].detach();
			}
			
			this.listeners = null;
			this.alignInput = null;
		}
		
	});
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {"requires": ["supra.htmleditor-base"]});YUI().add('supra.htmleditor', function (Y) {
}, YUI.version, {'requires': ['supra.htmleditor-base']});YUI.add("supra.input-html", function (Y) {
	//Invoke strict mode
	"use strict";
	
	var Manager = Supra.Manager;
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
		
		Manager.Loader.loadAction('EditorToolbar');
		Manager.Loader.loadAction('PageContentSettings');
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-html";
	Input.ATTRS = {
		'doc': {
			value: null
		},
		'win': {
			value: null
		},
		'toolbar': {
			value: null
		},
		'nodeIframe': {
			value: null
		},
		// HTML plugin information
		'plugins': {
			value: null
		}
	};
	
	/**
	 * Parse
	 */
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		/**
		 * Constants
		 */
		INPUT_TEMPLATE: '<textarea spellcheck="false"></textarea>',
		LABEL_TEMPLATE: '<label></label>',
		
		/**
		 * HTMLEditor instance
		 * @type {Object}
		 * @private
		 */
		htmleditor: null,
		
		
		
		
		/**
		 * ----------------------------------- PRIVATE --------------------------------------
		 */
		
		
		
		/**
		 * Attach event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			if (this.htmleditor) {
				this.htmleditor.on('change', function (evt) {
					this.fire('change');
				}, this);
			}
		},
		
		/**
		 * Render widgets
		 * 
		 * @private
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.set('boundingBox', this.get('srcNode'));
			
			this.createIframe();
		},
		
		/**
		 * Clean up
		 * 
		 * @private
		 */
		destructor: function () {
			if (this.htmleditor) {
				this.htmleditor.detach('change');
				this.htmleditor.destroy();
				this.htmleditor = null;
			}
		},
		
		/**
		 * Create HTML toolbar and load PageContentSettings before creating editor
		 * 
		 * @private
		 */
		loadDependancies: function () {
			//Toolbar needs to exist
			var action = Manager.getAction('EditorToolbar');
			if (!action.get('created')) {
				action.once('executed', function () {
					var action = Manager.getAction('PageContentSettings');
					if (!action.get('loaded')) {
						action.once('loaded', this.createEditor, this);
					} else {
						this.createEditor();
					}
				}, this);
				
				Manager.executeAction('EditorToolbar', true);
			} else {
				this.createEditor();
			}
		},
		
		/**
		 * Create HTML editor
		 * 
		 * @private
		 */
		createEditor: function () {
			if (this.htmleditor) return;
			
			var doc = this.get('doc'),
				win = this.get('win'),
				src = this.get('srcNode'),
				toolbar = Manager.EditorToolbar.getToolbar(),
				value = this.get('value');
			
			if (doc && win && src) {
				this.htmleditor = new Supra.HTMLEditor({
					'doc': doc,
					'win': win,
					'srcNode': Y.Node(doc).one('.editing'),
					'iframeNode': this.get('nodeIframe'),
					'toolbar': toolbar,
					'mode': Supra.HTMLEditor.MODE_RICH,
					'standalone': true,
					'parent': this,
					'root': this.get('root') || this,
					'plugins': this.get('plugins')
				});
				this.htmleditor.render();
				this.htmleditor.set('disabled', true);
				
				if (value && 'html' in value) {
					this.htmleditor.setAllData(value.data);
					this.htmleditor.setHTML(value.html);
				}
				
				Y.Node(doc).one('html').on('click', this.onIframeClick, this);
			}
		},
		
		/**
		 * Wait till stylesheets are loaded
		 * 
		 * @private
		 */
		waitTillStyleSheetsAreLoaded: function (links) {
			var fn = Y.bind(function () {
				var loaded = true;
				for(var i=0,ii=links.length; i<ii; i++) {
					if (!links[i].sheet) {
						loaded = false;
						break;
					} else {
					}
				}
				
				if (loaded) {
					Y.later(50, this, function () {
						this.loadDependancies();
					});
				} else {
					setTimeout(fn, 50);
				}
			}, this);
			setTimeout(fn, 50);
		},
		
		/**
		 * Create iframe for HTMLEditor
		 * 
		 * @private
		 */
		createIframe: function () {
			var textarea = this.get('inputNode'),
				iframe = Y.Node.create('<iframe />'),
				html = '';
			
			textarea.insert(iframe, 'after');
			textarea.addClass('hidden');
			
			html = Supra.data.get(['supra.htmleditor', 'standalone', 'doctype'], '<!DOCTYPE html>');
			html+= '<html lang="en" class="standalone standalone-disabled"><head>';
			
			//Add stylesheets to iframe
			if (!Supra.data.get(['supra.htmleditor', 'stylesheets', 'skip_default'], false)) {
				var uri = Manager.Loader.getStaticPath() + Manager.Loader.getActionBasePath('Header') + '/pagecontent/iframe.css';
				html+= '<link rel="stylesheet" type="text/css" href="' + uri + '" />';
			}
			
			var stylesheets = Supra.data.get(['supra.htmleditor', 'standalone', 'stylesheets'], []),
				i = 0,
				ii = stylesheets.length;
			
			for(; i<ii; i++) {
				html+= '<link rel="stylesheet" type="text/css" href="' + stylesheets[i] + '" />';
			}
			
			html+= '</head><body>';
			html+= this.selectorToHTML(Supra.data.get(['supra.htmleditor', 'standalone', 'wrap'], ''));
			html+= '</body></html>';
			
			this.writeHTML(iframe, html);
			this.set('nodeIframe', iframe);
			
			//Save document & window instances
			var win = this.get('nodeIframe').getDOMNode().contentWindow;
			var doc = win.document;
			this.set('win', win);
			this.set('doc', doc);
			
			//Wait till all stylesheets are loaded before creating editor
			this.waitTillStyleSheetsAreLoaded(Y.Node(doc).all('link[rel="stylesheet"]'));
		},
		
		/**
		 * On iframe click enable editing
		 * 
		 * @private
		 */
		onIframeClick: function () {
			if (!this.get('disabled')) {
				if (this.htmleditor.get('disabled') && !Manager.EditorToolbar.get('visible')) {
					
					Y.Node(this.get('doc')).one('html').removeClass('standalone-disabled');
					
					//Show toolbar without "Settings" button
					Manager.EditorToolbar.execute();
					Manager.EditorToolbar.getToolbar().getButton('settings').set('visible', false);
					
					this.htmleditor.set('disabled', false);
					
					Manager.EditorToolbar.once('afterVisibleChange', this.onIframeBlur, this);
				}
			}
		},
		
		/**
		 * On blur disable editor and 
		 */
		onIframeBlur: function (e) {
			if (!this.htmleditor.get('disabled') && !e.silent) {
				Y.Node(this.get('doc')).one('html').addClass('standalone-disabled');
				
				this.htmleditor.set('disabled', true);
				this.fire('change', {'value': this.get('value')});
			}
		},
		
		/**
		 * Create HTML which would match given selector
		 * 
		 * @param {String} selector CSS selector
		 * @return HTML
		 * @type {String}
		 * @private
		 */
		selectorToHTML: function (selector) {
			var attrs = {},
				attr = null,
				tag = 'div',
				
				start = [],
				end = [],
				index = 0;
			
			selector = selector.split(/\s+/g);
			
			for(var i=0,ii=selector.length; i<ii; i++) {
				attrs = {'class': 'yui3-box-reset'};
				tag = 'div';
				
				selector[i].replace(/(\.|#)?([a-z0-9\-\_]+)/g, function (all, type, value) {
					if (type == '.') { //Classname
						attrs['class'] += ' ' + value;
					} else if (type == '#') { //ID attribute
						attrs['id'] = value;
					} else if (!type) { //Node
						tag = value;
					}
				});
				
				//To last item add class
				if (i == ii-1) {
					attrs['class'] = attrs['class'] ? attrs['class'] + ' editing' : 'editing';
				}
				
				//Create tags
				end.unshift('</' + tag + '>');
				tag = '<' + tag;
				
				for(attr in attrs) {
					tag+= ' ' + attr + '="' + attrs[attr] + '"';
				}
				
				start.push(tag + '>');
			}
			
			var value = this.get('value'),
				content = '';
			
			if (value && value.html) {
				content = value.html;
			}
						
			return start.join('') + content + end.join('');
		},
		
		/**
		 * Write HTML into iframe
		 * 
		 * @param {String} html HTML
		 * @private
		 */
		writeHTML: function (iframe, html) {
			var win = iframe.getDOMNode().contentWindow;
			var doc = win.document;
			var scripts = [];
			
			doc.open('text/html', 'replace');
			doc.writeln(html);
			doc.close();
			
			Y.Node(doc).one('html').addClass('supra-cms');
		},
		
		
		
		
		/**
		 * ----------------------------------- API --------------------------------------
		 */
		
		
		
		/**
		 * Returns HTMLEditor instance
		 * 
		 * @return HTMLEditor instance
		 * @type {Object}
		 */
		getEditor: function () {
			return this.htmleditor;
		},
		
		
		
		
		/**
		 * ----------------------------------- ATTRIBUTES --------------------------------------
		 */
		
		
		
		/**
		 * Disabled attribute setter
		 * Disable / enable HTMLEditor
		 * 
		 * @param {Boolean} value New state value
		 * @return New state value
		 * @type {Boolean}
		 * @private
		 */
		_setDisabled: function (value) {
			//HTMLEditor is already disabled while used is not editing
			return !!value;
		},
		
		/**
		 * Value attribute getter
		 * Returns value, object with 'html' and 'data' keys
		 * 
		 * @param {Object} value Previous value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_getValue: function (value) {
			if (this.htmleditor) {
				//Remove data which is not bound to anything
				this.htmleditor.removeExpiredData();
				
				return {
					'html': this.htmleditor.getHTML(),
					'data': this.htmleditor.getAllData(),
					'fonts': this.htmleditor.getUsedFonts()
				};
			} else {
				return value;
			}
		},
		
		/**
		 * saveValue attribute getter
		 * Returns value for sending to server, object with 'html' and 'data' keys
		 * 
		 * @param {Object} value Previous value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_getSaveValue: function (value) {
			if (this.htmleditor) {
				return {
					'html': this.htmleditor.getProcessedHTML(),
					'data': this.htmleditor.getProcessedData(),
					'fonts': this.htmleditor.getUsedFonts()
				};
			} else {
				return value;
			}
		},
		
		/**
		 * Value attribute setter
		 * Set HTMLEdtior html and data
		 * 
		 * @param {Object} value New value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_setValue: function (value) {
			if (this.htmleditor) {
				this.htmleditor.setAllData(value.data);
				this.htmleditor.setHTML(value.html);
			}
			
			return value;
		}
		
	});
	
	Input.lipsum = function () {
		return {
			'data': {},
			'html': Supra.Lipsum.html()
		};
	};
	
	Supra.Input.Html = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto", "supra.htmleditor"]});YUI.add("supra.input-inline-html", function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = false;
	
	Input.NAME = "input-html-inline";
	Input.ATTRS = {
		'doc': {
			value: null
		},
		'win': {
			value: null
		},
		'toolbar': {
			value: null
		},
		'inline': {
			value: true,
			readOnly: true
		},
		// HTML plugin information
		'plugins': {
			value: null
		}
	};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		/**
		 * Constants
		 */
		INPUT_TEMPLATE: '',
		LABEL_TEMPLATE: '',
		
		/**
		 * HTMLEditor instance
		 * @type {Object}
		 * @private
		 */
		htmleditor: null,
		
		
		
		
		/**
		 * ----------------------------------- PRIVATE --------------------------------------
		 */
		
		
		
		/**
		 * Attach event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			if (this.htmleditor) {
				this.htmleditor.after('change', function (evt) {
					this.fire('change');
				}, this);
			}
		},
		
		/**
		 * Render widgets
		 * 
		 * @private
		 */
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			this.set('boundingBox', this.get('srcNode'));
			
			var doc = this.get('doc'),
				win = this.get('win'),
				src = this.get('srcNode'),
				toolbar = this.get('toolbar');
			
			if (doc && win && src) {
				this.htmleditor = new Supra.HTMLEditor({
					'doc': doc,
					'win': win,
					'srcNode': src,
					'iframeNode': this.get('nodeIframe'),
					'toolbar': toolbar,
					'mode': Supra.HTMLEditor.MODE_RICH,
					'parent': this,
					'root': this.get('root') || this,
					'disabled': true,
					'plugins': this.get('plugins')
				});
				this.htmleditor.render();
				this.htmleditor.set('disabled', true);
			}
		},
		
		/**
		 * Clean up
		 * 
		 * @private
		 */
		destructor: function () {
			if (this.htmleditor) {
				this.htmleditor.detach('change');
				this.htmleditor.destroy();
				this.htmleditor = null;
			}
		},
		
		
		
		/**
		 * ----------------------------------- API --------------------------------------
		 */
		
		
		
		/**
		 * Returns HTMLEditor instance
		 * 
		 * @return HTMLEditor instance
		 * @type {Object}
		 */
		getEditor: function () {
			return this.htmleditor;
		},
		
		/**
		 * Returns attribute value
		 * 
		 * @param {String} key Attribute name
		 * @return Attribute value
		 * @type {String}
		 */
		getAttribute: function (key) {
			return this.get('srcNode').getAttribute(key);
		},
		
		
		
		
		/**
		 * ----------------------------------- ATTRIBUTES --------------------------------------
		 */
		
		
		
		/**
		 * Disabled attribute setter
		 * Disable / enable HTMLEditor
		 * 
		 * @param {Boolean} value New state value
		 * @return New state value
		 * @type {Boolean}
		 * @private
		 */
		_setDisabled: function (value) {
			if (value) {
				this.blur();
			}
			
			if (this.htmleditor) {
				this.htmleditor.set('disabled', !!value);
				return !!value;
			}
			
			return false;
		},
		
		/**
		 * Value attribute getter
		 * Returns value, object with 'html' and 'data' keys
		 * 
		 * @param {Object} value Previous value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_getValue: function (value) {
			if (this.htmleditor) {
				//Remove data which is not bound to anything
				this.htmleditor.removeExpiredData();
				
				return {
					'html': this.htmleditor.getHTML(),
					'data': this.htmleditor.getAllData(),
					'fonts': this.htmleditor.getUsedFonts()
				};
			} else {
				return value;
			}
		},
		
		/**
		 * saveValue attribute getter
		 * Returns value for sending to server, object with 'html' and 'data' keys
		 * 
		 * @param {Object} value Previous value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_getSaveValue: function (value) {
			if (this.htmleditor) {
				return {
					'html': this.htmleditor.getProcessedHTML(),
					'data': this.htmleditor.getProcessedData(),
					'fonts': this.htmleditor.getUsedFonts()
				};
			} else {
				return value;
			}
		},
		
		/**
		 * Value attribute setter
		 * Set HTMLEdtior html and data
		 * 
		 * @param {Object} value New value
		 * @return New value
		 * @type {Object}
		 * @private
		 */
		_setValue: function (value) {
			if (typeof value === 'string') {
				value = {
					data: {},
					html: value
				};
			}
			
			if (this.htmleditor) {
				this.htmleditor.setAllData(value ? value.data : {});
				this.htmleditor.setHTML(value ? value.html : '');
			}
			
			return value;
		}
		
	});
	
	Input.lipsum = function () {
		return {
			'data': {},
			'html': Supra.Lipsum.html()
		};
	};
	
	Supra.Input.InlineHTML = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto", "supra.htmleditor"]});YUI.add("supra.input-inline-string", function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Helper functions for escaping/unescaping strings
	 */
	var HTML_CHARS = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;',
        '`': '&#x60;',
        ' ': '&nbsp;'
    }
	
	var HTML_CHARS_INVERSE = {};
	var HTML_CHARS_REGEXP = '';
	
	for (var i in HTML_CHARS) {
		HTML_CHARS_INVERSE[HTML_CHARS[i].toLowerCase()] = i;
		
		if (i != ' ') {
			// We escaping characters leave whitespace as is
			HTML_CHARS_REGEXP += '\\' + i;
		}
	}
	
	HTML_CHARS_REGEXP = new RegExp('[' + HTML_CHARS_REGEXP + ']', 'g');
	
	/**
	 * Escape HTML character for safe use in HTML
	 * Used in 'value' attribute setter / when setting value
	 */
	function escapeHtml (chr) {
		return HTML_CHARS[chr] || chr;
	}
	
	/**
	 * Unescape HTML character for string
	 * Used in 'value' and 'saveValue' attribute getter / when getting value
	 */
	function unescapeHtml (ent) {
		return HTML_CHARS_INVERSE[ent.toLowerCase()] || ent;
	}
	
	
	
	/**
	 * Inline string input widget
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = false;
	
	Input.NAME = "input-string-inline";
	Input.ATTRS = {
		'doc': null,
		'win': null,
		'maxLength': {
			value: 0,
			setter: '_setMaxLength'
		}
	};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.InlineHTML, {
		
		EDITOR_MODE: Supra.HTMLEditor.MODE_STRING,
		
		renderUI: function () {
			//We overwrite InlineHTML.renderUI and it shouldn't be called, that's why
			//we call InlineHTML parent not Input parent
			Supra.Input.InlineHTML.superclass.renderUI.apply(this, arguments);
			
			this.set('boundingBox', this.get('srcNode'));
			
			var doc = this.get('doc'),
				win = this.get('win'),
				src = this.get('srcNode');
			
			if (doc && win && src) {
				this.htmleditor = new Supra.HTMLEditor({
					'doc': doc,
					'win': win,
					'srcNode': src,
					'toolbar': this.get('toolbar'),
					'mode': this.EDITOR_MODE,
					'parent': this,
					'root': this.get('root') || this,
					'maxLength': this.get('maxLength')
				});
				this.htmleditor.render();
				this.htmleditor.set('disabled', true);
			}
		},
		
		_getValue: function (value) {
			if (this.htmleditor) {
				value = this.htmleditor.getHTML();
				value = value.replace(/<[^>]+>/g, '');
				value = value.replace(/&.*?;/g, unescapeHtml);
			}
		
			return value;
		},
		
		_getSaveValue: function (value) {
			if (this.htmleditor) {
				value = this.htmleditor.getProcessedHTML();
				
				// Remove all tags
				value = value.replace(/<[^>]+>/g, '');
				// Unescape characters
				value = value.replace(/&.*?;/g, unescapeHtml);
			}
			
			return value;
		},
		
		_setValue: function (value) {
			value = value || '';
			value = value.replace(HTML_CHARS_REGEXP, escapeHtml);
			if (this.htmleditor) {
				this.htmleditor.setHTML(value);
			}
			
			return value;
		},
		
		_setMaxLength: function (maxlength) {
			maxlength = parseInt(maxlength, 10) || 0;
			
			if (this.htmleditor) {
				this.htmleditor.set('maxLength', maxlength);
			}
			
			return maxlength;
		},
		
		/**
		 * On focus move carret to the end of the text
		 */
		focus: function () {
			if (this.get('disabled')) return;
			Input.superclass.focus.apply(this, arguments);
			
			var node = this.get('srcNode'),
				element = node.getDOMNode(),
				length = element.childNodes.length;
			
			this.htmleditor.setSelection({
				start: element,
				start_offset: length,
				end: element,
				end_offset: length
			});
		},
		
		/**
		 * On blur move carret to the body
		 */
		blur: function () {
			Input.superclass.blur.apply(this, arguments);
			if (this.get('disabled')) return;
			
			if (this.htmleditor) {
				//Set carret position to body
				this.htmleditor.setSelection({
					start: document.body,
					start_offset: 0,
					end: document.body,
					end_offset: 0
				});
			}
		},
		
		/**
		 * Select all text
		 */
		selectAll: function () {
			if (this.get('disabled')) return;
			
			var node = this.get('srcNode'),
				element = node.getDOMNode(),
				length = element.childNodes.length;
			
			this.htmleditor.setSelection({
				start: element,
				start_offset: 0,
				end: element,
				end_offset: length
			});
		},
		
		/**
		 * Clean up
		 */
		destructor: function () {
			if (this.htmleditor) {
				this.htmleditor.detach('change');
				this.htmleditor.destroy();
				this.htmleditor = null;
			}
		}
		
	});
	
	Input.lipsum = function () {
		return Supra.Lipsum.sentence({'count': 4, 'variation': 1});
	};
	
	Supra.Input.InlineString = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-inline-html"]});YUI.add("supra.input-inline-text", function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Helper functions for escaping/unescaping strings
	 */
	var HTML_CHARS = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;',
        '`': '&#x60;',
        ' ': '&nbsp;'
    }
	
	var HTML_CHARS_INVERSE = {};
	var HTML_CHARS_REGEXP = '';
	
	for (var i in HTML_CHARS) {
		HTML_CHARS_INVERSE[HTML_CHARS[i].toLowerCase()] = i;
		
		if (i != ' ') {
			// We escaping characters leave whitespace as is
			HTML_CHARS_REGEXP += '\\' + i;
		}
	}
	
	HTML_CHARS_REGEXP = new RegExp('[' + HTML_CHARS_REGEXP + ']', 'g');
	
	/**
	 * Escape HTML character for safe use in HTML
	 * Used in 'value' attribute setter / when setting value
	 */
	function escapeHtml (chr) {
		return HTML_CHARS[chr] || chr;
	}
	
	/**
	 * Unescape HTML character for string
	 * Used in 'value' and 'saveValue' attribute getter / when getting value
	 */
	function unescapeHtml (ent) {
		return HTML_CHARS_INVERSE[ent.toLowerCase()] || ent;
	}
	
	
	
	/**
	 * Inline text input widget
	 */
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = true;
	
	// Input is inside form
	Input.IS_CONTAINED = false;
	
	Input.NAME = "input-text-inline";
	
	Y.extend(Input, Supra.Input.InlineString, {
		
		EDITOR_MODE: Supra.HTMLEditor.MODE_TEXT,
		
		_getValue: function (value) {
			if (this.htmleditor) {
				value = this.htmleditor.getHTML();
				
				value = value.replace(/\n/g, '');
				value = value.replace(/<br\s*\/?>/ig, '\n');
				value = value.replace(/<[^>]+>/g, '');
				value = value.replace(/&.*?;/g, unescapeHtml);
			}
			
			return value;
		},
		
		_getSaveValue: function (value) {
			if (this.htmleditor) {
				value = this.htmleditor.getProcessedHTML();
				
				// Remove all tags
				value = value.replace(/\n/g, '');
				value = value.replace(/<\/?br\s*>/ig, '\n');
				value = value.replace(/<[^>]+>/g, '');
				// Unescape characters
				value = value.replace(/&.*?;/g, unescapeHtml);
			}
			
			return value;
		},
		
		_setValue: function (value) {
			value = value || '';
			value = value.replace(HTML_CHARS_REGEXP, escapeHtml);
			value = value.replace(/\n/g, '<br />');
			if (this.htmleditor) {
				this.htmleditor.setHTML(value);
			}
			
			return value;
		}
		
	});
	
	Input.lipsum = function () {
		return Supra.Lipsum.sentence({'count': 4, 'variation': 1});
	};
	
	Supra.Input.InlineText = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-inline-string"]});YUI.add('supra.form', function (Y) {
	//Invoke strict mode
	"use strict";
	
	//Shortcuts
	var QueryString = Y.QueryString;
	
	//Input configuration defaults
	var INPUT_DEFINITION = {
		'id': null,
		'name': null,
		'label': '',
		'type': 'String',
		'srcNode': null,
		'containerNode': null,
		'labelNode': null,
		'value': '',
		'disabled': false
	};
	
	/**
	 * Class for handling inputs, saving, loading and deleting data 
	 * 
	 * @alias Supra.Form
	 * @param {Object} config Configuration
	 */
	function Form (config) {
		//Fix 'value' references for inputs
		this.fixInputConfigValueReferences(config || {});
		
		Form.superclass.constructor.apply(this, [config || {}]);
		
		this.inputs = {};
		this.inputs_definition = {};
		this.init.apply(this, arguments);
		this.processAttributes();
	}
	
	Form.NAME = 'form';
	Form.ATTRS = {
		'inputs': {
			value: null
		},
		'autoDiscoverInputs': {
			value: true
		},
		'urlLoad': {
			value: null
		},
		'urlSave': {
			value: null
		},
		'urlDelete': {
			value: null
		},
		'style': {
			value: ''
		},
		/**
		 * Values which user was trying to set, but didn't had inputs
		 * for them
		 */
		'plainValues': {
			value: {}
		},
		'disabled': {
			value: false,
			setter: '_setDisabled'
		},
		/**
		 * Parent widget, could be empty
		 */
		'parent': {
			value: null
		},
		/**
		 * Root parent widget, usually same as parent attribute
		 */
		'root': {
			value: null
		},
		/**
		 * Slideshow object, optional
		 */
		'slideshow': {
			value: null
		}
	};
	Form.HTML_PARSER = {
		'urlLoad': function (srcNode) {
			var value = this.get('urlLoad');
			if (value === null && srcNode.test('form')) {
				value = srcNode.getAttribute('action');
			}
			return value ? value : null;
		}
	};
	
	Y.extend(Form, Y.Widget, {
		
		CONTENT_TEMPLATE: "<form></form>",
		
		/*
		 * List of input definitions
		 */
		inputs_definition: null,
		
		/*
		 * List of input fields
		 */
		inputs: null,
		
		/**
		 * Search for inputs in DOM
		 * 
		 * @private
		 * @return Object with input definitions
		 * @type {Object}
		 */
		discoverInputs: function () {
			var inputs = this.get('srcNode').all('input,textarea,select');
			var config = {};
			
			for(var i=0,ii=inputs.size(); i<ii; i++) {
				var input = inputs.item(i);
				
				//suIgnore allows to skip inputs
				if (input.getAttribute('suIgnore')) continue;
				
				var id = input.getAttribute('id') || input.getAttribute('name');
				var name = input.getAttribute('name') || input.getAttribute('id');
				var value = input.get('value');
				var disabled = input.getAttribute('disabled') ? true : false;
				var label = '';
				
				//If there is no name or id, then input can't be identified
				if (!id || !name) continue;
				
				var tagName = input.get('tagName').toLowerCase();
				var tagType = input.getAttribute('type').toLowerCase();
				var type = 'String';
				
				//Get label
				var labelNode = this.get('srcNode').one('label[for="' + id + '"]');
				if (labelNode) {
					label = labelNode.get('innerHTML');
				}
				
				//Detect type
				var suType = input.getAttribute('suType');
				if (suType) {
					type = suType;
				} else {
					switch(tagName) {
						case 'textarea':
							type = 'Text'; break;
						case 'select':
							type = 'Select'; break;
						case 'input':
							switch(tagType) {
								case 'hidden':
									type = 'Hidden'; break;
								case 'checkbox':
									type = 'Checkbox'; break;
								case 'radio':
									type = 'Radio'; break;
								case 'file':
									type = 'FileUpload'; break;
							}
							break;
					}
				}
				
				var srcNode = input.ancestor('div.field') || input;
				
				config[id] = {
					'id': id,
					'label': label,
					'name': name,
					'type': type,
					'srcNode': srcNode,
					'labelNode': labelNode,
					'value': value,
					'disabled': disabled
				};
			}
			
			return config;
		},
		
		/**
		 * Fix input config value references to prevent two inputs with
		 * same type (like Hidden) having same raw value
		 * 
		 * @param {Object} config
		 */
		fixInputConfigValueReferences: function (config) {
			if (config.inputs) {
				var empty = {},
					value = null;
				
				for(var i=0,ii=config.inputs.length; i<ii; i++) {
					value = config.inputs[i].value;
					if (Y.Lang.isObject(value)) {
						empty = (Y.Lang.isArray(value) ? [] : {});
						config.inputs[i].value = Supra.mix(empty, config.inputs[i].value, true);
					}
				}
			}
		},
		
		/**
		 * Normalize input config
		 * 
		 * @private
		 * @param {Object} config
		 * @return Normalized input config
		 * @type {Object}
		 */
		normalizeInputConfig: function () {
			//Convert arguments into
			//[{}, INPUT_DEFINITION, argument1, argument2, ...]
			var args = [].slice.call(arguments,0);
				args = [{'parent': this, 'root': this.get('root') || this}, INPUT_DEFINITION].concat(args);
			
			//Mix them together
			return Supra.mix.apply(Supra, args);
		},
		
		/**
		 * Create Input instance from configuration
		 * 
		 * @param {Object} config
		 * @return Input instance
		 * @type {Object}
		 */
		factoryField: function (config) {
			var type = config.type;
				type = type.substr(0,1).toUpperCase() + type.substr(1);
			
			if (config.value && !config.defaultValue) {
				config.defaultValue = config.value;
			} else if (!config.value && config.defaultValue) {
				config.value = config.defaultValue;
			}
			
			if (type in Supra.Input) {
				return new Supra.Input[type](config);
			} else {
				return null;
			}
		},
		
		/**
		 * Add input
		 * 
		 * config - input configuration object:
		 *     id         - unique field ID
		 *     name       - input name, will be sent as name on save request. Optional
		 *     label      - label text. Optional
		 *     type       - field type. Possible values: "String", "Path", "Template", "Checkbox", "Select", "Text", "Html". Optional, default is "String"
		 *     srcNode    - input node or field (input,label,etc.) node. Optional
		 *     labelNode  - label node, label property will be set to text content of labelNode. Optional
		 *     value      - input value. Optional, default is empty string,
		 *     disabled   - input disabled or not. Optional, if input has disabled attribute, then it will be used
		 * 
		 * @param {Object} config
		 */
		addInput: function (config, definition) {
			if (config.isInstanceOf && config.isInstanceOf('input') && definition) {
				//Add input to the list of form inputs
				config.set('parent', this);
				
				var id = config.get('id');
				this.inputs[id] = config;
				this.inputs_definition[id] = definition;
			} else if (this.get('rendered')) {
				
				//Create input and append
				var id = null,
					input = null,
					node = null,
					contentBox = this.getContentNode(),
					srcNode = this.get('srcNode');
				
				config = this.normalizeInputConfig(config);
				id = config.id || config.name;
				this.inputs_definition[id] = config;
				
				input = this.factoryField(config);
				if (input) {
					this.inputs[id] = input;
					
					if (config.srcNode) {
						input.render();
					} else if (config.containerNode) {
						//If input doesn't exist but has container node, then create
						//input inside it
						input.render(config.containerNode);
					} else {
						//If input doesn't exist, then create it
						input.render(contentBox);
					}
				}
				
			} else {
				var id = ('id' in config && config.id ? config.id : ('name' in config ? config.name : ''));
				if (!id) {
					Y.log('Input configuration must specify ID or NAME', 'debug');
					return this;
				}
				
				var conf = (id in this.inputs_definition ? this.inputs_definition[id] : {});
				this.inputs_definition[id] = Supra.mix(conf, config);
			}
			
			return this;
		},
		
		/**
		 * Alias of addInput
		 */
		setInput: function (config) {
			return this.addInput(config);
		},
		
		/**
		 * Returns form contentBox or slideshow main slide content
		 * 
		 * @returns {Object} Content node
		 */
		getContentNode: function () {
			var slideshow = this.get('slideshow'),
				slide,
				key;
			
			if (slideshow && slideshow.getSlide) {
				slide = slideshow.getSlide('propertySlideMain');
				if (!slide) {
					for (key in slideshow.slides) {
						slide = slideshow.getSlide(key);
					}
				}
				if (slide) {
					return slide.one('.su-slide-content');
				}
			}
			
			return this.get('contentBox');
		},
		
		
		/**
		 * Bind even listeners
		 * @private
		 */
		bindUI: function () {
			Form.superclass.bindUI.apply(this, arguments);
			
			//On visibility change show/hide form
			this.on('visibleChange', function (event) {
				this.get('boundingBox').toggleClass('hidden', !event.newVal);
			}, this);
			
			//Find button with 'form' attribute which could be in the footer
			//and add support for IE
			if (Y.UA.ie) {
				var form = this.get('srcNode'),
					form_id = form.get('id'),
					button = Y.one('button[form="' + form_id + '"]');
				
				if (button && !button.closest(form)) {
					//On submit call 'save'
					button.on('click', this.submit, this);
					
					//On input return key call 'save'
					form.all('input[type="text"],input[type="password"]').on('keyup', function (event) {
						if (event.keyCode == 13) { //Return key
							this.submit();
							event.preventDefault();
						}
					}, this);
				}
			}
			
			//On submit call 'save'
			this.get('srcNode').on('submit', function (event) {
				//Use ajax
				event.preventDefault();
				
				//Save form
				this.save();
			}, this);
		},
		
		/**
		 * Submit form
		 */
		submit: function () {
			this.fire('submit');
			this.save();
		},
		
		/**
		 * Process Input attribute
		 */
		processAttributes: function () {
			var inputs = this.get('inputs');
			
			if (Y.Lang.isArray(inputs)) {
				var obj = {},
					id = null,
					i = 0,
					ii = inputs.length;
				
				for(; i<ii; i++) {
					id = (('id' in inputs[i]) ? inputs[i].id : ('name' in inputs[i] ? inputs[i].name : null));
					if (id) {
						obj[id] = inputs[i];
					}
				}
				inputs = obj;
			}
			
			Supra.mix(this.inputs_definition, inputs || {});
		},
		
		/**
		 * Render form and inputs
		 * @private
		 */
		renderUI: function () {
			Form.superclass.renderUI.apply(this, arguments);
			
			var srcNode = this.get('srcNode');
			var contentBox = this.get('contentBox');
			
			var inputs = this.inputs || {};
			var definitions = this.inputs_definition || {};
			
			//Find all inputs
			if (this.get('autoDiscoverInputs')) {
				definitions = Supra.mix(this.discoverInputs(), definitions, true);
			}
			
			//Normalize definitions
			//by adding missing parameters
			var definition = null,
				id = null,
				node = null,
				input = null,
				slide = null,
				slideshow = this.get('slideshow');
			
			//Change content box to slideshow content
			if (slideshow) {
				if (slideshow === true) {
					slideshow = new Supra.Slideshow();
					slideshow.render(contentBox);
					this.set('slideshow', slideshow);
					slide = slideshow.addSlide('propertySlideMain');
				}
				contentBox = this.getContentNode();
			}
			
			//Create Inputs
			for(var i in definitions) {
				//If input already exists, then don't create it
				if (definitions[i].id in inputs) continue;
				
				definition = definitions[i] = this.normalizeInputConfig(definitions[i]);
				id = definition.id;
				
				//Try finding input
				if (!definition.srcNode) {
							    node = srcNode.one('#' + id);
					if (!node)  node = srcNode.one('*[name="' + definition.name + '"]');
					if (!node)  node = srcNode.one('*[data-input-id="' + id + '"]');
					
					if (node) {
						definition.srcNode = node;
					}
				}
				
				input = this.factoryField(definition);
				if (input) {
					inputs[id] = input;
					
					if (definition.srcNode) {
						input.render();
					} else if (definition.containerNode) {
						//If input doesn't exist but has container node, then create
						//input inside it
						input.render(definition.containerNode);
					} else {
						//If input doesn't exist, then create it
						input.render(contentBox);
					}
				}
			}
			
			this.inputs = inputs;
			this.inputs_definition = definitions;
			
			var style = this.get('style') || this.get('srcNode').getAttribute('suStyle') || 'default';
			this.setStyle(style);
		},
		
		/**
		 * Change form style
		 * 
		 * @param {String} style Style values, valid values are 'default', 'vertical' and 'default vertical'
		 */
		setStyle: function (style) {
			//Style value can be also 'default vertical'
			style = style.split(' ');
			
			var i = 0,
				ii = style.length;
			
			for(; i<ii; i++) {
				this.get('srcNode').addClass(Y.ClassNameManager.getClassName(Form.NAME, style[i]));
			}
		},
		
		/**
		 * Add classname to the form bounding box
		 * 
		 * @param {String} c Classname 
		 */
		addClass: function (c) {
			this.get('boundingBox').addClass(c);
			return this;
		},
		
		/**
		 * Remove classname from the form bounding box
		 * 
		 * @param {String} c Classname 
		 */
		removeClass: function (c) {
			this.get('boundingBox').removeClass(c);
			return this;
		},
		
		/**
		 * Returns true if forms bounding box has this classname, otherwise false
		 * 
		 * @param {String} c Classname 
		 */
		hasClass: function (c) {
			return this.get('boundingBox').hasClass(c);
		},
		
		/**
		 * Add/remove classname from the form bounding box
		 * 
		 * @param {String} c Classname
		 * @param {Boolean} v Add or remove, if true classname will be added, otherwise removed
		 */
		toggleClass: function (c, v) {
			this.get('boundingBox').toggleClass(c, v);
			return this;
		},
		
		/**
		 * Destructor
		 * 
		 * @private
		 */
		destructor: function () {
			//Destroy all input widgets
			var inputs = this.inputs;
			for(var key in inputs) {
				inputs[key].destroy();
			}
			
			this.inputs = null;
			this.inputs_definition = null;
		},
		
		/**
		 * Serialize multi-dimensional object into one dimensional object
		 * 
		 * @param {Object} obj
		 * @param {String} prefix
		 * @return One dimensional object
		 * @type {Object}
		 * @private
		 */
		serializeObject: function (obj, prefix, skip_encode) {
			var prefix = prefix || '';
			var out = {};
			
			for(var id in obj) {
				var name = skip_encode ? id : encodeURIComponent(id);
					name = prefix ? prefix + '[' + name + ']' : name;
				
				if (Y.Lang.isObject(obj[id])) {
					out = Y.mix(this.serializeObject(obj[id], name, skip_encode) ,out);
				} else {
					out[name] = skip_encode ? obj[id] : encodeURIComponent(obj[id]);
				}
			}
			
			return out;
		},
		
		/**
		 * Convert one-dimensional value object into multi-dimensional changing
		 * 'key1[key2][key3]' = 3 into {key1: {key2: {key3: 3}}}
		 * 
		 * @param {Object} obj
		 * @return Multi dimensional object
		 * @type {Object}
		 * @private
		 */
		unserializeObject: function (obj, skip_decode) {
			var out = {},
				m,
				name,
				is_string;
			
			for(var id in obj) {
				//If value is not string, then no need to decode
				is_string = typeof obj[id] == 'string';
				
				if (String(id).indexOf('[') != -1) {
					if (m = id.match(/([^\[]+)\[([^\]]+)\](.*)/)) {
						try {
							name = skip_decode || !is_string ? m[1] : QueryString.unescape(String(m[1]));
						} catch (e) {
							name = m[1];
						}
						if (!(name in out)) out[name] = {};
						this.unserializeItem(m[2] + m[3], obj[id], out[name], skip_decode);
					}
				} else {
					try {
						out[id] = skip_decode || !is_string ? obj[id] : QueryString.unescape(obj[id]);
					} catch (e) {
						out[id] = obj[id];
					}
				}
			}
			
			return out;
		},
		
		/**
		 * Parse ID string and set data on out object
		 * 
		 * @param {String} id
		 * @param {Object} value
		 * @param {Object} out
		 * @private
		 */
		unserializeItem: function (id, value, out, skip_decode) {
			var m, name, is_string;
			
			if (String(id).indexOf('[') != -1) {
				if (m = id.match(/([^\[]+)\[([^\]]+)\](.*)/)) {
					try {
						name = skip_decode ? m[1] : QueryString.unescape(String(m[1]));
					} catch (e) {
						name = m[1];
					}
					if (!(name in out)) out[name] = {};
					this.unserializeItem(m[2] + m[3], value, out[name], skip_decode);
				}
			} else {
				is_string = typeof value == 'string';
				try {
					out[id] = skip_decode || !is_string ? value : QueryString.unescape(value);
				} catch (e) {
					out[id] = value;
				}
			}
		},
		
		/**
		 * Returns serialize values ready for use in query string
		 * 
		 * @param {String} key Name of the property, which will be used for key, default is 'name'
		 * @return Form input values
		 * @type {Object}
		 */
		getSerializedValues: function (key) {
			var values = this.getValues(key);
				values = this.serializeObject(values);
			
			return values;
		},
		
		/**
		 * Returns values parsing input names and changing into
		 * multi-dimension object
		 * 
		 * @param {String} key Name of the property, which will be used for key, default is 'name'
		 * @return Form input values
		 * @type {Object}
		 */
		getValuesObject: function (key) {
			var values = this.getValues(key);
			return this.unserializeObject(values);
		},
		
		/**
		 * Returns input name => value pairs
		 * Optionally other attribute can be used instead of 'name'
		 * 
		 * @param {String} key
		 * @param {Boolean} save Return save value
		 * @return Form input values
		 * @type {Object}
		 */
		getValues: function (key, save) {
			var key = key || 'name';
			var values = Supra.mix({}, this.get('plainValues'));
			var definitions = this.inputs_definition;
			var prop = save ? 'saveValue' : 'value';
			
			for(var id in this.inputs) {
				var input = this.inputs[id];
				var val = input.get(prop);
				if (val !== undefined) {
					values[key == 'id' || key == 'name' ? (id in definitions ? definitions[id][key] : id) : input.getAttribute(key)] = val;
				}
			}
			
			return values;
		},
		
		/**
		 * Returns save values as input name => value pairs
		 * Optionally other attribute can be used instead of 'name'
		 * 
		 * @param {String} key
		 * @return Form input values
		 * @type {Object}
		 */
		getSaveValues: function (key) {
			return this.getValues(key, true);
		},
		
		/**
		 * Set input values
		 * 
		 * @param {Object} data
		 * @param {Object} key
		 */
		setValues: function (data, key, skip_encode) {
			var key = key || 'name',
				definitions = this.inputs_definition,
				input = null,
				key_value = null,
				data = skip_encode ? data : this.serializeObject(data, null, true),
				plainValues = this.get('plainValues');
			
			data = data || {};
			
			for(var id in this.inputs) {
				input = this.inputs[id];
				key_value = (key == 'id' || key == 'name' ? (id in definitions ? definitions[id][key] : id) : input.getAttribute(key));
				
				if (key_value in data) {
					input.set('value', data[key_value]);
				}
			}
			
			for(var id in data) {
				if (!this.inputs[id]) {
					plainValues[id] = data[id];
				}
			}
			
			return this;
		},
		
		/**
		 * Set input values without converting names {'a': {'b': 'c'}} into {'a[b]': 'c'}
		 * 
		 * @param {Object} data
		 * @param {Object} key
		 */
		setValuesObject: function (data, key) {
			return this.setValues(data, key, true);
		},
		
		/**
		 * Reset input values to defaults
		 * 
		 * @param {Array} inputs Optional. Array of input ids which should be reseted, if not set then all inpts
		 */
		resetValues: function (list) {
			var inputs = this.inputs;
			
			if (Y.Lang.isArray(list)) {
				for(var i=0,ii=list.length; i<ii; i++) {
					if (list[i] in inputs) {
						inputs[list[i]].resetValue();
						inputs[list[i]].set('error', false);
					}
				}
			} else {
				for(var id in inputs) {
					inputs[id].resetValue();
					inputs[id].set('error', false);
				}
			}
			
			this.set('plainValues', {});
			
			return this;
		},
		
		/**
		 * Returns inputs
		 *  
		 * @return All inputs
		 * @type {Object}
		 */
		getInputs: function (key) {
			if (!key || key == 'id') {
				return this.inputs;
			} else {
				var obj = {},
					inputs = this.inputs,
					i = null;
				
				for(i in inputs) obj[inputs[i].getAttribute(key)] = inputs[i];
				return obj;
			}
		},
		
		/**
		 * Returns input by ID or if not found, then by name
		 * 
		 * @param {String} id
		 * @return Input instance
		 * @type {Object}
		 */
		getInput: function (id) {
			if (id in this.inputs) {
				return this.inputs[id];
			} else {
				//Search by 'name'
				var definitions = this.inputs_definition;
				
				for(var i in definitions) {
					if (definitions[i].name == id) return this.inputs[i];
				}
			}
			return null;
		},
		
		/**
		 * Returns input configuration/definition by id or by name if
		 * there were no matches by id or null if name also didn't matches
		 * any input
		 * 
		 * @param {String} id
		 * @return Input configuration/definition
		 * @type {Object}
		 */
		getConfig: function (id) {
			var definitions = this.inputs_definition;
			if (id in definitions) {
				return definitions[id];
			} else {
				for(var i in definitions) {
					if (definitions[i].name == id) return definitions[i];
				}
			}
			return null;
		},
		
		/**
		 * Set if form should search for inputs
		 * 
		 * @param {Boolean} value
		 */
		setAutoDiscoverInputs: function (value) {
			this.set('autoDiscoverInputs', !!value);
			return this;
		},
		
		/**
		 * Set load request url
		 * 
		 * @param {String} url
		 */
		setURLLoad: function (url) {
			this.set('urlLoad', url);
			return this;
		},
		
		/**
		 * Set delete request url
		 * 
		 * @param {String} url
		 */
		setURLDelete: function (url) {
			this.set('urlDelete', url);
			return this;
		},
		
		/**
		 * Set save request url
		 * 
		 * @param {String} url
		 */
		setURLSave: function (url) {
			this.set('urlSave', url);
			return this;
		},
		
		/**
		 * Validate form values
		 * 
		 * @return True on success, false on failure
		 * @type {Boolean}
		 */
		validate: function () {
			//@TODO
			return true;
		},
		
		/**
		 * Validate and execute save request if url is set and user is authorized to save data
		 */
		save: function (callback, context) {
			if (!this.get('disabled') && this.validate()) {
				var uri = this.get('urlSave'),
					values = null;
				
				if (uri) {
					values = this.getSaveValues(this.get('inputs') ? 'id' : 'name');
					
					Supra.io(uri, {
						'method': 'post',
						'data': values,
						'context': context || this,
						'on': {
							'success': callback,
							'failure': callback
						}
					});
					
				} else {
					if (callback) {
						callback.call(context = context || this, null, 1);
					}
				}
				
				this.fire('save');
			} else {
				if (callback) {
					callback.call(context = context || this, null, 0);
				}
			}
		},
		
		/**
		 * Load data and populate form if url is set and user is authorized to load data
		 */
		load: function () {
			//@TODO
			
			this.fire('load');
		},
		
		/**
		 * Execute delete request if url is set, form has ID field and user is authorized to delete record
		 */
		'delete': function () {
			//@TODO
			
			this.fire('delete');
		},
		
		_setDisabled: function (disabled) {
			//If rendering phase and should enable form (default) then skip, bacause
			//all inputs already are enabled by default and if any is not
			//then that was intended like that
			if (!this.get('rendered') && !disabled) return disabled;
			
			var inputs = this.getInputs();
			for(var id in inputs) inputs[id].set('disabled', disabled);
			
			return disabled;
		}
	});
	
	/**
	 * Validation functions 
	 */
	Form.validate = {
		/**
		 * Regular expression to test email validity
		 * @type {Object}
		 */
		REGEX_EMAIL: /^\s*([a-z0-9]([a-z0-9\.\-\_]*[a-z0-9])?@[a-z0-9][a-z0-9\-\_]*([\.]([a-z0-9][a-z0-9\-\_]?)?[a-z0-9])*)\s*$/i,
		
		/**
		 * Returns true if str parammeter is not empty
		 * 
		 * @param {String} str String to validate
		 * @returns {Boolean} True if string is not empty, otherwise false
		 */
		required: function (str) {
			str = String(str);
			return !!Y.Lang.trim(str).length;
		},
		
		/**
		 * Validate email address validity
		 * 
		 * @param {String} str String to validate
		 * @returns {Boolean} True if string is valid email address, otherwise false
		 */
		email: function (str) {
			if (Form.validate.REGEX_EMAIL.test(String(str)) === false) {
				return false;
			} else {
				return true;
			}
		}
	}
	
	/**
	 * Returns lipsum data for inputs
	 * 
	 * @param {Object} inputs List of input definitions
	 * @returns {Object} Lipsum data for inputs
	 */
	Form.lipsum = function (inputs, overwrite_defaults) {
		var properties = inputs,
			property = null,
			i = 0,
			ii = properties.length,
			lipsum = null,
			input = null,
			generated = {};
		
		for (; i<ii; i++) {
			property = properties[i];
			lipsum = Form.lipsumProperty(property, overwrite_defaults);
			if (lipsum) {
				generated[property.id] = lipsum;
			}
		}
		
		return generated;
	};
	
	Form.lipsumProperty = function (property, overwrite_defaults) {
		var input = Supra.Input[property.type],
			i = 0,
			ii = 0,
			k = 0,
			kk = 0,
			lipsum = '',
			items = null,
			item = null;
		
		if (input && input.lipsum) {
			// Input
			if (overwrite_defaults) {
				lipsum = input.lipsum();
			}
		} else if (property.type == 'Gallery') {
			// Gallery block
			items = [];
			
			// Create 4 items
			if (property.properties) {
				for (k=0, kk=4; k<kk; k++) {
					item = {'id': Y.guid(), 'image': null, 'properties': {}};
					
					for (i=0, ii=property.properties.length; i<ii; i++) {
						lipsum = Form.lipsumProperty(property.properties[i], overwrite_defaults);
						item.properties[property.properties[i].id] = lipsum || property.properties[i].value || '';
					}
					items.push(item);
				}
			}
			
			lipsum = items.length ? items : null;
		} else if (property.type == 'Slideshow') {
			// Slideshow block
		}
		
		return lipsum;
	};
	
	
	Supra.Form = Form;
	Supra.Form.normalizeInputConfig = Form.prototype.normalizeInputConfig;
	Supra.Form.factoryField = Form.prototype.factoryField;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version);YUI.add('supra.header.appdock', function(Y) {
	//Invoke strict mode
	"use strict";
	
	//Icon size constant
	var ICON_SIZES = {
		'32': '_32x32.png',
		'64': '_64x64.png'
	};
	
	//Blank icon image
	var ICON_BLANK = '/cms/lib/supra/img/px.gif';
	
	//Templates
	var TEMPLATE_CURRENT = '<span class="icon-dashboard"><img src="/cms/lib/supra/img/toolbar/buttons-dashboard.png" /></span><img src="{icon}" alt="" class="icon" /><span class="title">{title}</span>';
	var TEMPLATE_ITEM = '<li><a href="{path}"><img src="{icon}" alt="" /><span>{title}</span></a></li>';
	var TEMPLATE_ITEM_LOGOUT = '<li class="logout"><a href="{path}"><div></div><span>{title}</span></a></li>';
	
	//Shortcuts
	var getClassName = Y.ClassNameManager.getClassName;
	
	/**
	 * Application dock bar
	 *
	 * @alias Supra.AppDock
	 * @param {Object} config Configuration
	 */
	function AppDock (config) {
		AppDock.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	AppDock.NAME = "app";
	AppDock.CLASS_NAME = getClassName(AppDock.NAME);
	
	AppDock.ATTRS = {
		
		/**
		 * Current application data
		 * @type {Object}
		 */
		'data': {
			'value': null
		},
		
		/**
		 * App node
		 * @type {Object}
		 */
		'nodeApp': {
			'value': null
		},
		
		/**
		 * App dock bar node
		 * @type {Object}
		 */
		'nodeDock': {
			'value': null
		}
	};
	
	AppDock.HTML_PARSER = {
		/**
		 * Find existing node
		 */
		'nodeApp': function (srcNode) {
			return srcNode.one('.' + getClassName(AppDock.NAME, 'current'));
		}
	};
	
	
	Y.extend(AppDock, Y.Widget, {
		
		/**
		 * Dock bar visiblity state
		 * @type {Boolean}
		 * @private
		 */
		dock_visible: false,
		
		/**
		 * Render dock bar
		 * @private
		 */
		renderUI: function () {
			AppDock.superclass.renderUI.apply(this, arguments);
			
			//Create node app
			var node_app = this.get('nodeApp');
			if (!node_app) {
				node_app = Y.Node.create('<a class="' + getClassName(AppDock.NAME, 'current') + '"></a>');
				this.get('contentBox').append(node_app);
				this.set('nodeApp', node_app);
			}
		},
		
		/**
		 * Bind event listeners
		 * @private
		 */
		bindUI: function () {
			AppDock.superclass.bindUI.apply(this, arguments);
			
			this.get('nodeApp').on('click', this.toggleAppDockBar, this);
			this.after('dataChange', this.syncUI, this);
		},
		
		/**
		 * Update UI
		 * @private
		 */
		syncUI: function () {
			var node_app = this.get('nodeApp'),
				data_app = this.get('data');
			
			var node_img = node_app.one('img.icon'),
				node_title = node_app.one('span.title');
			
			if (!node_img) {
				var node_data = {
					'icon': this.getAppIcon(data_app, '32'),
					'title': data_app ? data_app.title : ''
				};
				node_img = Y.Node.create(Y.substitute(TEMPLATE_CURRENT, node_data));
				node_app.append(node_img);
				node_title = node_app.one('span.title');
			} else {
				node_img.setAttribute('src', this.getAppIcon(data_app, '32'));
				node_title.set('text', data_app ? data_app.title : ''); 
			}
			
			// Hide title element if it's empty
			node_title.toggleClass("hidden", !data_app || !data_app.title);
		},
		
		/**
		 * Returns app icon URI
		 * 
		 * @param {Object} data Application data
		 * @param {String} size Icon size ID
		 * @return Application icon URI
		 * @type {String}
		 */
		getAppIcon: function (data, size) {
			if (data && data.icon && size in ICON_SIZES) {
				return data.icon + ICON_SIZES[size];
			} else {
				return ICON_BLANK;
			}
		},
		
		/**
		 * Open application dock bar
		 */
		toggleAppDockBar: function (event) {
			//Stop event
			if (event) event.halt();
			if (this.get('disabled')) return;
			
			//Hide if it's already visible
			var dashboard = Supra.Manager.getAction("Applications"),
				sites = Supra.Manager.getAction("Sites");
			
			if (dashboard.get("visible")) {
				if (sites.get("visible")) {
					sites.hide();
				} else {
					dashboard.hide();
				}
			} else {
				dashboard.execute();
			}
		}
	});
	
	
	//Add to Supra namespace
	Supra.AppDock = AppDock;
	
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.tooltip']});YUI.add('supra.header', function(Y) {
	//Invoke strict mode
	"use strict";
	
	//Add application configuration to Intl for templates
	Supra.Intl.add({'application': Supra.data.get('application')});
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:['supra.header.appdock']});/*
 * Supra.PluginLayout
 */
YUI.add('supra.plugin-layout', function (Y) {
	//Invoke strict mode
	"use strict";
	
	function PluginLayout () {
		PluginLayout.superclass.constructor.apply(this, arguments);
	}
	
	PluginLayout.NAME = 'plugin-playout';
	PluginLayout.NS = "layout";
	PluginLayout.ATTRS = {
		/**
		 * Offset margins
		 * [left, top, right, bottom]
		 */
		'offset': {
			'value': [0,0,0,0]
		},
		
		/**
		 * Number of ms for throttle
		 */
		'throttle': {
			'value': 0
		}
	};
	
	Y.extend(PluginLayout, Y.Plugin.Base, {
		
		/**
		 * List of widgets/nodes used for offset
		 * @type {Array}
		 */
		offsets: [],
		
		/**
		 * Sync function
		 * @type {Function}
		 */
		sync_function: null,
		
		/**
		 * Initialize plugin
		 * 
		 * @constructor
		 * @param {Object} config
		 */
		initializer: function (config) {
			//Reset value
			this.offsets = [];
			
			var throttle = this.get('throttle');
			if (throttle) {
				this.sync_function = Supra.throttle(this.syncUI, throttle, this);
			} else {
				this.sync_function = Y.bind(function () {
					// We still want small delay to prevent non-smooth animations when
					// two different components change layout, for example one block
					// calls to hide sidebar and another one right after that to show it
					Supra.immediate(this, this.syncUI);
				}, this);
			}
			
			this.sync_function();
			
			//On window resize sync position
			Y.on('resize', this.sync_function);
		},
		
		/**
		 * Update position
		 */
		syncUI: function () {
			// If layout is disabled for some reason, then
			if (this.get('host').get('layoutDisabled') === true) return;
			
			var config = this.get('offset'),
				changed = {'left': false, 'top': false, 'right': false, 'bottom': false},
				offset = {'left': config[0], 'top': config[1], 'right': config[2], 'bottom': config[3]},
				offsets = this.offsets,
				pos = null,
				size = null,
				xy = null,
				node = null,
				win_w = Y.DOM.winWidth(),
				win_h = Y.DOM.winHeight();
			
			for(var i=0,ii=offsets.length; i<ii; i++) {
				pos = offsets[i].pos;
				changed[pos] = true;
				
				//Only visible nodes
				if (!offsets[i].widget || offsets[i].widget.get('visible')) {
					node = offsets[i].node;
					xy = node.getXY();
					size = [node.get('offsetWidth'), node.get('offsetHeight')];
					pos = offsets[i].pos;
					
					switch(pos) {
						case 'top':
							offset[pos] = Math.max(offset[pos], xy[1] + size[1] + offsets[i].margin); break;
						case 'bottom':
							offset[pos] = Math.max(offset[pos], win_h - xy[1] + offsets[i].margin); break;
						case 'left':
							offset[pos] = Math.max(offset[pos], xy[0] + size[0] + offsets[i].margin); break;
						case 'right':
							offset[pos] = Math.max(offset[pos], win_w - xy[0] + offsets[i].margin); break;
					}
				}
			}
			
			var host = this.get('host'),
				node = host.get('boundingBox'),
				style = {},
				info = {};
			
			if (!node && host.isInstanceOf('Node')) node = host;
			if (!node) node = host.get('srcNode');
			
			if (node) {
				for(var pos in changed) {
					if (changed[pos]) {
						info[pos] = offset[pos];
						style[pos] = offset[pos] + 'px';
					}
				}
				node.setStyles(style);
				
				if (node.isInstanceOf('NodeList')) node = node.item(0);
				if (node) node.fire('contentResize');
			}
			
			this.fire('sync', {'offset': info});
		},
		
		/**
		 * Add offset widget
		 * 
		 * @param {Object} node Widget or node
		 * @param {String} pos
		 * @param {Object} margin
		 */
		addOffset: function (widget, node, pos, margin) {
			if (widget.after) {
				widget.after('contentResize', this.sync_function, this);
				widget.after('visibleChange', function (evt) {
					if (evt.prevVal != evt.newVal) {
						this.sync_function(evt);
					}
				}, this);
				
				if (widget.isInstanceOf('Tabs')) widget.after('activeTabChange', this.sync_function, this);
			}
			
			var node = node.isInstanceOf('Node') ? node : (widget ? widget.get('boundingBox') : null);
			
			if (widget || node) {
				this.offsets.push({
					'node': node,
					'widget': widget,
					'pos': pos,
					'margin': margin
				});
			}
		}
	
	});
	
	PluginLayout.TOP = 'top';
	PluginLayout.BOTTOM = 'bottom';
	PluginLayout.LEFT = 'left';
	PluginLayout.RIGHT = 'right';
	
	Supra.PluginLayout = PluginLayout;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires: ['widget', 'plugin']});YUI.add("supra.languagebar", function (Y) {
	
	/*
	 * Shortcuts
	 */
	var Template = Supra.Template;
	
	/*
	 * Regular expression to match language and context in locale string
	 */
	var REGEX_MATCH_LOCALE = /^([a-z]+)_([a-z]+)$/i;
	
	/*
	 * Templates
	 */
	var TEMPLATE_CONTENT = '<div class="yui3-languagebar-content">' +
								'<span class="label"></span> <a class="selected"><span class="title"></span><img src="/cms/lib/supra/img/flags/16x11/blank.png" alt="" /></a>' +
							'</div>';
	
	/* Language list template */
	var TEMPLATE = Template.compile(
			'<ul class="contexts">' +
			'	{% for context in contexts %}' +
			'	<li>' +
			'		<div class="context-title">{{ context.title|escape }}</div>' +
			'		<ul class="langs">' +
			'			{% for lang in context.languages %}' +
			'				<li>' +
			'					<a data-locale="{{ lang.id|escape }}">' +
			'						{% if lang.flag %}' +
			'							<img src="/cms/lib/supra/img/flags/16x11/{{ lang.flag }}.png" alt="" />' +
			'						{% else %}' +
			'							<img src="/cms/lib/supra/img/flags/16x11/blank.png" alt="" />' +
			'						{% endif %}' +
			'						<span>{{ lang.title|escape }}</span>' +
			'					</a>' +
			'				</li>' +
			'			{% endfor %}' +
			'		</ul>' +
			'	</li>' +
			'	{% endfor %}' +
			'</ul>'
		);
	
	/**
	 * Class for handling content languages
	 * 
	 */
	function LanguageBar (config) {
		LanguageBar.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	LanguageBar.NAME = 'languagebar';
	
	LanguageBar.ATTRS = {
		/**
		 * Context/language list
		 * @type {Array}
		 */
		'contexts': {
			value: null,
			setter: '_setContexts'
		},
		/**
		 * Current locale, format: LANGUAGE_CONTEXT
		 * @type {String}
		 */
		'locale': {
			value: '',
			setter: '_setLocale'
		},
		
		/**
		 * Language bar label text
		 * @type {String}
		 */
		'localeLabel': {
			value: '',
			setter: '_setLocaleLabel'
		},
		
		/**
		 * Disabled state
		 * @type {Boolean}
		 */
		'disabled': {
			value: false,
			setter: '_setDisabled'
		}
	};
	
	LanguageBar.HTML_PARSER = {
	};
	
	Y.extend(LanguageBar, Y.Widget, {
		/**
		 * Content template
		 * @type {String}
		 * @private
		 */
		CONTENT_TEMPLATE: TEMPLATE_CONTENT,
		
		/**
		 * Panel
		 * @private
		 */
		panel: null,
		
		
		/**
		 * Show language dropdown
		 * 
		 * @private
		 */
		toggleDropdown: function () {
			if (this.get('disabled')) return;
			
			//Create panel
			if (!this.panel) {
				this.panel = new Supra.Tooltip({
					'alignTarget': this.get('srcNode').one('a'),
					'alignPosition': 'T',
					'zIndex': 1
				});
				this.panel.render(this.get('contentBox'));
				
				//Create items
				var content = this.panel.get('contentBox');
				content.all('ul').remove();
				content.append(this.renderUIList());
				
				//On body click hide panel
				var body = new Y.Node(document.body);
				body.on('click', this.panel.hide, this.panel);
				
				this.panel.show();
			} else {
				if (this.panel.get('visible')) {
					this.panel.hide();
				} else {
					this.panel.show();
				}
			}
		},
		
		/**
		 * Set contexts
		 * 
		 * @param {Array} contexts Contexts
		 */
		_setContexts: function (contexts) {
			if (!this.panel) return;
			
			var content = this.panel.get('contentBox');
				content.all('ul').remove();
				content.append(this.renderUIList(contexts));
			
			this.set('locale', this.get('locale'));
		},
		
		/**
		 * Set disabled state
		 * 
		 * @param {Boolean} disabled Disabled state
		 * @private
		 */
		_setDisabled: function (disabled) {
			this.get('boundingBox').toggleClass(this.getClassName('disabled'), disabled);
			return disabled;
		},
		
		/**
		 * Render context/language list
		 * 
		 * @private
		 */
		renderUIList: function (contexts) {
			return Y.Node.create(TEMPLATE({
				'contexts': contexts || this.get('contexts')
			}));
		},
		
		/**
		 * Render UI
		 * 
		 * @private
		 */
		renderUI: function() {
			LanguageBar.superclass.renderUI.apply(this, arguments);
			
			//Set label, title, image
			this._setLocaleLabel(this.get('localeLabel'));
			this._setLocale(this.get('locale'));
		},
		
		/**
		 * Bind event listeners
		 * 
		 * @private
		 */
		bindUI: function () {
			LanguageBar.superclass.bindUI.apply(this, arguments);
			
			var link = this.get('srcNode').one('a');
			if (link) link.on('click', this.toggleDropdown, this)
			
			this.get('contentBox').on('click', function (evt) {
				evt.stopPropagation();
			});
			
			this.get('contentBox').delegate('click', function (evt) {
				var target = evt.target.closest('a');
				this.set('locale', target.getAttribute('data-locale'));
				this.panel.hide();
			}, 'li a', this);
		},
		
		/**
		 * Split locale into context and language
		 * 
		 * @param {String} locale Locale id
		 * @return Array with context and locale
		 * @type {Array}
		 * @private
		 */
		splitLocale: function (locale) {
			if (Y.Lang.isString(locale)) {
				var m = locale.match(REGEX_MATCH_LOCALE);
				if (m) {
					return [m[2], m[1]];
				}
			}
			return null;
		},
		
		/**
		 * Returns language by locale
		 * @param {Object} locale
		 */
		getLanguageByLocale: function (locale) {
			var contexts = this.get('contexts'),
			lang = null;
			
			for(var i=0,ii=contexts.length; i<ii; i++) {
				lang = this._find(contexts[i].languages, locale);
				if (lang) return lang;
			}
			
			return null;
		},
		
		/**
		 * Setter for locale attribute.
		 * Validate locale and update UI
		 * 
		 * @param {String} locale
		 * @return New locale value
		 * @type {String}
		 * @private
		 */
		_setLocale: function (locale) {
			var oldVal = this.get('locale'),
				lang = this.getLanguageByLocale(locale),
				node = null;
			
			if (lang) {
				node = this.get('srcNode').one('.title');
				if (node) node.set('text', lang.title);
				
				node = this.get('srcNode').one('img');
				if (node) node.set('src', '/cms/lib/supra/img/flags/16x11/' + lang.flag + '.png');
				
				return locale;
			}
			
			return oldVal;
		},
		
		/**
		 * Setter for localeLabel attribute
		 * 
		 * @param {String} label
		 */
		_setLocaleLabel: function (label) {
			if (!Y.Lang.isString(label)) label = '';
			var node = this.get('srcNode').one('.label');
			if (node) {
				node.toggleClass('hidden', !label);
				
				if (label) {
					node.set('text', label);
				}
			}
			return label;
		},
		
		/**
		 * Find array item by ID
		 * 
		 * @param {Array} arr Array to search
		 * @param {String} id Item ID
		 * @return Found item or null
		 * @type {Object}
		 * @private
		 */
		_find: function (arr, id) {
			if (arr) {
				for(var i=0,ii=arr.length; i<ii; i++) {
					if (arr[i].id == id) return arr[i];
				}
			}
			return null;
		}
	});
	
	Supra.LanguageBar = LanguageBar;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, { requires:['supra.tooltip'] });YUI.add("supra.slideshow-input-button", function (Y) {
	//Invoke strict mode
	"use strict";
	
	function Input (config) {
		Input.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	// Input is inline
	Input.IS_INLINE = false;
	
	// Input is inside form
	Input.IS_CONTAINED = true;
	
	Input.NAME = "input-button";
	Input.CLASS_NAME = Y.ClassNameManager.getClassName(Input.NAME);
	Input.ATTRS = {
		/**
		 * Button element, Supra.Button
		 */
		'button': {
			'value': null
		},
		
		/**
		 * Supra.Slideshow instance
		 */
		'slideshow': {
			'value': null
		},
		
		/**
		 * Slide ID
		 */
		'slideId': {
			'value': null
		},
		
		/**
		 * Icon
		 */
		'icon': {
			'value': null
		}
	};
	
	Input.HTML_PARSER = {};
	
	Y.extend(Input, Supra.Input.Proto, {
		INPUT_TEMPLATE: '',
		LABEL_TEMPLATE: '',
		
		renderUI: function () {
			Input.superclass.renderUI.apply(this, arguments);
			
			var icon = this.get('icon');
			
			this.get('boundingBox')
					.addClass('input-group')
					.addClass('input-group-button')
					.addClass('button-section');
			
			var button = new Supra.Button({
				'label': this.get('label'),
				'style': icon ? 'icon' : 'small-gray',
				'icon': icon
			});
			button.render(this.get('boundingBox'));
			this.set('button', button);
		},
		
		bindUI: function () {
			Input.superclass.bindUI.apply(this, arguments);
			
			var slideshow = this.get('slideshow'),
				slide_id = this.get('slideId');
			
			if (slideshow && slide_id) {
				this.get('button').on('click', this._scrollToSlide, this);
			}
		},
		
		_scrollToSlide: function () {
			this.get('slideshow').set('slide', this.get('slideId'));
		},
		
		_setValue: function (value) {
			return undefined;
		},
		
		_getValue: function (value) {
			return undefined;
		},
		
		_afterValueChange: function (evt) {
			if (evt.prevVal != evt.newVal) {
				this.fire('change', {'value': evt.newVal});
			}
		}
	});
	
	Supra.Input.Button = Input;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {requires:["supra.input-proto"]});YUI.add('supra.slideshow', function (Y) {
	//Invoke strict mode
	"use strict";
	
	/**
	 * Slideshow class 
	 * 
	 * @alias Supra.Slideshow
	 * @param {Object} config Configuration
	 */
	function Slideshow (config) {
		this.render_queue = [];
		this.history = [];
		this.slides = {};
		this.remove_on_hide = {};
		this.anim = null;
		
		Slideshow.superclass.constructor.apply(this, arguments);
		this.init.apply(this, arguments);
	}
	
	Slideshow.NAME = 'slideshow';
	Slideshow.CSS_PREFIX = 'su-' + Slideshow.NAME;
	
	Slideshow.ATTRS = {
		/**
		 * Slide list
		 * @type {Object}
		 */
		'slides': {
			value: null
		},
		
		/**
		 * Currently visible slide ID
		 * @type {String}
		 */
		'slide': {
			value: null
		},
		
		/**
		 * Don't use animations
		 */
		'noAnimations': {
			value: false
		},
		
		/**
		 * Animation duration 
		 */
		'animationDuration': {
			value: 0.5
		},
		
		/**
		 * Animation units, px or %
		 */
		'animationUnitType': {
			value: 'px'
		}
	};
	
	Slideshow.HTML_PARSER = {
		'slides': function (srcNode) {
			return srcNode.get('children');
		},
		'slide': function (srcNode) {
			var children = srcNode.get('children'),
				id = null;
			
			children.some(function (item) {
				if (!item.hasClass('hidden')) {
					id = item.getAttribute('id');
					return true;
				}
			});
			
			return id;
		}
	};
	
	Y.extend(Slideshow, Y.Widget, {
		
		/**
		 * Width of the slide container
		 * @type {Number}
		 */
		slide_width: 0,
		
		/**
		 * Slide list, keys are slide ids, values are bounding nodes
		 * @type {Object}
		 */
		slides: {},
		
		/**
		 * List of slides which will be removed when hidden
		 * @type {Object}
		 */
		remove_on_hide: {},
		
		/**
		 * Animation instance
		 * @type {Object}
		 */
		anim: null,
		
		/**
		 * Opened slide list
		 * @type {Array}
		 */
		history: [],
		
		/**
		 * Children widgets which needs to be rendered
		 * on slideshow renderUI
		 * @type {Array}
		 */
		render_queue: [],
		
		
		
		/**
		 * Render UI
		 */
		renderUI: function () {
			var slides = this.get('slides'),
				newSlides = {};
			
			if (slides) {
				slides.each(function () {
					var id = this.get('id');
					var bound = Y.Node.create('<div class="su-slide"></div>');
					var data = this.getData();
					
					this.addClass('su-slide-content');
					this.insert(bound, 'before');
					bound.append(this);
					bound.setData(data);
					newSlides[id] = bound;
					
					if (this.hasClass('hidden')) {
						this.removeClass('hidden');
						bound.addClass('hidden');
					}
					
					//Add scrollbar
					if (this.getAttribute('suScrollable') != 'false') {
						var scrollable = new Supra.Scrollable({
							'srcNode': this
						});
						
						scrollable.render();
						bound.setData('scrollable', scrollable);
					}
				});
				
				if (!this.get('slide')) {
					for(var i in newSlides) {
						newSlides[i].removeClass('hidden');
						this.history.push(i);
						this.set('slide', i, {'silent': true});
						break;
					}
				} else {
					var slideId = this.get('slide');
					if (Y.Array.indexOf(this.history, slideId) == -1) {
						this.history.push(slideId);
					}
				}
				
				Supra.mix(this.slides, newSlides);
			}
			
			this.anim = new Y.Anim({
				node: this.get('contentBox'),
				duration: this.get('animationDuration'),
				easing: Y.Easing.easeOutStrong
			});
		},
		
		bindUI: function () {
			
			//On a[data-target] link click change slide
			this.get('contentBox').delegate('click', this._onSectionLinkClick, 'a[data-target]', this);
			this.get('contentBox').delegate('keyup', this._onSectionLinkKey, 'a[data-target]', this);
			
			//On slide change scroll to it
			this.on('slideChange', function (e) {
				if (e.newVal != e.prevVal && !e.silent) {
					this.scrollTo(e.newVal);
				}
			}, this);
			
			//Handle window resize
			var layout = this.get('contentBox').closest('.left-container, .right-container');
			if (layout) layout.after('contentResize', this.syncUI, this);
			
			//Render Supra.Scrollable widgets
			var render_queue = this.render_queue;
			for(var i=0,ii=render_queue.length; i<ii; i++) {
				render_queue[i].render();
			}
			this.render_queue = [];
			
		},
		
		syncUI: function () {
			var slideId = this.get('slide'),
				index = Y.Array.indexOf(this.history, slideId),
				unit = this.get('animationUnitType');
			
			this.slide_width = null;
			this.slide_width = this._getWidth();
			
			this.get('contentBox').setStyle('left', - index * this.slide_width + unit);
			
			//Update scrollbar position
			if (this.slides[slideId]) {
				var content = this.slides[slideId].one('.su-slide-content, .su-multiview-slide-content');
				if (content) {
					content.fire('contentResize');
				}
			}
		},
		
		/**
		 * If user clicks on section link change slide to it
		 * 
		 * @param {Event} event Event facade object
		 * @private
		 */
		_onSectionLinkClick: function (event) {
			var node = event.target.closest('a');
			if (!node.hasClass('disabled')) {
				var slide = node.getAttribute('data-target');
				if (this.slides[slide]) this.set('slide', slide);
			}
		},
		
		/**
		 * If user presses key on section link change slide to it
		 * 
		 * @param {Event} event Event facade object
		 * @private
		 */
		_onSectionLinkKey: function (event) {
			if (event.keyCode == 13 || event.keyCode == 39) { //Return key or arrow right
				var node = event.target.closest('a'),
					slide = node.getAttribute('data-target');
				
				if (this.slides[slide]) this.set('slide', slide);
			}
		},
		
		/**
		 * Scroll to slide
		 * 
		 * @param {Object} slideId Slide ID
		 * @param {Function} callback Callback function
		 * @param {Object} context Callback function context
		 */
		scrollTo: function (slideId /* Slide ID */, callback /* Callback function */, context /* Context */) {
			var oldSlideId = this.get('slide');
			if (slideId == oldSlideId || !this.anim || !(slideId in this.slides)) return slideId;
			
			//Stop previous animation, otherwise new content may not be shown
			this.anim.stop();
			
			var index = Y.Array.indexOf(this.history, slideId),
				oldIndex = Y.Array.indexOf(this.history, oldSlideId),
				slideWidth = this._getWidth(),
				unit = this.get('animationUnitType'),
				to = - index * slideWidth + unit,
				from = - oldIndex * slideWidth + unit,
				boxNode = this.get('boundingBox');
			
			if (index == -1) {
				index = this.history.length;
				to = - index * slideWidth + unit;
				this.history[index] = slideId;
			}
			
			//Show and position new slide
			this.slides[slideId].setStyle('left', index * 100 + '%').removeClass('hidden');
			
			if (index < oldIndex) {
				this.history.splice(index + 1);
			}
			
			if (!this.get('noAnimations')) {
				//When animation ends hide old slide
				this.anim.once('end', function () {
					if (oldSlideId in this.slides) {
						if (oldSlideId in this.remove_on_hide) {
							//Remove slide
							this.removeSlide(oldSlideId);
						} else {
							//Hide slide
							this.slides[oldSlideId].addClass('hidden');
						}
						
						boxNode.setStyle('overflow', '');
					}
					
					//Execute callback
					if (Y.Lang.isFunction(callback)) {
						callback.call(context || this, slideId);
					}
				}, this);
				
				boxNode.setStyle('overflow', 'hidden');
				
				this.anim.stop();
				this.anim.set('from', {'left': from});
				this.anim.set('to', {'left': to});
				this.anim.run();
				
				//Update Supra.Scrollable
				Supra.immediate(this, function () {
					if (this.slides[slideId]) {
						var content = this.slides[slideId].one('.su-slide-content, .su-multiview-slide-content');
						if (content) {
							content.fire('contentResize');
						}
					}
				});
			} else {
				if (oldSlideId in this.slides) {
					if (oldSlideId in this.remove_on_hide) {
						//Remove slide
						this.removeSlide(oldSlideId);
					} else {
						//Hide slide
						this.slides[oldSlideId].addClass('hidden');
					}
				}
				this.get('contentBox').setStyle('left', to);
				
				//Make sure it's in correct position
				Supra.immediate(this, this.syncUI);
				
				//Execute callback
				if (Y.Lang.isFunction(callback)) {
					callback.call(context || this, slideId);
				}
			}
			
			this.set('slide', slideId, {silent: true});
			return slideId;
		},
		
		/**
		 * Scrolls to previous slide
		 * 
		 * @return New slide ID
		 * @type {String}
		 */
		scrollBack: function () {
			if (this.history.length > 1) {
				var slideId = this.history[this.history.length - 2];
				this.set('slide', slideId);
				return slideId;
			} else {
				return this.history.length ? this.history[0] : null;
			}
		},
		
		/**
		 * Scroll to root slide
		 * 
		 * @returns {String} New slide ID
		 */
		scrollRoot: function () {
			if (this.history.length > 1) {
				var slideId = this.history[0];
				this.set('slide', slideId);
				return slideId;
			} else {
				return this.history.length ? this.history[0] : null;
			}
		},
		
		/**
		 * Adds slide to the slideshow
		 * 
		 * @param {Object} options Slide options
		 * @param {Boolean} remove_on_hide Remove slide when it's hidden
		 * @return Slide boundingBox node
		 * @type {Object}
		 */
		addSlide: function (options) {
			var options = Supra.mix({
				'id': null,
				'removeOnHide': false,
				'scrollable': true,
				'title': '',
				'icon': ''
			}, Y.Lang.isObject(options) ? options : {'id': options});
			
			if (!options.id) return null;
			var slideId = options.id;
			
			if (options.removeOnHide) {
				this.remove_on_hide[slideId] = true;
			}
			
			if (!(slideId in this.slides)) {
				var slide = this.slides[slideId] = Y.Node.create('\
														<div class="hidden su-slide" data-icon="' + Y.Escape.html(options.icon) + '" data-title="' + Y.Escape.html(options.title) + '">\
															<div id="' + slideId + '" class="su-slide-content"></div>\
														</div>');
				
				this.slides[slideId] = slide;
				this.get('contentBox').append(slide);
				
				//Add scrollbar
				if (options.scrollable) {
					var slideContent = slide.one('.su-slide-content, .su-multiview-slide-content'),
						scrollable = new Supra.Scrollable({
							'srcNode': slideContent
						});
					
					slide.setData('scrollable', scrollable);
					
					if (this.get('rendered')) {
						scrollable.render();
					} else {
						this.render_queue.push(scrollable);
					}
				}
				
				//If there are no slides, then make this as main
				if (!this.get('slide')) {
					slide.removeClass('hidden');
					this.history.push(slideId);
					this.set('slide', slideId, {'silent': true});
					this.syncUI();
				}
				
				return slide;
			}
			
			return this.slides[slideId];
		},
		
		/**
		 * Remove slide
		 * 
		 * @param {String} slideId
		 */
		removeSlide: function (slideId) {
			if (slideId in this.slides) {
				//Remove slide
				this.slides[slideId].remove();
				delete(this.slides[slideId]);
				delete(this.remove_on_hide[slideId]);
			}
			
			return this;
		},
		
		/**
		 * Returns slide by ID
		 * 
		 * @return Slide boundingBox node
		 * @type {Object}
		 */
		getSlide: function (slideId) {
			if (slideId in this.slides) {
				return this.slides[slideId];
			} else {
				return null;
			}
		},
		
		/**
		 * Returns true if currently opened slide is first one
		 * or if slideId argument is passed checks if that slide is root
		 * 
		 * @param {String} slideId Optional, checks if given slide is root instead of current
		 * @return True if current slide is first one
		 * @type {Boolean}
		 */
		isRootSlide: function (slideId) {
			if (slideId) {
				return !this.history.length || this.history[0] == slideId;
			} else {
				return this.history.length <= 1;
			}
		},
		
		/**
		 * Returns if slide is in history
		 * 
		 * @param {String} slideId Slide ID
		 * @return True if slide is in history
		 * @type {Boolean}
		 */
		isInHistory: function (slideId /* Slide ID */) {
			return Y.Array.indexOf(this.history, slideId) !== -1;
		},
		
		/**
		 * Returns list of opened slides
		 * 
		 * @return List of slides
		 * @type {Array}
		 */
		getHistory: function () {
			return this.history;
		},
		
		/**
		 * Returns width of the slide container
		 * 
		 * @return Width of the slide container
		 * @type {Number}
		 */
		_getWidth: function () {
			if (!this.slide_width) {
				var unit = this.get('animationUnitType');
				if (unit == '%') {
					this.slide_width = 100; // 100%
				} else {
					this.slide_width = this.get('boundingBox').get('offsetWidth');
				}
			}
			return this.slide_width;
		}
		
	});
	
	
	Supra.Slideshow = Slideshow;
	
	//Since this widget has Supra namespace, it doesn't need to be bound to each YUI instance
	//Make sure this constructor function is called only once
	delete(this.fn); this.fn = function () {};
	
}, YUI.version, {'requires': ['widget', 'anim', 'supra.slideshow-input-button', 'supra.scrollable']});/**
 * Adds Supra.Deferred
 * 
 * Usage:
 * 		var deferred = Supra.Deferred();
 * 		
 * 		//Event handler function will be called when AppList object will exist
 * 		Y.on('exist', function () {...}, 'Supra.Dashboard.AppList');
 */
YUI.add('supra.deferred', function (Y) {
	//Invoke strict mode
	"use strict";
	
	// Functions which are available on promise object
	var PROMISE_EXPORT = ["done", "fail", "always", "progress", "then", "state"];
	
	var PREPARE_EXPORT = function (name, context) {
		return function (a, b, c, d) {
			var result = context[name](a, b, c, d);
			return name === "state" ? result : this;
		};
	};
	
	var global = window;
	
	
	function Deferred () {
		if (!(this instanceof Deferred)) return new Deferred();
		
		//Set initial state
		this._state = "pending";
		this._promise = null;
		this._args = null;
		this._listeners = {"resolved": [], "rejected": [], "notify": []};
		
		//As arguments may be passed done, fail and notify listeners
		if (arguments.length) {
			this.then.apply(this, [].splice.call(arguments));
		}
	}
	
	Deferred.prototype = {
		/**
		 * Deferred object state, values can be
		 *     pending - deferred object has not been resolved or rejected yet
		 *     rejected - deferred object is rejected
		 *     resolved - deferred object was resolved
		 * @type {String}
		 * @private
		 */
		_state: "",
		
		/**
		 * Deffered objects promise
		 * @type {Object}
		 * @private
		 */
		_promise: null,
		
		/**
		 * Listeners
		 * @type {Object}
		 * @private
		 */	
		_listeners: null,
		
		/**
		 * Arguments passed to listeners when Deferred object was resolved or rejected
		 * @type {Array}
		 * @private
		 */
		_args: null,
		
		
		// Deferred private functions
		
		
		/**
		 * Change Deferred object state
		 * 
		 * @param {String} state Deferred state
		 * @param {Object} context Callback context
		 * @param {Array} args Optional arguments passed to callbacks
		 * @private
		 */
		changeState: function (state, context, args) {
			if (this._state === "pending") {
				this._state = state;
				this._args = args;
				this.fire(this._listeners[state], context, args);
				this._listeners = {"resolved": [], "rejected": [], "notify": []};
			}
			return this;
		},
		
		/**
		 * Add listener to be called on state change or when Deferred object notifies progress
		 * 
		 * @param {String} event State on which listener should be called
		 * @param {Function} listener Function, or array of functions, called when Deferred object is resolved
		 * @param {Object} context Listener call context, optional
		 * @private
		 */
		bind: function (event, listener, context) {
			var state = this._state;
			
			//Validate arugments
			if (!listener || (event !== "rejected" && event !== "resolved" && event !== "notify")) return this;
			
			// Convert to array for easier manipulation
			if (typeof listener === "function") listener = [listener];
			if (!Y.Lang.isArray(listener)) return this;
			
			// If already resolved or rejected, then call listeners
			if (state === "resolved" || state === "rejected") {
				if (event === state) {
					this.fire(listener, context || global, this._args);
				}
			} else {
				// Change listener context, NOTE: this overrides resolveWith and rejectWith context
				if (context) {
					for (var i = 0, ii = listener.length; i<ii; i++) {
						listener[i] = Y.bind(listener[i], context);
					}
				}
				this._listeners[event] = this._listeners[event].concat(listener);
			}
			
			return this;
		},
		
		/**
		 * Call all listeners
		 * 
		 * @param {Array} listeners Array of listener functions
		 * @param {Object} context Listener call context
		 * @param {Array} args
		 * @private 
		 */
		fire: function (listeners, context, args) {
			var i = 0,
				ii = listeners.length;
			
			context = context || global;
			args = args || [];
			
			if (!Y.Lang.isArray(args)) {
				args = [args];
			}
			
			for (; i<ii; i++) {
				listeners[i].apply(context, args);
			}
			
			return this;
		},
		
		
		// Deferred public functions
		
		
		/**
		 * Returns deferreds promise object
		 * 
		 * @param {Object} dest Optional object on which deffered promise functions will be set
		 * @return {Object} Deferred promise object 
		 */
		promise: function (dest) {
			if (dest || !this._promise) {
				var promise = dest || {},
					exports = PROMISE_EXPORT,
					prepare = PREPARE_EXPORT,
					i = 0,
					ii = exports.length;
				
				for (; i<ii; i++) {
					promise[exports[i]] = prepare(exports[i], this);
				}
				
				// For convinience promise has 'promise' method
				promise.promise = function () { return this; };
				
				if (!dest) {
					this._promise = promise;
				}
				return promise;
			} else {
				return this._promise;
			}
		},
		
		/**
		 * Resolve a Deferred object
		 * 
		 * @param {Array} args Optional arguments passed to done callbacks
		 */
		resolve: function (args) {
			return this.changeState("resolved", global, args);
		},
		
		/**
		 * Resolve a Deferred object
		 * 
		 * @param {Object} context Callback context
		 * @param {Array} args Optional arguments passed to done callbacks
		 */
		resolveWith: function (context, args) {
			return this.changeState("resolved", context, args);
		},
		
		/**
		 * Reject a Deferred object
		 * 
		 * @param {Array} args Optional arguments passed to fail callbacks
		 */
		reject: function (args) {
			return this.changeState("rejected", global, args);
		},
		
		/**
		 * Reject a Deferred object
		 * 
		 * @param {Object} context Callback context
		 * @param {Array} args Optional arguments passed to fail callbacks
		 */
		rejectWith: function (context, args) {
			return this.changeState("rejected", context, args);
		},
		
		/**
		 * Notify Deferred objects progress listeners
		 * 
		 * @param {Array} args Optional arguments passed to progress callbacks
		 */
		notify: function (args) {
			if (this._state === "pending") {
				this.fire(this._listeners.notify, global, args);
			}
			return this;
		},
		
		/**
		 * Notify Deferred objects progress listeners
		 * 
		 * @param {Object} context Callback context
		 * @param {Array} args Optional arguments passed to progress callbacks
		 */
		notifyWith: function (args) {
			if (this._state === "pending") {
				this.fire(this._listeners.rejected, context, args);
			}
			return this;
		},
		
		
		// Promise functions
		
		
		/**
		 * Add listener to be called when deferred object is resolved
		 * 
		 * @param {Function} listener Function, or array of functions, called when Deferred object is resolved
		 * @param {Object} context Listener call context, optional
		 */
		done: function (listener, context) {
			return this.bind("resolved", listener, context);
		},
		
		/**
		 * Add listener to be called when deferred object is rejected
		 * 
		 * @param {Function} listener Function, or array of functions, called when Deferred object is rejected
		 * @param {Object} context Listener call context, optional
		 */
		fail: function (listener, context) {
			return this.bind("rejected", listener, context);
		},
		
		/**
		 * Add listener to be called when deferred object notifies progress
		 * 
		 * @param {Function} listener Function, or array of functions, called when Deferred object notifies progress
		 * @param {Object} context Listener call context, optional
		 */
		progress: function (listener, context) {
			return this.bind("notify", listener, context);
		},
		
		/**
		 * Add listeners to be called when deferred object is resolved or rejected
		 * 
		 * @param {Function} done Function, or array of functions, called when Deferred object is resolved
		 * @param {Function} fail Function, or array of functions, called when Deferred object is rejected
		 * @param {Function} progress Function, or array of functions, called when Deferred object notifies progress
		 * @param {Object} context Listener call context, optional
		 */
		then: function (done, fail, progress, context) {
			return this.bind("resolved", done, context)
					   .bind("rejected", fail, context)
					   .bind("notify", progress, context);
		},
		
		/**
		 * Add listener to be called when deferred object is resolved or rejected
		 * @param {Object} context Listener call context, optional
		 */
		always: function (listener, context) {
			return this.done(listener, context).fail(listener, context);
		},
		
		/**
		 * Returns deferred object state:
		 *     pending - deferred object has not been resolved or rejected yet
		 *     rejected - deferred object is rejected
		 *     resolved - deferred object was resolved
		 * 
		 * @return {String} Deferred object state
		 */
		state: function () {
			return this._state;
		}
	};
	
	/**
	 * Provides a way to execute callback functions on one or more Deferred objects.
	 * 
	 * If only one deferred object (or promise) is passed then returns its promise
	 * 
	 * If more than one is passed then returns new Deferred object which is resolved
	 * when all Deferred objects are resolved or is rejected when any of them is rejected.
	 * Returned Deferred object is resolved with all arguments from each object, eq.
	 *     Supra.Deferred.when( Supra.io('a'), Supra.io('b') ).then(function (a_args, b_args) {
	 * 	       alert(a_args[1]); // <- status
	 *     })
	 */
	Deferred.when = function () {
		var args = [].splice.call(arguments);
		
		// If first argument is array then use it as deferred list
		if (args.length === 1 && Y.Lang.isArray(args[0])) { 
			args = args[0];
		}
		
		// If there is only a single deferred object, then return its promise
		if (args.length === 1) {
			if (Y.Lang.isFunction(args[0].promise)) {
				return args[0].promise();
			} else {
				var deferred = new Deferred();
				deferred.resolveWith(deferred, args[0]);
				return deferred.promise();
			}
		} else {
			var results = [],
				count = args.length,
				waiting = 0,
				deferred = new Deferred();
			
			for (var i=0; i<count; i++) {
				if (args[i] && Y.Lang.isFunction(args[i].then)) {
					// Promise
					waiting++;
					(function (index, src) {
						src.then(function () {
							// On success update argument list and check if all has been resolved
							results[index] = [].splice.call(arguments);
							waiting--;
							if (!waiting) deferred.resolveWith(results);
						}, function () {
							// On failure reject immediately
							waiting--;
							deferred.reject();
						});
					})(i, args[i]);
				} else {
					results[i] = args[i];
					waiting--;
					if (!waiting) deferred.resolveWith(results);
				}
			}
			
			if (!waiting) {
				// No deferred's
				deferred.resolve();
			}
			
			return deferred;
		}
		
		// Blank promise, which is resolved immediately
		return (new Deferred()).resolve().promise();
	};
	
	Supra.Deferred = Deferred;
	
}, YUI.version);/**
 * For all modules loaded using pack.js skins are loaded using pack.css
 * and we need to mark these skin modules as loaded
 */
(function (Y) {
	
	var modules = Y.Env._loader.moduleInfo,
		loaded = YUI.Env._loaded[YUI.version],
		name = null;
	
	for (name in modules) {
		
		if (name.indexOf('skin-') === 0) {
			loaded[name] = true;
		} else if (name.indexOf('supra.') === 0) {
			loaded['skin-supra-' + name] = true;
		}
	}
	
})(Supra.Y);